[
    {
        "input": "Solve the system of equations using Gaussian elimination:\n2x + 3y - z = 5\n4x + y + 2z = 6\n-x + 2y + 3z = 4",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[2, 3, -1],\n              [4, 1,  2],\n              [-1, 2, 3]])\nb = np.array([5, 6, 4])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination to solve:\nx - y + 2z = 4\n3x + 2y - z = 1\n2x - 3y + 3z = 5",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[1, -1, 2],\n              [3, 2, -1],\n              [2, -3, 3]])\nb = np.array([4, 1, 5])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Find the solution to the system:\nx + 2y - z = 1\n2x - y + 3z = 5\n-x + 3y + 2z = 4",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[1, 2, -1],\n              [2, -1, 3],\n              [-1, 3, 2]])\nb = np.array([1, 5, 4])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using Gaussian elimination:\nx + y + z = 6\n2x - y + 3z = 14\n3x + 4y - 2z = -2",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[1, 1, 1],\n              [2, -1, 3],\n              [3, 4, -2]])\nb = np.array([6, 14, -2])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\nx - 2y + z = 0\n3x + y - 4z = 5\n2x + 3y + 3z = 10",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[1, -2, 1],\n              [3, 1, -4],\n              [2, 3, 3]])\nb = np.array([0, 5, 10])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system using Gaussian elimination:\n2x + y - z = 1\n-3x - y + 2z = -4\n-2x + y + 2z = -3",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[2, 1, -1],\n              [-3, -1, 2],\n              [-2, 1, 2]])\nb = np.array([1, -4, -3])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve:\n2x + 3y + z = 1\n4x + y - z = 2\n-2x + y + 3z = 3",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[2, 3, 1],\n              [4, 1, -1],\n              [-2, 1, 3]])\nb = np.array([1, 2, 3])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system of equations:\nx + y + z = 6\nx - y + z = 2\n2x + y - z = 2",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[1, 1, 1],\n              [1, -1, 1],\n              [2, 1, -1]])\nb = np.array([6, 2, 2])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination to solve:\nx + y + z = 1\nx + 2y + 3z = 4\nx + 4y + 9z = 10",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[1, 1, 1],\n              [1, 2, 3],\n              [1, 4, 9]])\nb = np.array([1, 4, 10])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\nx + y + z = 3\nx - y + z = 1\n2x + y - z = 2",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[1, 1, 1],\n              [1, -1, 1],\n              [2, 1, -1]])\nb = np.array([3, 1, 2])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\nx + y + z = 3\n2x + 3y + z = 7\nx + 4y + 2z = 9",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[1, 1, 1],\n              [2, 3, 1],\n              [1, 4, 2]])\nb = np.array([3, 7, 9])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve:\nx - 2y + z = -3\n2x + 3y + 4z = 8\n3x - y + z = 2",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[1, -2, 1],\n              [2, 3, 4],\n              [3, -1, 1]])\nb = np.array([-3, 8, 2])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the following:\nx - y + z = 0\ny - z = 0\nx + y + z = 6",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[1, -1, 1],\n              [0, 1, -1],\n              [1, 1, 1]])\nb = np.array([0, 0, 6])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve:\nx + y + z = 4\n2x + y - z = 1\n3x + 2y + z = 9",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[1, 1, 1],\n              [2, 1, -1],\n              [3, 2, 1]])\nb = np.array([4, 1, 9])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\n3x - y + 2z = 5\n2x + 4y - 3z = -6\nx + y + z = 4",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[3, -1, 2],\n              [2, 4, -3],\n              [1, 1, 1]])\nb = np.array([5, -6, 4])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Find the solution:\n4x + 2y + z = 9\n3x - y + z = 4\nx + y - z = 1",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[4, 2, 1],\n              [3, -1, 1],\n              [1, 1, -1]])\nb = np.array([9, 4, 1])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination to solve:\n3x + y - z = 2\n2x - 2y + 4z = -2\n-x + 0.5y - z = 0",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[3, 1, -1],\n              [2, -2, 4],\n              [-1, 0.5, -1]])\nb = np.array([2, -2, 0])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve:\n2x + y - z = 8\n-3x - y + 2z = -11\n-2x + y + 2z = -3",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[2, 1, -1],\n              [-3, -1, 2],\n              [-2, 1, 2]])\nb = np.array([8, -11, -3])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the linear system:\nx + 2y + 3z = 10\n2x + 3y + z = 8\n3x + y + 2z = 11",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[1, 2, 3],\n              [2, 3, 1],\n              [3, 1, 2]])\nb = np.array([10, 8, 11])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using Gaussian elimination:\n2x - y + z = 3\nx + y - z = 0\nx - 2y + 3z = -10",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[2, -1, 1],\n              [1, 1, -1],\n              [1, -2, 3]])\nb = np.array([3, 0, -10])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve this system:\n3x + 4y - 5z = 6\n2x - y + 2z = -1\n5x + 3y + z = 4",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[3, 4, -5],\n              [2, -1, 2],\n              [5, 3, 1]])\nb = np.array([6, -1, 4])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Find x, y, z from:\n4x + y + z = 7\nx + 3y + z = 6\nx + y + 5z = 9",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[4, 1, 1],\n              [1, 3, 1],\n              [1, 1, 5]])\nb = np.array([7, 6, 9])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using Gaussian elimination:\n5x + y + z = 10\nx + 3y + z = 8\nx + y + 4z = 9",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[5, 1, 1],\n              [1, 3, 1],\n              [1, 1, 4]])\nb = np.array([10, 8, 9])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Find the solution:\n3x + 2y + z = 1\n2x + 3y + 2z = 2\nx + 4y + 3z = 3",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[3, 2, 1],\n              [2, 3, 2],\n              [1, 4, 3]])\nb = np.array([1, 2, 3])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve:\nx + 2y + z = 7\n2x + 5y + z = 18\n3x + 6y + 2z = 25",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[1, 2, 1],\n              [2, 5, 1],\n              [3, 6, 2]])\nb = np.array([7, 18, 25])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\n2x + 4y + z = 5\nx + 3y + 2z = 6\n3x + y + z = 4",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[2, 4, 1],\n              [1, 3, 2],\n              [3, 1, 1]])\nb = np.array([5, 6, 4])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using Gaussian elimination:\n2x - y + 3z = 7\n4x + y - z = 1\n3x + 2y + z = 10",
        "output": "import numpy as np\nfrom numpy.linalg import solve\nA = np.array([[2, -1, 3],\n              [4, 1, -1],\n              [3, 2, 1]])\nb = np.array([7, 1, 10])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using matrix inversion:\n2x + y = 5\nx - 3y = -4",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, -3]])\nb = np.array([5, -4])\ntry:\n    x = np.linalg.inv(A).dot(b)\n    print(x)\nexcept np.linalg.LinAlgError:\n    print('Matrix is singular')"
    },
    {
        "input": "Solve the system using NumPy:\n3x - y + z = 2\n2x + 4y - 3z = -2\nx - y + 2z = 3",
        "output": "import numpy as np\nA = np.array([[3, -1, 1], [2, 4, -3], [1, -1, 2]])\nb = np.array([2, -2, 3])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\n3x + 4y = 10\n5x + 6y = 16",
        "output": "import numpy as np\nA = np.array([[3, 4], [5, 6]])\nb = np.array([10, 16])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using Gaussian elimination:\n4x - y + 2z = 9\n3x + 2y - z = 4\n2x - 3y + 4z = 7",
        "output": "import numpy as np\nfrom scipy.linalg import solve\nA = np.array([[4, -1, 2], [3, 2, -1], [2, -3, 4]])\nb = np.array([9, 4, 7])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Use matrix inverse:\n2x + 3y = 8\n4x + 5y = 16",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nb = np.array([8, 16])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve the system:\nx + y + z = 3\nx + 2y + 3z = 6\nx + 4y + 9z = 10",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, 2, 3], [1, 4, 9]])\nb = np.array([3, 6, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination:\nx + 2y + z = 7\n2x + 5y + z = 18\n3x + 6y + 2z = 25",
        "output": "import numpy as np\nA = np.array([[1, 2, 1], [2, 5, 1], [3, 6, 2]])\nb = np.array([7, 18, 25])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\nx - y + z = 1\n2x + 3y - z = 4\nx + y + z = 6",
        "output": "import numpy as np\nA = np.array([[1, -1, 1], [2, 3, -1], [1, 1, 1]])\nb = np.array([1, 4, 6])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination to solve:\n2x - y + 3z = 7\n4x + y - z = 1\n3x + 2y + z = 10",
        "output": "import numpy as np\nA = np.array([[2, -1, 3], [4, 1, -1], [3, 2, 1]])\nb = np.array([7, 1, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using matrix inversion:\nx + 2y = 4\n3x + 4y = 10",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nb = np.array([4, 10])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve the system:\n2x + y + z = 5\n4x + 3y + 5z = 13\n-2x + y + 2z = 3",
        "output": "import numpy as np\nA = np.array([[2, 1, 1], [4, 3, 5], [-2, 1, 2]])\nb = np.array([5, 13, 3])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve:\nx + 2y - z = 3\n3x - y + 2z = 4\n2x + y + z = 5",
        "output": "import numpy as np\nA = np.array([[1, 2, -1], [3, -1, 2], [2, 1, 1]])\nb = np.array([3, 4, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system using numpy:\n3x + 4y + 2z = 14\n2x + y + z = 8\nx + 2y + 3z = 11",
        "output": "import numpy as np\nA = np.array([[3, 4, 2], [2, 1, 1], [1, 2, 3]])\nb = np.array([14, 8, 11])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using Gaussian elimination:\nx + y + z = 3\n2x + 3y + 5z = 8\n4x + 5y + 6z = 12",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [2, 3, 5], [4, 5, 6]])\nb = np.array([3, 8, 12])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use matrix inverse method to solve:\nx + 4y = 9\n2x + 3y = 8",
        "output": "import numpy as np\nA = np.array([[1, 4], [2, 3]])\nb = np.array([9, 8])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve the system using Gaussian elimination:\n3x + 2y + z = 1\n2x + 3y + 2z = 4\nx + y + z = 2",
        "output": "import numpy as np\nA = np.array([[3, 2, 1], [2, 3, 2], [1, 1, 1]])\nb = np.array([1, 4, 2])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use matrix inverse method to solve:\n2x + y = 3\n5x + 4y = 8",
        "output": "import numpy as np\nA = np.array([[2, 1], [5, 4]])\nb = np.array([3, 8])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve using NumPy:\nx + y + z = 6\nx - y + z = 2\nx + y - z = 0",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, -1, 1], [1, 1, -1]])\nb = np.array([6, 2, 0])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination to solve:\n2x + 3y + z = 1\n4x + 5y + 3z = 3\n6x + 7y + 5z = 5",
        "output": "import numpy as np\nA = np.array([[2, 3, 1], [4, 5, 3], [6, 7, 5]])\nb = np.array([1, 3, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\n3x + y = 5\nx + 2y = 4",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 2]])\nb = np.array([5, 4])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system using numpy:\n2x + 3y - z = 1\nx - y + z = 2\n3x + 4y + 2z = 5",
        "output": "import numpy as np\nA = np.array([[2, 3, -1], [1, -1, 1], [3, 4, 2]])\nb = np.array([1, 2, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use matrix inverse to solve:\nx - 2y + 3z = 1\n2x + y + z = 4\n4x - y + z = 2",
        "output": "import numpy as np\nA = np.array([[1, -2, 3], [2, 1, 1], [4, -1, 1]])\nb = np.array([1, 4, 2])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination:\nx + 2y + 3z = 4\n2x + 3y + z = 5\n3x + y + 2z = 6",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 3, 1], [3, 1, 2]])\nb = np.array([4, 5, 6])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\n2x + 5y = 20\n3x + 2y = 15",
        "output": "import numpy as np\nA = np.array([[2, 5], [3, 2]])\nb = np.array([20, 15])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using matrix inverse:\n3x - y + z = 2\n2x + 4y - z = 3\nx - y + 2z = 1",
        "output": "import numpy as np\nA = np.array([[3, -1, 1], [2, 4, -1], [1, -1, 2]])\nb = np.array([2, 3, 1])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination:\n4x + y - z = 2\n2x - 3y + z = -5\nx + 2y + 3z = 3",
        "output": "import numpy as np\nA = np.array([[4, 1, -1], [2, -3, 1], [1, 2, 3]])\nb = np.array([2, -5, 3])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve system with matrix inversion:\n2x + y + z = 4\nx + 2y + z = 5\nx + y + 2z = 6",
        "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\nb = np.array([4, 5, 6])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Use NumPy to solve:\n5x + 6y + 7z = 18\n6x + 5y + 4z = 17\n7x + 8y + 9z = 24",
        "output": "import numpy as np\nA = np.array([[5, 6, 7], [6, 5, 4], [7, 8, 9]])\nb = np.array([18, 17, 24])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using Gaussian elimination:\n3x + y + 2z = 4\nx + 3y + z = 5\n2x + 2y + 3z = 6",
        "output": "import numpy as np\nA = np.array([[3, 1, 2], [1, 3, 1], [2, 2, 3]])\nb = np.array([4, 5, 6])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use matrix method to solve:\n6x + 7y = 30\n2x + 3y = 12",
        "output": "import numpy as np\nA = np.array([[6, 7], [2, 3]])\nb = np.array([30, 12])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination:\n3x + 2y + z = 8\nx - y + 2z = 3\n2x + 3y - z = 4",
        "output": "import numpy as np\nA = np.array([[3, 2, 1], [1, -1, 2], [2, 3, -1]])\nb = np.array([8, 3, 4])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\n2x + y - z = 0\nx + y + z = 6\n3x - y + 2z = 5",
        "output": "import numpy as np\nA = np.array([[2, 1, -1], [1, 1, 1], [3, -1, 2]])\nb = np.array([0, 6, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using matrix inversion:\n2x + 3y = 7\n4x + 5y = 11",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nb = np.array([7, 11])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination:\n3x + 2y = 12\n5x + 4y = 20",
        "output": "import numpy as np\nA = np.array([[3, 2], [5, 4]])\nb = np.array([12, 20])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system using Gaussian elimination:\n2x - y + 3z = 9\n4x + y - z = 1\n-2x + 5y + 2z = 7",
        "output": "import numpy as np\nA = np.array([[2, -1, 3], [4, 1, -1], [-2, 5, 2]])\nb = np.array([9, 1, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\n2x + 3y + 4z = 7\nx - y + z = 4\n3x + 4y - 2z = 1",
        "output": "import numpy as np\nA = np.array([[2, 3, 4], [1, -1, 1], [3, 4, -2]])\nb = np.array([7, 4, 1])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use matrix inversion to solve:\n4x - y + z = 5\n3x + 2y - z = 3\nx + y + z = 6",
        "output": "import numpy as np\nA = np.array([[4, -1, 1], [3, 2, -1], [1, 1, 1]])\nb = np.array([5, 3, 6])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve using NumPy:\n5x + 6y = 16\n7x - 3y = 5",
        "output": "import numpy as np\nA = np.array([[5, 6], [7, -3]])\nb = np.array([16, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination to solve:\n3x - y + 2z = 7\nx + 4y - z = 5\n2x - y + 3z = 8",
        "output": "import numpy as np\nA = np.array([[3, -1, 2], [1, 4, -1], [2, -1, 3]])\nb = np.array([7, 5, 8])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\n2x + y - z = 4\nx - 2y + 3z = -1\n3x + 4y + z = 7",
        "output": "import numpy as np\nA = np.array([[2, 1, -1], [1, -2, 3], [3, 4, 1]])\nb = np.array([4, -1, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using matrix inversion:\n3x + 2y + z = 5\n2x - y + 4z = 6\nx + 3y - 2z = 7",
        "output": "import numpy as np\nA = np.array([[3, 2, 1], [2, -1, 4], [1, 3, -2]])\nb = np.array([5, 6, 7])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination:\n2x - 3y + z = 1\n4x + y - 2z = 2\nx + 2y + 3z = 3",
        "output": "import numpy as np\nA = np.array([[2, -3, 1], [4, 1, -2], [1, 2, 3]])\nb = np.array([1, 2, 3])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\n5x + 2y - z = 4\n3x - y + 2z = 6\nx + 4y + 3z = 5",
        "output": "import numpy as np\nA = np.array([[5, 2, -1], [3, -1, 2], [1, 4, 3]])\nb = np.array([4, 6, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system using Gaussian elimination:\n6x - y + z = 10\n2x + 3y - 2z = 7\nx + 2y + 3z = 8",
        "output": "import numpy as np\nA = np.array([[6, -1, 1], [2, 3, -2], [1, 2, 3]])\nb = np.array([10, 7, 8])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use matrix inversion to solve the following system:\n3x + y - z = 2\n4x - 2y + 5z = -1\nx + 3y + 2z = 7",
        "output": "import numpy as np\nA = np.array([[3, 1, -1], [4, -2, 5], [1, 3, 2]])\nb = np.array([2, -1, 7])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve this linear system using numpy:\n2x + 4y + 6z = 18\nx + y + z = 6\n3x + 2y + z = 10",
        "output": "import numpy as np\nA = np.array([[2, 4, 6], [1, 1, 1], [3, 2, 1]])\nb = np.array([18, 6, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination to solve:\n4x + 2y - 3z = 5\n3x + y + 4z = 10\nx + 5y + z = 8",
        "output": "import numpy as np\nA = np.array([[4, 2, -3], [3, 1, 4], [1, 5, 1]])\nb = np.array([5, 10, 8])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using numpy:\n5x - y + z = 4\n2x + 3y - 2z = 1\nx - y + 4z = 7",
        "output": "import numpy as np\nA = np.array([[5, -1, 1], [2, 3, -2], [1, -1, 4]])\nb = np.array([4, 1, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve:\n6x - 2y + 3z = 12\nx + 4y - 5z = 2\n2x + y + z = 9",
        "output": "import numpy as np\nA = np.array([[6, -2, 3], [1, 4, -5], [2, 1, 1]])\nb = np.array([12, 2, 9])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use matrix inversion to solve:\n4x + y + 2z = 11\nx - 3y + z = 2\n2x + 2y + 3z = 13",
        "output": "import numpy as np\nA = np.array([[4, 1, 2], [1, -3, 1], [2, 2, 3]])\nb = np.array([11, 2, 13])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve using NumPy:\n3x + 3y + 3z = 9\nx + 2y + 3z = 8\n2x + y + z = 6",
        "output": "import numpy as np\nA = np.array([[3, 3, 3], [1, 2, 3], [2, 1, 1]])\nb = np.array([9, 8, 6])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination to solve:\n2x + y + z = 6\nx + 3y - z = 2\n3x + 4y + 2z = 10",
        "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 3, -1], [3, 4, 2]])\nb = np.array([6, 2, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using matrix inversion:\n5x - y + 2z = 4\nx + 3y - 4z = 6\n2x + 4y + z = 10",
        "output": "import numpy as np\nA = np.array([[5, -1, 2], [1, 3, -4], [2, 4, 1]])\nb = np.array([4, 6, 10])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve the system using Gaussian elimination:\n3x + y - z = 1\nx - y + z = -3\n2x + y + z = 0",
        "output": "import numpy as np\nA = np.array([[3, 1, -1], [1, -1, 1], [2, 1, 1]])\nb = np.array([1, -3, 0])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\n4x - y + z = 5\n3x + 2y - z = 3\nx + y + z = 6",
        "output": "import numpy as np\nA = np.array([[4, -1, 1], [3, 2, -1], [1, 1, 1]])\nb = np.array([5, 3, 6])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use matrix inversion to solve:\n3x + 2y + z = 5\n2x - y + 4z = 6\nx + 3y - 2z = 7",
        "output": "import numpy as np\nA = np.array([[3, 2, 1], [2, -1, 4], [1, 3, -2]])\nb = np.array([5, 6, 7])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve using NumPy:\n2x + 4y + 6z = 18\nx + y + z = 6\n3x + 2y + z = 10",
        "output": "import numpy as np\nA = np.array([[2, 4, 6], [1, 1, 1], [3, 2, 1]])\nb = np.array([18, 6, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using NumPy:\n5x - y + z = 4\n2x + 3y - 2z = 1\nx - y + 4z = 7",
        "output": "import numpy as np\nA = np.array([[5, -1, 1], [2, 3, -2], [1, -1, 4]])\nb = np.array([4, 1, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using NumPy:\n3x + 4y + 5z = 14\n2x + y - z = 1\nx + 3y + z = 7",
        "output": "import numpy as np\nA = np.array([[3, 4, 5], [2, 1, -1], [1, 3, 1]])\nb = np.array([14, 1, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve this system of equations using numpy:\n2x - 3y + z = 5\n-4x + y + 2z = -2\nx + 2y + 3z = 4",
        "output": "import numpy as np\nA = np.array([[2, -3, 1], [-4, 1, 2], [1, 2, 3]])\nb = np.array([5, -2, 4])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination for:\n4x + 3y + 2z = 1\n2x - 2y + z = -3\nx + y + z = 2",
        "output": "import numpy as np\nA = np.array([[4, 3, 2], [2, -2, 1], [1, 1, 1]])\nb = np.array([1, -3, 2])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using NumPy:\n2x + y = 7\nx - y = 1",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, -1]])\nb = np.array([7, 1])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use matrix inversion to solve:\n3x + y + z = 5\nx - 2y + 4z = 6\n2x + 3y + z = 10",
        "output": "import numpy as np\nA = np.array([[3, 1, 1], [1, -2, 4], [2, 3, 1]])\nb = np.array([5, 6, 10])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve this system:\nx + 2y - z = 3\n2x - y + 3z = 7\n4x + y + z = 10",
        "output": "import numpy as np\nA = np.array([[1, 2, -1], [2, -1, 3], [4, 1, 1]])\nb = np.array([3, 7, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination:\n2x + 3y + z = 1\nx - y + 2z = 4\n3x + 2y + 4z = 7",
        "output": "import numpy as np\nA = np.array([[2, 3, 1], [1, -1, 2], [3, 2, 4]])\nb = np.array([1, 4, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\n2x + y - 2z = -1\n4x - 6y = -2\n-2x + 7y + 2z = 9",
        "output": "import numpy as np\nA = np.array([[2, 1, -2], [4, -6, 0], [-2, 7, 2]])\nb = np.array([-1, -2, 9])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using NumPy:\n3x + y = 10\nx + 2y = 8",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 2]])\nb = np.array([10, 8])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system using Gaussian elimination:\n2x - 3y + z = 5\n-4x + y + 2z = -2\nx + 2y + 3z = 4",
        "output": "import numpy as np\nA = np.array([[2, -3, 1], [-4, 1, 2], [1, 2, 3]])\nb = np.array([5, -2, 4])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using matrix inversion:\n4x + y + 2z = 11\nx - 3y + z = 2\n2x + 2y + 3z = 13",
        "output": "import numpy as np\nA = np.array([[4, 1, 2], [1, -3, 1], [2, 2, 3]])\nb = np.array([11, 2, 13])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve the system:\n3x + 4y + 5z = 14\n2x + y - z = 1\nx + 3y + z = 7",
        "output": "import numpy as np\nA = np.array([[3, 4, 5], [2, 1, -1], [1, 3, 1]])\nb = np.array([14, 1, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination to solve:\n4x + 3y + 2z = 1\n2x - 2y + z = -3\nx + y + z = 2",
        "output": "import numpy as np\nA = np.array([[4, 3, 2], [2, -2, 1], [1, 1, 1]])\nb = np.array([1, -3, 2])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve using Gaussian elimination:\n5x + 2y + z = 17\nx + 3y + 2z = 13\n3x + y + 4z = 20",
        "output": "import numpy as np\nA = np.array([[5, 2, 1], [1, 3, 2], [3, 1, 4]])\nb = np.array([17, 13, 20])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the following system:\nx + y + z = 6\nx + 2y + 3z = 14\n2x + 3y + z = 10",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, 2, 3], [2, 3, 1]])\nb = np.array([6, 14, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use NumPy to solve:\n2x - y + 3z = 5\n4x + y - z = 3\n-2x + 5y + 2z = 7",
        "output": "import numpy as np\nA = np.array([[2, -1, 3], [4, 1, -1], [-2, 5, 2]])\nb = np.array([5, 3, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the linear system:\n6x - y + z = 4\n2x + 4y - z = 5\nx - y + 5z = 9",
        "output": "import numpy as np\nA = np.array([[6, -1, 1], [2, 4, -1], [1, -1, 5]])\nb = np.array([4, 5, 9])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use matrix inversion:\n3x + y = 9\nx + 2y = 8",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 2]])\nb = np.array([9, 8])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve using NumPy:\n4x + y + z = 9\n2x - y + 2z = 5\nx + 3y + 3z = 12",
        "output": "import numpy as np\nA = np.array([[4, 1, 1], [2, -1, 2], [1, 3, 3]])\nb = np.array([9, 5, 12])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve:\n5x + 2y - z = 3\nx - y + z = 1\n3x + 4y + z = 10",
        "output": "import numpy as np\nA = np.array([[5, 2, -1], [1, -1, 1], [3, 4, 1]])\nb = np.array([3, 1, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination:\n3x + 2y + 4z = 20\nx - y + z = 2\n2x + y - z = 5",
        "output": "import numpy as np\nA = np.array([[3, 2, 4], [1, -1, 1], [2, 1, -1]])\nb = np.array([20, 2, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve system of equations:\n4x + 2y - z = 6\n3x - y + 2z = 5\nx + y + z = 4",
        "output": "import numpy as np\nA = np.array([[4, 2, -1], [3, -1, 2], [1, 1, 1]])\nb = np.array([6, 5, 4])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve:\nx + 2y + z = 4\n3x - y + 2z = 7\n2x + y + 3z = 10",
        "output": "import numpy as np\nA = np.array([[1, 2, 1], [3, -1, 2], [2, 1, 3]])\nb = np.array([4, 7, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use matrix inversion to solve:\n2x + 3y = 5\nx + 2y = 4",
        "output": "import numpy as np\nA = np.array([[2, 3], [1, 2]])\nb = np.array([5, 4])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve the system using NumPy:\n4x + 5y = 9\n2x + y = 3",
        "output": "import numpy as np\nA = np.array([[4, 5], [2, 1]])\nb = np.array([9, 3])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Given the system:\nx + y + z = 2\n2x + 3y + z = 5\n-x + y + 2z = 1\nSolve it using NumPy.",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [2, 3, 1], [-1, 1, 2]])\nb = np.array([2, 5, 1])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Reduce the augmented matrix to RREF:\n[1 2 3 | 9]\n[0 1 4 | 8]\n[2 4 6 | 18]",
        "output": "import sympy as sp\nA = sp.Matrix([[1,2,3,9], [0,1,4,8], [2,4,6,18]])\nA_rref, _ = A.rref()\nsp.pprint(A_rref)"
    },
    {
        "input": "Solve the following system using Gaussian elimination:\n2x + y - z = 8\n-3x - y + 2z = -11\n-2x + y + 2z = -3",
        "output": "import numpy as np\nfrom scipy.linalg import solve\nA = np.array([[2,1,-1], [-3,-1,2], [-2,1,2]])\nb = np.array([8, -11, -3])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system and identify if it has a parametric solution:\n2x + 4y - 2z = 6\nx + 2y - z = 3\n0x + 0y + 0z = 0",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [2*x + 4*y - 2*z - 6, x + 2*y - z - 3]\nsol = sp.linsolve(eqs, x, y, z)\nprint(sol)"
    },
    {
        "input": "Solve for x, y using inverse matrix method:\n4x + y = 9\n2x - y = 1",
        "output": "import numpy as np\nA = np.array([[4,1],[2,-1]])\nb = np.array([9,1])\nx = np.dot(np.linalg.inv(A), b)\nprint(x)"
    },
    {
        "input": "Solve the following with parametric solution:\nx + 2y + 3z = 4\n2x + 4y + 6z = 8",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [x + 2*y + 3*z - 4, 2*x + 4*y + 6*z - 8]\nsol = sp.linsolve(eqs, x, y, z)\nprint(sol)"
    },
    {
        "input": "Use Cramerâ€™s Rule to solve:\n5x - y + z = 10\nx + 3y - z = 5\n2x + y + 4z = 11",
        "output": "import numpy as np\nA = np.array([[5, -1, 1], [1, 3, -1], [2, 1, 4]])\nb = np.array([10, 5, 11])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack((b, A[:,1], A[:,2])))\nDy = np.linalg.det(np.column_stack((A[:,0], b, A[:,2])))\nDz = np.linalg.det(np.column_stack((A[:,0], A[:,1], b)))\nprint((Dx/D, Dy/D, Dz/D))"
    },
    {
        "input": "Reduce the matrix to row echelon form:\n[2 1 -1 | 8]\n[-3 -1 2 | -11]\n[-2 1 2 | -3]",
        "output": "import sympy as sp\nA = sp.Matrix([[2,1,-1,8], [-3,-1,2,-11], [-2,1,2,-3]])\nA_rref, _ = A.rref()\nsp.pprint(A_rref)"
    },
    {
        "input": "Solve by matrix method:\n3x - y + 2z = 5\n2x + 4y = 6\nz = 2",
        "output": "import numpy as np\nA = np.array([[3,-1,2], [2,4,0], [0,0,1]])\nb = np.array([5,6,2])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Determine the RREF of this augmented matrix:\n[1 3 | 7]\n[2 6 | 14]",
        "output": "import sympy as sp\nA = sp.Matrix([[1,3,7],[2,6,14]])\nA_rref, _ = A.rref()\nsp.pprint(A_rref)"
    },
    {
        "input": "Solve the homogeneous system:\n2x - 4y + 6z = 0\nx - 2y + 3z = 0",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [2*x - 4*y + 6*z, x - 2*y + 3*z]\nsol = sp.linsolve(eqs, x, y, z)\nprint(sol)"
    },
    {
        "input": "Solve for x, y, z:\n3x + 4y + z = 1\nx + y + 3z = 2\nx + 2y + z = 3",
        "output": "import numpy as np\nA = np.array([[3,4,1], [1,1,3], [1,2,1]])\nb = np.array([1,2,3])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system using Gaussian elimination:\nx + y + z = 3\nx + 2y + 3z = 7\n2x + 3y + z = 7",
        "output": "import numpy as np\nfrom scipy.linalg import solve\nA = np.array([[1,1,1],[1,2,3],[2,3,1]])\nb = np.array([3,7,7])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system using Cramer's Rule:\n2x + 3y = 7\n4x - y = 5",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, -1]])\nb = np.array([7, 5])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.array([[7, 3], [5, -1]]))\nDy = np.linalg.det(np.array([[2, 7], [4, 5]]))\nx = Dx / D\ny = Dy / D\nprint((x, y))"
    },
    {
        "input": "Solve the system using an augmented matrix:\n3x - y + 2z = 5\n2x + 4y - z = 6\nx - 3y + 3z = 2",
        "output": "import sympy as sp\nA = sp.Matrix([[3, -1, 2, 5], [2, 4, -1, 6], [1, -3, 3, 2]])\nA_rref, _ = A.rref()\nsp.pprint(A_rref)"
    },
    {
        "input": "Find the parametric solution of the system:\nx - y + 2z = 3\n2x - 2y + 4z = 6\n-x + y - 2z = -3",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [x - y + 2*z - 3, 2*x - 2*y + 4*z - 6, -x + y - 2*z + 3]\nsol = sp.linsolve(eqs, x, y, z)\nprint(sol)"
    },
    {
        "input": "Solve the system using the inverse matrix method:\n4x - y = 7\n2x + 3y = 5",
        "output": "import numpy as np\nA = np.array([[4, -1], [2, 3]])\nb = np.array([7, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Reduce the augmented matrix to row echelon form:\n[2 1 -1 | 3]\n[4 -6 0 | -2]\n[-2 7 2 | 5]",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 1, -1, 3], [4, -6, 0, -2], [-2, 7, 2, 5]])\nA_rref, _ = A.rref()\nsp.pprint(A_rref)"
    },
    {
        "input": "Solve the system using Gaussian elimination:\n2x - y + z = 1\nx + y - z = 3\n3x - y + 2z = 4",
        "output": "import numpy as np\nA = np.array([[2, -1, 1], [1, 1, -1], [3, -1, 2]])\nb = np.array([1, 3, 4])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Find the parametric solution of the homogeneous system:\nx + 2y - z = 0\n2x + 4y - 2z = 0\n-x - 2y + z = 0",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [x + 2*y - z, 2*x + 4*y - 2*z, -x - 2*y + z]\nsol = sp.linsolve(eqs, x, y, z)\nprint(sol)"
    },
    {
        "input": "Solve the system using Cramer's Rule:\n5x + 2y - z = 10\n3x - y + 4z = 5\nx + 3y + 2z = 7",
        "output": "import numpy as np\nA = np.array([[5, 2, -1], [3, -1, 4], [1, 3, 2]])\nb = np.array([10, 5, 7])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack([b, A[:,1], A[:,2]]))\nDy = np.linalg.det(np.column_stack([A[:,0], b, A[:,2]]))\nDz = np.linalg.det(np.column_stack([A[:,0], A[:,1], b]))\nx = Dx / D\ny = Dy / D\nz = Dz / D\nprint((x, y, z))"
    },
    {
        "input": "Solve the system using matrix inverse method:\n3x + y - z = 1\n2x - 2y + 4z = -2\n-x + 0.5y - z = 0",
        "output": "import numpy as np\nA = np.array([[3, 1, -1], [2, -2, 4], [-1, 0.5, -1]])\nb = np.array([1, -2, 0])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use Gaussian elimination to solve:\n4x - y + z = 7\n2x + 3y + z = 4\nx + y - z = -2",
        "output": "import numpy as np\nA = np.array([[4, -1, 1], [2, 3, 1], [1, 1, -1]])\nb = np.array([7, 4, -2])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Find the general solution to the system:\n2x - y + 3z = 4\n-x + 2y - z = 1\nx + y + z = 6",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [2*x - y + 3*z - 4, -x + 2*y - z - 1, x + y + z - 6]\nsol = sp.linsolve(eqs, x, y, z)\nprint(sol)"
    },
    {
        "input": "Use Gauss-Jordan elimination to solve:\n1x + 2y - z = 3\n2x + 3y + 2z = 7\n3x + y + 4z = 10",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 2, -1, 3], [2, 3, 2, 7], [3, 1, 4, 10]])\nA_rref, _ = A.rref()\nsp.pprint(A_rref)"
    },
    {
        "input": "Write the augmented matrix and solve:\n5x - y = 9\n3x + 4y = 1",
        "output": "import sympy as sp\nA = sp.Matrix([[5, -1, 9], [3, 4, 1]])\nA_rref, _ = A.rref()\nsp.pprint(A_rref)"
    },
    {
        "input": "Use matrix methods to solve:\n7x + 2y - 3z = 5\n2x - 5y + z = -1\n4x + 3y + 2z = 10",
        "output": "import numpy as np\nA = np.array([[7, 2, -3], [2, -5, 1], [4, 3, 2]])\nb = np.array([5, -1, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system using the substitution method:\n3x + 4y = 12\nx - 2y = 5",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 4*y, 12)\neq2 = sp.Eq(x - 2*y, 5)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the elimination method:\n5x - 3y = -14\n3x + y = 0",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x - 3*y, -14)\neq2 = sp.Eq(3*x + y, 0)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using matrices:\n3x + 2y = 5\n7x - 4y = 10",
        "output": "import numpy as np\nA = np.array([[3, 2], [7, -4]])\nb = np.array([5, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system of three variables:\n2x - y + z = 3\nx + y - z = 0\n3x - 2y + 4z = 5",
        "output": "import numpy as np\nA = np.array([[2, -1, 1], [1, 1, -1], [3, -2, 4]])\nb = np.array([3, 0, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "A store sells apples and oranges. An apple costs $0.50 and an orange costs $0.80. If a customer buys 10 fruits for $7.00, how many of each did they buy?",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 10)\neq2 = sp.Eq(0.5*x + 0.8*y, 7)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Find the inverse of the matrix and use it to solve the system:\n[2 3]\n[4 5]\nwith b = [1 2]",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nb = np.array([1, 2])\nA_inv = np.linalg.inv(A)\nx = np.dot(A_inv, b)\nprint(x)"
    },
    {
        "input": "Solve the system using determinants:\n3x - y = 2\n2x + 4y = 10",
        "output": "import numpy as np\nA = np.array([[3, -1], [2, 4]])\nb = np.array([2, 10])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack([b, A[:,1]]))\nDy = np.linalg.det(np.column_stack([A[:,0], b]))\nx = Dx / D\ny = Dy / D\nprint((x, y))"
    },
    {
        "input": "A company produces two products, A and B. Each unit of A requires 2 hours of labor and 3 units of material. Each unit of B requires 1 hour of labor and 2 units of material. The company has 100 hours of labor and 120 units of material available. How many units of each product should be produced to use all resources?",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + y, 100)\neq2 = sp.Eq(3*x + 2*y, 120)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\n4x - 2y = 8\nx + y = 3",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(4*x - 2*y, 8)\neq2 = sp.Eq(x + y, 3)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the elimination method:\n6x + 4y = 20\n3x - 2y = 5",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(6*x + 4*y, 20)\neq2 = sp.Eq(3*x - 2*y, 5)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system of equations:\nx + 2y + 3z = 14\n2x + 3y + z = 13\n3x + y + 2z = 13",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 3, 1], [3, 1, 2]])\nb = np.array([14, 13, 13])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system using matrix inversion:\n[1 2]\n[3 4]\nb = [5 11]",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nb = np.array([5, 11])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "A small business makes two products. Each product A earns $40 profit and product B earns $30 profit. Each A takes 1 hour on machine 1 and 2 hours on machine 2. Each B takes 2 hours on machine 1 and 1 hour on machine 2. The company has 40 hours on machine 1 and 50 hours on machine 2. How many of each product to maximize profit using all available time?",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + 2*y, 40)\neq2 = sp.Eq(2*x + y, 50)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Use Gaussian elimination to solve:\n2x - y + z = 2\n3x + 2y - 4z = -2\n-x + 0.5y - z = 0",
        "output": "import sympy as sp\nA = sp.Matrix([[2, -1, 1, 2], [3, 2, -4, -2], [-1, 0.5, -1, 0]])\nA_rref, _ = A.rref()\nsp.pprint(A_rref)"
    },
    {
        "input": "Given the system:\n3x + 4y - 2z = 7\n-2x + y + 3z = -5\nx - y + z = 4\nFind the solution.",
        "output": "import numpy as np\nA = np.array([[3, 4, -2], [-2, 1, 3], [1, -1, 1]])\nb = np.array([7, -5, 4])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the following system with parametric solution (underdetermined):\nx + y + z = 3\n2x + 3y + 4z = 7",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [x + y + z - 3, 2*x + 3*y + 4*z - 7]\nsol = sp.linsolve(eqs, x, y, z)\nprint(sol)"
    },
    {
        "input": "Solve the system:\nx - y = 1\n2x + 3y = 12",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x - y, 1)\neq2 = sp.Eq(2*x + 3*y, 12)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\n2x + 3y = 16\n4x - y = 9",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 16)\neq2 = sp.Eq(4*x - y, 9)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the elimination method:\n5x + 2y = 20\n3x - 4y = -6",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x + 2*y, 20)\neq2 = sp.Eq(3*x - 4*y, -6)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using matrices:\n2x - y = 4\nx + 3y = 7",
        "output": "import numpy as np\nA = np.array([[2, -1], [1, 3]])\nb = np.array([4, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system of three variables:\nx + y + z = 6\n2x - y + 3z = 14\n-3x + 4y - z = -2",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [2, -1, 3], [-3, 4, -1]])\nb = np.array([6, 14, -2])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "A farmer has 100 acres of land to plant wheat and corn. Each acre of wheat yields $200 profit, and each acre of corn yields $300 profit. The farmer wants to plant all 100 acres and maximize profit. How many acres of each should be planted?",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 100)\neq2 = sp.Eq(200*x + 300*y, 200*x + 300*(100 - x))\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Find the inverse of the matrix and use it to solve the system:\n[3 2]\n[1 4]\nwith b = [7 10]",
        "output": "import numpy as np\nA = np.array([[3, 2], [1, 4]])\nb = np.array([7, 10])\nA_inv = np.linalg.inv(A)\nx = np.dot(A_inv, b)\nprint(x)"
    },
    {
        "input": "Solve the system using determinants:\n4x + y = 9\n2x - 3y = -4",
        "output": "import numpy as np\nA = np.array([[4, 1], [2, -3]])\nb = np.array([9, -4])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack([b, A[:,1]]))\nDy = np.linalg.det(np.column_stack([A[:,0], b]))\nx = Dx / D\ny = Dy / D\nprint((x, y))"
    },
    {
        "input": "A company produces two products, X and Y. Each unit of X requires 3 hours of labor and 2 units of material. Each unit of Y requires 2 hours of labor and 4 units of material. The company has 120 hours of labor and 160 units of material available. How many units of each product should be produced to use all resources?",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 2*y, 120)\neq2 = sp.Eq(2*x + 4*y, 160)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\n3x - y = 7\n2x + 4y = 10",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - y, 7)\neq2 = sp.Eq(2*x + 4*y, 10)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the elimination method:\n7x + 5y = 19\n4x - 3y = 2",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(7*x + 5*y, 19)\neq2 = sp.Eq(4*x - 3*y, 2)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using matrices:\n3x - 4y + z = 2\nx + 5y - 2z = 3\n2x - y + 3z = -1",
        "output": "import numpy as np\nA = np.array([[3, -4, 1], [1, 5, -2], [2, -1, 3]])\nb = np.array([2, 3, -1])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Use Cramer's Rule to solve:\n2x + 3y = 8\n4x - y = 2",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, -1]])\nb = np.array([8, 2])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack((b, A[:,1])))\nDy = np.linalg.det(np.column_stack((A[:,0], b)))\nx = Dx / D\ny = Dy / D\nprint((x, y))"
    },
    {
        "input": "Solve the following system using Gaussian elimination:\n1x + 2y + 3z = 9\n2x + 5y + 2z = 20\n4x + 2y + 5z = 31",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 2, 3, 9], [2, 5, 2, 20], [4, 2, 5, 31]])\nrref, _ = A.rref()\nsp.pprint(rref)"
    },
    {
        "input": "Use substitution to solve:\n3x + y = 10\nx = 2y - 4",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + y, 10)\neq2 = sp.Eq(x, 2*y - 4)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve using numpy:\n[2x - 3y = 1, x + 4y = 7]",
        "output": "import numpy as np\nA = np.array([[2, -3], [1, 4]])\nb = np.array([1, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the following system:\n3a + 4b = 10\n6a - 2b = 8",
        "output": "import sympy as sp\na, b = sp.symbols('a b')\neq1 = sp.Eq(3*a + 4*b, 10)\neq2 = sp.Eq(6*a - 2*b, 8)\nsol = sp.solve((eq1, eq2), (a, b))\nprint(sol)"
    },
    {
        "input": "Solve the system:\n2x + 3y + z = 5\n4x + y - z = 6\n-2x + 5y + 2z = -3",
        "output": "import numpy as np\nA = np.array([[2, 3, 1], [4, 1, -1], [-2, 5, 2]])\nb = np.array([5, 6, -3])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "A boat travels 24 miles downstream in 2 hours and returns upstream in 3 hours. Find the speed of the boat in still water and the speed of the current.",
        "output": "import sympy as sp\nb, c = sp.symbols('b c')\neq1 = sp.Eq(2*(b + c), 24)\neq2 = sp.Eq(3*(b - c), 24)\nsol = sp.solve((eq1, eq2), (b, c))\nprint(sol)"
    },
    {
        "input": "Solve the system with fractions:\n(1/2)x + (1/3)y = 1\n(2/3)x - (1/4)y = 2",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq((1/2)*x + (1/3)*y, 1)\neq2 = sp.Eq((2/3)*x - (1/4)*y, 2)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Use matrix row operations to solve:\n3x + y = 7\n2x - 5y = -3",
        "output": "import sympy as sp\nA = sp.Matrix([[3, 1, 7], [2, -5, -3]])\nrref, _ = A.rref()\nsp.pprint(rref)"
    },
    {
        "input": "You buy 5 notebooks and 3 pens for $13.50. Your friend buys 3 notebooks and 4 pens for $11. How much is each notebook and pen?",
        "output": "import sympy as sp\nn, p = sp.symbols('n p')\neq1 = sp.Eq(5*n + 3*p, 13.50)\neq2 = sp.Eq(3*n + 4*p, 11)\nsol = sp.solve((eq1, eq2), (n, p))\nprint(sol)"
    },
    {
        "input": "Solve the following system of 3 equations:\nx - y + 2z = 4\n3x + 2y - z = 5\n2x + y + z = 7",
        "output": "import numpy as np\nA = np.array([[1, -1, 2], [3, 2, -1], [2, 1, 1]])\nb = np.array([4, 5, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\n4a + 2b = 8\n3a - b = 5",
        "output": "import sympy as sp\na, b = sp.symbols('a b')\neq1 = sp.Eq(4*a + 2*b, 8)\neq2 = sp.Eq(3*a - b, 5)\nsol = sp.solve((eq1, eq2), (a, b))\nprint(sol)"
    },
    {
        "input": "A car rental company charges $25 per day and $0.10 per mile. Another company charges $30 per day and $0.05 per mile. At how many miles will the cost be the same?",
        "output": "import sympy as sp\nm = sp.symbols('m')\neq = sp.Eq(25 + 0.10*m, 30 + 0.05*m)\nsol = sp.solve(eq, m)\nprint(sol)"
    },
    {
        "input": "Solve the system with decimals:\n1.2x + 3.5y = 7.6\n0.8x - 1.2y = 2.4",
        "output": "import numpy as np\nA = np.array([[1.2, 3.5], [0.8, -1.2]])\nb = np.array([7.6, 2.4])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve this word problem:\nThe sum of two numbers is 10. Their difference is 4. What are the numbers?",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 10)\neq2 = sp.Eq(x - y, 4)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system:\n5x - 2y + z = 3\nx + y - z = 4\n2x - 3y + 2z = -6",
        "output": "import numpy as np\nA = np.array([[5, -2, 1], [1, 1, -1], [2, -3, 2]])\nb = np.array([3, 4, -6])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\n3x + 2y - z = 1\n2x - 2y + 4z = -2\n-1x + 0.5y - z = 0",
        "output": "import numpy as np\nA = np.array([[3, 2, -1], [2, -2, 4], [-1, 0.5, -1]])\nb = np.array([1, -2, 0])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve this practical system:\nYou buy 2 burgers and 3 drinks for $12. Your friend buys 3 burgers and 2 drinks for $13. How much is each burger and drink?",
        "output": "import sympy as sp\nb, d = sp.symbols('b d')\neq1 = sp.Eq(2*b + 3*d, 12)\neq2 = sp.Eq(3*b + 2*d, 13)\nsol = sp.solve((eq1, eq2), (b, d))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\n2x - 3y = 7\n4x + y = 5",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x - 3*y, 7)\neq2 = sp.Eq(4*x + y, 5)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the elimination method:\n3x + 4y = 12\n5x - 2y = 10",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 4*y, 12)\neq2 = sp.Eq(5*x - 2*y, 10)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using matrices:\n7x + 5y = 2\n3x - y = 6",
        "output": "import numpy as np\nA = np.array([[7, 5], [3, -1]])\nb = np.array([2, 6])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system of three variables:\n2x + y - z = 4\nx - 2y + 3z = -1\n3x + 4y - 5z = 2",
        "output": "import numpy as np\nA = np.array([[2, 1, -1], [1, -2, 3], [3, 4, -5]])\nb = np.array([4, -1, 2])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "A store sells two types of coffee: regular and premium. Regular coffee costs $5 per pound, and premium coffee costs $8 per pound. If a customer buys 10 pounds of coffee for a total of $70, how many pounds of each type did they purchase?",
        "output": "import sympy as sp\nr, p = sp.symbols('r p')\neq1 = sp.Eq(r + p, 10)\neq2 = sp.Eq(5*r + 8*p, 70)\nsol = sp.solve((eq1, eq2), (r, p))\nprint(sol)"
    },
    {
        "input": "Find the inverse of the matrix and use it to solve the system:\n[3 4]\n[2 5]\nwith b = [7 12]",
        "output": "import numpy as np\nA = np.array([[3, 4], [2, 5]])\nb = np.array([7, 12])\nA_inv = np.linalg.inv(A)\nx = np.dot(A_inv, b)\nprint(x)"
    },
    {
        "input": "Solve the system using determinants:\n4x - y = 9\n2x + 3y = 5",
        "output": "import numpy as np\nA = np.array([[4, -1], [2, 3]])\nb = np.array([9, 5])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack([b, A[:,1]]))\nDy = np.linalg.det(np.column_stack([A[:,0], b]))\nx = Dx / D\ny = Dy / D\nprint((x, y))"
    },
    {
        "input": "A company produces two products: desks and chairs. Each desk requires 4 hours of labor and 3 units of material. Each chair requires 2 hours of labor and 1 unit of material. The company has 100 hours of labor and 50 units of material available. How many desks and chairs should be produced to use all resources?",
        "output": "import sympy as sp\nd, c = sp.symbols('d c')\neq1 = sp.Eq(4*d + 2*c, 100)\neq2 = sp.Eq(3*d + c, 50)\nsol = sp.solve((eq1, eq2), (d, c))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\n5x - y = 3\nx + 3y = 7",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x - y, 3)\neq2 = sp.Eq(x + 3*y, 7)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the elimination method:\n2x + 3y = 8\n4x - y = 6",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 8)\neq2 = sp.Eq(4*x - y, 6)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve using Cramer's Rule:\n4x + 2y = 10\n3x + 5y = 11",
        "output": "import numpy as np\nA = np.array([[4, 2], [3, 5]])\nb = np.array([10, 11])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack([b, A[:, 1]]))\nDy = np.linalg.det(np.column_stack([A[:, 0], b]))\nx = Dx / D\ny = Dy / D\nprint((x, y))"
    },
    {
        "input": "Solve this homogeneous system:\n3x - 2y + z = 0\n-6x + 4y - 2z = 0\n9x - 6y + 3z = 0",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(3*x - 2*y + z, 0)\neq2 = sp.Eq(-6*x + 4*y - 2*z, 0)\neq3 = sp.Eq(9*x - 6*y + 3*z, 0)\nsol = sp.solve((eq1, eq2, eq3), (x, y, z), dict=True)\nprint(sol)"
    },
    {
        "input": "Use Gaussian elimination to solve:\n[2 1 -1 | 3]\n[-3 -1 2 | -11]\n[-2 1 2 | -3]",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 1, -1, 3], [-3, -1, 2, -11], [-2, 1, 2, -3]])\nRREF = A.rref()[0]\nprint(RREF)"
    },
    {
        "input": "Find the general solution to the system:\nx + 2y - z = 4\n2x + 4y - 2z = 8\n3x + 6y - 3z = 12",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + 2*y - z, 4)\neq2 = sp.Eq(2*x + 4*y - 2*z, 8)\neq3 = sp.Eq(3*x + 6*y - 3*z, 12)\nsol = sp.solve((eq1, eq2, eq3), (x, y, z), dict=True)\nprint(sol)"
    },
    {
        "input": "Use matrix inverse to solve:\n[1 2]\n[3 4] * [x y]^T = [5 6]^T",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nb = np.array([5, 6])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Use LU decomposition to solve:\nA = [[4, 3], [6, 3]], b = [10, 12]",
        "output": "import scipy.linalg as la\nimport numpy as np\nA = np.array([[4, 3], [6, 3]])\nb = np.array([10, 12])\nP, L, U = la.lu(A)\ny = np.linalg.solve(L, np.dot(P.T, b))\nx = np.linalg.solve(U, y)\nprint(x)"
    },
    {
        "input": "Solve by Gauss-Jordan elimination:\n[1 -2 3 | 9]\n[2 1 2 | 8]\n[3 0 -1 | 3]",
        "output": "import sympy as sp\nA = sp.Matrix([[1, -2, 3, 9], [2, 1, 2, 8], [3, 0, -1, 3]])\nRREF = A.rref()[0]\nprint(RREF)"
    },
    {
        "input": "Solve this system:\n5x - 3y + z = -1\n2x + 4y - 3z = 7\nx + y + z = 2",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(5*x - 3*y + z, -1)\neq2 = sp.Eq(2*x + 4*y - 3*z, 7)\neq3 = sp.Eq(x + y + z, 2)\nsol = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(sol)"
    },
    {
        "input": "Use Cramer's Rule to solve:\n2x + y = 1\n3x - y = 2",
        "output": "import numpy as np\nA = np.array([[2, 1], [3, -1]])\nb = np.array([1, 2])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack([b, A[:, 1]]))\nDy = np.linalg.det(np.column_stack([A[:, 0], b]))\nx = Dx / D\ny = Dy / D\nprint((x, y))"
    },
    {
        "input": "Solve the system using matrix inverse:\n3x + 4y = 5\n2x + y = 1",
        "output": "import numpy as np\nA = np.array([[3, 4], [2, 1]])\nb = np.array([5, 1])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve the homogeneous system:\n2x - 4y + 6z = 0\n-x + 2y - 3z = 0\n4x - 8y + 12z = 0",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x - 4*y + 6*z, 0)\neq2 = sp.Eq(-x + 2*y - 3*z, 0)\neq3 = sp.Eq(4*x - 8*y + 12*z, 0)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z), dict=True)\nprint(sol)"
    },
    {
        "input": "Solve this system of three equations with three unknowns:\n4x - y + z = 7\n2x + 3y - z = 4\n-x + 2y + 5z = 6",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x - y + z, 7)\neq2 = sp.Eq(2*x + 3*y - z, 4)\neq3 = sp.Eq(-x + 2*y + 5*z, 6)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Solve using Gauss-Jordan elimination:\n[1 1 -1 | 9]\n[2 -1 1 | -2]\n[3 2 -4 | 3]",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 1, -1, 9], [2, -1, 1, -2], [3, 2, -4, 3]])\nRREF = A.rref()[0]\nprint(RREF)"
    },
    {
        "input": "Find the general solution of:\nx - y + 2z = 3\n2x - 2y + 4z = 6",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x - y + 2*z, 3)\neq2 = sp.Eq(2*x - 2*y + 4*z, 6)\nsol = sp.solve([eq1, eq2], (x, y, z), dict=True)\nprint(sol)"
    },
    {
        "input": "Solve using Cramer's Rule:\n7x + 4y = 13\n5x - 2y = 3",
        "output": "import numpy as np\nA = np.array([[7, 4], [5, -2]])\nb = np.array([13, 3])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack([b, A[:, 1]]))\nDy = np.linalg.det(np.column_stack([A[:, 0], b]))\nx = Dx / D\ny = Dy / D\nprint((x, y))"
    },
    {
        "input": "Solve the system:\nx + y + z = 1\nx - y + z = 3\n2x + y + 3z = 4",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + y + z, 1)\neq2 = sp.Eq(x - y + z, 3)\neq3 = sp.Eq(2*x + y + 3*z, 4)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Use Gaussian elimination to solve:\n[3 2 -1 | 1]\n[2 -2 4 | -2]\n[-1 0.5 -1 | 0]",
        "output": "import sympy as sp\nA = sp.Matrix([[3, 2, -1, 1], [2, -2, 4, -2], [-1, 0.5, -1, 0]])\nRREF = A.rref()[0]\nprint(RREF)"
    },
    {
        "input": "Solve by finding the inverse of the matrix:\n[1 2 3]\n[0 1 4]\n[5 6 0] and b = [6 4 2]",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [0, 1, 4], [5, 6, 0]])\nb = np.array([6, 4, 2])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve the linear system:\n4x - y + 3z = 7\n2x + y - z = 3\n-2x + 5y + 2z = 9",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x - y + 3*z, 7)\neq2 = sp.Eq(2*x + y - z, 3)\neq3 = sp.Eq(-2*x + 5*y + 2*z, 9)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Solve:\n3x + y = 10\n2x - y = 3",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + y, 10)\neq2 = sp.Eq(2*x - y, 3)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Use LU decomposition to solve:\nA = [[2, 1], [8, 7]], b = [3, 24]",
        "output": "import scipy.linalg as la\nimport numpy as np\nA = np.array([[2, 1], [8, 7]])\nb = np.array([3, 24])\nP, L, U = la.lu(A)\ny = np.linalg.solve(L, P.T @ b)\nx = np.linalg.solve(U, y)\nprint(x)"
    },
    {
        "input": "Solve the following matrix equation:\nAX = B where A = [[1, 2], [3, 4]], B = [[5], [11]]",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5], [11]])\nX = np.linalg.solve(A, B)\nprint(X)"
    },
    {
        "input": "Is the following system inconsistent?\n[1 2 3 | 4]\n[0 0 0 | 1]",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 2, 3, 4], [0, 0, 0, 1]])\nRREF = A.rref()[0]\nprint(RREF)"
    },
    {
        "input": "Use parametric form to solve:\nx - y + 2z = 3\n2x - 2y + 4z = 6\n-3x + 3y - 6z = -9",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x - y + 2*z, 3)\neq2 = sp.Eq(2*x - 2*y + 4*z, 6)\neq3 = sp.Eq(-3*x + 3*y - 6*z, -9)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z), dict=True)\nprint(sol)"
    },
    {
        "input": "Solve:\nx + y + z = 0\n2x + 3y + z = 1\n3x + 5y + 2z = 3",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + y + z, 0)\neq2 = sp.Eq(2*x + 3*y + z, 1)\neq3 = sp.Eq(3*x + 5*y + 2*z, 3)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Use augmented matrix to find solution of:\n[2 3 | 5]\n[4 6 | 10]",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 3, 5], [4, 6, 10]])\nRREF = A.rref()[0]\nprint(RREF)"
    },
    {
        "input": "Solve:\n2x + y + z = 7\nx + 3y + 2z = 13\n3x + y + 4z = 15",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x + y + z, 7)\neq2 = sp.Eq(x + 3*y + 2*z, 13)\neq3 = sp.Eq(3*x + y + 4*z, 15)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\n2x + 3y = 12\nx - y = 4",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 12)\neq2 = sp.Eq(x - y, 4)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the elimination method:\n3x - 2y = 5\n5x + 3y = 7",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - 2*y, 5)\neq2 = sp.Eq(5*x + 3*y, 7)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system of equations:\n4x + 5y - z = 10\n2x - y + 3z = 5\nx + 2y + 4z = 8",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x + 5*y - z, 10)\neq2 = sp.Eq(2*x - y + 3*z, 5)\neq3 = sp.Eq(x + 2*y + 4*z, 8)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Solve the system using matrix inversion:\n3x + 4y = 10\n5x - 2y = -3",
        "output": "import numpy as np\nA = np.array([[3, 4], [5, -2]])\nb = np.array([10, -3])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve the system using Cramer's Rule:\n2x + y - z = 3\nx - y + 2z = -2\n3x + 2y + z = 1",
        "output": "import numpy as np\nA = np.array([[2, 1, -1], [1, -1, 2], [3, 2, 1]])\nb = np.array([3, -2, 1])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack([b, A[:, 1], A[:, 2]]))\nDy = np.linalg.det(np.column_stack([A[:, 0], b, A[:, 2]]))\nDz = np.linalg.det(np.column_stack([A[:, 0], A[:, 1], b]))\nx = Dx / D\ny = Dy / D\nz = Dz / D\nprint((x, y, z))"
    },
    {
        "input": "Solve the system using Gaussian elimination:\n[1 2 3 | 4]\n[2 3 4 | 5]\n[3 4 5 | 6]",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])\nRREF = A.rref()[0]\nprint(RREF)"
    },
    {
        "input": "Solve the system:\n3x + 2y = 8\nx - 4y = -2",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 2*y, 8)\neq2 = sp.Eq(x - 4*y, -2)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system:\n2x - y + 3z = 7\nx + 4y - z = -1\n3x + y + 2z = 5",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x - y + 3*z, 7)\neq2 = sp.Eq(x + 4*y - z, -1)\neq3 = sp.Eq(3*x + y + 2*z, 5)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Solve the system using the elimination method:\n5x + 3y = 11\n3x - 2y = 4",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x + 3*y, 11)\neq2 = sp.Eq(3*x - 2*y, 4)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\n4x - y = 2\n2x + 3y = 12",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(4*x - y, 2)\neq2 = sp.Eq(2*x + 3*y, 12)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system:\n3x - y + 2z = 5\n2x + 4y - z = -1\nx - 2y + z = 0",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(3*x - y + 2*z, 5)\neq2 = sp.Eq(2*x + 4*y - z, -1)\neq3 = sp.Eq(x - 2*y + z, 0)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Solve the system:\nx + y = 6\nx - y = 4",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 6)\neq2 = sp.Eq(x - y, 4)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system:\n4x + y = 7\n-2x + 3y = 1",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(4*x + y, 7)\neq2 = sp.Eq(-2*x + 3*y, 1)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using matrices:\n[2 1 -1 | 8]\n[-3 -1 2 | -11]\n[-2 1 2 | -3]",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 1, -1, 8], [-3, -1, 2, -11], [-2, 1, 2, -3]])\nRREF = A.rref()[0]\nprint(RREF)"
    },
    {
        "input": "Find the solution to the system:\n5x - 3y + 2z = 3\n4x + y - z = 2\n-x + 2y + 5z = -4",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(5*x - 3*y + 2*z, 3)\neq2 = sp.Eq(4*x + y - z, 2)\neq3 = sp.Eq(-x + 2*y + 5*z, -4)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Solve the system using the inverse matrix method:\n[1 2 3 | 9]\n[0 1 4 | 10]\n[5 6 0 | 2]",
        "output": "import numpy as np\nA = np.array([[1,2,3], [0,1,4], [5,6,0]])\nb = np.array([9,10,2])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve the system:\n2x + 3y = 12\n4x + 6y = 24",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 12)\neq2 = sp.Eq(4*x + 6*y, 24)\nsol = sp.solve([eq1, eq2], (x, y), dict=True)\nprint(sol)"
    },
    {
        "input": "Solve the system:\nx - y + z = 0\n2x + y - z = 3\n3x + 2y + z = 5",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x - y + z, 0)\neq2 = sp.Eq(2*x + y - z, 3)\neq3 = sp.Eq(3*x + 2*y + z, 5)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Find the values of a and b that make the system consistent:\nx + ay = 2\n2x + 4y = b",
        "output": "import sympy as sp\nx, y, a, b = sp.symbols('x y a b')\neq1 = sp.Eq(x + a*y, 2)\neq2 = sp.Eq(2*x + 4*y, b)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Use Gaussian elimination to solve:\n[1 -1 2 | 3]\n[3 2 -4 | -10]\n[2 3 -1 | 1]",
        "output": "import sympy as sp\nA = sp.Matrix([[1, -1, 2, 3], [3, 2, -4, -10], [2, 3, -1, 1]])\nRREF = A.rref()[0]\nprint(RREF)"
    },
    {
        "input": "Solve the system:\n2x + 3y - z = 1\n4x + y + z = 7\n-2x + 5y - 3z = -4",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x + 3*y - z, 1)\neq2 = sp.Eq(4*x + y + z, 7)\neq3 = sp.Eq(-2*x + 5*y - 3*z, -4)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Use matrix method to solve:\n[1 3 1 | 9]\n[2 7 2 | 24]\n[1 5 2 | 17]",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 3, 1, 9], [2, 7, 2, 24], [1, 5, 2, 17]])\nRREF = A.rref()[0]\nprint(RREF)"
    },
    {
        "input": "Solve using substitution:\n3x + 2y = 16\ny = 4x - 5",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 2*y, 16)\neq2 = sp.Eq(y, 4*x - 5)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system:\n3x - y = 2\n6x - 2y = 4",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - y, 2)\neq2 = sp.Eq(6*x - 2*y, 4)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system with parametric solutions:\nx + y + z = 6\n2x + 3y + z = 10",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + y + z, 6)\neq2 = sp.Eq(2*x + 3*y + z, 10)\nsol = sp.solve([eq1, eq2], (x, y, z), dict=True)\nprint(sol)"
    },
    {
        "input": "Use Gaussian elimination:\n[1 2 3 | 14]\n[2 5 2 | 18]\n[2 3 1 | 10]",
        "output": "import sympy as sp\nA = sp.Matrix([[1,2,3,14],[2,5,2,18],[2,3,1,10]])\nRREF = A.rref()[0]\nprint(RREF)"
    },
    {
        "input": "Solve the system using numpy:\n[2 3 | 8]\n[1 -4 | -2]",
        "output": "import numpy as np\nA = np.array([[2, 3], [1, -4]])\nb = np.array([8, -2])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "Solve the system:\nx + y + z = 6\nx + 2y + 3z = 14\nx + 4y + 9z = 30",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + y + z, 6)\neq2 = sp.Eq(x + 2*y + 3*z, 14)\neq3 = sp.Eq(x + 4*y + 9*z, 30)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Use inverse matrix to solve:\n[1 2 | 5]\n[3 4 | 11]",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nb = np.array([5, 11])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
    },
    {
        "input": "Solve:\n4x + y - z = 5\n2x - 2y + z = -3\nx + y + z = 4",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x + y - z, 5)\neq2 = sp.Eq(2*x - 2*y + z, -3)\neq3 = sp.Eq(x + y + z, 4)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Solve the following linear system:\n3x + 4y = 7\n-6x - 8y = -14",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 4*y, 7)\neq2 = sp.Eq(-6*x - 8*y, -14)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system:\n7x + 2y = 3\n5x - 3y = -7",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(7*x + 2*y, 3)\neq2 = sp.Eq(5*x - 3*y, -7)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Find the solution to:\n-3x + 4y - 2z = 7\nx - y + z = -1\n2x + 3y - z = 4",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(-3*x + 4*y - 2*z, 7)\neq2 = sp.Eq(x - y + z, -1)\neq3 = sp.Eq(2*x + 3*y - z, 4)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Solve the system:\n5x - 2y = 7\n3x + 4y = -5",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x - 2*y, 7)\neq2 = sp.Eq(3*x + 4*y, -5)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "A boat travels 36 miles downstream in 3 hours and returns upstream in 4 hours. Find the speed of the boat in still water and the speed of the current.",
        "output": "import sympy as sp\nb, c = sp.symbols('b c')\neq1 = sp.Eq(3*(b + c), 36)\neq2 = sp.Eq(4*(b - c), 36)\nsol = sp.solve([eq1, eq2], (b, c))\nprint(sol)"
    },
    {
        "input": "Solve the system:\n2x + 3y = 8\n4x + 6y = 16",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 8)\neq2 = sp.Eq(4*x + 6*y, 16)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "The sum of two numbers is 15, and their difference is 3. Find the numbers.",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 15)\neq2 = sp.Eq(x - y, 3)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using matrices:\n[3 1 | 9]\n[2 4 | 12]",
        "output": "import numpy as np\nA = np.array([[3, 1], [2, 4]])\nb = np.array([9, 12])\nx = np.linalg.solve(A, b)\nprint(x)"
    },
    {
        "input": "A chemist needs to mix a 10% acid solution with a 25% acid solution to obtain 10 liters of a 15% solution. How many liters of each solution should be used?",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 10)\neq2 = sp.Eq(0.10*x + 0.25*y, 0.15*10)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system:\n3x + 4y - z = 5\n2x - y + 3z = 9\nx + 2y + z = 4",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(3*x + 4*y - z, 5)\neq2 = sp.Eq(2*x - y + 3*z, 9)\neq3 = sp.Eq(x + 2*y + z, 4)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Two angles are complementary. The measure of one angle is 10 degrees more than twice the other. Find the measures of the angles.",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 90)\neq2 = sp.Eq(x, 2*y + 10)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system:\n4x - y + z = 2\n3x + 2y - z = 5\nx - y + 2z = 3",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x - y + z, 2)\neq2 = sp.Eq(3*x + 2*y - z, 5)\neq3 = sp.Eq(x - y + 2*z, 3)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Solve the system:\n2x + 3y + 4z = 7\nx - y + z = 4\n3x + 2y - z = 5",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x + 3*y + 4*z, 7)\neq2 = sp.Eq(x - y + z, 4)\neq3 = sp.Eq(3*x + 2*y - z, 5)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Solve the system:\n2x - 3y + z = -4\nx + y - z = 3\n3x - 2y + 4z = 10",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x - 3*y + z, -4)\neq2 = sp.Eq(x + y - z, 3)\neq3 = sp.Eq(3*x - 2*y + 4*z, 10)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Find the values of x and y:\n3x - 5y = -4\n2x + y = 7",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - 5*y, -4)\neq2 = sp.Eq(2*x + y, 7)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the following:\n5x + 2y - z = 10\nx - y + 3z = 1\n2x + y + 2z = 7",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(5*x + 2*y - z, 10)\neq2 = sp.Eq(x - y + 3*z, 1)\neq3 = sp.Eq(2*x + y + 2*z, 7)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Using Cramer's Rule, solve:\n3x + y = 10\n2x - y = 4",
        "output": "import sympy as sp\nA = sp.Matrix([[3, 1], [2, -1]])\nB = sp.Matrix([10, 4])\nsol = A.LUsolve(B)\nprint(sol)"
    },
    {
        "input": "Solve:\nx + y + z = 6\n2x + 3y + z = 14\nx - y + 2z = 2",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + y + z, 6)\neq2 = sp.Eq(2*x + 3*y + z, 14)\neq3 = sp.Eq(x - y + 2*z, 2)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Solve by substitution:\n4x - y = 5\nx + 3y = 7",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(4*x - y, 5)\neq2 = sp.Eq(x + 3*y, 7)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Three consecutive integers add up to 96. Find the integers.",
        "output": "import sympy as sp\nx = sp.symbols('x')\neq = sp.Eq(x + (x+1) + (x+2), 96)\nsol = sp.solve(eq, x)\nprint([sol[0], sol[0]+1, sol[0]+2])"
    },
    {
        "input": "Two numbers differ by 5. Their sum is 21. Find the numbers.",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x - y, 5)\neq2 = sp.Eq(x + y, 21)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using Gaussian elimination:\n[2 1 -1 | 8]\n[-3 -1 2 | -11]\n[-2 1 2 | -3]",
        "output": "import numpy as np\nfrom scipy.linalg import solve\nA = np.array([[2, 1, -1], [-3, -1, 2], [-2, 1, 2]])\nb = np.array([8, -11, -3])\nx = solve(A, b)\nprint(x)"
    },
    {
        "input": "In a triangle, the sum of the angles is 180 degrees. One angle is twice the second, and the third angle is 30 degrees more than the second. Find the angles.",
        "output": "import sympy as sp\na, b, c = sp.symbols('a b c')\neq1 = sp.Eq(a + b + c, 180)\neq2 = sp.Eq(a, 2*b)\neq3 = sp.Eq(c, b + 30)\nsol = sp.solve([eq1, eq2, eq3], (a, b, c))\nprint(sol)"
    },
    {
        "input": "Solve:\n4x - y + 2z = 7\n-2x + 5y - z = -8\nx + 3y + 3z = 12",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x - y + 2*z, 7)\neq2 = sp.Eq(-2*x + 5*y - z, -8)\neq3 = sp.Eq(x + 3*y + 3*z, 12)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
    },
    {
        "input": "Solve:\n2x + 3y = 12\nx - y = 2",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 12)\neq2 = sp.Eq(x - y, 2)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system of equations:\n3x + 4y = 12\n5x - 2y = -6",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 4*y, 12)\neq2 = sp.Eq(5*x - 2*y, -6)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
    },
    {
        "input": "Solve the system of equations:\n2x - 3y + z = 7\n4x + y - 2z = -3\n-x + 2y + 3z = 4",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x - 3*y + z, 7)\neq2 = sp.Eq(4*x + y - 2*z, -3)\neq3 = sp.Eq(-x + 2*y + 3*z, 4)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
    },
    {
        "input": "Solve the system of equations:\n7a + 5b = 2\n3a - 2b = 8",
        "output": "import sympy as sp\na, b = sp.symbols('a b')\neq1 = sp.Eq(7*a + 5*b, 2)\neq2 = sp.Eq(3*a - 2*b, 8)\nsolution = sp.solve((eq1, eq2), (a, b))\nprint(solution)"
    },
    {
        "input": "Solve the system of equations:\n4p - q + 2r = 9\n2p + 3q - r = -4\n-p + 2q + 5r = 7",
        "output": "import sympy as sp\np, q, r = sp.symbols('p q r')\neq1 = sp.Eq(4*p - q + 2*r, 9)\neq2 = sp.Eq(2*p + 3*q - r, -4)\neq3 = sp.Eq(-p + 2*q + 5*r, 7)\nsolution = sp.solve((eq1, eq2, eq3), (p, q, r))\nprint(solution)"
    },
    {
        "input": "Solve the system of equations:\n5m + 2n - 3o = 10\n-3m + 4n + o = -5\n2m - n + 4o = 6",
        "output": "import sympy as sp\nm, n, o = sp.symbols('m n o')\neq1 = sp.Eq(5*m + 2*n - 3*o, 10)\neq2 = sp.Eq(-3*m + 4*n + o, -5)\neq3 = sp.Eq(2*m - n + 4*o, 6)\nsolution = sp.solve((eq1, eq2, eq3), (m, n, o))\nprint(solution)"
    },
    {
        "input": "Solve the system of equations:\n3x - y + 2z = 5\nx + 4y - z = 6\n2x - 3y + 3z = -4",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(3*x - y + 2*z, 5)\neq2 = sp.Eq(x + 4*y - z, 6)\neq3 = sp.Eq(2*x - 3*y + 3*z, -4)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
    },
    {
        "input": "Solve the system of equations:\n2a + 3b - c = 7\n4a - b + 5c = -3\n-a + 2b + 3c = 4",
        "output": "import sympy as sp\na, b, c = sp.symbols('a b c')\neq1 = sp.Eq(2*a + 3*b - c, 7)\neq2 = sp.Eq(4*a - b + 5*c, -3)\neq3 = sp.Eq(-a + 2*b + 3*c, 4)\nsolution = sp.solve((eq1, eq2, eq3), (a, b, c))\nprint(solution)"
    },
    {
        "input": "Solve the system of equations:\n5x + 3y = 11\n2x - 4y = -8",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x + 3*y, 11)\neq2 = sp.Eq(2*x - 4*y, -8)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
    },
    {
        "input": "Solve the system of equations:\n3p - 2q + r = 4\n2p + q - 3r = -6\np + 4q + 2r = 5",
        "output": "import sympy as sp\np, q, r = sp.symbols('p q r')\neq1 = sp.Eq(3*p - 2*q + r, 4)\neq2 = sp.Eq(2*p + q - 3*r, -6)\neq3 = sp.Eq(p + 4*q + 2*r, 5)\nsolution = sp.solve((eq1, eq2, eq3), (p, q, r))\nprint(solution)"
    },
    {
        "input": "Solve the system of equations:\n4x - 3y + 2z = 8\n2x + y - z = -3\n3x + 2y + 4z = 7",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x - 3*y + 2*z, 8)\neq2 = sp.Eq(2*x + y - z, -3)\neq3 = sp.Eq(3*x + 2*y + 4*z, 7)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
    },
    {
        "input": "Solve the system of equations:\n2x + 3y = 18\n4x - y = 2",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 18)\neq2 = sp.Eq(4*x - y, 2)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
    },
    {
        "input": "Solve the system of equations:\n6a - 4b = 10\n3a + 2b = 8",
        "output": "import sympy as sp\na, b = sp.symbols('a b')\neq1 = sp.Eq(6*a - 4*b, 10)\neq2 = sp.Eq(3*a + 2*b, 8)\nsolution = sp.solve((eq1, eq2), (a, b))\nprint(solution)"
    },
    {
        "input": "Solve the system of equations:\n7x - 2y + 3z = 5\n3x + 4y - z = 7\nx - y + 2z = 4",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(7*x - 2*y + 3*z, 5)\neq2 = sp.Eq(3*x + 4*y - z, 7)\neq3 = sp.Eq(x - y + 2*z, 4)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
    },
    {
        "input": "Solve the system using Cramer's Rule:\n2x + 3y = 7\n4x - y = 1",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[2, 3], [4, -1]])\nB = sp.Matrix([7, 1])\nsolution = A.LUsolve(B)\nprint(dict(zip((x, y), solution)))"
    },
    {
        "input": "Solve the system using Gaussian Elimination:\nx + y + z = 6\n2x + 3y + 7z = 20\n4x + 5y + 6z = 26",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[1,1,1,6],[2,3,7,20],[4,5,6,26]])\nreduced = A.rref()\nprint(reduced[0])"
    },
    {
        "input": "Find the solution to the system:\n3x + 2y = 12\nx - y = 1",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 2*y, 12)\neq2 = sp.Eq(x - y, 1)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
    },
    {
        "input": "Solve the following system:\n2x + 5y - z = 1\n3x - y + 2z = 4\nx + y + z = 6",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x + 5*y - z, 1)\neq2 = sp.Eq(3*x - y + 2*z, 4)\neq3 = sp.Eq(x + y + z, 6)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
    },
    {
        "input": "Solve the system of linear equations:\nx + 2y = 10\n3x + 4y = 24",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + 2*y, 10)\neq2 = sp.Eq(3*x + 4*y, 24)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
    },
    {
        "input": "Use Cramer's Rule to solve:\n4a + b = 7\na - 2b = -1",
        "output": "import sympy as sp\na, b = sp.symbols('a b')\nA = sp.Matrix([[4,1],[1,-2]])\nB = sp.Matrix([7,-1])\nsolution = A.LUsolve(B)\nprint(dict(zip((a, b), solution)))"
    },
    {
        "input": "Use augmented matrix and row reduction:\n2x - y = 3\n5x + 3y = 13",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[2, -1, 3], [5, 3, 13]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
    },
    {
        "input": "Solve the system:\n3m + 4n + 5o = 27\n2m - 2n + o = 1\nm + n + o = 10",
        "output": "import sympy as sp\nm, n, o = sp.symbols('m n o')\neq1 = sp.Eq(3*m + 4*n + 5*o, 27)\neq2 = sp.Eq(2*m - 2*n + o, 1)\neq3 = sp.Eq(m + n + o, 10)\nsolution = sp.solve((eq1, eq2, eq3), (m, n, o))\nprint(solution)"
    },
    {
        "input": "Solve the system:\n6x + 2y = 14\nx - 3y = -7",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(6*x + 2*y, 14)\neq2 = sp.Eq(x - 3*y, -7)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
    },
    {
        "input": "Solve the system:\n2x + y - z = 4\nx - y + 2z = 2\n3x + 2y + z = 10",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x + y - z, 4)\neq2 = sp.Eq(x - y + 2*z, 2)\neq3 = sp.Eq(3*x + 2*y + z, 10)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
    },
    {
        "input": "Use Gaussian elimination to solve:\n3x - 2y + 4z = 10\nx + y + z = 6\n2x - y + 3z = 9",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[3, -2, 4, 10], [1, 1, 1, 6], [2, -1, 3, 9]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
    },
    {
        "input": "Solve the system using matrix inverse method:\n5x + 3y = 16\nx + 2y = 8",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[5, 3], [1, 2]])\nB = sp.Matrix([16, 8])\nsolution = A.inv() * B\nprint(dict(zip((x, y), solution)))"
    },
    {
        "input": "Find parametric solution of the system:\nx - y + z = 0\n2x + y - z = 3",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x - y + z, 0)\neq2 = sp.Eq(2*x + y - z, 3)\nsolution = sp.solve((eq1, eq2), (x, y, z), dict=True)\nprint(solution)"
    },
    {
        "input": "Use Cramer's Rule to solve:\n3a + 2b = 7\n5a + 4b = 13",
        "output": "import sympy as sp\na, b = sp.symbols('a b')\nA = sp.Matrix([[3, 2], [5, 4]])\nB = sp.Matrix([7, 13])\nsolution = A.LUsolve(B)\nprint(dict(zip((a, b), solution)))"
    },
    {
        "input": "Solve for x, y, z:\nx + y + z = 3\nx - y + z = 1\nx + 2y - z = 4",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + y + z, 3)\neq2 = sp.Eq(x - y + z, 1)\neq3 = sp.Eq(x + 2*y - z, 4)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
    },
    {
        "input": "Solve this system using Gaussian elimination:\n3x + 2y = 12\nx - y = 1",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[3, 2, 12], [1, -1, 1]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
    },
    {
        "input": "Use inverse method:\n7x - 2y = 5\n3x + y = 4",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[7, -2], [3, 1]])\nB = sp.Matrix([5, 4])\nsolution = A.inv() * B\nprint(dict(zip((x, y), solution)))"
    },
    {
        "input": "Solve the system:\n2a - b + c = 3\na + b + c = 6\n3a - 2b + 4c = 10",
        "output": "import sympy as sp\na, b, c = sp.symbols('a b c')\neq1 = sp.Eq(2*a - b + c, 3)\neq2 = sp.Eq(a + b + c, 6)\neq3 = sp.Eq(3*a - 2*b + 4*c, 10)\nsolution = sp.solve((eq1, eq2, eq3), (a, b, c))\nprint(solution)"
    },
    {
        "input": "Solve for x and y:\n8x - 3y = 17\n2x + 5y = 1",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(8*x - 3*y, 17)\neq2 = sp.Eq(2*x + 5*y, 1)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
    },
    {
        "input": "Solve:\n4x + y - z = 8\nx - y + z = 2\n3x + 2y + z = 13",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x + y - z, 8)\neq2 = sp.Eq(x - y + z, 2)\neq3 = sp.Eq(3*x + 2*y + z, 13)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
    },
    {
        "input": "Use augmented matrix form:\n2x - y = 4\n-3x + 4y = -10",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[2, -1, 4], [-3, 4, -10]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
    },
    {
        "input": "Solve this system:\n5x + 2y = 9\nx + y = 3",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x + 2*y, 9)\neq2 = sp.Eq(x + y, 3)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
    },
    {
        "input": "Find values of x, y such that:\n3x + 4y = 11\n6x + 8y = 22",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neqs = [sp.Eq(3*x + 4*y, 11), sp.Eq(6*x + 8*y, 22)]\nsolution = sp.solve(eqs, (x, y), dict=True)\nprint(solution)"
    },
    {
        "input": "Use Gaussian elimination to solve:\nx - 2y + z = 1\n2x + y - 3z = -2\n3x - y + 2z = 0",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[1, -2, 1, 1], [2, 1, -3, -2], [3, -1, 2, 0]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
    },
    {
        "input": "Solve the system:\n3a + b = 7\na - b = 1",
        "output": "import sympy as sp\na, b = sp.symbols('a b')\neq1 = sp.Eq(3*a + b, 7)\neq2 = sp.Eq(a - b, 1)\nsolution = sp.solve((eq1, eq2), (a, b))\nprint(solution)"
    },
    {
        "input": "Solve this linear system:\n4x - 2y + z = 5\nx + y - z = 2\n2x - y + 3z = 10",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x - 2*y + z, 5)\neq2 = sp.Eq(x + y - z, 2)\neq3 = sp.Eq(2*x - y + 3*z, 10)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
    },
    {
        "input": "Solve the system:\n2x - y + 3z = 7\nx + 4y - z = -1\n3x - y + z = 10",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x - y + 3*z, 7)\neq2 = sp.Eq(x + 4*y - z, -1)\neq3 = sp.Eq(3*x - y + z, 10)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
    },
    {
        "input": "Find the inverse solution for:\n3x + y = 7\n2x - 4y = -6",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[3, 1], [2, -4]])\nB = sp.Matrix([7, -6])\nsolution = A.inv() * B\nprint(dict(zip((x, y), solution)))"
    },
    {
        "input": "Solve using Gaussian elimination:\n2x + y + z = 4\nx - y + 2z = 1\n3x + 2y - z = 7",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[2, 1, 1, 4], [1, -1, 2, 1], [3, 2, -1, 7]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
    },
    {
        "input": "Solve the following linear system:\n5x + y = 11\nx - y = 1",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x + y, 11)\neq2 = sp.Eq(x - y, 1)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
    },
    {
        "input": "Use Cramerâ€™s Rule to solve:\n2x + y = 3\nx - y = 1",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[2, 1], [1, -1]])\nB = sp.Matrix([3, 1])\nsolution = A.LUsolve(B)\nprint(dict(zip((x, y), solution)))"
    },
    {
        "input": "Solve this 2x2 system:\n4x - y = 9\n2x + 3y = 1",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(4*x - y, 9)\neq2 = sp.Eq(2*x + 3*y, 1)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
    },
    {
        "input": "Use augmented matrix:\n2a + 3b + c = 1\n4a + 6b + 2c = 2\n3a - b + c = 0",
        "output": "import sympy as sp\na, b, c = sp.symbols('a b c')\nA = sp.Matrix([[2, 3, 1, 1], [4, 6, 2, 2], [3, -1, 1, 0]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
    },
    {
        "input": "Find parametric form of the solution:\nx + y - z = 0\n2x - y + z = 1",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(x + y - z, 0), sp.Eq(2*x - y + z, 1)]\nsolution = sp.solve(eqs, (x, y, z), dict=True)\nprint(solution)"
    },
    {
        "input": "Use inverse matrix method:\n4a + b = 10\n2a - b = 2",
        "output": "import sympy as sp\na, b = sp.symbols('a b')\nA = sp.Matrix([[4, 1], [2, -1]])\nB = sp.Matrix([10, 2])\nsolution = A.inv() * B\nprint(dict(zip((a, b), solution)))"
    },
    {
        "input": "Solve:\nx + 2y + z = 4\n3x + y - z = 3\n2x + 3y + 4z = 10",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(x + 2*y + z, 4), sp.Eq(3*x + y - z, 3), sp.Eq(2*x + 3*y + 4*z, 10)]\nsolution = sp.solve(eqs, (x, y, z))\nprint(solution)"
    },
    {
        "input": "Use RREF to solve:\n2x - y + 3z = 7\nx + 4y - z = -1\n3x - y + z = 10",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[2, -1, 3, 7], [1, 4, -1, -1], [3, -1, 1, 10]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
    },
    {
        "input": "Solve this:\n4x + y - 2z = 5\n3x - 2y + z = 2\n2x + y + 3z = 12",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(4*x + y - 2*z, 5), sp.Eq(3*x - 2*y + z, 2), sp.Eq(2*x + y + 3*z, 12)]\nsolution = sp.solve(eqs, (x, y, z))\nprint(solution)"
    },
    {
        "input": "Find the solution using inverse matrix:\n3x + 2y = 12\nx + 4y = 10",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[3, 2], [1, 4]])\nB = sp.Matrix([12, 10])\nsolution = A.inv() * B\nprint(dict(zip((x, y), solution)))"
    },
    {
        "input": "Solve:\n5x + 2y - z = 3\n3x - y + 4z = 7\nx + y + z = 6",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(5*x + 2*y - z, 3), sp.Eq(3*x - y + 4*z, 7), sp.Eq(x + y + z, 6)]\nsolution = sp.solve(eqs, (x, y, z))\nprint(solution)"
    },
    {
        "input": "Use Gaussian elimination:\n4x + 2y = 10\n2x + y = 5",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[4, 2, 10], [2, 1, 5]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
    },
    {
        "input": "Solve the system:\n7x - y = 3\n2x + 5y = 11",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(7*x - y, 3)\neq2 = sp.Eq(2*x + 5*y, 11)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
    },
    {
        "input": "Find solution:\n3a + 2b = 14\na - 4b = -10",
        "output": "import sympy as sp\na, b = sp.symbols('a b')\neq1 = sp.Eq(3*a + 2*b, 14)\neq2 = sp.Eq(a - 4*b, -10)\nsolution = sp.solve((eq1, eq2), (a, b))\nprint(solution)"
    },
    {
        "input": "Solve the system:\n3x + 4y = 12\n5x - 2y = 10",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 4*y, 12)\neq2 = sp.Eq(5*x - 2*y, 10)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
    },
    {
        "input": "Solve using substitution:\nx + 2y = 10\n3x - y = 5",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + 2*y, 10)\neq2 = sp.Eq(3*x - y, 5)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
    },
    {
        "input": "Solve the 3Ã—3 system:\nx + y - z = 2\n2x + y + z = 7\nx - y + 2z = 4",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(x + y - z, 2), sp.Eq(2*x + y + z, 7), sp.Eq(x - y + 2*z, 4)]\nsolution = sp.solve(eqs, (x, y, z))\nprint(solution)"
    },
    {
        "input": "Use Cramerâ€™s Rule to solve:\n2x + y = 7\nx - 3y = -8",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[2, 1], [1, -3]])\nB = sp.Matrix([7, -8])\nsolution = A.inv() * B\nprint(dict(zip((x, y), solution)))"
    },
    {
        "input": "Solve using Gauss Elimination:\n2x + 3y + z = 10\n4x - y + 5z = 5\nx + 2y - 3z = -4",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[2, 3, 1, 10], [4, -1, 5, 5], [1, 2, -3, -4]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
    },
    {
        "input": "Use RREF to solve:\nx - 2y + z = 3\n3x + y - z = 7\n2x - y + 4z = 5",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[1, -2, 1, 3], [3, 1, -1, 7], [2, -1, 4, 5]])\nrref_matrix, _ = A.rref()\nprint(rref_matrix)"
    },
    {
        "input": "Find the parametric form of the solution:\n2x + y + z = 3\n4x + 2y + 2z = 6",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x + y + z, 3)\neq2 = sp.Eq(4*x + 2*y + 2*z, 6)\nsolution = sp.solve((eq1, eq2), (x, y, z), dict=True)\nprint(solution)"
    },
    {
        "input": "Solve:\nx + y + z = 6\nx + 2y + 3z = 14\n2x + 3y + az = b (express in terms of a and b)",
        "output": "import sympy as sp\nx, y, z, a, b = sp.symbols('x y z a b')\neqs = [sp.Eq(x + y + z, 6), sp.Eq(x + 2*y + 3*z, 14), sp.Eq(2*x + 3*y + a*z, b)]\nsolution = sp.solve(eqs, (x, y, z), dict=True)\nprint(solution)"
    },
    {
        "input": "Solve the homogeneous system:\n3x - y + 2z = 0\n2x + 4y - z = 0\nx + y + z = 0",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(3*x - y + 2*z, 0), sp.Eq(2*x + 4*y - z, 0), sp.Eq(x + y + z, 0)]\nsolution = sp.solve(eqs, (x, y, z), dict=True)\nprint(solution)"
    },
    {
        "input": "Use Gaussian elimination to solve:\n3x + 2y - z = 1\n2x - 2y + 4z = -2\n-1x + 0.5y - z = 0",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[3, 2, -1, 1], [2, -2, 4, -2], [-1, 0.5, -1, 0]])\nrref, _ = A.rref()\nprint(rref)"
    },
    {
        "input": "Find the inverse of matrix A and use it to solve Ax = b:\nA = [[1, 2], [3, 4]], b = [5, 11]",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 2], [3, 4]])\nb = sp.Matrix([5, 11])\nx = A.inv() * b\nprint('Solution:', x)"
    },
    {
        "input": "Use matrix inverse to solve:\nA = [[2, 1], [5, 3]], b = [1, 2]",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 1], [5, 3]])\nb = sp.Matrix([1, 2])\nx = A.inv() * b\nprint('Solution:', x)"
    },
    {
        "input": "Perform one row operation to eliminate x from second equation:\nRow1: x + 2y = 4\nRow2: 3x + y = 5",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 2, 4], [3, 1, 5]])\nA[1,:] = A[1,:] - 3*A[0,:]\nprint(A)"
    },
    {
        "input": "Write the augmented matrix of the system:\n2x + y - z = 1\n-x + 3y + 2z = 4\n3x - 2y + z = 5",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 1, -1, 1], [-1, 3, 2, 4], [3, -2, 1, 5]])\nprint('Augmented matrix:', A)"
    },
    {
        "input": "Find the null space of the matrix:\nA = [[1, 2, 3], [2, 4, 6]]",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 2, 3], [2, 4, 6]])\nnullspace = A.nullspace()\nprint('Null space:', nullspace)"
    },
    {
        "input": "Solve:\n3x - 2y + z = 1\nx + y + z = 4\n2x + 3y - z = 2",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(3*x - 2*y + z, 1), sp.Eq(x + y + z, 4), sp.Eq(2*x + 3*y - z, 2)]\nsolution = sp.solve(eqs, (x, y, z), dict=True)\nprint(solution)"
    },
    {
        "input": "Reduce the matrix to echelon form:\nA = [[1, 2, -1], [2, 4, 0], [-1, -2, 2]]",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 2, -1], [2, 4, 0], [-1, -2, 2]])\nA_echelon = A.echelon_form()\nprint(A_echelon)"
    },
    {
        "input": "Find determinant and solution:\n2x + y = 5\nx - y = 1",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[2, 1], [1, -1]])\nb = sp.Matrix([5, 1])\ndet = A.det()\nsol = A.inv() * b if det != 0 else 'No inverse'\nprint('Determinant:', det, 'Solution:', sol)"
    },
    {
        "input": "Find general solution for the system:\nx + 2y + z = 4\n2x + 4y + 2z = 8",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(x + 2*y + z, 4), sp.Eq(2*x + 4*y + 2*z, 8)]\nsolution = sp.solve(eqs, (x, y, z), dict=True)\nprint(solution)"
    },
    {
        "input": "Solve by substitution:\nx + y = 5\nx - y = 1",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\ny_expr = 5 - x\nx_val = sp.solve(x - y_expr - 1, x)[0]\ny_val = 5 - x_val\nprint('x =', x_val, ', y =', y_val)"
    },
    {
        "input": "Use Gaussian elimination to solve:\n4x + y + z = 7\n2x + 3y + 2z = 4\nx + y + z = 3",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[4, 1, 1, 7], [2, 3, 2, 4], [1, 1, 1, 3]])\nrref, _ = A.rref()\nprint(rref)"
    },
    {
        "input": "Solve the system using the elimination method:\n6x + y = 8\n4x + 2y = 0",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(6*x + y, 8)\neq2 = sp.Eq(4*x + 2*y, 0)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the elimination method:\n-3x + 4y = 12\n6x - 8y = -24",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(-3*x + 4*y, 12)\neq2 = sp.Eq(6*x - 8*y, -24)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the elimination method:\n2x - 5y = 20\n4x - 10y = 40",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x - 5*y, 20)\neq2 = sp.Eq(4*x - 10*y, 40)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Use Cramerâ€™s Rule to solve the system:\n2x + 3y = 5\n4x - y = 1",
        "output": "import sympy as sp\nfrom sympy import Matrix\nx, y = sp.symbols('x y')\nA = Matrix([[2, 3], [4, -1]])\nB = Matrix([5, 1])\nsol = A.LUsolve(B)\nprint(dict(zip((x, y), sol)))"
    },
    {
        "input": "Use Cramerâ€™s Rule to solve the system:\n3x - y = 4\n2x + 5y = 1",
        "output": "import sympy as sp\nfrom sympy import Matrix\nx, y = sp.symbols('x y')\nA = Matrix([[3, -1], [2, 5]])\nB = Matrix([4, 1])\nsol = A.LUsolve(B)\nprint(dict(zip((x, y), sol)))"
    },
    {
        "input": "Use matrix inverse to solve the system:\n2x + y = 3\nx - y = 1",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, -1]])\nB = np.array([3, 1])\nX = np.linalg.inv(A).dot(B)\nprint({'x': X[0], 'y': X[1]})"
    },
    {
        "input": "Use matrix inverse to solve the system:\n4x - 2y = 10\n-3x + y = -5",
        "output": "import numpy as np\nA = np.array([[4, -2], [-3, 1]])\nB = np.array([10, -5])\nX = np.linalg.inv(A).dot(B)\nprint({'x': X[0], 'y': X[1]})"
    },
    {
        "input": "Find the solution using Gaussian elimination:\n3x + 2y = 16\nx - y = 1",
        "output": "import numpy as np\nA = np.array([[3, 2, 16], [1, -1, 1]], dtype=float)\nA[1] = A[1] - A[0]*(A[1][0]/A[0][0])\nA[1] = A[1]/A[1][1]\nA[0] = A[0] - A[1]*(A[0][1])\nA[0] = A[0]/A[0][0]\nprint({'x': A[0][2], 'y': A[1][2]})"
    },
    {
        "input": "Solve the system of equations:\n2x + 3y - z = 5\n4x - y + 2z = 6\n-6x + 5y + z = -4",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x + 3*y - z, 5)\neq2 = sp.Eq(4*x - y + 2*z, 6)\neq3 = sp.Eq(-6*x + 5*y + z, -4)\nsol = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(sol)"
    },
    {
        "input": "Solve for x and y:\n7x + 3y = -1\n-2x + 5y = 17",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(7*x + 3*y, -1)\neq2 = sp.Eq(-2*x + 5*y, 17)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Use matrix methods to solve:\n5x - 4y = 9\n-3x + 2y = -7",
        "output": "import numpy as np\nA = np.array([[5, -4], [-3, 2]])\nB = np.array([9, -7])\nX = np.linalg.solve(A, B)\nprint({'x': X[0], 'y': X[1]})"
    },
    {
        "input": "Use Gaussian elimination to solve:\nx + y + z = 6\n2x - y + 3z = 14\nx + 2y - z = -2",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + y + z, 6)\neq2 = sp.Eq(2*x - y + 3*z, 14)\neq3 = sp.Eq(x + 2*y - z, -2)\nsol = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\n7x - 8y = -12\n-4x + 2y = 3",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(7*x - 8*y, -12)\neq2 = sp.Eq(-4*x + 2*y, 3)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\n3x + 9y = -6\n-4x - 12y = 8",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 9*y, -6)\neq2 = sp.Eq(-4*x - 12*y, 8)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\n-7x + 7y = 63\ny = 6 - 2x",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(-7*x + 7*y, 63)\neq2 = sp.Eq(y, 6 - 2*x)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\n3x - 8y = 27\ny = 4 - 7x",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - 8*y, 27)\neq2 = sp.Eq(y, 4 - 7*x)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\nx = 19 + 7y\n3x - 3y = 3",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x, 19 + 7*y)\neq2 = sp.Eq(3*x - 3*y, 3)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\nx = 39 + 8y\n-9x + 2y = -71",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x, 39 + 8*y)\neq2 = sp.Eq(-9*x + 2*y, -71)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\nx = -5 - 2y\n-2x - 6y = 18",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x, -5 - 2*y)\neq2 = sp.Eq(-2*x - 6*y, 18)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\nx = 15 + 6y\n9x + 3y = 21",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x, 15 + 6*y)\neq2 = sp.Eq(9*x + 3*y, 21)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\n6x - 8y = 24\ny = 15 + 3x",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(6*x - 8*y, 24)\neq2 = sp.Eq(y, 15 + 3*x)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\n9x + 8y = -45\ny = 15 - 8x",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(9*x + 8*y, -45)\neq2 = sp.Eq(y, 15 - 8*x)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the elimination method:\nx + 4y = 0\n9x - 7y = -43",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + 4*y, 0)\neq2 = sp.Eq(9*x - 7*y, -43)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the elimination method:\nx + 6y = -53\n5x - 9y = 47",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + 6*y, -53)\neq2 = sp.Eq(5*x - 9*y, 47)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the substitution method:\n2x + 3y = 6\nx - 4y = 8",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 6)\neq2 = sp.Eq(x - 4*y, 8)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the elimination method:\n5x - 2y = 9\n3x + 4y = -7",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x - 2*y, 9)\neq2 = sp.Eq(3*x + 4*y, -7)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Use Cramer's Rule to solve the system:\n3x + y = 7\n2x - 5y = -3",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[3, 1], [2, -5]])\nB = sp.Matrix([7, -3])\nsol = A.inv() * B\nprint(dict(zip((x, y), sol)))"
    },
    {
        "input": "Solve the system using matrix inverses:\n4x + y = 5\n-2x + 3y = 4",
        "output": "import numpy as np\nA = np.array([[4, 1], [-2, 3]])\nB = np.array([5, 4])\nX = np.linalg.inv(A).dot(B)\nprint({'x': X[0], 'y': X[1]})"
    },
    {
        "input": "Solve the system using the substitution method:\n7x - 3y = 10\n2x + y = 5",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(7*x - 3*y, 10)\neq2 = sp.Eq(2*x + y, 5)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the elimination method:\n6x + 5y = 20\n4x - 2y = -6",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(6*x + 5*y, 20)\neq2 = sp.Eq(4*x - 2*y, -6)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Use Cramer's Rule to solve the system:\n5x + 2y = 3\n3x - y = 7",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[5, 2], [3, -1]])\nB = sp.Matrix([3, 7])\nsol = A.inv() * B\nprint(dict(zip((x, y), sol)))"
    },
    {
        "input": "Solve the system using matrix inverses:\n3x - y = 4\nx + 2y = -1",
        "output": "import numpy as np\nA = np.array([[3, -1], [1, 2]])\nB = np.array([4, -1])\nX = np.linalg.inv(A).dot(B)\nprint({'x': X[0], 'y': X[1]})"
    },
    {
        "input": "Solve the system using the substitution method:\n4x + 3y = 14\n2x - 5y = -3",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(4*x + 3*y, 14)\neq2 = sp.Eq(2*x - 5*y, -3)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the elimination method:\n3x + 4y = 12\n5x - 2y = 8",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 4*y, 12)\neq2 = sp.Eq(5*x - 2*y, 8)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Use Cramer's Rule to solve the system:\n2x - 3y = 5\n4x + y = -2",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[2, -3], [4, 1]])\nB = sp.Matrix([5, -2])\nsol = A.inv() * B\nprint(dict(zip((x, y), sol)))"
    },
    {
        "input": "Solve the system using matrix inverses:\n5x + y = 6\n3x - 4y = 2",
        "output": "import numpy as np\nA = np.array([[5, 1], [3, -4]])\nB = np.array([6, 2])\nX = np.linalg.inv(A).dot(B)\nprint({'x': X[0], 'y': X[1]})"
    },
    {
        "input": "Solve the system using the substitution method:\n3x - 2y = 7\nx + 4y = -5",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - 2*y, 7)\neq2 = sp.Eq(x + 4*y, -5)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system using the elimination method:\n6x - y = 10\n-3x + 2y = -5",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(6*x - y, 10)\neq2 = sp.Eq(-3*x + 2*y, -5)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Use Cramer's Rule to solve:\n4x + y = 1\nx - 2y = 3",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[4, 1], [1, -2]])\nB = sp.Matrix([1, 3])\nsol = A.inv() * B\nprint(dict(zip((x, y), sol)))"
    },
    {
        "input": "Solve using matrix inverse method:\n2x + 5y = 11\n3x - y = 4",
        "output": "import numpy as np\nA = np.array([[2, 5], [3, -1]])\nB = np.array([11, 4])\nX = np.linalg.inv(A).dot(B)\nprint({'x': X[0], 'y': X[1]})"
    },
    {
        "input": "Solve the system using substitution:\n3x = y + 2\n4x - y = 6",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x, y + 2)\neq2 = sp.Eq(4*x - y, 6)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system:\n7x + 2y = 16\nx - y = 3",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(7*x + 2*y, 16)\neq2 = sp.Eq(x - y, 3)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Use Cramer's Rule to solve:\n3x - 4y = -1\n2x + y = 5",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[3, -4], [2, 1]])\nB = sp.Matrix([-1, 5])\nsol = A.inv() * B\nprint(dict(zip((x, y), sol)))"
    },
    {
        "input": "Solve using matrix inverses:\n6x + 7y = 13\n4x - y = 9",
        "output": "import numpy as np\nA = np.array([[6, 7], [4, -1]])\nB = np.array([13, 9])\nX = np.linalg.inv(A).dot(B)\nprint({'x': X[0], 'y': X[1]})"
    },
    {
        "input": "Solve by elimination:\n2x + y = 5\n-6x + 3y = -15",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + y, 5)\neq2 = sp.Eq(-6*x + 3*y, -15)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve the system:\nx + y = 6\n2x - 3y = -7",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 6)\neq2 = sp.Eq(2*x - 3*y, -7)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve using substitution:\n3x - y = 0\nx + 2y = 8",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - y, 0)\neq2 = sp.Eq(x + 2*y, 8)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve using Cramer's Rule:\n5x - y = 4\n2x + 3y = 7",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[5, -1], [2, 3]])\nB = sp.Matrix([4, 7])\nsol = A.inv() * B\nprint(dict(zip((x, y), sol)))"
    },
    {
        "input": "Solve with matrix inverse:\n7x + 3y = 10\nx + 2y = 1",
        "output": "import numpy as np\nA = np.array([[7, 3], [1, 2]])\nB = np.array([10, 1])\nX = np.linalg.inv(A).dot(B)\nprint({'x': X[0], 'y': X[1]})"
    },
    {
        "input": "Solve by substitution:\n2x = y - 1\nx + y = 4",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x, y - 1)\neq2 = sp.Eq(x + y, 4)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve by elimination:\n4x + 3y = 24\n2x - 6y = 10",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(4*x + 3*y, 24)\neq2 = sp.Eq(2*x - 6*y, 10)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Solve:\nx - y = 1\nx + y = 5",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x - y, 1)\neq2 = sp.Eq(x + y, 5)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
    },
    {
        "input": "Find the rank of the matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[0, 0, 0], [0, 0, 0], [0, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 0, 0], [0, 0, 0], [0, 0, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1, 0, 0], [0, 1, 0], [0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[2, 4, 6], [1, 2, 3], [3, 6, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 4, 6], [1, 2, 3], [3, 6, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[5, 10], [10, 20]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 10], [10, 20]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1, 2, 3], [0, 0, 0], [4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [0, 0, 0], [4, 5, 6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1, 2], [2, 4], [3, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [2, 4], [3, 6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 10]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 10]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1, 0, 0], [0, 0, 0], [0, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 0], [0, 0, 0], [0, 0, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 2], [3, 4], [5, 6], [7, 8]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[2, 3, 5], [4, 6, 10], [1, 1.5, 2.5]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3, 5], [4, 6, 10], [1, 1.5, 2.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 2, 3], [0, 1, 4], [0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [0, 1, 4], [0, 0, 1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[2, 4, 1], [0, 3, 7], [6, 9, 8]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 4, 1], [0, 3, 7], [6, 9, 8]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[5, 0, 0], [0, 5, 0], [0, 0, 5]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 0, 0], [0, 5, 0], [0, 0, 5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[0, 1, 2], [1, 0, 3], [4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 1, 2], [1, 0, 3], [4, 5, 6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1, 1, 1], [1, 1, 1], [1, 1, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 1, 1], [1, 1, 1], [1, 1, 1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[2, 3, 5], [4, 6, 10], [8, 12, 20]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3, 5], [4, 6, 10], [8, 12, 20]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1, 2], [3, 6], [5, 10]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 6], [5, 10]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[7, 8, 9], [2, 4, 6], [3, 6, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[7, 8, 9], [2, 4, 6], [3, 6, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[2, 4, 6], [1, 2, 3], [0, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 4, 6], [1, 2, 3], [0, 0, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[3, 1, 4], [1, 5, 9], [2, 6, 5]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 1, 4], [1, 5, 9], [2, 6, 5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 2, 1], [2, 4, 2], [3, 6, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 1], [2, 4, 2], [3, 6, 3]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[0, 0, 0], [0, 1, 0], [0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 0, 0], [0, 1, 0], [0, 0, 1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1, 3, 5], [2, 4, 6], [3, 5, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 3, 5], [2, 4, 6], [3, 5, 7]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[3, 6, 9], [2, 4, 6], [1, 2, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 6, 9], [2, 4, 6], [1, 2, 3]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[10, 20], [5, 10]].",
        "output": "import numpy as np\nmatrix = np.array([[10, 20], [5, 10]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the zero matrix of order 3.",
        "output": "import numpy as np\nmatrix = np.zeros((3, 3))\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 10]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 10]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the rank of matrix [[2, 4], [6, 12]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 4], [6, 12]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of a diagonal matrix with one zero entry: [[1,0,0], [0,0,0], [0,0,3]].",
        "output": "import numpy as np\nmatrix = np.array([[1,0,0], [0,0,0], [0,0,3]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[1, 0, 0], [0, 1, 0], [0, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of the identity matrix of order 4?",
        "output": "import numpy as np\nmatrix = np.identity(4)\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix with a row of zeros: [[3, 5, 2], [1, 2, 1], [0, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 5, 2], [1, 2, 1], [0, 0, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of a 2x2 invertible matrix [[7, 3], [2, 5]].",
        "output": "import numpy as np\nmatrix = np.array([[7, 3], [2, 5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of [[1, 2, 3], [2, 4, 6], [3, 6, 9]]?",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [2, 4, 6], [3, 6, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of a matrix where all elements are the same: [[5, 5], [5, 5]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 5], [5, 5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the rank of matrix [[1, 1, 1], [1, 2, 3], [1, 4, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 1, 1], [1, 2, 3], [1, 4, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of a matrix with full row rank but more columns than rows: [[1, 2, 3], [4, 5, 6]]?",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of [[0, 2], [0, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 2], [0, 4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of a 1x3 matrix [[4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 5, 6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of a matrix with a column of zeros: [[2, 0, 3], [4, 0, 6], [6, 0, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 0, 3], [4, 0, 6], [6, 0, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[1, 3], [2, 6], [3, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 3], [2, 6], [3, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of a 3x3 matrix with two linearly dependent rows?",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [2, 4, 6], [5, 6, 7]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of a sparse matrix [[0, 0, 5], [0, 0, 0], [0, 0, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 0, 5], [0, 0, 0], [0, 0, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of [[1, 0], [0, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0], [0, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the rank of the matrix [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of a matrix [[1, 0, 0], [0, 0, 0], [0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 0], [0, 0, 0], [0, 0, 1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of matrix [[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12]]?",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[2, 4, 6], [1, 2, 3], [3, 6, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 4, 6], [1, 2, 3], [3, 6, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of the matrix [[1, 0, 0], [0, 1, 0], [0, 0, 1]]?",
        "output": "import numpy as np\nmatrix = np.identity(3)\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1, 2, 3], [0, 0, 0], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [0, 0, 0], [7, 8, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4], [5, 6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 10]]?",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 10]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[2, 3], [5, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3], [5, 7]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1, 2, 3], [4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 2], [2, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [2, 4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]?",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1, 2], [3, 4], [5, 6], [7, 8]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1, 0, 0], [0, 1, 0], [0, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[2, 4, 6], [4, 8, 12], [6, 12, 18]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 4, 6], [4, 8, 12], [6, 12, 18]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[2, 4, 6], [8, 10, 12], [14, 16, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 4, 6], [8, 10, 12], [14, 16, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[-1, -2, -3], [-4, -5, -6], [-7, -8, -7]].",
        "output": "import numpy as np\nmatrix = np.array([[-1, -2, -3], [-4, -5, -6], [-7, -8, -7]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 5, 6], [1, 0, 1], [1, 3, 2]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 5, 6], [1, 0, 1], [1, 3, 2]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of the matrix [[7, 0, 0], [1, 8, 2], [0, 4, 1]]?",
        "output": "import numpy as np\nmatrix = np.array([[7, 0, 0], [1, 8, 2], [0, 4, 1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of the matrix [[10, 5], [6, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[10, 5], [6, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[5, 3], [2, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 3], [2, 4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[2, 4, 2, 4], [2, 6, 4, 4], [4, 8, 6, 8], [6, 14, 8, 12]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 4, 2, 4], [2, 6, 4, 4], [4, 8, 6, 8], [6, 14, 8, 12]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of the matrix [[0, 0, 0], [0, 0, 0], [0, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.zeros((3, 3))\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1, 0, 0], [0, 1, 0], [0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.identity(3)\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1, 2], [2, 4], [3, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [2, 4], [3, 6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 2, 3], [0, 0, 0], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [0, 0, 0], [7, 8, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of the matrix [[1, 2], [3, 4], [5, 6]]?",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4], [5, 6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 10]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 10]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[0, 0, 0], [0, 0, 0], [0, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.zeros((3, 3))\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 0, 0], [0, 1, 0], [0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.identity(3)\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of the matrix [[2, 4, 6], [1, 2, 3], [3, 6, 9]]?",
        "output": "import numpy as np\nmatrix = np.array([[2, 4, 6], [1, 2, 3], [3, 6, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of the matrix [[5, 10, 15], [10, 20, 30], [15, 30, 45]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 10, 15], [10, 20, 30], [15, 30, 45]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4], [5, 6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[2, 3, 5], [7, 11, 13], [17, 19, 23]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3, 5], [7, 11, 13], [17, 19, 23]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of the matrix [[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12]]?",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of the matrix [[0, 1, 2], [0, 0, 3], [0, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 1, 2], [0, 0, 3], [0, 0, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 10]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 10]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of the matrix [[1, 0, 0], [0, 1, 0], [0, 0, 0], [0, 0, 0]]?",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 0], [0, 0, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1, 2, 4, 4], [5, 6, 7, 8], [9, 10, 11, 12]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[3, 6, 9], [1, 2, 4], [4, 8, 12]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 6, 9], [1, 2, 3], [4, 8, 12]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of the matrix [[1, 3, 5], [2, 4, 6], [3, 6, 9]]?",
        "output": "import numpy as np\nmatrix = np.array([[1, 3, 5], [2, 4, 6], [3, 6, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1, 0, 0], [0, 1, 0], [0, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.identity(4)\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of the matrix [[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 13]]?",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 13]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1, 2, 2], [4, 5, 6], [7, 8, 10]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 2], [4, 5, 6], [7, 8, 10]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[8, 2, 3, 4], [5, 6, 8, 8], [9, 10, 11, 12]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12], [4, 8, 12, 16]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12], [4, 8, 12, 16]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[0, 0, 2], [0, 0, 0], [0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 0, 0], [0, 0, 0], [0, 0, 1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 2], [2, 4], [3, 6], [4, 8]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [2, 4], [3, 6], [4, 8]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of the matrix [[5, 0, 0], [0, 0, 0], [5, 0, 0]]?",
        "output": "import numpy as np\nmatrix = np.array([[5, 0, 0], [5, 0, 0], [0, 0, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[2, 3, 5], [7, 11, 13], [17, 19, 23], [29, 31, 37]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3, 5], [7, 11, 13], [17, 19, 23], [29, 31, 37]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.identity(5)\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of the matrix [[1, 2, 3], [2, 4, 6], [3, 6, 9], [4, 8, 12]]?",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [2, 4, 6], [3, 6, 9], [4, 8, 12]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of the matrix [[0, 1, 2, 3], [0, 0, 3, 4], [0, 0, 0, 5], [0, 0, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 1, 2, 3], [0, 0, 3, 4], [0, 0, 0, 5], [0, 0, 0, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 10], [11, 12, 13]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 10], [11, 12, 13]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1, 2], [2, 4], [3, 6], [4, 8], [5, 10]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [2, 4], [3, 6], [4, 8], [5, 10]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[2, 4, 6], [4, 8, 12], [6, 12, 18]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 4, 6], [4, 8, 12], [6, 12, 18]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of the matrix [[1, 2, 3], [0, 0, 0], [0, 0, 0]]?",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [0, 0, 0], [0, 0, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of the matrix [[1, 0, 0], [0, 1, 0], [0, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1, 0], [0, 1], [1, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0], [0, 1], [1, 1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[2, 3, 5], [7, 11, 13], [17, 19, 23]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3, 5], [7, 11, 13], [17, 19, 23]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[2, -3, 1], [4, -6, 2], [1, -1.5, 0.5]].",
        "output": "import numpy as np\nmatrix = np.array([[2, -3, 1], [4, -6, 2], [1, -1.5, 0.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the rank of matrix [[1, 2, 1], [2, 4, 2], [3, 6, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 1], [2, 4, 2], [3, 6, 3]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of the matrix [[1, 2, 3], [0, 1, 4], [5, 6, 0]]?",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [0, 1, 4], [5, 6, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[3, 0, 2], [2, 0, -2], [0, 1, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 0, 2], [2, 0, -2], [0, 1, 1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[1, 1, 1, 1], [0, 1, 2, 3], [1, 2, 3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 1, 1, 1], [0, 1, 2, 3], [1, 2, 3, 4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of a matrix formed by rows [1, 0, 1], [0, 1, 1], [1, 1, 2].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 1], [0, 1, 1], [1, 1, 2]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1, 0, 0], [2, 3, 0], [4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 0], [2, 3, 0], [4, 5, 6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of matrix [[3, 2, 1], [6, 4, 2], [9, 6, 3]]?",
        "output": "import numpy as np\nmatrix = np.array([[3, 2, 1], [6, 4, 2], [9, 6, 3]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine rank of matrix [[4, 2], [8, 4], [12, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 2], [8, 4], [12, 6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[1, 2], [2, 5], [3, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [2, 5], [3, 7]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of a matrix where all rows are multiples of [1, 1, 1].",
        "output": "import numpy as np\nmatrix = np.array([[1, 1, 1], [2, 2, 2], [3, 3, 3]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the rank of matrix [[4, 5, 6], [2, 3, 1], [6, 7, 5]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 5, 6], [2, 3, 1], [6, 7, 5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[2, 4, 6], [1, 3, 5], [0, 1, 2]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 4, 6], [1, 3, 5], [0, 1, 2]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find rank of matrix [[7, 8, 9], [5, 6, 4], [3, 2, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[7, 8, 9], [5, 6, 4], [3, 2, 1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate rank of matrix [[1, 3, 5, 7], [2, 4, 6, 8], [3, 6, 9, 12]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 3, 5, 7], [2, 4, 6, 8], [3, 6, 9, 12]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine rank of the matrix with rows [0, 1, 0], [1, 0, 0], [0, 0, 1].",
        "output": "import numpy as np\nmatrix = np.array([[0, 1, 0], [1, 0, 0], [0, 0, 1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of matrix [[1, 2, 3], [2, 4, 6], [3, 6, 9.001]]?",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [2, 4, 6], [3, 6, 9.001]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of a matrix with one row being all nines: [[1, 2, 3], [9, 9, 9], [3, 6, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [9, 9, 9], [3, 6, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the rank of the matrix formed by [[2, 5], [4, 10], [6, 15]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 5], [4, 10], [6, 15]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate rank of matrix [[0, 0, 1], [0, 1, 0], [1, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 0, 1], [0, 1, 0], [1, 0, 0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of matrix [[1, 4, 7], [2, 5, 8], [3, 6, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 4, 7], [2, 5, 8], [3, 6, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[1, 1, 1, 1], [1, 2, 3, 4], [4, 3, 2, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 1, 1, 1], [1, 2, 3, 4], [4, 3, 2, 1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of matrix [[0, 0], [0, 5], [0, 10]]?",
        "output": "import numpy as np\nmatrix = np.array([[0, 0], [0, 5], [0, 10]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find rank of matrix [[2, 3], [4, 6.1], [6, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3], [4, 6.1], [6, 9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[1.2, 2.4], [2.4, 4.8]].",
        "output": "import numpy as np\nmatrix = np.array([[1.2, 2.4], [2.4, 4.8]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the rank of matrix [[0.5, 1.0], [1.5, 2.0]].",
        "output": "import numpy as np\nmatrix = np.array([[0.5, 1.0], [1.5, 2.0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[3.14, 2.71], [1.61, 0.57]].",
        "output": "import numpy as np\nmatrix = np.array([[3.14, 2.71], [1.61, 0.57]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of matrix [[1.1, 2.2, 3.3], [2.2, 4.4, 6.6]].",
        "output": "import numpy as np\nmatrix = np.array([[1.1, 2.2, 3.3], [2.2, 4.4, 6.6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of matrix [[0.1, 0.2, 0.3], [0.3, 0.6, 0.9], [0.2, 0.4, 0.6]]?",
        "output": "import numpy as np\nmatrix = np.array([[0.1, 0.2, 0.3], [0.3, 0.6, 0.9], [0.2, 0.4, 0.6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[2.5, 3.5], [5.0, 7.0]].",
        "output": "import numpy as np\nmatrix = np.array([[2.5, 3.5], [5.0, 7.0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[1.001, 1.002], [2.002, 2.004]].",
        "output": "import numpy as np\nmatrix = np.array([[1.001, 1.002], [2.002, 2.004]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[0.5, 1.5, 2.5], [1.0, 3.0, 5.0], [1.5, 4.5, 7.5]].",
        "output": "import numpy as np\nmatrix = np.array([[0.5, 1.5, 2.5], [1.0, 3.0, 5.0], [1.5, 4.5, 7.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the rank of matrix [[1.2, 3.5], [2.4, 7.0], [3.6, 10.5]].",
        "output": "import numpy as np\nmatrix = np.array([[1.2, 3.5], [2.4, 7.0], [3.6, 10.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[0.3, 0.6], [0.9, 1.8], [1.2, 2.4]].",
        "output": "import numpy as np\nmatrix = np.array([[0.3, 0.6], [0.9, 1.8], [1.2, 2.4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of matrix [[4.1, 5.2, 6.3], [2.2, 3.3, 4.4], [6.3, 8.4, 10.5]]?",
        "output": "import numpy as np\nmatrix = np.array([[4.1, 5.2, 6.3], [2.2, 3.3, 4.4], [6.3, 8.4, 10.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[7.7, 8.8, 9.9], [6.6, 5.5, 4.4], [3.3, 2.2, 1.1]].",
        "output": "import numpy as np\nmatrix = np.array([[7.7, 8.8, 9.9], [6.6, 5.5, 4.4], [3.3, 2.2, 1.1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[1.111, 2.222], [3.333, 4.444]].",
        "output": "import numpy as np\nmatrix = np.array([[1.111, 2.222], [3.333, 4.444]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of matrix [[5.5, 6.6], [11.0, 13.2]].",
        "output": "import numpy as np\nmatrix = np.array([[5.5, 6.6], [11.0, 13.2]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate rank of matrix [[0.123, 0.456], [0.789, 1.234]].",
        "output": "import numpy as np\nmatrix = np.array([[0.123, 0.456], [0.789, 1.234]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate rank of matrix [[9.8, 7.6, 5.4], [3.2, 1.0, 0.9], [6.7, 8.8, 9.9]].",
        "output": "import numpy as np\nmatrix = np.array([[9.8, 7.6, 5.4], [3.2, 1.0, 0.9], [6.7, 8.8, 9.9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine rank of matrix [[2.25, 3.75], [4.5, 7.5]].",
        "output": "import numpy as np\nmatrix = np.array([[2.25, 3.75], [4.5, 7.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find rank of matrix [[0.0, 0.1], [0.1, 0.0]].",
        "output": "import numpy as np\nmatrix = np.array([[0.0, 0.1], [0.1, 0.0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[3.3, 2.2], [6.6, 4.4], [9.9, 6.6]].",
        "output": "import numpy as np\nmatrix = np.array([[3.3, 2.2], [6.6, 4.4], [9.9, 6.6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[0.12, 0.34], [0.56, 0.78]].",
        "output": "import numpy as np\nmatrix = np.array([[0.12, 0.34], [0.56, 0.78]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine rank of matrix [[5.25, 6.75], [10.5, 13.5]].",
        "output": "import numpy as np\nmatrix = np.array([[5.25, 6.75], [10.5, 13.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of matrix [[0.999, 0.998], [0.997, 0.996]]?",
        "output": "import numpy as np\nmatrix = np.array([[0.999, 0.998], [0.997, 0.996]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate rank of matrix [[0.01, 0.02, 0.03], [0.04, 0.05, 0.06]].",
        "output": "import numpy as np\nmatrix = np.array([[0.01, 0.02, 0.03], [0.04, 0.05, 0.06]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate rank of matrix [[1.234, 2.345, 3.456], [4.567, 5.678, 6.789]].",
        "output": "import numpy as np\nmatrix = np.array([[1.234, 2.345, 3.456], [4.567, 5.678, 6.789]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[0.2, 0.4, 0.6], [0.1, 0.2, 0.3], [0.3, 0.6, 0.9]].",
        "output": "import numpy as np\nmatrix = np.array([[0.2, 0.4, 0.6], [0.1, 0.2, 0.3], [0.3, 0.6, 0.9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[2.3, 3.6, 4.8], [1.1, 2.2, 3.3], [3.4, 5.8, 8.1]].",
        "output": "import numpy as np\nmatrix = np.array([[2.3, 3.6, 4.8], [1.1, 2.2, 3.3], [3.4, 5.8, 8.1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the rank of matrix [[1.5, 2.5, 3.5], [3.0, 5.0, 7.0], [4.5, 7.5, 10.5]].",
        "output": "import numpy as np\nmatrix = np.array([[1.5, 2.5, 3.5], [3.0, 5.0, 7.0], [4.5, 7.5, 10.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of matrix [[0.33, 0.66], [0.99, 1.32]]?",
        "output": "import numpy as np\nmatrix = np.array([[0.33, 0.66], [0.99, 1.32]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[2.0, 4.0], [1.0, 2.0], [0.5, 1.0]].",
        "output": "import numpy as np\nmatrix = np.array([[2.0, 4.0], [1.0, 2.0], [0.5, 1.0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute rank of matrix [[1.25, 2.50], [2.50, 5.00]].",
        "output": "import numpy as np\nmatrix = np.array([[1.25, 2.50], [2.50, 5.00]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[3.3, 6.6, 9.9], [6.6, 13.2, 19.8]].",
        "output": "import numpy as np\nmatrix = np.array([[3.3, 6.6, 9.9], [6.6, 13.2, 19.8]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine rank of matrix [[5.5, 11.0], [11.0, 22.0], [16.5, 33.0]].",
        "output": "import numpy as np\nmatrix = np.array([[5.5, 11.0], [11.0, 22.0], [16.5, 33.0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the rank of matrix [[0.1, 0.1, 0.1], [0.1, 0.1, 0.1], [0.1, 0.1, 0.1]].",
        "output": "import numpy as np\nmatrix = np.array([[0.1, 0.1, 0.1], [0.1, 0.1, 0.1], [0.1, 0.1, 0.1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate rank of matrix [[0.99, 1.98], [1.98, 3.96], [2.97, 5.94]].",
        "output": "import numpy as np\nmatrix = np.array([[0.99, 1.98], [1.98, 3.96], [2.97, 5.94]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of matrix [[3.7, 1.8], [7.2, 3.5], [5.1, 2.4]]?",
        "output": "import numpy as np\nmatrix = np.array([[3.7, 1.8], [7.2, 3.5], [5.1, 2.4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[0.55, 0.65, 0.75], [1.1, 1.3, 1.5]].",
        "output": "import numpy as np\nmatrix = np.array([[0.55, 0.65, 0.75], [1.1, 1.3, 1.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find rank of matrix [[8.8, 9.9, 10.1], [4.4, 5.5, 6.6], [2.2, 3.3, 4.4]].",
        "output": "import numpy as np\nmatrix = np.array([[8.8, 9.9, 10.1], [4.4, 5.5, 6.6], [2.2, 3.3, 4.4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[1.9, 3.8], [3.8, 7.6], [5.7, 11.4]].",
        "output": "import numpy as np\nmatrix = np.array([[1.9, 3.8], [3.8, 7.6], [5.7, 11.4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate rank of matrix [[0.25, 0.50, 0.75], [0.50, 1.00, 1.50], [0.75, 1.50, 2.25]].",
        "output": "import numpy as np\nmatrix = np.array([[0.25, 0.50, 0.75], [0.50, 1.00, 1.50], [0.75, 1.50, 2.25]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[2.8, 3.6, 4.4], [5.6, 7.2, 8.8], [8.4, 10.8, 13.2]].",
        "output": "import numpy as np\nmatrix = np.array([[2.8, 3.6, 4.4], [5.6, 7.2, 8.8], [8.4, 10.8, 13.2]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of matrix [[1.6, 3.2], [3.2, 6.4], [4.8, 9.6]].",
        "output": "import numpy as np\nmatrix = np.array([[1.6, 3.2], [3.2, 6.4], [4.8, 9.6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate rank of matrix [[0.45, 0.90], [0.90, 1.80], [1.35, 2.70]].",
        "output": "import numpy as np\nmatrix = np.array([[0.45, 0.90], [0.90, 1.80], [1.35, 2.70]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find rank of matrix [[0.101, 0.202], [0.303, 0.404]].",
        "output": "import numpy as np\nmatrix = np.array([[0.101, 0.202], [0.303, 0.404]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of matrix [[0.01, 0.03], [0.05, 0.07]]?",
        "output": "import numpy as np\nmatrix = np.array([[0.01, 0.03], [0.05, 0.07]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine rank of matrix [[1.1, 2.3], [3.5, 4.7], [5.9, 6.8]].",
        "output": "import numpy as np\nmatrix = np.array([[1.1, 2.3], [3.5, 4.7], [5.9, 6.8]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the rank of matrix [[2.222, 3.333], [4.444, 5.555]].",
        "output": "import numpy as np\nmatrix = np.array([[2.222, 3.333], [4.444, 5.555]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1.2, 2.4, 3.6], [4.8, 6.0, 7.2], [8.4, 9.6, 10.8]].",
        "output": "import numpy as np\nmatrix = np.array([[1.2, 2.4, 3.6], [4.8, 6.0, 7.2], [8.4, 9.6, 10.8]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[0.5, 1.5], [1.0, 3.0], [1.5, 4.5]].",
        "output": "import numpy as np\nmatrix = np.array([[0.5, 1.5], [1.0, 3.0], [1.5, 4.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the rank of matrix [[2.25, 4.5, 6.75], [1.5, 3.0, 4.5], [0.75, 1.5, 2.25]].",
        "output": "import numpy as np\nmatrix = np.array([[2.25, 4.5, 6.75], [1.5, 3.0, 4.5], [0.75, 1.5, 2.25]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of matrix [[4.4, 2.2], [6.6, 3.3]]?",
        "output": "import numpy as np\nmatrix = np.array([[4.4, 2.2], [6.6, 3.3]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[0.1, 0.3, 0.5], [0.2, 0.6, 1.0], [0.4, 1.2, 2.0]].",
        "output": "import numpy as np\nmatrix = np.array([[0.1, 0.3, 0.5], [0.2, 0.6, 1.0], [0.4, 1.2, 2.0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate rank of matrix [[9.9, 8.8, 7.7], [6.6, 5.5, 4.4], [3.3, 2.2, 1.1]].",
        "output": "import numpy as np\nmatrix = np.array([[9.9, 8.8, 7.7], [6.6, 5.5, 4.4], [3.3, 2.2, 1.1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of matrix [[2.1, 3.2], [4.3, 6.4], [6.5, 9.6]].",
        "output": "import numpy as np\nmatrix = np.array([[2.1, 3.2], [4.3, 6.4], [6.5, 9.6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate rank of matrix [[3.3, 3.3], [6.6, 6.6]].",
        "output": "import numpy as np\nmatrix = np.array([[3.3, 3.3], [6.6, 6.6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of matrix [[0.05, 0.10], [0.10, 0.20]]?",
        "output": "import numpy as np\nmatrix = np.array([[0.05, 0.10], [0.10, 0.20]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[0.2, 0.4], [0.6, 0.8], [1.0, 1.2]].",
        "output": "import numpy as np\nmatrix = np.array([[0.2, 0.4], [0.6, 0.8], [1.0, 1.2]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[5.5, 4.4, 3.3], [2.2, 1.1, 0.0], [0.0, -1.1, -2.2]].",
        "output": "import numpy as np\nmatrix = np.array([[5.5, 4.4, 3.3], [2.2, 1.1, 0.0], [0.0, -1.1, -2.2]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[7.1, 8.2], [9.3, 10.4], [11.5, 12.6]].",
        "output": "import numpy as np\nmatrix = np.array([[7.1, 8.2], [9.3, 10.4], [11.5, 12.6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate rank of matrix [[1.0, 2.0, 3.0], [4.1, 5.1, 6.1], [7.2, 8.2, 9.2]].",
        "output": "import numpy as np\nmatrix = np.array([[1.0, 2.0, 3.0], [4.1, 5.1, 6.1], [7.2, 8.2, 9.2]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[-1.1, -2.2], [3.3, 4.4]].",
        "output": "import numpy as np\nmatrix = np.array([[-1.1, -2.2], [3.3, 4.4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[0.333, 0.667, 1.000], [0.999, 1.333, 1.667]].",
        "output": "import numpy as np\nmatrix = np.array([[0.333, 0.667, 1.000], [0.999, 1.333, 1.667]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of matrix [[1.1, 2.2], [2.2, 4.4]]?",
        "output": "import numpy as np\nmatrix = np.array([[1.1, 2.2], [2.2, 4.4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find rank of matrix [[9.1, 8.3, 7.2], [6.2, 5.1, 4.0], [3.0, 2.5, 1.5]].",
        "output": "import numpy as np\nmatrix = np.array([[9.1, 8.3, 7.2], [6.2, 5.1, 4.0], [3.0, 2.5, 1.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of matrix [[0.15, 0.3], [0.3, 0.6], [0.45, 0.9]].",
        "output": "import numpy as np\nmatrix = np.array([[0.15, 0.3], [0.3, 0.6], [0.45, 0.9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate rank of matrix [[1.123, 2.246], [3.369, 4.492]].",
        "output": "import numpy as np\nmatrix = np.array([[1.123, 2.246], [3.369, 4.492]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of matrix [[4.0, 4.0], [4.0, 4.0]]?",
        "output": "import numpy as np\nmatrix = np.array([[4.0, 4.0], [4.0, 4.0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[0.33, 0.66], [0.99, 1.32], [1.65, 1.98]].",
        "output": "import numpy as np\nmatrix = np.array([[0.33, 0.66], [0.99, 1.32], [1.65, 1.98]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find rank of matrix [[7.25, 5.75, 3.25], [2.50, 1.25, 0.75], [1.00, 0.50, 0.25]].",
        "output": "import numpy as np\nmatrix = np.array([[7.25, 5.75, 3.25], [2.50, 1.25, 0.75], [1.00, 0.50, 0.25]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of matrix [[3.333, 3.667], [4.444, 5.556], [6.666, 7.777]].",
        "output": "import numpy as np\nmatrix = np.array([[3.333, 3.667], [4.444, 5.556], [6.666, 7.777]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[1.2, 3.4], [5.6, 7.8]].",
        "output": "import numpy as np\nmatrix = np.array([[1.2, 3.4], [5.6, 7.8]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[0.1, 0.2], [0.2, 0.4]].",
        "output": "import numpy as np\nmatrix = np.array([[0.1, 0.2], [0.2, 0.4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the rank of the matrix [[9.1, 8.2, 7.3], [6.4, 5.5, 4.6], [3.7, 2.8, 1.9]].",
        "output": "import numpy as np\nmatrix = np.array([[9.1, 8.2, 7.3], [6.4, 5.5, 4.6], [3.7, 2.8, 1.9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[1.5, 2.5, 3.5], [4.5, 5.5, 6.5], [7.5, 8.5, 9.5]].",
        "output": "import numpy as np\nmatrix = np.array([[1.5, 2.5, 3.5], [4.5, 5.5, 6.5], [7.5, 8.5, 9.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[2.2, 4.4, 6.6], [1.1, 2.2, 3.3], [3.3, 6.6, 9.9]].",
        "output": "import numpy as np\nmatrix = np.array([[2.2, 4.4, 6.6], [1.1, 2.2, 3.3], [3.3, 6.6, 9.9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of matrix [[-1.1, -2.2], [3.3, 4.4]].",
        "output": "import numpy as np\nmatrix = np.array([[-1.1, -2.2], [3.3, 4.4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[0.25, 0.5], [0.75, 1.0]].",
        "output": "import numpy as np\nmatrix = np.array([[0.25, 0.5], [0.75, 1.0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[5.5, 0.0], [0.0, 5.5]].",
        "output": "import numpy as np\nmatrix = np.array([[5.5, 0.0], [0.0, 5.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[1.1, 1.1], [2.2, 2.2], [3.3, 3.3]].",
        "output": "import numpy as np\nmatrix = np.array([[1.1, 1.1], [2.2, 2.2], [3.3, 3.3]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find rank of matrix with decimal values: [[3.3, 2.2], [6.6, 4.4]].",
        "output": "import numpy as np\nmatrix = np.array([[3.3, 2.2], [6.6, 4.4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[0.75, 0.25], [0.25, 0.75]].",
        "output": "import numpy as np\nmatrix = np.array([[0.75, 0.25], [0.25, 0.75]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of matrix [[2.5, 5.0, 7.5], [5.0, 10.0, 15.0], [7.5, 15.0, 22.5]].",
        "output": "import numpy as np\nmatrix = np.array([[2.5, 5.0, 7.5], [5.0, 10.0, 15.0], [7.5, 15.0, 22.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[-3.3, -6.6, -9.9], [4.4, 8.8, 13.2], [5.5, 11.0, 16.5]].",
        "output": "import numpy as np\nmatrix = np.array([[-3.3, -6.6, -9.9], [4.4, 8.8, 13.2], [5.5, 11.0, 16.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[1.1, 2.2, 3.3, 4.4], [2.2, 4.4, 6.6, 8.8], [3.3, 6.6, 9.9, 13.2]].",
        "output": "import numpy as np\nmatrix = np.array([[1.1, 2.2, 3.3, 4.4], [2.2, 4.4, 6.6, 8.8], [3.3, 6.6, 9.9, 13.2]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[2.1, 4.2], [1.05, 2.1]].",
        "output": "import numpy as np\nmatrix = np.array([[2.1, 4.2], [1.05, 2.1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of matrix [[1.11, 2.22, 3.33], [4.44, 5.55, 6.66], [7.77, 8.88, 9.99]].",
        "output": "import numpy as np\nmatrix = np.array([[1.11, 2.22, 3.33], [4.44, 5.55, 6.66], [7.77, 8.88, 9.99]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[0.123, 0.456], [0.789, 0.321]].",
        "output": "import numpy as np\nmatrix = np.array([[0.123, 0.456], [0.789, 0.321]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[2.75, 3.25, 4.75], [5.25, 6.5, 7.25], [8.1, 9.2, 10.3]].",
        "output": "import numpy as np\nmatrix = np.array([[2.75, 3.25, 4.75], [5.25, 6.5, 7.25], [8.1, 9.2, 10.3]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[0.11, 0.22], [0.33, 0.44]].",
        "output": "import numpy as np\nmatrix = np.array([[0.11, 0.22], [0.33, 0.44]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[1.01, 2.02, 3.03], [4.04, 5.05, 6.06], [7.07, 8.08, 9.09]].",
        "output": "import numpy as np\nmatrix = np.array([[1.01, 2.02, 3.03], [4.04, 5.05, 6.06], [7.07, 8.08, 9.09]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of matrix [[10.1, 20.2, 30.3], [5.05, 10.1, 15.15], [2.02, 4.04, 6.06]].",
        "output": "import numpy as np\nmatrix = np.array([[10.1, 20.2, 30.3], [5.05, 10.1, 15.15], [2.02, 4.04, 6.06]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[0.0, 0.0, 0.1], [0.1, 0.0, 0.0], [0.0, 0.1, 0.0]].",
        "output": "import numpy as np\nmatrix = np.array([[0.0, 0.0, 0.1], [0.1, 0.0, 0.0], [0.0, 0.1, 0.0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[1.333, 2.666], [2.666, 5.332]].",
        "output": "import numpy as np\nmatrix = np.array([[1.333, 2.666], [2.666, 5.332]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[3.14, 1.59, 2.65], [3.58, 9.79, 3.23], [8.46, 2.64, 3.38]].",
        "output": "import numpy as np\nmatrix = np.array([[3.14, 1.59, 2.65], [3.58, 9.79, 3.23], [8.46, 2.64, 3.38]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate rank of matrix [[6.6, 7.7, 8.8], [9.9, 10.1, 11.2], [12.3, 13.4, 14.5]].",
        "output": "import numpy as np\nmatrix = np.array([[6.6, 7.7, 8.8], [9.9, 10.1, 11.2], [12.3, 13.4, 14.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute rank of matrix [[0.125, 0.25], [0.375, 0.5]].",
        "output": "import numpy as np\nmatrix = np.array([[0.125, 0.25], [0.375, 0.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[0.0001, 0.0002], [0.0003, 0.0004]].",
        "output": "import numpy as np\nmatrix = np.array([[0.0001, 0.0002], [0.0003, 0.0004]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine rank of matrix [[1.5, 3.0, 4.5], [3.0, 6.0, 9.0], [4.5, 9.0, 13.5]].",
        "output": "import numpy as np\nmatrix = np.array([[1.5, 3.0, 4.5], [3.0, 6.0, 9.0], [4.5, 9.0, 13.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate rank of matrix [[-1.25, -2.5, -3.75], [1.25, 2.5, 3.75], [-2.5, -5.0, -7.5]].",
        "output": "import numpy as np\nmatrix = np.array([[-1.25, -2.5, -3.75], [1.25, 2.5, 3.75], [-2.5, -5.0, -7.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute rank of matrix [[0.314, 1.592, 2.653], [5.897, 9.793, 2.384], [6.264, 3.383, 2.327]].",
        "output": "import numpy as np\nmatrix = np.array([[0.314, 1.592, 2.653], [5.897, 9.793, 2.384], [6.264, 3.383, 2.327]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find rank of matrix [[7.7, 8.8, 9.9], [1.1, 2.2, 3.3], [4.4, 5.5, 6.6]].",
        "output": "import numpy as np\nmatrix = np.array([[7.7, 8.8, 9.9], [1.1, 2.2, 3.3], [4.4, 5.5, 6.6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate rank of matrix [[0.5, 0.3, 0.2], [1.0, 0.6, 0.4], [1.5, 0.9, 0.6]].",
        "output": "import numpy as np\nmatrix = np.array([[0.5, 0.3, 0.2], [1.0, 0.6, 0.4], [1.5, 0.9, 0.6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[-5.77, 5.208, 3.71], [-1.596, 0.835, -9.983]].",
        "output": "import numpy as np\nmatrix = np.array([[-5.77, 5.208, 3.71], [-1.596, 0.835, -9.983]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[8.993, 2.375, 7.29, 8.975], [6.246, 2.768, 9.959, 8.955], [7.939, 2.767, 6.618, 4.936], [-5.508, 2.865, -0.844, 7.82]].",
        "output": "import numpy as np\nmatrix = np.array([[8.993, 2.375, 7.29, 8.975], [6.246, 2.768, 9.959, 8.955], [7.939, 2.767, 6.618, 4.936], [-5.508, 2.865, -0.844, 7.82]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1.354, -3.652, 5.876], [2.002, -6.523, 9.128]].",
        "output": "import numpy as np\nmatrix = np.array([[1.354, -3.652, 5.876], [2.002, -6.523, 9.128]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[4.621, -7.332], [1.112, 0.003], [3.141, 6.283]].",
        "output": "import numpy as np\nmatrix = np.array([[4.621, -7.332], [1.112, 0.003], [3.141, 6.283]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[2.718, 3.141, 1.414], [1.732, 0.577, 2.236], [0.707, 1.618, 3.333]].",
        "output": "import numpy as np\nmatrix = np.array([[2.718, 3.141, 1.414], [1.732, 0.577, 2.236], [0.707, 1.618, 3.333]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[0.001, 0.002], [0.003, 0.004]].",
        "output": "import numpy as np\nmatrix = np.array([[0.001, 0.002], [0.003, 0.004]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[10.1, 20.2, 30.3], [40.4, 50.5, 60.6], [70.7, 80.8, 90.9]].",
        "output": "import numpy as np\nmatrix = np.array([[10.1, 20.2, 30.3], [40.4, 50.5, 60.6], [70.7, 80.8, 90.9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[-0.25, 0.75], [-1.25, 1.75], [2.5, -2.5]].",
        "output": "import numpy as np\nmatrix = np.array([[-0.25, 0.75], [-1.25, 1.75], [2.5, -2.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[5.555, -6.666, 7.777, -8.888], [9.999, -0.101, 1.212, -2.323], [3.434, -4.545, 5.656, -6.767]].",
        "output": "import numpy as np\nmatrix = np.array([[5.555, -6.666, 7.777, -8.888], [9.999, -0.101, 1.212, -2.323], [3.434, -4.545, 5.656, -6.767]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[3.333, 2.222, 1.111], [4.444, 5.555, 6.666], [7.777, 8.888, 9.999]].",
        "output": "import numpy as np\nmatrix = np.array([[3.333, 2.222, 1.111], [4.444, 5.555, 6.666], [7.777, 8.888, 9.999]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[-3.21, 2.98], [-4.67, 5.43]].",
        "output": "import numpy as np\nmatrix = np.array([[-3.21, 2.98], [-4.67, 5.43]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1.001, 2.002, 3.003, 4.004], [5.005, 6.006, 7.007, 8.008]].",
        "output": "import numpy as np\nmatrix = np.array([[1.001, 2.002, 3.003, 4.004], [5.005, 6.006, 7.007, 8.008]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1.11, 2.22], [3.33, 4.44], [5.55, 6.66]].",
        "output": "import numpy as np\nmatrix = np.array([[1.11, 2.22], [3.33, 4.44], [5.55, 6.66]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[9.81, -1.62], [4.37, 2.19]].",
        "output": "import numpy as np\nmatrix = np.array([[9.81, -1.62], [4.37, 2.19]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[0.707, 0.707], [0.866, -0.5], [0.5, 0.866]].",
        "output": "import numpy as np\nmatrix = np.array([[0.707, 0.707], [0.866, -0.5], [0.5, 0.866]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[2.33, 4.66], [3.99, 7.98]].",
        "output": "import numpy as np\nmatrix = np.array([[2.33, 4.66], [3.99, 7.98]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[-1.1, 2.2, -3.3], [4.4, -5.5, 6.6]].",
        "output": "import numpy as np\nmatrix = np.array([[-1.1, 2.2, -3.3], [4.4, -5.5, 6.6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[0.123, 0.456], [0.789, 1.012], [1.345, 1.678]].",
        "output": "import numpy as np\nmatrix = np.array([[0.123, 0.456], [0.789, 1.012], [1.345, 1.678]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[10.1, 20.2, 30.3], [40.4, 50.5, 60.6]].",
        "output": "import numpy as np\nmatrix = np.array([[10.1, 20.2, 30.3], [40.4, 50.5, 60.6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[-7.7, 8.8], [-9.9, 10.01]].",
        "output": "import numpy as np\nmatrix = np.array([[-7.7, 8.8], [-9.9, 10.01]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[2.222, 4.444, 6.666], [8.888, 10.101, 12.121]].",
        "output": "import numpy as np\nmatrix = np.array([[2.222, 4.444, 6.666], [8.888, 10.101, 12.121]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1.001, 1.002], [1.003, 1.004], [1.005, 1.006]].",
        "output": "import numpy as np\nmatrix = np.array([[1.001, 1.002], [1.003, 1.004], [1.005, 1.006]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[3.14, 1.59, 2.65], [5.35, 8.97, 9.32], [3.84, 6.26, 4.33]].",
        "output": "import numpy as np\nmatrix = np.array([[3.14, 1.59, 2.65], [5.35, 8.97, 9.32], [3.84, 6.26, 4.33]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[1.6, 3.7, 9.2], [2.4, 1.5, 6.8]].",
        "output": "import numpy as np\nmatrix = np.array([[1.6, 3.7, 9.2], [2.4, 1.5, 6.8]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[-2.2, 4.4, -6.6], [8.8, -10.1, 12.2], [14.3, -16.4, 18.5]].",
        "output": "import numpy as np\nmatrix = np.array([[-2.2, 4.4, -6.6], [8.8, -10.1, 12.2], [14.3, -16.4, 18.5]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[0.12, 0.34, 0.56], [0.78, 0.90, 0.12], [0.34, 0.56, 0.78]].",
        "output": "import numpy as np\nmatrix = np.array([[0.12, 0.34, 0.56], [0.78, 0.90, 0.12], [0.34, 0.56, 0.78]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[6.022, 3.141], [2.718, 1.618], [1.414, 0.577]].",
        "output": "import numpy as np\nmatrix = np.array([[6.022, 3.141], [2.718, 1.618], [1.414, 0.577]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[2.45, 1.39, 3.57], [4.21, 5.62, 6.33], [7.74, 8.19, 9.83]].",
        "output": "import numpy as np\nmatrix = np.array([[2.45, 1.39, 3.57], [4.21, 5.62, 6.33], [7.74, 8.19, 9.83]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[0.33, 1.67], [2.99, 3.15], [4.20, 5.31]].",
        "output": "import numpy as np\nmatrix = np.array([[0.33, 1.67], [2.99, 3.15], [4.20, 5.31]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[6.6, 3.3, 1.1], [2.2, 4.4, 6.6]].",
        "output": "import numpy as np\nmatrix = np.array([[6.6, 3.3, 1.1], [2.2, 4.4, 6.6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of the matrix [[1.25, 3.75], [2.50, 7.50], [3.75, 11.25]].",
        "output": "import numpy as np\nmatrix = np.array([[1.25, 3.75], [2.50, 7.50], [3.75, 11.25]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the rank of the matrix [[0.8, 1.6], [3.2, 6.4]].",
        "output": "import numpy as np\nmatrix = np.array([[0.8, 1.6], [3.2, 6.4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of the matrix [[10.5, 12.6, 14.7], [15.8, 18.9, 20.0]].",
        "output": "import numpy as np\nmatrix = np.array([[10.5, 12.6, 14.7], [15.8, 18.9, 20.0]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of the matrix [[2.3, 3.4, 5.6], [1.2, 0.8, 4.1]].",
        "output": "import numpy as np\nmatrix = np.array([[2.3, 3.4, 5.6], [1.2, 0.8, 4.1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of the matrix [[0.12, 0.24, 0.36], [0.48, 0.60, 0.72], [0.84, 0.96, 1.08]]?",
        "output": "import numpy as np\nmatrix = np.array([[0.12, 0.24, 0.36], [0.48, 0.60, 0.72], [0.84, 0.96, 1.08]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the rank of the matrix [[1.11, 0.22, -1.33], [-0.44, 0.55, 0.66]].",
        "output": "import numpy as np\nmatrix = np.array([[1.11, 0.22, -1.33], [-0.44, 0.55, 0.66]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of matrix [[3.75, 5.50, 7.25], [9.00, 10.75, 12.50], [14.25, 16.00, 17.75]].",
        "output": "import numpy as np\nmatrix = np.array([[3.75, 5.50, 7.25], [9.00, 10.75, 12.50], [14.25, 16.00, 17.75]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of the matrix [[2.718, 3.141, 1.618], [0.577, 1.732, 2.236]].",
        "output": "import numpy as np\nmatrix = np.array([[2.718, 3.141, 1.618], [0.577, 1.732, 2.236]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[4.2, 8.4, 12.6], [2.1, 4.2, 6.3], [0.7, 1.4, 2.1]].",
        "output": "import numpy as np\nmatrix = np.array([[4.2, 8.4, 12.6], [2.1, 4.2, 6.3], [0.7, 1.4, 2.1]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the rank of matrix [[3.2, 4.4], [5.6, 6.8], [7.0, 8.2]].",
        "output": "import numpy as np\nmatrix = np.array([[3.2, 4.4], [5.6, 6.8], [7.0, 8.2]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[0.001, 0.002], [0.003, 0.004], [0.005, 0.006]].",
        "output": "import numpy as np\nmatrix = np.array([[0.001, 0.002], [0.003, 0.004], [0.005, 0.006]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of matrix [[1.1, -2.2], [-3.3, 4.4], [5.5, -6.6]].",
        "output": "import numpy as np\nmatrix = np.array([[1.1, -2.2], [-3.3, 4.4], [5.5, -6.6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]].",
        "output": "import numpy as np\nmatrix = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[9.999, 8.888, 7.777], [6.666, 5.555, 4.444]].",
        "output": "import numpy as np\nmatrix = np.array([[9.999, 8.888, 7.777], [6.666, 5.555, 4.444]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Evaluate the rank of matrix [[3.3, 3.3, 3.3], [6.6, 6.6, 6.6]].",
        "output": "import numpy as np\nmatrix = np.array([[3.3, 3.3, 3.3], [6.6, 6.6, 6.6]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "What is the rank of matrix [[7.12, 6.45, 8.32], [5.99, 3.22, 2.13], [9.89, 0.01, 4.56]]?",
        "output": "import numpy as np\nmatrix = np.array([[7.12, 6.45, 8.32], [5.99, 3.22, 2.13], [9.89, 0.01, 4.56]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Compute the rank of matrix [[11.11, 22.22], [33.33, 44.44]].",
        "output": "import numpy as np\nmatrix = np.array([[11.11, 22.22], [33.33, 44.44]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Determine the rank of matrix [[13.13, 26.26, 39.39], [52.52, 65.65, 78.78]].",
        "output": "import numpy as np\nmatrix = np.array([[13.13, 26.26, 39.39], [52.52, 65.65, 78.78]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Find the rank of matrix [[4.41, 3.14], [2.17, 1.61], [0.57, 6.02]].",
        "output": "import numpy as np\nmatrix = np.array([[4.41, 3.14], [2.17, 1.61], [0.57, 6.02]])\nrank = np.linalg.matrix_rank(matrix)\nprint(f'The rank is {rank}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[4, 3], [6, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 3], [6, 3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[2, -1, 3], [1, 0, 2], [4, 1, 8]].",
        "output": "import numpy as np\nmatrix = np.array([[2, -1, 3], [1, 0, 2], [4, 1, 8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[5, 2], [7, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 2], [7, 3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[3, -2], [5, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[3, -2], [5, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[2, 3, 1], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3, 1], [4, 5, 6], [7, 8, 9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[6, 1], [4, 2]].",
        "output": "import numpy as np\nmatrix = np.array([[6, 1], [4, 2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[1, 4, 7], [2, 5, 8], [3, 6, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 4, 7], [2, 5, 8], [3, 6, 9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[5, 0], [0, 5]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 0], [0, 5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[2, 0, 0], [0, 3, 0], [0, 0, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 0, 0], [0, 3, 0], [0, 0, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[2, 3, 4], [1, 0, 6], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3, 4], [1, 0, 6], [7, 8, 9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[3, 2], [1, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 2], [1, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[1, 2, 3], [0, 1, 4], [5, 6, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [0, 1, 4], [5, 6, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[4, 5], [6, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 5], [6, 7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[2, 3, 1], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3, 1], [4, 5, 6], [7, 8, 9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[1, 0], [0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0], [0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[3, 2], [5, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 2], [5, 7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[1, 4, 7], [2, 5, 8], [3, 6, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 4, 7], [2, 5, 8], [3, 6, 9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[2, -3], [4, -6]].",
        "output": "import numpy as np\nmatrix = np.array([[2, -3], [4, -6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[5, 3, 1], [2, 4, 6], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 3, 1], [2, 4, 6], [7, 8, 9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[0, 1], [1, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 1], [1, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[4, 0], [0, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 0], [0, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[1, 0, 0], [0, 1, 0], [0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[3, 1], [2, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 1], [2, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[6, 1, 1], [4, -2, 5], [2, 8, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[6, 1, 1], [4, -2, 5], [2, 8, 7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[2, 0, 0], [0, 3, 0], [0, 0, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 0, 0], [0, 3, 0], [0, 0, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 10]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 10]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[0, 2], [3, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 2], [3, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[1, 2, 3], [0, 1, 4], [5, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [0, 1, 4], [5, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[2, 3], [1, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3], [1, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[0, 1, 2], [3, 4, 5], [6, 7, 8]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[5, -2], [7, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[5, -2], [7, 3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[1, 2, 1], [2, 1, 2], [1, 2, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 1], [2, 1, 2], [1, 2, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[3, 0], [0, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 0], [0, 3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[2, 3, 4], [1, 0, 1], [4, 3, 2]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3, 4], [1, 0, 1], [4, 3, 2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[1, 2, 3], [3, 2, 1], [2, 3, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [3, 2, 1], [2, 3, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[4, 0], [0, 5]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 0], [0, 5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[2, 0], [0, 2]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 0], [0, 2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[3, 1, 4], [1, 5, 9], [2, 6, 5]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 1, 4], [1, 5, 9], [2, 6, 5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[1, 3, 3], [1, 4, 3], [1, 3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 3, 3], [1, 4, 3], [1, 3, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[5, 0], [0, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 0], [0, 6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[2, 4, 6], [1, 3, 5], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 4, 6], [1, 3, 5], [7, 8, 9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[3, 2], [5, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 2], [5, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[0, 1], [1, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 1], [1, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[3, 2, 1], [1, 0, 2], [4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 2, 1], [1, 0, 2], [4, 5, 6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[3, 1], [2, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 1], [2, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[6, 1, 1], [4, -2, 5], [2, 8, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[6, 1, 1], [4, -2, 5], [2, 8, 7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[1, 2], [3, 5]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[7, -4, 2], [3, 1, -5], [2, 2, -5]].",
        "output": "import numpy as np\nmatrix = np.array([[7, -4, 2], [3, 1, -5], [2, 2, -5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[1, -6, -7], [1, -4, 7], [-1, -3, -6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, -6, -7], [1, -4, 7], [-1, -3, -6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[-1, -1, -1], [4, 5, -3], [-1, -6, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[-1, -1, -1], [4, 5, -3], [-1, -6, 3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[7, 5, 7], [6, -5, -5], [6, 2, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[7, 5, 7], [6, -5, -5], [6, 2, 3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[4, -6, 4], [-4, -7, -5], [2, 7, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[4, -6, 4], [-4, -7, -5], [2, 7, 3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[-1, -3, 4], [-1, 2, 6], [-3, -7, 2]].",
        "output": "import numpy as np\nmatrix = np.array([[-1, -3, 4], [-1, 2, 6], [-3, -7, 2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[2, 7, 5], [1, 2, 5], [0, 0, -4]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 7, 5], [1, 2, 5], [0, 0, -4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[1, -2, 2], [-5, -1, 5], [4, -1, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, -2, 2], [-5, -1, 5], [4, -1, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[-5, 2, -3], [-2, -1, -5], [5, -5, -3]].",
        "output": "import numpy as np\nmatrix = np.array([[-5, 2, -3], [-2, -1, -5], [5, -5, -3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[-4, 1, 2], [1, -3, 2], [-4, 4, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[-4, 1, 2], [1, -3, 2], [-4, 4, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[2, 5], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 5], [3, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[6, 2], [-5, -2]].",
        "output": "import numpy as np\nmatrix = np.array([[6, 2], [-5, -2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[3, -3], [2, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[3, -3], [2, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[0.5, -2], [4, -6]].",
        "output": "import numpy as np\nmatrix = np.array([[0.5, -2], [4, -6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[-5, 4], [-4, 5]].",
        "output": "import numpy as np\nmatrix = np.array([[-5, 4], [-4, 5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[-9, -0.2], [-10, -0.5]].",
        "output": "import numpy as np\nmatrix = np.array([[-9, -0.2], [-10, -0.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[9, 3], [4, 8]].",
        "output": "import numpy as np\nmatrix = np.array([[9, 3], [4, 8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[1, 2, 1], [0, 3, 4], [5, 6, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 1], [0, 3, 4], [5, 6, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[7, 8], [2, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[7, 8], [2, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[1, 0, 5], [2, 1, 6], [3, 4, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 5], [2, 1, 6], [3, 4, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[0, 3, 2], [1, -1, 4], [2, 1, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 3, 2], [1, -1, 4], [2, 1, 3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[4, 1], [7, -3]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 1], [7, -3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[2, -1, 3], [1, 4, -2], [0, 5, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[2, -1, 3], [1, 4, -2], [0, 5, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[6, 7], [2, 5]].",
        "output": "import numpy as np\nmatrix = np.array([[6, 7], [2, 5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[0.5, 1.5], [2.5, 3.5]].",
        "output": "import numpy as np\nmatrix = np.array([[0.5, 1.5], [2.5, 3.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[1, 0, 2], [0, 1, 3], [4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 2], [0, 1, 3], [4, 5, 6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[5, 2, 1], [0, 3, 4], [2, 1, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 2, 1], [0, 3, 4], [2, 1, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[1.2, 0.5], [3.4, 2.2]].",
        "output": "import numpy as np\nmatrix = np.array([[1.2, 0.5], [3.4, 2.2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[0, 2, 1], [3, 0, 4], [5, 6, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 2, 1], [3, 0, 4], [5, 6, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[2, 3], [1, 2]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3], [1, 2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[1, 4, 6], [2, 1, 5], [3, 7, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 4, 6], [2, 1, 5], [3, 7, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[4, 2, 1], [1, 5, 3], [2, 0, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 2, 1], [1, 5, 3], [2, 0, 6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[1, -2, 3], [0, 1, 4], [5, 6, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, -2, 3], [0, 1, 4], [5, 6, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[8, 2], [3, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[8, 2], [3, 7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[0, 1, 2], [3, 0, 1], [4, 5, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 1, 2], [3, 0, 1], [4, 5, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[-1, 2], [3, -4]].",
        "output": "import numpy as np\nmatrix = np.array([[-1, 2], [3, -4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[5, 0, 1], [1, 3, 0], [0, 2, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 0, 1], [1, 3, 0], [0, 2, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[2.5, 1.2], [4.1, 3.3]].",
        "output": "import numpy as np\nmatrix = np.array([[2.5, 1.2], [4.1, 3.3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[3, 4, 1], [2, 0, 5], [6, 7, 8]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 4, 1], [2, 0, 5], [6, 7, 8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[3, 0, 0], [0, 4, 0], [0, 0, 5]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 0, 0], [0, 4, 0], [0, 0, 5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[2.2, 1.1], [3.3, 4.4]].",
        "output": "import numpy as np\nmatrix = np.array([[2.2, 1.1], [3.3, 4.4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[0.5, 1.5, 2.5], [1.0, 2.0, 3.0], [4.0, 5.0, 6.0]].",
        "output": "import numpy as np\nmatrix = np.array([[0.5, 1.5, 2.5], [1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[1.2, 3.4], [5.6, 7.8]].",
        "output": "import numpy as np\nmatrix = np.array([[1.2, 3.4], [5.6, 7.8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[3.3, 1.1, 0.9], [2.2, 4.4, 6.6], [5.5, 7.7, 9.9]].",
        "output": "import numpy as np\nmatrix = np.array([[3.3, 1.1, 0.9], [2.2, 4.4, 6.6], [5.5, 7.7, 9.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[1.5, 2.5], [3.5, 4.5]].",
        "output": "import numpy as np\nmatrix = np.array([[1.5, 2.5], [3.5, 4.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[0.7, 1.3, 2.9], [4.1, 5.6, 6.2], [7.8, 8.3, 9.4]].",
        "output": "import numpy as np\nmatrix = np.array([[0.7, 1.3, 2.9], [4.1, 5.6, 6.2], [7.8, 8.3, 9.4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[5.0, 1.2], [0.3, 7.7]].",
        "output": "import numpy as np\nmatrix = np.array([[5.0, 1.2], [0.3, 7.7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[4.4, 2.2, 1.1], [0.5, 3.3, 6.6], [7.7, 8.8, 9.9]].",
        "output": "import numpy as np\nmatrix = np.array([[4.4, 2.2, 1.1], [0.5, 3.3, 6.6], [7.7, 8.8, 9.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[6.1, 2.3], [1.4, 3.5]].",
        "output": "import numpy as np\nmatrix = np.array([[6.1, 2.3], [1.4, 3.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[9.8, 7.6, 5.4], [3.2, 1.0, 0.8], [6.6, 4.4, 2.2]].",
        "output": "import numpy as np\nmatrix = np.array([[9.8, 7.6, 5.4], [3.2, 1.0, 0.8], [6.6, 4.4, 2.2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[0.2, 0.4], [0.6, 0.8]].",
        "output": "import numpy as np\nmatrix = np.array([[0.2, 0.4], [0.6, 0.8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[1.1, 2.2, 3.3], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9]].",
        "output": "import numpy as np\nmatrix = np.array([[1.1, 2.2, 3.3], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[3.1, 2.4], [1.6, 4.8]].",
        "output": "import numpy as np\nmatrix = np.array([[3.1, 2.4], [1.6, 4.8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[0.3, 0.6, 0.9], [1.2, 1.5, 1.8], [2.1, 2.4, 2.7]].",
        "output": "import numpy as np\nmatrix = np.array([[0.3, 0.6, 0.9], [1.2, 1.5, 1.8], [2.1, 2.4, 2.7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[7.2, 5.1], [4.3, 6.4]].",
        "output": "import numpy as np\nmatrix = np.array([[7.2, 5.1], [4.3, 6.4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[3.0, 1.0, 2.0], [0.5, 4.5, 5.5], [6.5, 7.5, 8.5]].",
        "output": "import numpy as np\nmatrix = np.array([[3.0, 1.0, 2.0], [0.5, 4.5, 5.5], [6.5, 7.5, 8.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[9.0, 3.0], [6.0, 2.0]].",
        "output": "import numpy as np\nmatrix = np.array([[9.0, 3.0], [6.0, 2.0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[0.2, 0.1, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]].",
        "output": "import numpy as np\nmatrix = np.array([[0.2, 0.1, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[3.6, 2.1], [5.2, 1.7]].",
        "output": "import numpy as np\nmatrix = np.array([[3.6, 2.1], [5.2, 1.7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[2.5, 1.2, 3.3], [4.4, 0.1, 2.2], [3.3, 4.4, 5.5]].",
        "output": "import numpy as np\nmatrix = np.array([[2.5, 1.2, 3.3], [4.4, 0.1, 2.2], [3.3, 4.4, 5.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[0.9, 1.2], [2.3, 3.4]].",
        "output": "import numpy as np\nmatrix = np.array([[0.9, 1.2], [2.3, 3.4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the matrix [[1.6, 2.7, 3.8], [4.9, 5.1, 6.2], [7.3, 8.4, 9.5]].",
        "output": "import numpy as np\nmatrix = np.array([[1.6, 2.7, 3.8], [4.9, 5.1, 6.2], [7.3, 8.4, 9.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[6.5, 5.6], [4.0, 8.9]].",
        "output": "import numpy as np\nmatrix = np.array([[6.5, 5.6], [4.0, 8.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[0.4, 6.4, 7.8], [0.9, 7.6, 8.3], [1.9, 7.1, 5.6]].",
        "output": "import numpy as np\nmatrix = np.array([[0.4, 6.4, 7.8], [0.9, 7.6, 8.3], [1.9, 7.1, 5.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[0.6, 6.0, 4.1], [8.0, 5.8, 5.7], [5.1, 3.5, 2.2]].",
        "output": "import numpy as np\nmatrix = np.array([[0.6, 6.0, 4.1], [8.0, 5.8, 5.7], [5.1, 3.5, 2.2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[3.3, 4.4], [5.5, 6.6]].",
        "output": "import numpy as np\nmatrix = np.array([[3.3, 4.4], [5.5, 6.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[1.1, 2.2, 3.3], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9]].",
        "output": "import numpy as np\nmatrix = np.array([[1.1, 2.2, 3.3], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[0.5, 1.2], [3.3, 2.1]].",
        "output": "import numpy as np\nmatrix = np.array([[0.5, 1.2], [3.3, 2.1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[1.5, 2.5, 3.5], [0.5, 4.5, 6.5], [7.5, 8.5, 9.5]].",
        "output": "import numpy as np\nmatrix = np.array([[1.5, 2.5, 3.5], [0.5, 4.5, 6.5], [7.5, 8.5, 9.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[9.1, 8.2], [3.4, 1.6]].",
        "output": "import numpy as np\nmatrix = np.array([[9.1, 8.2], [3.4, 1.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[4.4, 5.5], [6.6, 7.7]].",
        "output": "import numpy as np\nmatrix = np.array([[4.4, 5.5], [6.6, 7.7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[2.4, 3.5], [4.6, 5.7]].",
        "output": "import numpy as np\nmatrix = np.array([[2.4, 3.5], [4.6, 5.7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[8.3, 2.4, 1.5], [0.5, 1.2, 2.3], [3.1, 4.6, 5.8]].",
        "output": "import numpy as np\nmatrix = np.array([[8.3, 2.4, 1.5], [0.5, 1.2, 2.3], [3.1, 4.6, 5.8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[2.1, 0.4, 1.7], [3.5, 6.4, 2.3], [7.1, 1.8, 0.5]].",
        "output": "import numpy as np\nmatrix = np.array([[2.1, 0.4, 1.7], [3.5, 6.4, 2.3], [7.1, 1.8, 0.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[2.7, 3.2], [4.5, 5.6]].",
        "output": "import numpy as np\nmatrix = np.array([[2.7, 3.2], [4.5, 5.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[4.1, 5.5], [6.6, 7.7]].",
        "output": "import numpy as np\nmatrix = np.array([[4.1, 5.5], [6.6, 7.7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[5.2, 6.6], [7.7, 8.8]].",
        "output": "import numpy as np\nmatrix = np.array([[5.2, 6.6], [7.7, 8.8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[6.3, 7.7], [8.8, 9.9]].",
        "output": "import numpy as np\nmatrix = np.array([[6.3, 7.7], [8.8, 9.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[1.4, 2.3], [3.2, 4.1]].",
        "output": "import numpy as np\nmatrix = np.array([[1.4, 2.3], [3.2, 4.1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[0.9, 1.8], [2.7, 3.6]].",
        "output": "import numpy as np\nmatrix = np.array([[0.9, 1.8], [2.7, 3.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[3.5, 4.4], [5.5, 6.6]].",
        "output": "import numpy as np\nmatrix = np.array([[3.5, 4.4], [5.5, 6.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[7.6, 8.9], [9.2, 2.3]].",
        "output": "import numpy as np\nmatrix = np.array([[7.6, 8.9], [9.2, 2.3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[2.1, 3.6], [4.7, 5.8]].",
        "output": "import numpy as np\nmatrix = np.array([[2.1, 3.6], [4.7, 5.8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[8.3, 9.1], [1.2, 3.4]].",
        "output": "import numpy as np\nmatrix = np.array([[8.3, 9.1], [1.2, 3.4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[0.5, 1.3, 2.1], [3.4, 4.6, 5.8], [6.9, 7.7, 8.5]].",
        "output": "import numpy as np\nmatrix = np.array([[0.5, 1.3, 2.1], [3.4, 4.6, 5.8], [6.9, 7.7, 8.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[9.1, 8.2, 7.3], [6.4, 5.5, 4.6], [3.7, 2.8, 1.9]].",
        "output": "import numpy as np\nmatrix = np.array([[9.1, 8.2, 7.3], [6.4, 5.5, 4.6], [3.7, 2.8, 1.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[1.2, 0.5, 3.1], [4.8, 6.9, 2.3], [7.1, 8.4, 9.6]].",
        "output": "import numpy as np\nmatrix = np.array([[1.2, 0.5, 3.1], [4.8, 6.9, 2.3], [7.1, 8.4, 9.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[2.4, 3.5, 1.6], [5.7, 6.8, 4.9], [7.0, 8.1, 9.2]].",
        "output": "import numpy as np\nmatrix = np.array([[2.4, 3.5, 1.6], [5.7, 6.8, 4.9], [7.0, 8.1, 9.2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[3.3, 4.4, 5.5], [6.6, 7.7, 8.8], [9.9, 1.1, 2.2]].",
        "output": "import numpy as np\nmatrix = np.array([[3.3, 4.4, 5.5], [6.6, 7.7, 8.8], [9.9, 1.1, 2.2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[4.2, 3.1, 2.0], [1.9, 5.8, 6.7], [7.6, 8.5, 9.4]].",
        "output": "import numpy as np\nmatrix = np.array([[4.2, 3.1, 2.0], [1.9, 5.8, 6.7], [7.6, 8.5, 9.4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[5.5, 6.6, 7.7], [8.8, 9.9, 1.1], [2.2, 3.3, 4.4]].",
        "output": "import numpy as np\nmatrix = np.array([[5.5, 6.6, 7.7], [8.8, 9.9, 1.1], [2.2, 3.3, 4.4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[6.6, 5.4, 3.3], [2.2, 1.1, 0.9], [8.8, 7.7, 6.5]].",
        "output": "import numpy as np\nmatrix = np.array([[6.6, 5.4, 3.3], [2.2, 1.1, 0.9], [8.8, 7.7, 6.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[7.8, 6.6, 5.4], [4.3, 3.2, 2.1], [1.0, 9.9, 8.8]].",
        "output": "import numpy as np\nmatrix = np.array([[7.8, 6.6, 5.4], [4.3, 3.2, 2.1], [1.0, 9.9, 8.8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[9.9, 8.8], [7.7, 6.6]].",
        "output": "import numpy as np\nmatrix = np.array([[9.9, 8.8], [7.7, 6.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[1.1, 0.9], [2.8, 3.6]].",
        "output": "import numpy as np\nmatrix = np.array([[1.1, 0.9], [2.8, 3.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[4.4, 3.3], [2.2, 1.1]].",
        "output": "import numpy as np\nmatrix = np.array([[4.4, 3.3], [2.2, 1.1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[7.1, 8.2], [9.3, 0.4]].",
        "output": "import numpy as np\nmatrix = np.array([[7.1, 8.2], [9.3, 0.4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the 3x3 matrix [[2, 4, 6], [1, 3, 5], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 4, 6], [1, 3, 5], [7, 8, 9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[1, 0, 2], [0, 1, 0], [3, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 2], [0, 1, 0], [3, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[5, 2, 1], [0, 3, 7], [6, 8, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 2, 1], [0, 3, 7], [6, 8, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[9, 4, 3], [2, 8, 1], [7, 0, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[9, 4, 3], [2, 8, 1], [7, 0, 6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[1, 2, 3], [4, 5, 6], [7, 8, 10]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 10]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of matrix [[3, 1, 2], [0, 4, 5], [6, 7, 8]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 1, 2], [0, 4, 5], [6, 7, 8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of matrix [[1, 2, 3], [0, 1, 4], [5, 6, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [0, 1, 4], [5, 6, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of matrix [[1, 0, 0], [0, 1, 0], [0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of matrix [[3, -2, 5], [1, 0, -1], [4, 2, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[3, -2, 5], [1, 0, -1], [4, 2, 3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the 4x4 matrix [[1, 2, 3, 4], [5, 6, 7, 8], [9, 1, 2, 3], [4, 5, 6, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 1, 2, 3], [4, 5, 6, 7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[2, 4, 1], [3, 1, 5], [6, 2, 8]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 4, 1], [3, 1, 5], [6, 2, 8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[0, 1, 2], [3, 4, 5], [6, 7, 8]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[7, 8, 9], [1, 2, 3], [4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[7, 8, 9], [1, 2, 3], [4, 5, 6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of [[10, 20, 30], [40, 50, 60], [70, 80, 90]].",
        "output": "import numpy as np\nmatrix = np.array([[10, 20, 30], [40, 50, 60], [70, 80, 90]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[1, 3, 5, 7], [2, 4, 6, 8], [9, 10, 11, 12], [13, 14, 15, 16]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 3, 5, 7], [2, 4, 6, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of a 4x4 matrix [[2, 0, 1, 3], [4, 1, 0, 2], [3, 2, 1, 1], [5, 3, 2, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 0, 1, 3], [4, 1, 0, 2], [3, 2, 1, 1], [5, 3, 2, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[6, 2, 3, 4], [1, 5, 0, 7], [9, 8, 6, 3], [2, 1, 4, 5]].",
        "output": "import numpy as np\nmatrix = np.array([[6, 2, 3, 4], [1, 5, 0, 7], [9, 8, 6, 3], [2, 1, 4, 5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[1, 2, 3], [3, 2, 1], [4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [3, 2, 1], [4, 5, 6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[2, 4, 6, 8], [1, 3, 5, 7], [9, 11, 13, 15], [0, 2, 4, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 4, 6, 8], [1, 3, 5, 7], [9, 11, 13, 15], [0, 2, 4, 6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate determinant of [[1, 2, 3], [4, 5, 6], [0, 1, 2]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [0, 1, 2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[9, 6, 3], [2, 5, 8], [7, 1, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[9, 6, 3], [2, 5, 8], [7, 1, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of matrix [[4, 1, 0, 3], [2, 2, 3, 1], [5, 6, 7, 8], [0, 9, 1, 2]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 1, 0, 3], [2, 2, 3, 1], [5, 6, 7, 8], [0, 9, 1, 2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate determinant of [[10, 11, 12], [13, 14, 15], [16, 17, 18]].",
        "output": "import numpy as np\nmatrix = np.array([[10, 11, 12], [13, 14, 15], [16, 17, 18]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[3, 5, 1, 2], [6, 7, 8, 9], [10, 11, 12, 13], [14, 15, 16, 17]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 5, 1, 2], [6, 7, 8, 9], [10, 11, 12, 13], [14, 15, 16, 17]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of [[0, 2, 3, 1], [4, 0, 6, 2], [7, 8, 0, 5], [9, 1, 2, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 2, 3, 1], [4, 0, 6, 2], [7, 8, 0, 5], [9, 1, 2, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of matrix [[1, 2, 3, 4], [4, 3, 2, 1], [1, 0, 1, 0], [0, 1, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [4, 3, 2, 1], [1, 0, 1, 0], [0, 1, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of [[5, 0, 1, 3], [2, 6, 0, 1], [4, 2, 7, 0], [3, 1, 5, 8]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 0, 1, 3], [2, 6, 0, 1], [4, 2, 7, 0], [3, 1, 5, 8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[9, 8, 7, 6], [5, 4, 3, 2], [1, 2, 3, 4], [0, 1, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[9, 8, 7, 6], [5, 4, 3, 2], [1, 2, 3, 4], [0, 1, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[10, 11, 12, 13], [14, 15, 16, 17], [18, 19, 20, 21], [22, 23, 24, 25]].",
        "output": "import numpy as np\nmatrix = np.array([[10, 11, 12, 13], [14, 15, 16, 17], [18, 19, 20, 21], [22, 23, 24, 25]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of [[1, 5, 9, 13], [2, 6, 10, 14], [3, 7, 11, 15], [4, 8, 12, 16]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 5, 9, 13], [2, 6, 10, 14], [3, 7, 11, 15], [4, 8, 12, 16]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[6, 1, 8, 3], [7, 5, 9, 2], [4, 3, 2, 1], [5, 4, 6, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[6, 1, 8, 3], [7, 5, 9, 2], [4, 3, 2, 1], [5, 4, 6, 7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[8, 4, 2, 6], [3, 1, 5, 7], [9, 0, 8, 4], [2, 3, 1, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[8, 4, 2, 6], [3, 1, 5, 7], [9, 0, 8, 4], [2, 3, 1, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[0, 2, 3, 1], [1, 0, 2, 3], [3, 1, 0, 2], [2, 3, 1, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 2, 3, 1], [1, 0, 2, 3], [3, 1, 0, 2], [2, 3, 1, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of [[4, 2, 1, 5], [3, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 2, 1, 5], [3, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[1, 2, 1, 0], [0, 1, 0, 1], [3, 0, 1, 2], [4, 5, 6, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 1, 0], [0, 1, 0, 1], [3, 0, 1, 2], [4, 5, 6, 7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[3, 6, 9, 2], [1, 2, 3, 4], [0, 5, 7, 6], [8, 4, 2, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 6, 9, 2], [1, 2, 3, 4], [0, 5, 7, 6], [8, 4, 2, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of [[1, 1, 1, 1], [2, 3, 4, 5], [6, 7, 8, 9], [10, 11, 12, 13]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 1, 1, 1], [2, 3, 4, 5], [6, 7, 8, 9], [10, 11, 12, 13]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[3, 0, 2, -1], [1, 2, 0, -2], [4, 0, 6, -3], [5, 0, 2, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 0, 2, -1], [1, 2, 0, -2], [4, 0, 6, -3], [5, 0, 2, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of [[7, 2, 1, 0], [0, 3, -1, 2], [4, 0, 5, 6], [9, 8, 3, 2]].",
        "output": "import numpy as np\nmatrix = np.array([[7, 2, 1, 0], [0, 3, -1, 2], [4, 0, 5, 6], [9, 8, 3, 2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[1, 3, 5, 7], [2, 4, 6, 8], [1, 0, 1, 0], [0, 1, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 3, 5, 7], [2, 4, 6, 8], [1, 0, 1, 0], [0, 1, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[2, 4, 6, 8], [1, 3, 5, 7], [0, 2, 4, 6], [1, 1, 1, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 4, 6, 8], [1, 3, 5, 7], [0, 2, 4, 6], [1, 1, 1, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[1, 4, 7, 10], [2, 5, 8, 11], [3, 6, 9, 12], [0, 0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 4, 7, 10], [2, 5, 8, 11], [3, 6, 9, 12], [0, 0, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of [[3, 3, 3, 3], [4, 4, 4, 4], [5, 5, 5, 5], [6, 6, 6, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 3, 3, 3], [4, 4, 4, 4], [5, 5, 5, 5], [6, 6, 6, 6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[2, 0, 1, 3], [1, 0, 2, 1], [4, 1, 3, 0], [5, 6, 2, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 0, 1, 3], [1, 0, 2, 1], [4, 1, 3, 0], [5, 6, 2, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[8, 6, 4, 2], [7, 5, 3, 1], [6, 4, 2, 0], [5, 3, 1, -1]].",
        "output": "import numpy as np\nmatrix = np.array([[8, 6, 4, 2], [7, 5, 3, 1], [6, 4, 2, 0], [5, 3, 1, -1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12], [4, 8, 12, 16]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12], [4, 8, 12, 16]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[1, -1, 2, -2], [-3, 3, -4, 4], [5, -5, 6, -6], [-7, 7, -8, 8]].",
        "output": "import numpy as np\nmatrix = np.array([[1, -1, 2, -2], [-3, 3, -4, 4], [5, -5, 6, -6], [-7, 7, -8, 8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of matrix [[3, 1, 4, 1], [5, 9, 2, 6], [5, 3, 5, 8], [9, 7, 9, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 1, 4, 1], [5, 9, 2, 6], [5, 3, 5, 8], [9, 7, 9, 3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of matrix [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of matrix [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of the identity matrix of order 4.",
        "output": "import numpy as np\nmatrix = np.identity(4)\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of matrix [[4, 3, 2, 1], [0, 1, 2, 3], [1, 0, 1, 0], [0, 1, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 3, 2, 1], [0, 1, 2, 3], [1, 0, 1, 0], [0, 1, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of matrix [[5, 2, 0, 1], [1, 4, 3, 0], [0, 1, 5, 2], [2, 0, 1, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 2, 0, 1], [1, 4, 3, 0], [0, 1, 5, 2], [2, 0, 1, 3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of matrix [[1, 3, 5, 7], [2, 4, 6, 8], [9, 10, 11, 12], [0, 1, 2, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 3, 5, 7], [2, 4, 6, 8], [9, 10, 11, 12], [0, 1, 2, 3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of matrix [[1, 2, 3, 4], [0, 1, 4, 7], [0, 0, 1, 3], [0, 0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [0, 1, 4, 7], [0, 0, 1, 3], [0, 0, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of matrix [[1, 0, 2, -1], [3, 0, 0, 5], [2, 1, 4, -3], [1, 0, 5, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 2, -1], [3, 0, 0, 5], [2, 1, 4, -3], [1, 0, 5, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of matrix [[2, -3, 1, 5], [4, 0, -2, 3], [-1, 2, 3, 1], [0, 1, 4, -2]].",
        "output": "import numpy as np\nmatrix = np.array([[2, -3, 1, 5], [4, 0, -2, 3], [-1, 2, 3, 1], [0, 1, 4, -2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of matrix [[6, 1, 1, 3], [4, -2, 5, 1], [2, 8, 7, 6], [3, 1, 9, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[6, 1, 1, 3], [4, -2, 5, 1], [2, 8, 7, 6], [3, 1, 9, 7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[5, 0, 0, 0], [0, 4, 0, 0], [0, 0, 3, 0], [0, 0, 0, 2]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 0, 0, 0], [0, 4, 0, 0], [0, 0, 3, 0], [0, 0, 0, 2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of matrix [[7, 5, 3, 1], [6, 4, 2, 0], [5, 3, 1, -1], [4, 2, 0, -2]].",
        "output": "import numpy as np\nmatrix = np.array([[7, 5, 3, 1], [6, 4, 2, 0], [5, 3, 1, -1], [4, 2, 0, -2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of matrix [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of [[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12], [4, 8, 12, 16]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12], [4, 8, 12, 16]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of matrix [[1, 2, 1, 0], [3, 6, 3, 0], [0, 1, 0, 1], [2, 4, 2, 2]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 1, 0], [3, 6, 3, 0], [0, 1, 0, 1], [2, 4, 2, 2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of matrix [[1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of [[1, 0, 1, 0], [0, 1, 0, 1], [1, 1, 1, 1], [0, 1, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 1, 0], [0, 1, 0, 1], [1, 1, 1, 1], [0, 1, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of matrix [[10, 0, 0, 0], [0, 20, 0, 0], [0, 0, 30, 0], [0, 0, 0, 40]].",
        "output": "import numpy as np\nmatrix = np.array([[10, 0, 0, 0], [0, 20, 0, 0], [0, 0, 30, 0], [0, 0, 0, 40]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of matrix [[1, 2, 3, 0], [0, 1, 4, 0], [0, 0, 1, 0], [0, 0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 0], [0, 1, 4, 0], [0, 0, 1, 0], [0, 0, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of matrix [[2, 1, 0, -1], [0, 3, 2, 1], [1, 0, 4, 2], [3, 2, 1, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 1, 0, -1], [0, 3, 2, 1], [1, 0, 4, 2], [3, 2, 1, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of matrix [[4, 1, 0, 0], [3, 4, 1, 0], [2, 3, 4, 1], [1, 2, 3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 1, 0, 0], [3, 4, 1, 0], [2, 3, 4, 1], [1, 2, 3, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[2, 5, 7], [6, 3, 4], [5, -2, -3]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 5, 7], [6, 3, 4], [5, -2, -3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[1, 0, 2], [-1, 3, 1], [3, 2, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 2], [-1, 3, 1], [3, 2, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of matrix [[4, 1, 2], [0, 3, 1], [7, 2, 5]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 1, 2], [0, 3, 1], [7, 2, 5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of matrix [[5.5, 3.2, 1.1], [2.0, 4.0, 3.3], [1.1, 0.5, 2.2]].",
        "output": "import numpy as np\nmatrix = np.array([[5.5, 3.2, 1.1], [2.0, 4.0, 3.3], [1.1, 0.5, 2.2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "What is the determinant of matrix [[0, 1, 2], [3, 4, 5], [6, 7, 8]]?",
        "output": "import numpy as np\nmatrix = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[2, 0, 1], [1, 3, 2], [1, 0, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 0, 1], [1, 3, 2], [1, 0, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of matrix [[3.3, 2.2, 1.1], [1.0, 1.0, 1.0], [0.0, 0.5, 0.5]].",
        "output": "import numpy as np\nmatrix = np.array([[3.3, 2.2, 1.1], [1.0, 1.0, 1.0], [0.0, 0.5, 0.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[2, 3, 4], [4, 3, 2], [1, 2, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3, 4], [4, 3, 2], [1, 2, 3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of matrix [[1, 4, 6], [0, 1, 0], [3, 2, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 4, 6], [0, 1, 0], [3, 2, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of matrix [[5, 1, 0], [0, 3, 2], [4, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 1, 0], [0, 3, 2], [4, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of [[1.1, 2.2, 3.3], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9]].",
        "output": "import numpy as np\nmatrix = np.array([[1.1, 2.2, 3.3], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of matrix [[10, -5, 3], [0, 4, 2], [7, 1, -1]].",
        "output": "import numpy as np\nmatrix = np.array([[10, -5, 3], [0, 4, 2], [7, 1, -1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "What is the determinant of matrix [[3.5, 0, 2.1], [1.1, 4.4, 0.5], [2.2, 1.3, 3.3]]?",
        "output": "import numpy as np\nmatrix = np.array([[3.5, 0, 2.1], [1.1, 4.4, 0.5], [2.2, 1.3, 3.3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of matrix [[0, 2, -1], [3, -4, 5], [6, 1, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 2, -1], [3, -4, 5], [6, 1, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of matrix [[1, 2, 1], [0, 1, 0], [2, 4, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 1], [0, 1, 0], [2, 4, 3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[1.1, 0.0, 1.1], [0.0, 1.1, 1.1], [1.1, 1.1, 0.0]].",
        "output": "import numpy as np\nmatrix = np.array([[1.1, 0.0, 1.1], [0.0, 1.1, 1.1], [1.1, 1.1, 0.0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of matrix [[2, 1, 3], [1, 0, 2], [3, 4, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 1, 3], [1, 0, 2], [3, 4, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of matrix [[1, 1, 1], [1, 2, 3], [1, 4, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 1, 1], [1, 2, 3], [1, 4, 9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of matrix [[2, 2, 3], [1, 1, 1], [4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 2, 3], [1, 1, 1], [4, 5, 6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of matrix [[0, 1, 0], [2, 3, 4], [5, 6, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 1, 0], [2, 3, 4], [5, 6, 7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of matrix [[4, 5, 6], [7, 8, 9], [1, 2, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 5, 6], [7, 8, 9], [1, 2, 3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "What is the determinant of matrix [[1, 3, 2], [4, 0, 1], [6, 5, 7]]?",
        "output": "import numpy as np\nmatrix = np.array([[1, 3, 2], [4, 0, 1], [6, 5, 7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of matrix [[9, 8, 7], [6, 5, 4], [3, 2, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[9, 8, 7], [6, 5, 4], [3, 2, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[3.3, 2.1, 1.0], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9]].",
        "output": "import numpy as np\nmatrix = np.array([[3.3, 2.1, 1.0], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of matrix [[2.5, 3.1, 1.2], [4.3, 1.1, 2.0], [0.5, 6.2, 3.3]].",
        "output": "import numpy as np\nmatrix = np.array([[2.5, 3.1, 1.2], [4.3, 1.1, 2.0], [0.5, 6.2, 3.3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of [[3, 2, 1], [6, 5, 4], [9, 8, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 2, 1], [6, 5, 4], [9, 8, 7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of [[4.1, 5.2, 6.3], [7.4, 8.5, 9.6], [1.7, 2.8, 3.9]].",
        "output": "import numpy as np\nmatrix = np.array([[4.1, 5.2, 6.3], [7.4, 8.5, 9.6], [1.7, 2.8, 3.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[2.1, 4.2, 3.3], [1.4, 5.5, 6.6], [7.7, 8.8, 9.9]].",
        "output": "import numpy as np\nmatrix = np.array([[2.1, 4.2, 3.3], [1.4, 5.5, 6.6], [7.7, 8.8, 9.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "What is the determinant of [[10, 11, 12], [13, 14, 15], [16, 17, 18]]?",
        "output": "import numpy as np\nmatrix = np.array([[10, 11, 12], [13, 14, 15], [16, 17, 18]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of matrix [[1.5, 2.5, 3.5], [4.5, 5.5, 6.5], [7.5, 8.5, 9.5]].",
        "output": "import numpy as np\nmatrix = np.array([[1.5, 2.5, 3.5], [4.5, 5.5, 6.5], [7.5, 8.5, 9.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[5, 4, 3], [2, 1, 0], [6, 7, 8]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 4, 3], [2, 1, 0], [6, 7, 8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of matrix [[0.9, 1.2, 2.3], [3.4, 4.5, 5.6], [6.7, 7.8, 8.9]].",
        "output": "import numpy as np\nmatrix = np.array([[0.9, 1.2, 2.3], [3.4, 4.5, 5.6], [6.7, 7.8, 8.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[1, 2, 0], [0, 1, 3], [4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 0], [0, 1, 3], [4, 5, 6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "What is the determinant of matrix [[3.3, 1.1, 2.2], [4.4, 6.6, 5.5], [7.7, 8.8, 9.9]]?",
        "output": "import numpy as np\nmatrix = np.array([[3.3, 1.1, 2.2], [4.4, 6.6, 5.5], [7.7, 8.8, 9.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[2, 4, 6], [1, 3, 5], [0, 2, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 4, 6], [1, 3, 5], [0, 2, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of matrix [[6.6, 5.5, 4.4], [3.3, 2.2, 1.1], [0.0, 1.1, 2.2]].",
        "output": "import numpy as np\nmatrix = np.array([[6.6, 5.5, 4.4], [3.3, 2.2, 1.1], [0.0, 1.1, 2.2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of [[1.2, 3.4, 5.6], [7.8, 9.0, 1.2], [3.4, 5.6, 7.8]].",
        "output": "import numpy as np\nmatrix = np.array([[1.2, 3.4, 5.6], [7.8, 9.0, 1.2], [3.4, 5.6, 7.8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of matrix [[0.5, 1.5, 2.5], [3.5, 4.5, 5.5], [6.5, 7.5, 8.5]].",
        "output": "import numpy as np\nmatrix = np.array([[0.5, 1.5, 2.5], [3.5, 4.5, 5.5], [6.5, 7.5, 8.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[3, 3, 3], [2, 2, 2], [1, 1, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 3, 3], [2, 2, 2], [1, 1, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[2.0, 3.0, 4.0], [1.0, 2.0, 3.0], [0.0, 1.0, 2.0]].",
        "output": "import numpy as np\nmatrix = np.array([[2.0, 3.0, 4.0], [1.0, 2.0, 3.0], [0.0, 1.0, 2.0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[5, 2, 1], [0, 3, 6], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 2, 1], [0, 3, 6], [7, 8, 9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "What is the determinant of matrix [[4.5, 3.5, 2.5], [1.5, 0.5, -0.5], [6.5, 7.5, 8.5]]?",
        "output": "import numpy as np\nmatrix = np.array([[4.5, 3.5, 2.5], [1.5, 0.5, -0.5], [6.5, 7.5, 8.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of [[2.2, 1.1, 0.0], [3.3, 2.2, 1.1], [4.4, 3.3, 2.2]].",
        "output": "import numpy as np\nmatrix = np.array([[2.2, 1.1, 0.0], [3.3, 2.2, 1.1], [4.4, 3.3, 2.2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of matrix [[9, 0, 1], [2, 3, 4], [5, 6, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[9, 0, 1], [2, 3, 4], [5, 6, 7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Evaluate the determinant of [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]].",
        "output": "import numpy as np\nmatrix = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of matrix [[3.14, 1.59, 2.65], [5.35, 8.97, 9.32], [3.84, 6.26, 4.33]].",
        "output": "import numpy as np\nmatrix = np.array([[3.14, 1.59, 2.65], [5.35, 8.97, 9.32], [3.84, 6.26, 4.33]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the 4x4 matrix [[1.1, 2.2, 3.3, 4.4], [5.5, 6.6, 7.7, 8.8], [9.9, 1.0, 2.1, 3.2], [4.3, 5.4, 6.5, 7.6]].",
        "output": "import numpy as np\nmatrix = np.array([[1.1, 2.2, 3.3, 4.4], [5.5, 6.6, 7.7, 8.8], [9.9, 1.0, 2.1, 3.2], [4.3, 5.4, 6.5, 7.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the 4x4 matrix [[0.5, 1.2, 3.4, 4.1], [2.3, 0.8, 6.5, 7.1], [5.9, 2.2, 3.3, 0.4], [9.1, 8.2, 7.3, 6.4]].",
        "output": "import numpy as np\nmatrix = np.array([[0.5, 1.2, 3.4, 4.1], [2.3, 0.8, 6.5, 7.1], [5.9, 2.2, 3.3, 0.4], [9.1, 8.2, 7.3, 6.4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[7.1, 3.3, 0.9, 4.7], [1.8, 2.6, 5.3, 6.1], [0.2, 9.4, 8.3, 7.5], [3.3, 4.4, 5.5, 6.6]].",
        "output": "import numpy as np\nmatrix = np.array([[7.1, 3.3, 0.9, 4.7], [1.8, 2.6, 5.3, 6.1], [0.2, 9.4, 8.3, 7.5], [3.3, 4.4, 5.5, 6.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of matrix [[4.1, 5.2, 6.3, 7.4], [3.5, 2.6, 1.7, 0.8], [9.0, 8.1, 7.2, 6.3], [5.4, 4.5, 3.6, 2.7]].",
        "output": "import numpy as np\nmatrix = np.array([[4.1, 5.2, 6.3, 7.4], [3.5, 2.6, 1.7, 0.8], [9.0, 8.1, 7.2, 6.3], [5.4, 4.5, 3.6, 2.7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "What is the determinant of the matrix [[1.5, 2.6, 3.7, 4.8], [4.9, 5.1, 6.2, 7.3], [7.4, 8.5, 9.6, 1.7], [2.8, 3.9, 4.0, 5.1]]?",
        "output": "import numpy as np\nmatrix = np.array([[1.5, 2.6, 3.7, 4.8], [4.9, 5.1, 6.2, 7.3], [7.4, 8.5, 9.6, 1.7], [2.8, 3.9, 4.0, 5.1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the 4x4 matrix [[3.1, 4.2, 5.3, 6.4], [1.5, 2.6, 3.7, 4.8], [5.9, 6.0, 7.1, 8.2], [2.3, 3.4, 4.5, 5.6]].",
        "output": "import numpy as np\nmatrix = np.array([[3.1, 4.2, 5.3, 6.4], [1.5, 2.6, 3.7, 4.8], [5.9, 6.0, 7.1, 8.2], [2.3, 3.4, 4.5, 5.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[2.4, 3.5, 4.6, 5.7], [6.8, 7.9, 8.0, 1.1], [2.2, 3.3, 4.4, 5.5], [6.6, 7.7, 8.8, 9.9]].",
        "output": "import numpy as np\nmatrix = np.array([[2.4, 3.5, 4.6, 5.7], [6.8, 7.9, 8.0, 1.1], [2.2, 3.3, 4.4, 5.5], [6.6, 7.7, 8.8, 9.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[9.9, 8.8, 7.7, 6.6], [5.5, 4.4, 3.3, 2.2], [1.1, 2.2, 3.3, 4.4], [5.5, 6.6, 7.7, 8.8]].",
        "output": "import numpy as np\nmatrix = np.array([[9.9, 8.8, 7.7, 6.6], [5.5, 4.4, 3.3, 2.2], [1.1, 2.2, 3.3, 4.4], [5.5, 6.6, 7.7, 8.8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of [[0.1, 1.2, 2.3, 3.4], [4.5, 5.6, 6.7, 7.8], [8.9, 9.0, 0.1, 1.2], [2.3, 3.4, 4.5, 5.6]].",
        "output": "import numpy as np\nmatrix = np.array([[0.1, 1.2, 2.3, 3.4], [4.5, 5.6, 6.7, 7.8], [8.9, 9.0, 0.1, 1.2], [2.3, 3.4, 4.5, 5.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "What is the determinant of matrix [[3.3, 2.2, 1.1, 0.9], [4.5, 5.6, 6.7, 7.8], [8.9, 9.0, 1.1, 2.2], [3.3, 4.4, 5.5, 6.6]]?",
        "output": "import numpy as np\nmatrix = np.array([[3.3, 2.2, 1.1, 0.9], [4.5, 5.6, 6.7, 7.8], [8.9, 9.0, 1.1, 2.2], [3.3, 4.4, 5.5, 6.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[6.2, 4.8, 3.9, 1.2], [2.4, 6.5, 7.1, 3.3], [1.8, 2.2, 9.0, 0.5], [7.7, 8.1, 3.3, 2.9]].",
        "output": "import numpy as np\nmatrix = np.array([[6.2, 4.8, 3.9, 1.2], [2.4, 6.5, 7.1, 3.3], [1.8, 2.2, 9.0, 0.5], [7.7, 8.1, 3.3, 2.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of the matrix [[2.1, 3.3, 5.5, 7.7], [1.0, 4.4, 6.6, 8.8], [9.9, 2.2, 3.3, 4.4], [5.5, 6.6, 7.7, 8.8]].",
        "output": "import numpy as np\nmatrix = np.array([[2.1, 3.3, 5.5, 7.7], [1.0, 4.4, 6.6, 8.8], [9.9, 2.2, 3.3, 4.4], [5.5, 6.6, 7.7, 8.8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of matrix [[4.4, 3.3, 2.2, 1.1], [5.6, 6.7, 7.8, 8.9], [1.2, 3.4, 5.6, 7.8], [9.0, 8.1, 7.2, 6.3]].",
        "output": "import numpy as np\nmatrix = np.array([[4.4, 3.3, 2.2, 1.1], [5.6, 6.7, 7.8, 8.9], [1.2, 3.4, 5.6, 7.8], [9.0, 8.1, 7.2, 6.3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[1.5, 3.7, 4.2, 6.1], [0.5, 2.6, 5.9, 7.3], [8.8, 6.4, 3.1, 9.2], [2.3, 4.4, 6.5, 8.6]].",
        "output": "import numpy as np\nmatrix = np.array([[1.5, 3.7, 4.2, 6.1], [0.5, 2.6, 5.9, 7.3], [8.8, 6.4, 3.1, 9.2], [2.3, 4.4, 6.5, 8.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "What is the determinant of [[7.4, 5.1, 3.3, 2.8], [1.6, 0.9, 4.4, 6.7], [8.2, 9.3, 7.5, 1.4], [3.6, 2.1, 4.8, 5.5]]?",
        "output": "import numpy as np\nmatrix = np.array([[7.4, 5.1, 3.3, 2.8], [1.6, 0.9, 4.4, 6.7], [8.2, 9.3, 7.5, 1.4], [3.6, 2.1, 4.8, 5.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[2, 0, 1], [3, 0, 0], [5, 1, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 0, 1], [3, 0, 0], [5, 1, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of the matrix [[1, 0, 2], [-1, 3, 1], [3, 1, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 2], [-1, 3, 1], [3, 1, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of [[0, 2, 1], [3, 1, 0], [4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 2, 1], [3, 1, 0], [4, 5, 6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[3, 2, -1], [2, -2, 4], [-1, 0.5, -1]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 2, -1], [2, -2, 4], [-1, 1, -1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[4, 3, 2], [1, 1, 1], [7, 6, 5]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 3, 2], [1, 1, 1], [7, 6, 5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of [[5, 6, 7], [1, 2, 3], [8, 9, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 6, 7], [1, 2, 3], [8, 9, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "What is the determinant of [[2, 5, 7], [6, 3, 4], [5, -2, -3]]?",
        "output": "import numpy as np\nmatrix = np.array([[2, 5, 7], [6, 3, 4], [5, -2, -3]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[1, 3, 5], [2, 4, 7], [1, 1, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 3, 5], [2, 4, 7], [1, 1, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of [[0, 1, 2], [3, 4, 5], [6, 7, 8]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[1, 0, 0], [0, 1, 0], [0, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[1, 2, 3], [0, 1, 4], [5, 6, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [0, 1, 4], [5, 6, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of [[2, -3, 1], [2, 0, -1], [1, 4, 5]].",
        "output": "import numpy as np\nmatrix = np.array([[2, -3, 1], [2, 0, -1], [1, 4, 5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "What is the determinant of [[1, 2, 3], [2, 3, 4], [3, 4, 5]]?",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[6, 1, 1], [4, -2, 5], [2, 8, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[6, 1, 1], [4, -2, 5], [2, 8, 7]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[1, 0, 2], [0, 1, 3], [4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 0, 2], [0, 1, 3], [4, 5, 6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of [[2, 3, 1], [4, 1, 5], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3, 1], [4, 1, 5], [7, 8, 9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "What is the determinant of [[9, 8, 7], [6, 5, 4], [3, 2, 1]]?",
        "output": "import numpy as np\nmatrix = np.array([[9, 8, 7], [6, 5, 4], [3, 2, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[1, 4, 5], [6, 7, 8], [9, 10, 11]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 4, 5], [6, 7, 8], [9, 10, 11]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[2, 1, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 1, 3], [4, 5, 6], [7, 8, 9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of [[1, 2, 1], [0, 1, 0], [2, 3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 1], [0, 1, 0], [2, 3, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[1, 1, 1], [0, 1, 0], [1, 0, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 1, 1], [0, 1, 0], [1, 0, 1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "What is the determinant of [[2, 3, 4], [1, 0, 0], [0, 1, 0]]?",
        "output": "import numpy as np\nmatrix = np.array([[2, 3, 4], [1, 0, 0], [0, 1, 0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of [[5, 2, 1], [0, 3, 0], [1, 0, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 2, 1], [0, 3, 0], [1, 0, 4]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of the matrix [[1.2, 2.5, 3.1, 4.0], [5.6, 6.3, 7.2, 8.4], [9.1, 10.7, 11.5, 12.6], [13.3, 14.8, 15.9, 16.0]].",
        "output": "import numpy as np\nmatrix = np.array([[1.2, 2.5, 3.1, 4.0], [5.6, 6.3, 7.2, 8.4], [9.1, 10.7, 11.5, 12.6], [13.3, 14.8, 15.9, 16.0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of [[2.3, 4.5, 1.1, 6.7], [7.2, 3.3, 8.4, 9.1], [10.0, 11.3, 2.6, 12.8], [13.5, 14.6, 15.7, 1.0]].",
        "output": "import numpy as np\nmatrix = np.array([[2.3, 4.5, 1.1, 6.7], [7.2, 3.3, 8.4, 9.1], [10.0, 11.3, 2.6, 12.8], [13.5, 14.6, 15.7, 1.0]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of [[0.5, 1.1, 2.2, 3.3], [4.4, 5.5, 6.6, 7.7], [8.8, 9.9, 10.1, 11.2], [12.3, 13.4, 14.5, 15.6]].",
        "output": "import numpy as np\nmatrix = np.array([[0.5, 1.1, 2.2, 3.3], [4.4, 5.5, 6.6, 7.7], [8.8, 9.9, 10.1, 11.2], [12.3, 13.4, 14.5, 15.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "What is the determinant of [[3.3, 2.2, 1.1, 0.0], [4.4, 5.5, 6.6, 7.7], [8.8, 9.9, 10.0, 11.1], [12.2, 13.3, 14.4, 15.5]]?",
        "output": "import numpy as np\nmatrix = np.array([[3.3, 2.2, 1.1, 0.0], [4.4, 5.5, 6.6, 7.7], [8.8, 9.9, 10.0, 11.1], [12.2, 13.3, 14.4, 15.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[2.2, 4.4, 6.6, 8.8], [1.1, 3.3, 5.5, 7.7], [9.9, 8.8, 7.7, 6.6], [5.5, 4.4, 3.3, 2.2]].",
        "output": "import numpy as np\nmatrix = np.array([[2.2, 4.4, 6.6, 8.8], [1.1, 3.3, 5.5, 7.7], [9.9, 8.8, 7.7, 6.6], [5.5, 4.4, 3.3, 2.2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[7.5, 6.3, 5.1, 4.9], [3.7, 2.5, 1.3, 0.1], [8.6, 9.4, 10.2, 11.0], [12.8, 13.6, 14.4, 15.2]].",
        "output": "import numpy as np\nmatrix = np.array([[7.5, 6.3, 5.1, 4.9], [3.7, 2.5, 1.3, 0.1], [8.6, 9.4, 10.2, 11.0], [12.8, 13.6, 14.4, 15.2]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of [[1.5, 2.6, 3.7, 4.8], [5.9, 6.0, 7.1, 8.2], [9.3, 10.4, 11.5, 12.6], [13.7, 14.8, 15.9, 16.1]].",
        "output": "import numpy as np\nmatrix = np.array([[1.5, 2.6, 3.7, 4.8], [5.9, 6.0, 7.1, 8.2], [9.3, 10.4, 11.5, 12.6], [13.7, 14.8, 15.9, 16.1]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[0.0, 1.1, 2.2, 3.3], [4.4, 5.5, 6.6, 7.7], [8.8, 9.9, 10.0, 11.1], [12.2, 13.3, 14.4, 15.5]].",
        "output": "import numpy as np\nmatrix = np.array([[0.0, 1.1, 2.2, 3.3], [4.4, 5.5, 6.6, 7.7], [8.8, 9.9, 10.0, 11.1], [12.2, 13.3, 14.4, 15.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Compute the determinant of [[9.0, 8.1, 7.2, 6.3], [5.4, 4.5, 3.6, 2.7], [1.8, 0.9, 0.0, -0.9], [-1.8, -2.7, -3.6, -4.5]].",
        "output": "import numpy as np\nmatrix = np.array([[9.0, 8.1, 7.2, 6.3], [5.4, 4.5, 3.6, 2.7], [1.8, 0.9, 0.0, -0.9], [-1.8, -2.7, -3.6, -4.5]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Calculate the determinant of [[0.4, 1.5, 2.6, 3.7], [4.8, 5.9, 6.0, 7.1], [8.2, 9.3, 10.4, 11.5], [12.6, 13.7, 14.8, 15.9]].",
        "output": "import numpy as np\nmatrix = np.array([[0.4, 1.5, 2.6, 3.7], [4.8, 5.9, 6.0, 7.1], [8.2, 9.3, 10.4, 11.5], [12.6, 13.7, 14.8, 15.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Determine the determinant of [[5.1, 6.2, 7.3, 8.4], [9.5, 10.6, 11.7, 12.8], [13.9, 14.0, 15.1, 16.2], [17.3, 18.4, 19.5, 20.6]].",
        "output": "import numpy as np\nmatrix = np.array([[5.1, 6.2, 7.3, 8.4], [9.5, 10.6, 11.7, 12.8], [13.9, 14.0, 15.1, 16.2], [17.3, 18.4, 19.5, 20.6]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "What is the determinant of [[0.3, 1.6, 2.9, 4.2], [5.5, 6.8, 8.1, 9.4], [10.7, 12.0, 13.3, 14.6], [15.9, 17.2, 18.5, 19.8]]?",
        "output": "import numpy as np\nmatrix = np.array([[0.3, 1.6, 2.9, 4.2], [5.5, 6.8, 8.1, 9.4], [10.7, 12.0, 13.3, 14.6], [15.9, 17.2, 18.5, 19.8]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the determinant of [[1.4, 2.5, 3.6, 4.7], [5.8, 6.9, 7.0, 8.1], [9.2, 10.3, 11.4, 12.5], [13.6, 14.7, 15.8, 16.9]].",
        "output": "import numpy as np\nmatrix = np.array([[1.4, 2.5, 3.6, 4.7], [5.8, 6.9, 7.0, 8.1], [9.2, 10.3, 11.4, 12.5], [13.6, 14.7, 15.8, 16.9]])\ndet = np.linalg.det(matrix)\nprint(f'The determinant is {det}')"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[5, 4, 2], [0, 5, 1], [0, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 4, 2], [0, 5, 1], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[2, 1, 0], [0, 2, 0], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 1, 0], [0, 2, 0], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[4, 0, 1], [0, 4, 0], [0, 0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[4, 0, 1], [0, 4, 0], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Find the Jordan form of A = [[1, 1], [0, 1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 1], [0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[1, 2, 0], [0, 1, 2], [0, 0, 1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 2, 0], [0, 1, 2], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Find the Jordan form of A = [[0, 1], [-1, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 1], [-1, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[6, 2, 1], [0, 6, 2], [0, 0, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[6, 2, 1], [0, 6, 2], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[0, 1, 0], [0, 0, 1], [1, 0, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Compute Jordan form of A = [[4, 1], [0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[4, 1], [0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[7, 5, 0], [0, 7, 5], [0, 0, 7]].",
        "output": "from sympy import Matrix\nA = Matrix([[7, 5, 0], [0, 7, 5], [0, 0, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[0, 1], [0, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 1], [0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Find the Jordan form of A = [[3, 2], [0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 2], [0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[2, 0], [0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 0], [0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Compute Jordan Normal Form of A = [[5, 1, 0], [0, 5, 1], [0, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 1, 0], [0, 5, 1], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Find Jordan form of A = [[-2, 1], [0, -2]].",
        "output": "from sympy import Matrix\nA = Matrix([[-2, 1], [0, -2]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Jordan Normal Form of A = [[1, 1, 0], [0, 1, 1], [0, 0, 1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 1, 0], [0, 1, 1], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Jordan form of A = [[2, 1, 0], [0, 2, 1], [0, 0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 1, 0], [0, 2, 1], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Find Jordan form of A = [[3, 0], [0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 0], [0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Find Jordan form of A = [[1, 0], [0, 1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 0], [0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Compute Jordan Normal Form of A = [[0, 1, 0], [0, 0, 1], [0, 0, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Jordan form of A = [[5, 1, 1], [0, 5, 1], [0, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 1, 1], [0, 5, 1], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Find the Jordan form of A = [[-1, 1], [0, -1]].",
        "output": "from sympy import Matrix\nA = Matrix([[-1, 1], [0, -1]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Jordan form of A = [[0, 1], [1, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 1], [1, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan Normal Form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of matrix A = [[2, 3, 1], [0, 2, 1], [0, 0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 3, 1], [0, 2, 1], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Form of the matrix A = [[4, 2, 0], [0, 4, 1], [0, 0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[4, 2, 0], [0, 4, 1], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form for A = [[-1, 1, 0], [0, -1, 1], [0, 0, -1]].",
        "output": "from sympy import Matrix\nA = Matrix([[-1, 1, 0], [0, -1, 1], [0, 0, -1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan form of A = [[3, 1, 0], [0, 3, 0], [0, 0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 1, 0], [0, 3, 0], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[5, 0, 1], [0, 5, 0], [0, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 0, 1], [0, 5, 0], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of A = [[6, 4, 1], [0, 6, 0], [0, 0, 6]]?",
        "output": "from sympy import Matrix\nA = Matrix([[6, 4, 1], [0, 6, 0], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Evaluate the Jordan Normal Form of matrix A = [[0, 0, 1], [0, 0, 0], [0, 0, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 0, 1], [0, 0, 0], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan form of A = [[2, 0, 0], [0, 2, 1], [0, 0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 0, 0], [0, 2, 1], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form for A = [[-2, 1, 0], [0, -2, 1], [0, 0, -2]].",
        "output": "from sympy import Matrix\nA = Matrix([[-2, 1, 0], [0, -2, 1], [0, 0, -2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Form of matrix A = [[3, 0, 1], [0, 3, 1], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 0, 1], [0, 3, 1], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[10, 2, 0], [0, 10, 2], [0, 0, 10]].",
        "output": "from sympy import Matrix\nA = Matrix([[10, 2, 0], [0, 10, 2], [0, 0, 10]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Evaluate the Jordan Normal Form of A = [[1, 1, 1], [0, 1, 1], [0, 0, 1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 1, 1], [0, 1, 1], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Form of matrix A = [[-1, 0, 1], [0, -1, 0], [0, 0, -1]].",
        "output": "from sympy import Matrix\nA = Matrix([[-1, 0, 1], [0, -1, 0], [0, 0, -1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[4, 1, 1], [0, 4, 0], [0, 0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[4, 1, 1], [0, 4, 0], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Form of matrix A = [[7, 0, 0], [0, 7, 0], [0, 0, 7]].",
        "output": "from sympy import Matrix\nA = Matrix([[7, 0, 0], [0, 7, 0], [0, 0, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Evaluate the Jordan Normal Form of A = [[8, 3, 0], [0, 8, 3], [0, 0, 8]].",
        "output": "from sympy import Matrix\nA = Matrix([[8, 3, 0], [0, 8, 3], [0, 0, 8]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Form of matrix A = [[6, 2, 2], [0, 6, 2], [0, 0, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[6, 2, 2], [0, 6, 2], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of matrix A = [[-3, 0, 1], [0, -3, 1], [0, 0, -3]].",
        "output": "from sympy import Matrix\nA = Matrix([[-3, 0, 1], [0, -3, 1], [0, 0, -3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[11, 4, 4], [0, 11, 4], [0, 0, 11]].",
        "output": "from sympy import Matrix\nA = Matrix([[11, 4, 4], [0, 11, 4], [0, 0, 11]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of A = [[12, 0, 2], [0, 12, 2], [0, 0, 12]]?",
        "output": "from sympy import Matrix\nA = Matrix([[12, 0, 2], [0, 12, 2], [0, 0, 12]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[14, 5, 0], [0, 14, 5], [0, 0, 14]].",
        "output": "from sympy import Matrix\nA = Matrix([[14, 5, 0], [0, 14, 5], [0, 0, 14]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[2, 1, 0], [0, 2, 1], [0, 0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 1, 0], [0, 2, 1], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[0, 1, 0], [0, 0, 1], [0, 0, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[3, 0, 1], [0, 3, 0], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 0, 1], [0, 3, 0], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[-1, 1, 0], [0, -1, 1], [0, 0, -1]].",
        "output": "from sympy import Matrix\nA = Matrix([[-1, 1, 0], [0, -1, 1], [0, 0, -1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[5, 1, 1], [0, 5, 0], [0, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 1, 1], [0, 5, 0], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[4, 2, 1], [0, 4, 2], [0, 0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[4, 2, 1], [0, 4, 2], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[0, 0, 0], [1, 0, 0], [0, 1, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 0, 0], [1, 0, 0], [0, 1, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[7, 3, 0], [0, 7, 3], [0, 0, 7]].",
        "output": "from sympy import Matrix\nA = Matrix([[7, 3, 0], [0, 7, 3], [0, 0, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[6, 2, 0], [0, 6, 1], [0, 0, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[6, 2, 0], [0, 6, 1], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[3, 2, 0], [0, 3, 1], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 2, 0], [0, 3, 1], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[1, 1, 1], [0, 1, 1], [0, 0, 1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 1, 1], [0, 1, 1], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[-3, 1, 0], [0, -3, 1], [0, 0, -3]].",
        "output": "from sympy import Matrix\nA = Matrix([[-3, 1, 0], [0, -3, 1], [0, 0, -3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[2, 2, 1], [0, 2, 2], [0, 0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 2, 1], [0, 2, 2], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[9, 4, 2], [0, 9, 4], [0, 0, 9]].",
        "output": "from sympy import Matrix\nA = Matrix([[9, 4, 2], [0, 9, 4], [0, 0, 9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[0, 2, 0], [0, 0, 2], [0, 0, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 2, 0], [0, 0, 2], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[1, 0, 1], [0, 1, 0], [0, 0, 1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 0, 1], [0, 1, 0], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[8, 3, 1], [0, 8, 3], [0, 0, 8]].",
        "output": "from sympy import Matrix\nA = Matrix([[8, 3, 1], [0, 8, 3], [0, 0, 8]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[5, 0, 2], [0, 5, 0], [0, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 0, 2], [0, 5, 0], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[-2, 1, 0], [0, -2, 1], [0, 0, -2]].",
        "output": "from sympy import Matrix\nA = Matrix([[-2, 1, 0], [0, -2, 1], [0, 0, -2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[4, 0, 0], [0, 4, 1], [0, 0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[4, 0, 0], [0, 4, 1], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[6, 1, 1], [0, 6, 1], [0, 0, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[6, 1, 1], [0, 6, 1], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[2, 0, 0], [0, 2, 1], [0, 0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 0, 0], [0, 2, 1], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[1, 0, 2], [0, 1, 0], [0, 0, 1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 0, 2], [0, 1, 0], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[-1, 2, 1], [0, -1, 2], [0, 0, -1]].",
        "output": "from sympy import Matrix\nA = Matrix([[-1, 2, 1], [0, -1, 2], [0, 0, -1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[3, 1, 1], [0, 3, 1], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 1, 1], [0, 3, 1], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[1, 1, 0], [0, 1, 1], [0, 0, 1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 1, 0], [0, 1, 1], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[2, 1, 1], [0, 2, 1], [0, 0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 1, 1], [0, 2, 1], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[3, 2, 0], [0, 3, 1], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 2, 0], [0, 3, 1], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[4, 0, 1], [0, 4, 1], [0, 0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[4, 0, 1], [0, 4, 1], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[5, 1, 0], [0, 5, 0], [0, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 1, 0], [0, 5, 0], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[6, 0, 0], [1, 6, 0], [0, 1, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[6, 0, 0], [1, 6, 0], [0, 1, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[7, 1, 0], [0, 7, 1], [0, 0, 7]].",
        "output": "from sympy import Matrix\nA = Matrix([[7, 1, 0], [0, 7, 1], [0, 0, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[8, 2, 0], [0, 8, 0], [0, 0, 8]].",
        "output": "from sympy import Matrix\nA = Matrix([[8, 2, 0], [0, 8, 0], [0, 0, 8]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[9, 0, 0], [0, 9, 0], [1, 0, 9]].",
        "output": "from sympy import Matrix\nA = Matrix([[9, 0, 0], [0, 9, 0], [1, 0, 9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[10, 0, 1], [0, 10, 0], [0, 0, 10]].",
        "output": "from sympy import Matrix\nA = Matrix([[10, 0, 1], [0, 10, 0], [0, 0, 10]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[4, 4, 0], [0, 4, 4], [0, 0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[4, 4, 0], [0, 4, 4], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[5, 2, 2], [0, 5, 2], [0, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 2, 2], [0, 5, 2], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[6, 0, 0], [0, 6, 2], [0, 0, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[6, 0, 0], [0, 6, 2], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[7, 0, 2], [0, 7, 0], [0, 0, 7]].",
        "output": "from sympy import Matrix\nA = Matrix([[7, 0, 2], [0, 7, 0], [0, 0, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[8, 3, 0], [0, 8, 3], [0, 0, 8]].",
        "output": "from sympy import Matrix\nA = Matrix([[8, 3, 0], [0, 8, 3], [0, 0, 8]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[-2, 1, 0], [0, -2, 1], [0, 0, -2]].",
        "output": "from sympy import Matrix\nA = Matrix([[-2, 1, 0], [0, -2, 1], [0, 0, -2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[1, 1, 1], [0, 1, 1], [0, 0, 1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 1, 1], [0, 1, 1], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[0, 0, 1], [0, 0, 0], [1, 0, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 0, 1], [0, 0, 0], [1, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[1, 0, 1], [0, 1, 0], [0, 0, 1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 0, 1], [0, 1, 0], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[2, 0, 0], [2, 2, 0], [0, 2, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 0, 0], [2, 2, 0], [0, 2, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[2, 0, 1], [0, 2, 0], [0, 0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 0, 1], [0, 2, 0], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[3, 1, 1], [0, 3, 1], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 1, 1], [0, 3, 1], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[4, 0, 0], [0, 4, 1], [0, 0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[4, 0, 0], [0, 4, 1], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[5, 1, 0], [0, 5, 1], [0, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 1, 0], [0, 5, 1], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[6, 1, 1], [0, 6, 1], [0, 0, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[6, 1, 1], [0, 6, 1], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[7, 0, 0], [0, 7, 0], [1, 0, 7]].",
        "output": "from sympy import Matrix\nA = Matrix([[7, 0, 0], [0, 7, 0], [1, 0, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[8, 2, 0], [0, 8, 1], [0, 0, 8]].",
        "output": "from sympy import Matrix\nA = Matrix([[8, 2, 0], [0, 8, 1], [0, 0, 8]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[9, 1, 1], [0, 9, 0], [0, 0, 9]].",
        "output": "from sympy import Matrix\nA = Matrix([[9, 1, 1], [0, 9, 0], [0, 0, 9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[10, 0, 2], [0, 10, 2], [0, 0, 10]].",
        "output": "from sympy import Matrix\nA = Matrix([[10, 0, 2], [0, 10, 2], [0, 0, 10]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[1.5, 1, 0], [0, 1.5, 1], [0, 0, 1.5]].",
        "output": "from sympy import Matrix\nA = Matrix([[1.5, 1, 0], [0, 1.5, 1], [0, 0, 1.5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[2.2, 0, 1], [0, 2.2, 0], [0, 0, 2.2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2.2, 0, 1], [0, 2.2, 0], [0, 0, 2.2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[-3, 0, 1], [0, -3, 0], [0, 0, -3]].",
        "output": "from sympy import Matrix\nA = Matrix([[-3, 0, 1], [0, -3, 0], [0, 0, -3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[0, 1, 1], [0, 0, 1], [0, 0, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 1, 1], [0, 0, 1], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[1, 1, 0], [0, 1, 0], [0, 0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 1, 0], [0, 1, 0], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[2, 0, 0], [0, 3, 1], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 0, 0], [0, 3, 1], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[3, 0, 0], [0, 3, 0], [0, 0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 0, 0], [0, 3, 0], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[4, 1, 0], [0, 4, 0], [0, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[4, 1, 0], [0, 4, 0], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[5, 0, 0], [0, 6, 1], [0, 0, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 0, 0], [0, 6, 1], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[6, 1, 0], [0, 6, 0], [0, 0, 7]].",
        "output": "from sympy import Matrix\nA = Matrix([[6, 1, 0], [0, 6, 0], [0, 0, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[7, 0, 0], [0, 8, 1], [0, 0, 8]].",
        "output": "from sympy import Matrix\nA = Matrix([[7, 0, 0], [0, 8, 1], [0, 0, 8]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[8, 0, 1], [0, 8, 0], [0, 0, 9]].",
        "output": "from sympy import Matrix\nA = Matrix([[8, 0, 1], [0, 8, 0], [0, 0, 9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[9, 2, 0], [0, 9, 0], [0, 0, 10]].",
        "output": "from sympy import Matrix\nA = Matrix([[9, 2, 0], [0, 9, 0], [0, 0, 10]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[10, 0, 0], [0, 10, 1], [0, 0, 11]].",
        "output": "from sympy import Matrix\nA = Matrix([[10, 0, 0], [0, 10, 1], [0, 0, 11]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[2, 1, 0], [0, 2, 0], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 1, 0], [0, 2, 0], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[4, 2, 0], [0, 4, 0], [0, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[4, 2, 0], [0, 4, 0], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[3.3, 1, 0], [0, 3.3, 0], [0, 0, 4.4]].",
        "output": "from sympy import Matrix\nA = Matrix([[3.3, 1, 0], [0, 3.3, 0], [0, 0, 4.4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[1, 0, 0], [0, 2, 1], [0, 0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 0, 0], [0, 2, 1], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[5, 0, 0], [0, 5, 0], [1, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 0, 0], [0, 5, 0], [1, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[-1, 2, 0], [0, -1, 2], [0, 0, -1]].",
        "output": "from sympy import Matrix\nA = Matrix([[-1, 2, 0], [0, -1, 2], [0, 0, -1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[0.5, 1, 1], [0, 0.5, 1], [0, 0, 0.5]].",
        "output": "from sympy import Matrix\nA = Matrix([[0.5, 1, 1], [0, 0.5, 1], [0, 0, 0.5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[3, 0, 0], [0, 3, 1], [0, 0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 0, 0], [0, 3, 1], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[7, 0, 0], [1, 7, 0], [0, 0, 8]].",
        "output": "from sympy import Matrix\nA = Matrix([[7, 0, 0], [1, 7, 0], [0, 0, 8]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[9, 1, 0], [0, 9, 1], [0, 0, 9]].",
        "output": "from sympy import Matrix\nA = Matrix([[9, 1, 0], [0, 9, 1], [0, 0, 9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[10, 0, 2], [0, 10, 0], [0, 0, 10]].",
        "output": "from sympy import Matrix\nA = Matrix([[10, 0, 2], [0, 10, 0], [0, 0, 10]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[2, 1, 0], [0, 3, 1], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 1, 0], [0, 3, 1], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[3, 0, 1], [0, 4, 0], [0, 0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 0, 1], [0, 4, 0], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[5, 1, 0], [0, 6, 1], [0, 0, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 1, 0], [0, 6, 1], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[7, 0, 0], [0, 7, 0], [0, 1, 7]].",
        "output": "from sympy import Matrix\nA = Matrix([[7, 0, 0], [0, 7, 0], [0, 1, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[8, 2, 1], [0, 8, 0], [0, 0, 9]].",
        "output": "from sympy import Matrix\nA = Matrix([[8, 2, 1], [0, 8, 0], [0, 0, 9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[1.1, 0, 1], [0, 1.1, 0], [0, 0, 2.2]].",
        "output": "from sympy import Matrix\nA = Matrix([[1.1, 0, 1], [0, 1.1, 0], [0, 0, 2.2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[2.5, 1, 0], [0, 2.5, 0], [0, 0, 2.5]].",
        "output": "from sympy import Matrix\nA = Matrix([[2.5, 1, 0], [0, 2.5, 0], [0, 0, 2.5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[0, 0, 0], [0, 0, 1], [0, 0, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 0, 0], [0, 0, 1], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[3, 1, 0], [0, 4, 1], [0, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 1, 0], [0, 4, 1], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[6, 0, 0], [0, 6, 0], [0, 0, 7]].",
        "output": "from sympy import Matrix\nA = Matrix([[6, 0, 0], [0, 6, 0], [0, 0, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[8, 0, 1], [0, 9, 0], [0, 0, 9]].",
        "output": "from sympy import Matrix\nA = Matrix([[8, 0, 1], [0, 9, 0], [0, 0, 9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[1, 2, 0], [0, 1, 0], [0, 0, 1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 2, 0], [0, 1, 0], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[3, 0, 2], [0, 3, 0], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 0, 2], [0, 3, 0], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[2, 0, 0], [1, 2, 0], [0, 0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 0, 0], [1, 2, 0], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[0, 1, 0], [0, 0, 1], [0, 0, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form for A = [[6, 1, 0], [0, 6, 0], [0, 0, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[6, 1, 0], [0, 6, 0], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of matrix A = [[3, 1, 1], [0, 3, 0], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 1, 1], [0, 3, 0], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of matrix A = [[1, 2, 3], [0, 1, 4], [0, 0, 1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 2, 3], [0, 1, 4], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of matrix A = [[2, 2, 0], [0, 2, 1], [0, 0, 2]]?",
        "output": "from sympy import Matrix\nA = Matrix([[2, 2, 0], [0, 2, 1], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[4.5, 0, 0], [0, 4.5, 1], [0, 0, 4.5]].",
        "output": "from sympy import Matrix\nA = Matrix([[4.5, 0, 0], [0, 4.5, 1], [0, 0, 4.5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form for matrix A = [[5, 1, 1], [0, 5, 1], [0, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 1, 1], [0, 5, 1], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of A = [[3, 2, 1], [0, 3, 1], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 2, 1], [0, 3, 1], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of matrix A = [[6.6, 1.1, 0], [0, 6.6, 1.1], [0, 0, 6.6]].",
        "output": "from sympy import Matrix\nA = Matrix([[6.6, 1.1, 0], [0, 6.6, 1.1], [0, 0, 6.6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form for A = [[2, 1, 1], [0, 2, 1], [0, 0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 1, 1], [0, 2, 1], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[9, 0, 1], [0, 9, 1], [0, 0, 9]].",
        "output": "from sympy import Matrix\nA = Matrix([[9, 0, 1], [0, 9, 1], [0, 0, 9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of matrix A = [[5, 1, 0], [0, 5, 0], [0, 0, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 1, 0], [0, 5, 0], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form for A = [[7.7, 0, 0], [0, 7.7, 1], [0, 0, 7.7]].",
        "output": "from sympy import Matrix\nA = Matrix([[7.7, 0, 0], [0, 7.7, 1], [0, 0, 7.7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[0, 0, 1], [0, 0, 0], [0, 0, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 0, 1], [0, 0, 0], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of matrix A = [[8, 1, 0], [0, 8, 0], [0, 0, 9]].",
        "output": "from sympy import Matrix\nA = Matrix([[8, 1, 0], [0, 8, 0], [0, 0, 9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[3.3, 0.2, 0], [0, 3.3, 0.2], [0, 0, 3.3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3.3, 0.2, 0], [0, 3.3, 0.2], [0, 0, 3.3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of matrix A = [[6, 0, 2], [0, 6, 0], [0, 0, 6]]?",
        "output": "from sympy import Matrix\nA = Matrix([[6, 0, 2], [0, 6, 0], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of matrix A = [[1, 0, 0], [0, 2, 0], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 0, 0], [0, 2, 0], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of A = [[2.2, 1.1, 0], [0, 2.2, 1.1], [0, 0, 2.2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2.2, 1.1, 0], [0, 2.2, 1.1], [0, 0, 2.2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of matrix A = [[4, 0, 1], [0, 4, 1], [0, 0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[4, 0, 1], [0, 4, 1], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[5.5, 0, 0], [0, 6.6, 0], [0, 0, 5.5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5.5, 0, 0], [0, 6.6, 0], [0, 0, 5.5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[3, 1, 0], [0, 3, 1], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 1, 0], [0, 3, 1], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[1, 1, 0], [0, 1, 1], [0, 0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 1, 0], [0, 1, 1], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of matrix A = [[7, 0, 1], [0, 7, 0], [0, 0, 8]].",
        "output": "from sympy import Matrix\nA = Matrix([[7, 0, 1], [0, 7, 0], [0, 0, 8]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of A = [[2, 1, 0], [0, 2, 0], [0, 0, 1]]?",
        "output": "from sympy import Matrix\nA = Matrix([[2, 1, 0], [0, 2, 0], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[9, 1, 0], [0, 9, 0], [0, 0, 9]].",
        "output": "from sympy import Matrix\nA = Matrix([[9, 1, 0], [0, 9, 0], [0, 0, 9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[1.1, 0, 0], [0, 1.1, 1.1], [0, 0, 1.1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1.1, 0, 0], [0, 1.1, 1.1], [0, 0, 1.1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of matrix A = [[5, 1, 0], [0, 5, 1], [0, 0, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 1, 0], [0, 5, 1], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of A = [[0, 1, 1], [0, 0, 1], [0, 0, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 1, 1], [0, 0, 1], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form for A = [[4.2, 1.1, 0], [0, 4.2, 0], [0, 0, 4.2]]?",
        "output": "from sympy import Matrix\nA = Matrix([[4.2, 1.1, 0], [0, 4.2, 0], [0, 0, 4.2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[6, 2, 0], [0, 6, 2], [0, 0, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[6, 2, 0], [0, 6, 2], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[2, 0, 0], [1, 2, 0], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 0, 0], [1, 2, 0], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form for A = [[7, 1, 1], [0, 7, 1], [0, 0, 7]].",
        "output": "from sympy import Matrix\nA = Matrix([[7, 1, 1], [0, 7, 1], [0, 0, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of A = [[1, 0, 0], [0, 1, 0], [0, 1, 1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 0, 0], [0, 1, 0], [0, 1, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[4, 2, 0], [0, 4, 0], [0, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[4, 2, 0], [0, 4, 0], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of A = [[3, 1, 0], [0, 3, 0], [0, 0, 4]]?",
        "output": "from sympy import Matrix\nA = Matrix([[3, 1, 0], [0, 3, 0], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[5.5, 0, 0], [0, 5.5, 1.5], [0, 0, 5.5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5.5, 0, 0], [0, 5.5, 1.5], [0, 0, 5.5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form for A = [[7, 1, 0], [0, 7, 0], [0, 0, 7]].",
        "output": "from sympy import Matrix\nA = Matrix([[7, 1, 0], [0, 7, 0], [0, 0, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of matrix A = [[2, 1, 0], [0, 2, 1], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 1, 0], [0, 2, 1], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[8.8, 0, 0], [0, 8.8, 1.1], [0, 0, 8.8]].",
        "output": "from sympy import Matrix\nA = Matrix([[8.8, 0, 0], [0, 8.8, 1.1], [0, 0, 8.8]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form for A = [[0, 0, 0], [1, 0, 0], [0, 1, 0]]?",
        "output": "from sympy import Matrix\nA = Matrix([[0, 0, 0], [1, 0, 0], [0, 1, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of matrix A = [[3, 0, 1], [0, 3, 1], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 0, 1], [0, 3, 1], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of A = [[5, 1, 0], [0, 5, 1], [0, 0, 7]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 1, 0], [0, 5, 1], [0, 0, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[2, 1, 0], [0, 2, 1], [0, 0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 1, 0], [0, 2, 1], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[4, 2, 1], [0, 4, 2], [0, 0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[4, 2, 1], [0, 4, 2], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[3.5, 0, 1.1], [0, 3.5, 0], [0, 0, 3.5]].",
        "output": "from sympy import Matrix\nA = Matrix([[3.5, 0, 1.1], [0, 3.5, 0], [0, 0, 3.5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[0, 1, 0], [0, 0, 1], [0, 0, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form for A = [[1, 2, 0], [0, 1, 2], [0, 0, 1]]?",
        "output": "from sympy import Matrix\nA = Matrix([[1, 2, 0], [0, 1, 2], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of matrix A = [[6, 1, 0], [0, 6, 0], [1, 0, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[6, 1, 0], [0, 6, 0], [1, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[8, 2, 1], [0, 8, 2], [0, 0, 8]].",
        "output": "from sympy import Matrix\nA = Matrix([[8, 2, 1], [0, 8, 2], [0, 0, 8]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of matrix A = [[9, 0, 1], [0, 9, 1], [0, 0, 9]].",
        "output": "from sympy import Matrix\nA = Matrix([[9, 0, 1], [0, 9, 1], [0, 0, 9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of A = [[5, 1, 1], [0, 5, 1], [0, 0, 5]]?",
        "output": "from sympy import Matrix\nA = Matrix([[5, 1, 1], [0, 5, 1], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of A = [[1.2, 0, 1.2], [0, 1.2, 0], [0, 0, 1.2]].",
        "output": "from sympy import Matrix\nA = Matrix([[1.2, 0, 1.2], [0, 1.2, 0], [0, 0, 1.2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form for matrix A = [[7.7, 1.1, 0], [0, 7.7, 1.1], [0, 0, 7.7]].",
        "output": "from sympy import Matrix\nA = Matrix([[7.7, 1.1, 0], [0, 7.7, 1.1], [0, 0, 7.7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of matrix A = [[4, 1, 1], [0, 4, 1], [0, 0, 4]].",
        "output": "from sympy import Matrix\nA = Matrix([[4, 1, 1], [0, 4, 1], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of A = [[2, 1, 1], [0, 2, 1], [0, 0, 2]]?",
        "output": "from sympy import Matrix\nA = Matrix([[2, 1, 1], [0, 2, 1], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[0, 1, 1], [0, 0, 1], [0, 0, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 1, 1], [0, 0, 1], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of A = [[6, 1, 0], [0, 6, 1], [0, 0, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[6, 1, 0], [0, 6, 1], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[1.1, 1.1, 0], [0, 1.1, 1.1], [0, 0, 1.1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1.1, 1.1, 0], [0, 1.1, 1.1], [0, 0, 1.1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of matrix A = [[7, 0, 0], [0, 7, 1], [0, 0, 7]].",
        "output": "from sympy import Matrix\nA = Matrix([[7, 0, 0], [0, 7, 1], [0, 0, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form for A = [[5, 2, 0], [0, 5, 2], [0, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 2, 0], [0, 5, 2], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[9, 0, 0], [0, 9, 1], [0, 0, 9]].",
        "output": "from sympy import Matrix\nA = Matrix([[9, 0, 0], [0, 9, 1], [0, 0, 9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of A = [[3, 2, 1], [0, 3, 2], [0, 0, 3]]?",
        "output": "from sympy import Matrix\nA = Matrix([[3, 2, 1], [0, 3, 2], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of A = [[4.4, 0, 1], [0, 4.4, 1], [0, 0, 4.4]].",
        "output": "from sympy import Matrix\nA = Matrix([[4.4, 0, 1], [0, 4.4, 1], [0, 0, 4.4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[5.5, 2.2, 0], [0, 5.5, 2.2], [0, 0, 5.5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5.5, 2.2, 0], [0, 5.5, 2.2], [0, 0, 5.5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[3, 1, 0], [0, 3, 0], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 1, 0], [0, 3, 0], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of matrix A = [[9, 0, 3], [0, 9, 0], [0, 0, 9]]?",
        "output": "from sympy import Matrix\nA = Matrix([[9, 0, 3], [0, 9, 0], [0, 0, 9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form for matrix A = [[1.1, 0, 1], [0, 1.1, 0], [0, 0, 1.1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1.1, 0, 1], [0, 1.1, 0], [0, 0, 1.1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[7.7, 1.3, 0], [0, 7.7, 1.3], [0, 0, 7.7]].",
        "output": "from sympy import Matrix\nA = Matrix([[7.7, 1.3, 0], [0, 7.7, 1.3], [0, 0, 7.7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of matrix A = [[4.4, 0.5, 0], [0, 4.4, 0.5], [0, 0, 4.4]].",
        "output": "from sympy import Matrix\nA = Matrix([[4.4, 0.5, 0], [0, 4.4, 0.5], [0, 0, 4.4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[6.6, 0, 2], [0, 6.6, 0], [0, 0, 6.6]].",
        "output": "from sympy import Matrix\nA = Matrix([[6.6, 0, 2], [0, 6.6, 0], [0, 0, 6.6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of matrix A = [[2, 0, 2], [0, 2, 0], [0, 0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 0, 2], [0, 2, 0], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of A = [[0.9, 1, 1], [0, 0.9, 1], [0, 0, 0.9]]?",
        "output": "from sympy import Matrix\nA = Matrix([[0.9, 1, 1], [0, 0.9, 1], [0, 0, 0.9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[5, 1, 1], [0, 5, 1], [0, 0, 5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5, 1, 1], [0, 5, 1], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of A = [[7, 0, 4], [0, 7, 0], [0, 0, 7]].",
        "output": "from sympy import Matrix\nA = Matrix([[7, 0, 4], [0, 7, 0], [0, 0, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[3.3, 0, 0.5], [0, 3.3, 0], [0, 0, 3.3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3.3, 0, 0.5], [0, 3.3, 0], [0, 0, 3.3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[1.5, 1, 0], [0, 1.5, 0], [0, 0, 1.5]].",
        "output": "from sympy import Matrix\nA = Matrix([[1.5, 1, 0], [0, 1.5, 0], [0, 0, 1.5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form for matrix A = [[0.2, 0.2, 0], [0, 0.2, 0.2], [0, 0, 0.2]].",
        "output": "from sympy import Matrix\nA = Matrix([[0.2, 0.2, 0], [0, 0.2, 0.2], [0, 0, 0.2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[4.1, 0, 2.2], [0, 4.1, 0], [0, 0, 4.1]].",
        "output": "from sympy import Matrix\nA = Matrix([[4.1, 0, 2.2], [0, 4.1, 0], [0, 0, 4.1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of A = [[6, 2, 3], [0, 6, 2], [0, 0, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[6, 2, 3], [0, 6, 2], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of A = [[0, 3, 2], [0, 0, 3], [0, 0, 0]]?",
        "output": "from sympy import Matrix\nA = Matrix([[0, 3, 2], [0, 0, 3], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of matrix A = [[8.5, 0.5, 0.5], [0, 8.5, 0.5], [0, 0, 8.5]].",
        "output": "from sympy import Matrix\nA = Matrix([[8.5, 0.5, 0.5], [0, 8.5, 0.5], [0, 0, 8.5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[3, 0, 0.3], [0, 3, 0], [0, 0, 3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3, 0, 0.3], [0, 3, 0], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[10, 1, 0], [0, 10, 1], [0, 0, 10]].",
        "output": "from sympy import Matrix\nA = Matrix([[10, 1, 0], [0, 10, 1], [0, 0, 10]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[2.2, 0, 1], [0, 2.2, 0], [0, 0, 2.2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2.2, 0, 1], [0, 2.2, 0], [0, 0, 2.2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of matrix A = [[0.5, 1, 0], [0, 0.5, 1], [0, 0, 0.5]]?",
        "output": "from sympy import Matrix\nA = Matrix([[0.5, 1, 0], [0, 0.5, 1], [0, 0, 0.5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form for matrix A = [[6, 0, 1], [0, 6, 0], [0, 0, 6]].",
        "output": "from sympy import Matrix\nA = Matrix([[6, 0, 1], [0, 6, 0], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[3.3, 1.1, 0], [0, 3.3, 1.1], [0, 0, 3.3]].",
        "output": "from sympy import Matrix\nA = Matrix([[3.3, 1.1, 0], [0, 3.3, 1.1], [0, 0, 3.3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[1, 2, 0], [0, 1, 2], [0, 0, 1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 2, 0], [0, 1, 2], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form for A = [[9, 0, 0.9], [0, 9, 0], [0, 0, 9]].",
        "output": "from sympy import Matrix\nA = Matrix([[9, 0, 0.9], [0, 9, 0], [0, 0, 9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of A = [[4.4, 0.4, 0], [0, 4.4, 0.4], [0, 0, 4.4]]?",
        "output": "from sympy import Matrix\nA = Matrix([[4.4, 0.4, 0], [0, 4.4, 0.4], [0, 0, 4.4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[0, 1, 0], [0, 0, 1], [0, 0, 0]].",
        "output": "from sympy import Matrix\nA = Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[2.5, 0, 0.3], [0, 2.5, 0], [0, 0, 2.5]].",
        "output": "from sympy import Matrix\nA = Matrix([[2.5, 0, 0.3], [0, 2.5, 0], [0, 0, 2.5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form for matrix A = [[7, 0, 7], [0, 7, 0], [0, 0, 7]].",
        "output": "from sympy import Matrix\nA = Matrix([[7, 0, 7], [0, 7, 0], [0, 0, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[8.8, 0, 0.8], [0, 8.8, 0.8], [0, 0, 8.8]].",
        "output": "from sympy import Matrix\nA = Matrix([[8.8, 0, 0.8], [0, 8.8, 0.8], [0, 0, 8.8]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of matrix A = [[6.3, 0, 6.3], [0, 6.3, 0], [0, 0, 6.3]].",
        "output": "from sympy import Matrix\nA = Matrix([[6.3, 0, 6.3], [0, 6.3, 0], [0, 0, 6.3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of A = [[3, 3, 0], [0, 3, 3], [0, 0, 3]]?",
        "output": "from sympy import Matrix\nA = Matrix([[3, 3, 0], [0, 3, 3], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[1, 0.5, 0], [0, 1, 0.5], [0, 0, 1]].",
        "output": "from sympy import Matrix\nA = Matrix([[1, 0.5, 0], [0, 1, 0.5], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of A = [[5.5, 5.5, 0], [0, 5.5, 5.5], [0, 0, 5.5]].",
        "output": "from sympy import Matrix\nA = Matrix([[5.5, 5.5, 0], [0, 5.5, 5.5], [0, 0, 5.5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[2, 2, 2], [0, 2, 2], [0, 0, 2]].",
        "output": "from sympy import Matrix\nA = Matrix([[2, 2, 2], [0, 2, 2], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form for A = [[3.7, 0, 1.1], [0, 3.7, 0], [0, 0, 3.7]].",
        "output": "from sympy import Matrix\nA = Matrix([[3.7, 0, 1.1], [0, 3.7, 0], [0, 0, 3.7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of A = [[0, 0, 0.1], [0, 0, 0], [0, 0, 0]]?",
        "output": "from sympy import Matrix\nA = Matrix([[0, 0, 0.1], [0, 0, 0], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[18.96, 1, 0], [0, 18.96, 1], [0, 0, 18.96]].",
        "output": "from sympy import Matrix\nA = Matrix([[18.96, 1, 0], [0, 18.96, 1], [0, 0, 18.96]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[6.79, 1, 0], [0, 6.79, 1], [0, 0, 6.79]].",
        "output": "from sympy import Matrix\nA = Matrix([[6.79, 1, 0], [0, 6.79, 1], [0, 0, 6.79]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[5.16, 1, 0], [0, 5.16, 1], [0, 0, 5.16]].",
        "output": "from sympy import Matrix\nA = Matrix([[5.16, 1, 0], [0, 5.16, 1], [0, 0, 5.16]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[11.82, 1, 0], [0, 11.82, 1], [0, 0, 11.82]].",
        "output": "from sympy import Matrix\nA = Matrix([[11.82, 1, 0], [0, 11.82, 1], [0, 0, 11.82]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[12.6, 1, 0], [0, 12.6, 1], [0, 0, 12.6]].",
        "output": "from sympy import Matrix\nA = Matrix([[12.6, 1, 0], [0, 12.6, 1], [0, 0, 12.6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[7.59, 1, 0], [0, 7.59, 1], [0, 0, 7.59]].",
        "output": "from sympy import Matrix\nA = Matrix([[7.59, 1, 0], [0, 7.59, 1], [0, 0, 7.59]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[6.17, 1, 0], [0, 6.17, 1], [0, 0, 6.17]].",
        "output": "from sympy import Matrix\nA = Matrix([[6.17, 1, 0], [0, 6.17, 1], [0, 0, 6.17]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[8.38, 1, 0], [0, 8.38, 1], [0, 0, 8.38]].",
        "output": "from sympy import Matrix\nA = Matrix([[8.38, 1, 0], [0, 8.38, 1], [0, 0, 8.38]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[11.25, 1, 0], [0, 11.25, 1], [0, 0, 11.25]].",
        "output": "from sympy import Matrix\nA = Matrix([[11.25, 1, 0], [0, 11.25, 1], [0, 0, 11.25]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[19.75, 1, 0], [0, 19.75, 1], [0, 0, 19.75]].",
        "output": "from sympy import Matrix\nA = Matrix([[19.75, 1, 0], [0, 19.75, 1], [0, 0, 19.75]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[17.67, 1, 0], [0, 17.67, 1], [0, 0, 17.67]].",
        "output": "from sympy import Matrix\nA = Matrix([[17.67, 1, 0], [0, 17.67, 1], [0, 0, 17.67]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[5.6, 1, 0], [0, 5.6, 1], [0, 0, 5.6]].",
        "output": "from sympy import Matrix\nA = Matrix([[5.6, 1, 0], [0, 5.6, 1], [0, 0, 5.6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[11.85, 1, 0], [0, 11.85, 1], [0, 0, 11.85]].",
        "output": "from sympy import Matrix\nA = Matrix([[11.85, 1, 0], [0, 11.85, 1], [0, 0, 11.85]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[4.92, 1, 0], [0, 4.92, 1], [0, 0, 4.92]].",
        "output": "from sympy import Matrix\nA = Matrix([[4.92, 1, 0], [0, 4.92, 1], [0, 0, 4.92]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[8.21, 1, 0], [0, 8.21, 1], [0, 0, 8.21]].",
        "output": "from sympy import Matrix\nA = Matrix([[8.21, 1, 0], [0, 8.21, 1], [0, 0, 8.21]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[16.04, 1, 0], [0, 16.04, 1], [0, 0, 16.04]].",
        "output": "from sympy import Matrix\nA = Matrix([[16.04, 1, 0], [0, 16.04, 1], [0, 0, 16.04]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[5.48, 1, 0], [0, 5.48, 1], [0, 0, 5.48]].",
        "output": "from sympy import Matrix\nA = Matrix([[5.48, 1, 0], [0, 5.48, 1], [0, 0, 5.48]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[3.19, 1, 0], [0, 3.19, 1], [0, 0, 3.19]].",
        "output": "from sympy import Matrix\nA = Matrix([[3.19, 1, 0], [0, 3.19, 1], [0, 0, 3.19]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[5.51, 1, 0], [0, 5.51, 1], [0, 0, 5.51]].",
        "output": "from sympy import Matrix\nA = Matrix([[5.51, 1, 0], [0, 5.51, 1], [0, 0, 5.51]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[14.62, 1, 0], [0, 14.62, 1], [0, 0, 14.62]].",
        "output": "from sympy import Matrix\nA = Matrix([[14.62, 1, 0], [0, 14.62, 1], [0, 0, 14.62]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[5.81, 1, 0], [0, 5.81, 1], [0, 0, 5.81]].",
        "output": "from sympy import Matrix\nA = Matrix([[5.81, 1, 0], [0, 5.81, 1], [0, 0, 5.81]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[2.01, 1, 0], [0, 2.01, 1], [0, 0, 2.01]].",
        "output": "from sympy import Matrix\nA = Matrix([[2.01, 1, 0], [0, 2.01, 1], [0, 0, 2.01]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[14.38, 1, 0], [0, 14.38, 1], [0, 0, 14.38]].",
        "output": "from sympy import Matrix\nA = Matrix([[14.38, 1, 0], [0, 14.38, 1], [0, 0, 14.38]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[17.65, 1, 0], [0, 17.65, 1], [0, 0, 17.65]].",
        "output": "from sympy import Matrix\nA = Matrix([[17.65, 1, 0], [0, 17.65, 1], [0, 0, 17.65]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[18.66, 1, 0], [0, 18.66, 1], [0, 0, 18.66]].",
        "output": "from sympy import Matrix\nA = Matrix([[18.66, 1, 0], [0, 18.66, 1], [0, 0, 18.66]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[5, 1, 0], [0, 5, 1], [0, 0, 5]].",
        "output": "import sympy as sp\nA = sp.Matrix([[5, 1, 0], [0, 5, 1], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[2, 1, 0], [0, 2, 0], [0, 0, 3]].",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 1, 0], [0, 2, 0], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[1, 0, 1], [0, 1, 0], [0, 0, 1]].",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 0, 1], [0, 1, 0], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[2, 1], [0, 2]].",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 1], [0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[1, 3, 0], [0, 1, 3], [0, 0, 1]].",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 3, 0], [0, 1, 3], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[0, 1, 0], [0, 0, 1], [0, 0, 0]].",
        "output": "import sympy as sp\nA = sp.Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[5, 4], [0, 5]].",
        "output": "import sympy as sp\nA = sp.Matrix([[5, 4], [0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[-1, 1, 0], [0, -1, 1], [0, 0, -1]].",
        "output": "import sympy as sp\nA = sp.Matrix([[-1, 1, 0], [0, -1, 1], [0, 0, -1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[2, 1, 0], [0, 2, 1], [0, 0, 2]].",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 1, 0], [0, 2, 1], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[4, 1, 0], [0, 4, 0], [0, 0, 5]].",
        "output": "import sympy as sp\nA = sp.Matrix([[4, 1, 0], [0, 4, 0], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[3, 2], [0, 3]].",
        "output": "import sympy as sp\nA = sp.Matrix([[3, 2], [0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[6, 1, 0], [0, 6, 0], [0, 0, 6]].",
        "output": "import sympy as sp\nA = sp.Matrix([[6, 1, 0], [0, 6, 0], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[0, 0, 0], [0, 0, 0], [0, 0, 0]].",
        "output": "import sympy as sp\nA = sp.Matrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[2, 0], [0, 3]].",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 0], [0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[9, 1, 0], [0, 9, 1], [0, 0, 9]].",
        "output": "import sympy as sp\nA = sp.Matrix([[9, 1, 0], [0, 9, 1], [0, 0, 9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[7, 0, 0], [0, 7, 0], [0, 0, 8]].",
        "output": "import sympy as sp\nA = sp.Matrix([[7, 0, 0], [0, 7, 0], [0, 0, 8]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[2, 5], [0, 2]].",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 5], [0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[4, 1], [0, 5]].",
        "output": "import sympy as sp\nA = sp.Matrix([[4, 1], [0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[-2, 1], [0, -2]].",
        "output": "import sympy as sp\nA = sp.Matrix([[-2, 1], [0, -2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[3, 0, 0], [0, 4, 0], [0, 0, 4]].",
        "output": "import sympy as sp\nA = sp.Matrix([[3, 0, 0], [0, 4, 0], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[5, 0], [0, 5]].",
        "output": "import sympy as sp\nA = sp.Matrix([[5, 0], [0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[6, 2, 0], [0, 6, 2], [0, 0, 6]].",
        "output": "import sympy as sp\nA = sp.Matrix([[6, 2, 0], [0, 6, 2], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of A = [[2, 1], [0, 3]].",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 1], [0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[4, 0, 1], [0, 4, 0], [0, 0, 4]].",
        "output": "import sympy as sp\nA = sp.Matrix([[4, 0, 1], [0, 4, 0], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[1, 0], [0, 2]].",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 0], [0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of the matrix A = [[6, 2, 0], [0, 6, 1], [0, 0, 6]].",
        "output": "import sympy as sp\nA = sp.Matrix([[6, 2, 0], [0, 6, 1], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of the matrix A = [[1, 0, 0], [0, 1, 1], [0, 0, 1]].",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 0, 0], [0, 1, 1], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of the matrix A = [[3, 1, 0], [0, 3, 0], [0, 0, 3]].",
        "output": "import sympy as sp\nA = sp.Matrix([[3, 1, 0], [0, 3, 0], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[4, 1, 1], [0, 4, 1], [0, 0, 4]].",
        "output": "import sympy as sp\nA = sp.Matrix([[4, 1, 1], [0, 4, 1], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form of A = [[2, 0, 0], [0, 2, 0], [0, 0, 2]].",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 0, 0], [0, 2, 0], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form of A = [[0, 1, 0], [0, 0, 1], [0, 0, 0]].",
        "output": "import sympy as sp\nA = sp.Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "What is the Jordan Normal Form of A = [[7, 0, 1], [0, 7, 0], [0, 0, 7]]?",
        "output": "import sympy as sp\nA = sp.Matrix([[7, 0, 1], [0, 7, 0], [0, 0, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan form of the matrix A = [[9, 0, 0], [0, 9, 0], [0, 0, 9]].",
        "output": "import sympy as sp\nA = sp.Matrix([[9, 0, 0], [0, 9, 0], [0, 0, 9]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of A = [[5, 1, 0], [0, 5, 1], [0, 0, 5]].",
        "output": "import sympy as sp\nA = sp.Matrix([[5, 1, 0], [0, 5, 1], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan form of A = [[3, 3, 0], [0, 3, 3], [0, 0, 3]].",
        "output": "import sympy as sp\nA = sp.Matrix([[3, 3, 0], [0, 3, 3], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan form of A = [[6, 0, 2], [0, 6, 0], [0, 0, 6]].",
        "output": "import sympy as sp\nA = sp.Matrix([[6, 0, 2], [0, 6, 0], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan form of A = [[1, 1, 1], [0, 1, 1], [0, 0, 1]].",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 1, 1], [0, 1, 1], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan Normal Form for A = [[0, 0, 1], [0, 0, 0], [0, 0, 0]].",
        "output": "import sympy as sp\nA = sp.Matrix([[0, 0, 1], [0, 0, 0], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan form of A = [[2, 1, 1], [0, 2, 1], [0, 0, 2]].",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 1, 1], [0, 2, 1], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan Normal Form for A = [[10, 2, 0], [0, 10, 2], [0, 0, 10]].",
        "output": "import sympy as sp\nA = sp.Matrix([[10, 2, 0], [0, 10, 2], [0, 0, 10]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan form of matrix A = [[-1, 1, 0], [0, -1, 1], [0, 0, -1]].",
        "output": "import sympy as sp\nA = sp.Matrix([[-1, 1, 0], [0, -1, 1], [0, 0, -1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan form of A = [[0, 1, 1], [0, 0, 1], [0, 0, 0]].",
        "output": "import sympy as sp\nA = sp.Matrix([[0, 1, 1], [0, 0, 1], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form of matrix A = [[11, 0, 0], [0, 11, 0], [0, 0, 11]].",
        "output": "import sympy as sp\nA = sp.Matrix([[11, 0, 0], [0, 11, 0], [0, 0, 11]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan form of A = [[3, 2, 1], [0, 3, 2], [0, 0, 3]].",
        "output": "import sympy as sp\nA = sp.Matrix([[3, 2, 1], [0, 3, 2], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Determine the Jordan form of A = [[1, 0, 1], [0, 1, 0], [0, 0, 1]].",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 0, 1], [0, 1, 0], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan Normal Form of matrix A = [[4, 4, 4], [0, 4, 4], [0, 0, 4]].",
        "output": "import sympy as sp\nA = sp.Matrix([[4, 4, 4], [0, 4, 4], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Calculate the Jordan form of A = [[5, 5, 0], [0, 5, 5], [0, 0, 5]].",
        "output": "import sympy as sp\nA = sp.Matrix([[5, 5, 0], [0, 5, 5], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Compute the Jordan Normal Form for A = [[2, 0, 1], [0, 2, 0], [0, 0, 2]].",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 0, 1], [0, 2, 0], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the Jordan form of matrix A = [[7, 3, 0], [0, 7, 3], [0, 0, 7]].",
        "output": "import sympy as sp\nA = sp.Matrix([[7, 3, 0], [0, 7, 3], [0, 0, 7]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\", J)"
    },
    {
        "input": "Find the result of the transformation T(x, y) = [x + y, x - y] on the vector [-2, -2].",
        "output": "import numpy as np\nv = np.array([-2, -2])\nT = np.array([[1, 1], [1, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find T(3, -1) for the transformation T(x, y) = [3x - 2y, x + 4y].",
        "output": "import numpy as np\nv = np.array([3, -1])\nT = np.array([[3, -2], [1, 4]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Determine the output of the transformation T(x, y) = [-x + y, 2x - 3y] applied to vector (2, 5).",
        "output": "import numpy as np\nv = np.array([2, 5])\nT = np.array([[-1, 1], [2, -3]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(-3, 4) where T(x, y) = [x + 2y, -3x + y].",
        "output": "import numpy as np\nv = np.array([-3, 4])\nT = np.array([[1, 2], [-3, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Apply the transformation T(x, y) = [x - y, y] to the vector (0, 7).",
        "output": "import numpy as np\nv = np.array([0, 7])\nT = np.array([[1, -1], [0, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Compute T(1, 1) for T(x, y) = [4x + 2y, -2x + y].",
        "output": "import numpy as np\nv = np.array([1, 1])\nT = np.array([[4, 2], [-2, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find the transformation of (5, -3) under T(x, y) = [x, 3x + 2y].",
        "output": "import numpy as np\nv = np.array([5, -3])\nT = np.array([[1, 0], [3, 2]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(-1, -1) where T(x, y) = [x - 2y, y - x].",
        "output": "import numpy as np\nv = np.array([-1, -1])\nT = np.array([[1, -2], [-1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Compute the result of T(2, 0) for T(x, y) = [3x, y - x].",
        "output": "import numpy as np\nv = np.array([2, 0])\nT = np.array([[3, 0], [-1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find T(4, 1) for T(x, y) = [2x + y, -x + 3y].",
        "output": "import numpy as np\nv = np.array([4, 1])\nT = np.array([[2, 1], [-1, 3]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Apply T(x, y) = [x, x + y] to vector (-2, 3).",
        "output": "import numpy as np\nv = np.array([-2, 3])\nT = np.array([[1, 0], [1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(6, -2) where T(x, y) = [2x, y + x].",
        "output": "import numpy as np\nv = np.array([6, -2])\nT = np.array([[2, 0], [1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Determine T(0, 0) under T(x, y) = [x - y, 2x + y].",
        "output": "import numpy as np\nv = np.array([0, 0])\nT = np.array([[1, -1], [2, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find T(-1, 2) for T(x, y) = [-x + 3y, 4x - y].",
        "output": "import numpy as np\nv = np.array([-1, 2])\nT = np.array([[-1, 3], [4, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Compute T(2, 2) where T(x, y) = [x + y, x - y].",
        "output": "import numpy as np\nv = np.array([2, 2])\nT = np.array([[1, 1], [1, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Apply T(x, y) = [3x - y, 5y] to vector (1, 4).",
        "output": "import numpy as np\nv = np.array([1, 4])\nT = np.array([[3, -1], [0, 5]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find the output for T(-2, 1) with T(x, y) = [x + 2y, y - x].",
        "output": "import numpy as np\nv = np.array([-2, 1])\nT = np.array([[1, 2], [-1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(3, 3) for T(x, y) = [4x, -2y].",
        "output": "import numpy as np\nv = np.array([3, 3])\nT = np.array([[4, 0], [0, -2]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Determine the result of T(5, 0) for T(x, y) = [x, y, x - y].",
        "output": "import numpy as np\nv = np.array([5, 0])\nT = np.array([[1, 0], [0, 1], [1, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Apply transformation T(x, y) = [x + y, x + 2y] to (1, -1).",
        "output": "import numpy as np\nv = np.array([1, -1])\nT = np.array([[1, 1], [1, 2]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Compute T(-4, -4) for T(x, y) = [x - 3y, 2x + y].",
        "output": "import numpy as np\nv = np.array([-4, -4])\nT = np.array([[1, -3], [2, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find T(7, 2) for T(x, y) = [2x - y, x + y].",
        "output": "import numpy as np\nv = np.array([7, 2])\nT = np.array([[2, -1], [1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(3, -2) where T(x, y) = [-x + y, x + 2y].",
        "output": "import numpy as np\nv = np.array([3, -2])\nT = np.array([[-1, 1], [1, 2]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find the output of T(0, 2) for T(x, y) = [3y, x - y].",
        "output": "import numpy as np\nv = np.array([0, 2])\nT = np.array([[0, 3], [1, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(1, 0) where T(x, y) = [2x + 3y, -x + y].",
        "output": "import numpy as np\nv = np.array([1, 0])\nT = np.array([[2, 3], [-1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Determine the result of T(x, y) = [3x, 2y] when applied to vector [2, 6].",
        "output": "import numpy as np\nv = np.array([2, 6])\nT = np.array([[3, 0], [0, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute the transformation T(x, y) = [x + y, x - y] at vector [-1, 1].",
        "output": "import numpy as np\nv = np.array([-1, 1])\nT = np.array([[1, 1], [1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the result of the transformation T(x, y) = [3x + 4y, 2x - y] on the vector [1, 2].",
        "output": "import numpy as np\nv = np.array([1, 2])\nT = np.array([[3, 4], [2, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply the transformation T(x, y) = [x - 3y, 2x + y] to the vector [3, -1].",
        "output": "import numpy as np\nv = np.array([3, -1])\nT = np.array([[1, -3], [2, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(-1, 4) where T(x, y) = [4x - y, x + 5y].",
        "output": "import numpy as np\nv = np.array([-1, 4])\nT = np.array([[4, -1], [1, 5]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "What is T(2, 3) if T(x, y) = [-x + y, x + y]?",
        "output": "import numpy as np\nv = np.array([2, 3])\nT = np.array([[-1, 1], [1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the image of the vector [0, 5] under the transformation T(x, y) = [6x, -2y].",
        "output": "import numpy as np\nv = np.array([0, 5])\nT = np.array([[6, 0], [0, -2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute T(1, -3) for T(x, y) = [x + y, 4x - y].",
        "output": "import numpy as np\nv = np.array([1, -3])\nT = np.array([[1, 1], [4, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the result of the transformation T(x, y) = [2x + y, y - 3x] on the vector [-2, 2].",
        "output": "import numpy as np\nv = np.array([-2, 2])\nT = np.array([[2, 1], [-3, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply T(x, y) = [x, -x + y] to the vector [4, 5].",
        "output": "import numpy as np\nv = np.array([4, 5])\nT = np.array([[1, 0], [-1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(3, 2) where T(x, y) = [x - y, x + 2y].",
        "output": "import numpy as np\nv = np.array([3, 2])\nT = np.array([[1, -1], [1, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T(-4, 1) for the transformation T(x, y) = [3x + 2y, -x + y].",
        "output": "import numpy as np\nv = np.array([-4, 1])\nT = np.array([[3, 2], [-1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine the transformation result T(x, y) = [2x, x + y] applied to (6, -2).",
        "output": "import numpy as np\nv = np.array([6, -2])\nT = np.array([[2, 0], [1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply T(x, y) = [-2x + 3y, 5x] on vector [1, 4].",
        "output": "import numpy as np\nv = np.array([1, 4])\nT = np.array([[-2, 3], [5, 0]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate the transformation T(x, y) = [x - y, 2x + 3y] on (0, -3).",
        "output": "import numpy as np\nv = np.array([0, -3])\nT = np.array([[1, -1], [2, 3]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T(-1, -2) for T(x, y) = [3x, 4x + y].",
        "output": "import numpy as np\nv = np.array([-1, -2])\nT = np.array([[3, 0], [4, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate the transformation T(x, y) = [x + 3y, 5x - y] on vector (2, 2).",
        "output": "import numpy as np\nv = np.array([2, 2])\nT = np.array([[1, 3], [5, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute T(2, 1) where T(x, y) = [3x + y, x - y].",
        "output": "import numpy as np\nv = np.array([2, 1])\nT = np.array([[3, 1], [1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the image of [5, 0] under T(x, y) = [-x + y, 4x].",
        "output": "import numpy as np\nv = np.array([5, 0])\nT = np.array([[-1, 1], [4, 0]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(1, 3) for T(x, y) = [2x, y - x].",
        "output": "import numpy as np\nv = np.array([1, 3])\nT = np.array([[2, 0], [-1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply the transformation T(x, y) = [x, x + 2y] on the vector (4, -1).",
        "output": "import numpy as np\nv = np.array([4, -1])\nT = np.array([[1, 0], [1, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute T(3, 0) where T(x, y) = [5x, x - 4y].",
        "output": "import numpy as np\nv = np.array([3, 0])\nT = np.array([[5, 0], [1, -4]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "What is T(-3, 1) if T(x, y) = [x + 2y, -x - y]?",
        "output": "import numpy as np\nv = np.array([-3, 1])\nT = np.array([[1, 2], [-1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(0, 2) where T(x, y) = [3y, x - y].",
        "output": "import numpy as np\nv = np.array([0, 2])\nT = np.array([[0, 3], [1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply T(x, y) = [2x + 3y, x - 2y] to the vector (1, 1).",
        "output": "import numpy as np\nv = np.array([1, 1])\nT = np.array([[2, 3], [1, -2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T(-2, 2) where T(x, y) = [x + y, 4x - y].",
        "output": "import numpy as np\nv = np.array([-2, 2])\nT = np.array([[1, 1], [4, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the image of the vector [2, -3] under the transformation T(x, y) = [x + 2y, 3x - y].",
        "output": "import numpy as np\nv = np.array([2, -3])\nT = np.array([[1, 2], [3, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(-1, 4) for the transformation T(x, y) = [2x - y, x + 3y].",
        "output": "import numpy as np\nv = np.array([-1, 4])\nT = np.array([[2, -1], [1, 3]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine T(3, 3) if T(x, y) = [-x + y, 2x + y].",
        "output": "import numpy as np\nv = np.array([3, 3])\nT = np.array([[-1, 1], [2, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply T(x, y) = [4x - 2y, x + y] to the vector [0, 5].",
        "output": "import numpy as np\nv = np.array([0, 5])\nT = np.array([[4, -2], [1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T(1, 2) where T(x, y) = [x, x + 2y].",
        "output": "import numpy as np\nv = np.array([1, 2])\nT = np.array([[1, 0], [1, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(6, -1) where T(x, y) = [3x, x - y].",
        "output": "import numpy as np\nv = np.array([6, -1])\nT = np.array([[3, 0], [1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute the transformation T(5, 0) where T(x, y) = [-2x + y, 4x].",
        "output": "import numpy as np\nv = np.array([5, 0])\nT = np.array([[-2, 1], [4, 0]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(-3, -2) where T(x, y) = [x - y, 2x + 3y].",
        "output": "import numpy as np\nv = np.array([-3, -2])\nT = np.array([[1, -1], [2, 3]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply the transformation T(x, y) = [x + y, 5x - y] to the vector [4, -2].",
        "output": "import numpy as np\nv = np.array([4, -2])\nT = np.array([[1, 1], [5, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the image of vector [7, 3] under T(x, y) = [2x + 2y, -x + y].",
        "output": "import numpy as np\nv = np.array([7, 3])\nT = np.array([[2, 2], [-1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(0, 0) for T(x, y) = [x - y, x + y].",
        "output": "import numpy as np\nv = np.array([0, 0])\nT = np.array([[1, -1], [1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Calculate T(-1, -1) where T(x, y) = [x + 3y, 2x - 2y].",
        "output": "import numpy as np\nv = np.array([-1, -1])\nT = np.array([[1, 3], [2, -2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the result of T(x, y) = [3x - y, -x + 2y] on [1, -3].",
        "output": "import numpy as np\nv = np.array([1, -3])\nT = np.array([[3, -1], [-1, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(2, 2) for T(x, y) = [-x + y, x + y].",
        "output": "import numpy as np\nv = np.array([2, 2])\nT = np.array([[-1, 1], [1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply T(x, y) = [x - 2y, 4x + y] to the vector [3, 2].",
        "output": "import numpy as np\nv = np.array([3, 2])\nT = np.array([[1, -2], [4, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute T(5, -3) where T(x, y) = [x + y, 3x + y].",
        "output": "import numpy as np\nv = np.array([5, -3])\nT = np.array([[1, 1], [3, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(-4, 2) for T(x, y) = [x - y, x - 3y].",
        "output": "import numpy as np\nv = np.array([-4, 2])\nT = np.array([[1, -1], [1, -3]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T(3, 1) if T(x, y) = [5x + y, -x + 4y].",
        "output": "import numpy as np\nv = np.array([3, 1])\nT = np.array([[5, 1], [-1, 4]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine T(6, -2) where T(x, y) = [x - y, 2x + 2y].",
        "output": "import numpy as np\nv = np.array([6, -2])\nT = np.array([[1, -1], [2, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply T(x, y) = [x + 4y, -2x + y] to the vector [-1, 1].",
        "output": "import numpy as np\nv = np.array([-1, 1])\nT = np.array([[1, 4], [-2, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(-5, 5) for T(x, y) = [3x + y, -x - y].",
        "output": "import numpy as np\nv = np.array([-5, 5])\nT = np.array([[3, 1], [-1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the transformation T(8, 1) where T(x, y) = [x - y, 2x - y].",
        "output": "import numpy as np\nv = np.array([8, 1])\nT = np.array([[1, -1], [2, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute T(1, -2) under T(x, y) = [-x + 2y, 4x + y].",
        "output": "import numpy as np\nv = np.array([1, -2])\nT = np.array([[-1, 2], [4, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(-2, 3) where T(x, y) = [2x, 3y].",
        "output": "import numpy as np\nv = np.array([-2, 3])\nT = np.array([[2, 0], [0, 3]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T(0, 6) where T(x, y) = [x + y, 5x - y].",
        "output": "import numpy as np\nv = np.array([0, 6])\nT = np.array([[1, 1], [5, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the result of applying T(x, y) = [2x + 3y, -x + 4y] to the vector [1, 2].",
        "output": "import numpy as np\nv = np.array([1, 2])\nT = np.array([[2, 3], [-1, 4]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate the transformation T(x, y) = [x - 2y, y + 3x] on [4, -1].",
        "output": "import numpy as np\nv = np.array([4, -1])\nT = np.array([[1, -2], [3, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute the transformation T(x, y) = [5x, x - 2y] for the vector [2, 1].",
        "output": "import numpy as np\nv = np.array([2, 1])\nT = np.array([[5, 0], [1, -2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine T(-3, 5) for T(x, y) = [-x + y, x + y].",
        "output": "import numpy as np\nv = np.array([-3, 5])\nT = np.array([[-1, 1], [1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the image of [1, 0] under T(x, y) = [3x - y, x + y].",
        "output": "import numpy as np\nv = np.array([1, 0])\nT = np.array([[3, -1], [1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply T(x, y) = [x, -x + 2y] to the vector [2, 2].",
        "output": "import numpy as np\nv = np.array([2, 2])\nT = np.array([[1, 0], [-1, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate the result of T(3, -2) where T(x, y) = [x + y, y - x].",
        "output": "import numpy as np\nv = np.array([3, -2])\nT = np.array([[1, 1], [-1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T(0, -5) under the transformation T(x, y) = [x - y, 3x + y].",
        "output": "import numpy as np\nv = np.array([0, -5])\nT = np.array([[1, -1], [3, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(1, 1) where T(x, y) = [2x + y, x - y].",
        "output": "import numpy as np\nv = np.array([1, 1])\nT = np.array([[2, 1], [1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute T(2, -3) for T(x, y) = [4x - y, 2x + y].",
        "output": "import numpy as np\nv = np.array([2, -3])\nT = np.array([[4, -1], [2, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the image of [3, 3] under T(x, y) = [x - y, 2x + y].",
        "output": "import numpy as np\nv = np.array([3, 3])\nT = np.array([[1, -1], [2, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply T(x, y) = [x + 2y, -3x + y] to the vector [-2, 1].",
        "output": "import numpy as np\nv = np.array([-2, 1])\nT = np.array([[1, 2], [-3, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(-1, 3) for T(x, y) = [2x + 4y, -x - y].",
        "output": "import numpy as np\nv = np.array([-1, 3])\nT = np.array([[2, 4], [-1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T(1, -2) under the transformation T(x, y) = [x + y, -2x + y].",
        "output": "import numpy as np\nv = np.array([1, -2])\nT = np.array([[1, 1], [-2, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(4, 1) where T(x, y) = [2x - 3y, x + 2y].",
        "output": "import numpy as np\nv = np.array([4, 1])\nT = np.array([[2, -3], [1, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply T(x, y) = [x + 3y, 2x - y] to the vector [3, 0].",
        "output": "import numpy as np\nv = np.array([3, 0])\nT = np.array([[1, 3], [2, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine the transformation T(-4, -2) where T(x, y) = [3x + y, -x + 2y].",
        "output": "import numpy as np\nv = np.array([-4, -2])\nT = np.array([[3, 1], [-1, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T(0, 3) for T(x, y) = [x + 2y, 4x - y].",
        "output": "import numpy as np\nv = np.array([0, 3])\nT = np.array([[1, 2], [4, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(5, -5) where T(x, y) = [-2x + y, x + 3y].",
        "output": "import numpy as np\nv = np.array([5, -5])\nT = np.array([[-2, 1], [1, 3]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute the transformation T(x, y) = [x - 4y, x + y] on vector [6, 2].",
        "output": "import numpy as np\nv = np.array([6, 2])\nT = np.array([[1, -4], [1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(1, -1) under T(x, y) = [x + 2y, 5x - y].",
        "output": "import numpy as np\nv = np.array([1, -1])\nT = np.array([[1, 2], [5, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine the output of T(x, y) = [3x + 2y, -x - 2y] for vector [-3, 1].",
        "output": "import numpy as np\nv = np.array([-3, 1])\nT = np.array([[3, 2], [-1, -2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply the transformation T(x, y) = [2x - y, x - y] to vector [1, 3].",
        "output": "import numpy as np\nv = np.array([1, 3])\nT = np.array([[2, -1], [1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(7, 2) where T(x, y) = [x + 3y, 2x - y].",
        "output": "import numpy as np\nv = np.array([7, 2])\nT = np.array([[1, 3], [2, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute the transformation T(x, y) = [4x + y, -2x + 3y] for [1, 2].",
        "output": "import numpy as np\nv = np.array([1, 2])\nT = np.array([[4, 1], [-2, 3]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(4, 3) where T(x, y) = [2x + y, -x + 4y].",
        "output": "import numpy as np\nv = np.array([4, 3])\nT = np.array([[2, 1], [-1, 4]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find T(-2, 1) for the transformation T(x, y) = [x - 2y, 3x + y].",
        "output": "import numpy as np\nv = np.array([-2, 1])\nT = np.array([[1, -2], [3, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Compute the result of applying T(x, y) = [x + y, -x + y] to (0, 2).",
        "output": "import numpy as np\nv = np.array([0, 2])\nT = np.array([[1, 1], [-1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "What is T(5, -1) under T(x, y) = [3x + y, 2x - y]?",
        "output": "import numpy as np\nv = np.array([5, -1])\nT = np.array([[3, 1], [2, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate the transformation T(x, y) = [-2x + 3y, x + y] on the vector (2, -2).",
        "output": "import numpy as np\nv = np.array([2, -2])\nT = np.array([[-2, 3], [1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Determine T(3, 0) where T(x, y) = [4x - y, -x + 2y].",
        "output": "import numpy as np\nv = np.array([3, 0])\nT = np.array([[4, -1], [-1, 2]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Apply the transformation T(x, y) = [x + 5y, 2x - 3y] to (1, 2).",
        "output": "import numpy as np\nv = np.array([1, 2])\nT = np.array([[1, 5], [2, -3]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find T(0, -3) for T(x, y) = [2x - y, 3x + 4y].",
        "output": "import numpy as np\nv = np.array([0, -3])\nT = np.array([[2, -1], [3, 4]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(-2, -2) under T(x, y) = [x + 2y, -3x - y].",
        "output": "import numpy as np\nv = np.array([-2, -2])\nT = np.array([[1, 2], [-3, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Compute the image of (2, 1) under T(x, y) = [x, 2x + 3y].",
        "output": "import numpy as np\nv = np.array([2, 1])\nT = np.array([[1, 0], [2, 3]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "What is the result of applying T(x, y) = [5x - y, -2x + 3y] to (1, -1)?",
        "output": "import numpy as np\nv = np.array([1, -1])\nT = np.array([[5, -1], [-2, 3]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(2, 2) if T(x, y) = [x + y, 4x - 3y].",
        "output": "import numpy as np\nv = np.array([2, 2])\nT = np.array([[1, 1], [4, -3]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find T(-1, 1) for transformation T(x, y) = [-x + 3y, 2x + y].",
        "output": "import numpy as np\nv = np.array([-1, 1])\nT = np.array([[-1, 3], [2, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Apply T(x, y) = [2x + y, x - 4y] on vector (3, -1).",
        "output": "import numpy as np\nv = np.array([3, -1])\nT = np.array([[2, 1], [1, -4]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Compute the image of (1, 3) under T(x, y) = [3x, 2y].",
        "output": "import numpy as np\nv = np.array([1, 3])\nT = np.array([[3, 0], [0, 2]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Determine T(0, 1) where T(x, y) = [x + 2y, 5x - y].",
        "output": "import numpy as np\nv = np.array([0, 1])\nT = np.array([[1, 2], [5, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(-2, 4) under transformation T(x, y) = [4x - y, 2x + y].",
        "output": "import numpy as np\nv = np.array([-2, 4])\nT = np.array([[4, -1], [2, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "What is T(2, -3) if T(x, y) = [-x + y, 3x + 2y]?",
        "output": "import numpy as np\nv = np.array([2, -3])\nT = np.array([[-1, 1], [3, 2]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Compute the transformation T(4, 1) where T(x, y) = [2x + 3y, -x + y].",
        "output": "import numpy as np\nv = np.array([4, 1])\nT = np.array([[2, 3], [-1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find T(1, -2) under T(x, y) = [x - 2y, -2x + 5y].",
        "output": "import numpy as np\nv = np.array([1, -2])\nT = np.array([[1, -2], [-2, 5]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(3, 2) for T(x, y) = [x + y, x - y].",
        "output": "import numpy as np\nv = np.array([3, 2])\nT = np.array([[1, 1], [1, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "What is the result of T(5, 0) under T(x, y) = [2x - 3y, -4x + y]?",
        "output": "import numpy as np\nv = np.array([5, 0])\nT = np.array([[2, -3], [-4, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Apply T(x, y) = [x + 3y, 3x - y] to the vector (-1, 2).",
        "output": "import numpy as np\nv = np.array([-1, 2])\nT = np.array([[1, 3], [3, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find T(0, 0) for T(x, y) = [5x + y, x - y].",
        "output": "import numpy as np\nv = np.array([0, 0])\nT = np.array([[5, 1], [1, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(1, 4) if T(x, y) = [-x + 2y, x + y].",
        "output": "import numpy as np\nv = np.array([1, 4])\nT = np.array([[-1, 2], [1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Apply the transformation T(x, y) = [3x, 2y] on the vector [5, 2].",
        "output": "import numpy as np\nv = np.array([5, 2])\nT = np.array([[3, 0], [0, 2]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(3, -1) where T(x, y) = [x - 2y, y + x].",
        "output": "import numpy as np\nv = np.array([3, -1])\nT = np.array([[1, -2], [1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find T(1, 4) for T(x, y) = [2x + y, x - y].",
        "output": "import numpy as np\nv = np.array([1, 4])\nT = np.array([[2, 1], [1, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Determine the image of [0, 5] under T(x, y) = [x + y, 4x - y].",
        "output": "import numpy as np\nv = np.array([0, 5])\nT = np.array([[1, 1], [4, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Transform the vector [3, 3] using T(x, y) = [x - y, 2x + y].",
        "output": "import numpy as np\nv = np.array([3, 3])\nT = np.array([[1, -1], [2, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(-2, 4) for T(x, y) = [x + 2y, 3x - y].",
        "output": "import numpy as np\nv = np.array([-2, 4])\nT = np.array([[1, 2], [3, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Apply T(x, y) = [5x - 3y, x + y] on the vector [1, 2].",
        "output": "import numpy as np\nv = np.array([1, 2])\nT = np.array([[5, -3], [1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find the result of T(6, 0) where T(x, y) = [x, y - x].",
        "output": "import numpy as np\nv = np.array([6, 0])\nT = np.array([[1, 0], [-1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Determine T(-1, -2) for T(x, y) = [x + 2y, 2x + 3y].",
        "output": "import numpy as np\nv = np.array([-1, -2])\nT = np.array([[1, 2], [2, 3]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Transform [2, 1] using T(x, y) = [2x - y, x + 3y].",
        "output": "import numpy as np\nv = np.array([2, 1])\nT = np.array([[2, -1], [1, 3]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate the transformation T(x, y) = [4x, x - y] on [3, 5].",
        "output": "import numpy as np\nv = np.array([3, 5])\nT = np.array([[4, 0], [1, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find the image of [4, -1] under T(x, y) = [x + 3y, 2x - y].",
        "output": "import numpy as np\nv = np.array([4, -1])\nT = np.array([[1, 3], [2, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Apply the transformation T(x, y) = [x - y, 2y] on the vector [1, 0].",
        "output": "import numpy as np\nv = np.array([1, 0])\nT = np.array([[1, -1], [0, 2]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(2, 2) where T(x, y) = [x + y, y - x].",
        "output": "import numpy as np\nv = np.array([2, 2])\nT = np.array([[1, 1], [-1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find T(0, 3) for T(x, y) = [2y, x - y].",
        "output": "import numpy as np\nv = np.array([0, 3])\nT = np.array([[0, 2], [1, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Compute T(5, 1) for T(x, y) = [x + 4y, 2x].",
        "output": "import numpy as np\nv = np.array([5, 1])\nT = np.array([[1, 4], [2, 0]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Transform [1, -1] using T(x, y) = [x + y, 3x - y].",
        "output": "import numpy as np\nv = np.array([1, -1])\nT = np.array([[1, 1], [3, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(2, 0) for T(x, y) = [x, x + y].",
        "output": "import numpy as np\nv = np.array([2, 0])\nT = np.array([[1, 0], [1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Apply T(x, y) = [3x + 2y, y - x] to [2, 2].",
        "output": "import numpy as np\nv = np.array([2, 2])\nT = np.array([[3, 2], [-1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Transform [6, -3] using T(x, y) = [x + y, 2x - 3y].",
        "output": "import numpy as np\nv = np.array([6, -3])\nT = np.array([[1, 1], [2, -3]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find the output of T(x, y) = [2x + y, x - 2y] on the vector [1, 1].",
        "output": "import numpy as np\nv = np.array([1, 1])\nT = np.array([[2, 1], [1, -2]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(4, 5) for T(x, y) = [x + 2y, 4x - y].",
        "output": "import numpy as np\nv = np.array([4, 5])\nT = np.array([[1, 2], [4, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Compute T(1, 2) for T(x, y) = [3x, x + 2y].",
        "output": "import numpy as np\nv = np.array([1, 2])\nT = np.array([[3, 0], [1, 2]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find T(0, -2) where T(x, y) = [x + y, 2y].",
        "output": "import numpy as np\nv = np.array([0, -2])\nT = np.array([[1, 1], [0, 2]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Determine T(3, 3) for T(x, y) = [x - y, y].",
        "output": "import numpy as np\nv = np.array([3, 3])\nT = np.array([[1, -1], [0, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Apply the transformation T(x, y) = [2x - y, 3x + 4y] to the vector [3, -1].",
        "output": "import numpy as np\nv = np.array([3, -1])\nT = np.array([[2, -1], [3, 4]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find T(-2, 4) where T(x, y) = [x + 3y, 2x - y].",
        "output": "import numpy as np\nv = np.array([-2, 4])\nT = np.array([[1, 3], [2, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate the transformation T(x, y) = [-x + 2y, 5x - y] at (1, 2).",
        "output": "import numpy as np\nv = np.array([1, 2])\nT = np.array([[-1, 2], [5, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Compute the result of T(4, 0) where T(x, y) = [4x + y, -2x + 3y].",
        "output": "import numpy as np\nv = np.array([4, 0])\nT = np.array([[4, 1], [-2, 3]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Apply the transformation T(x, y) = [x - y, x + 2y] on the vector [1, 5].",
        "output": "import numpy as np\nv = np.array([1, 5])\nT = np.array([[1, -1], [1, 2]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(0, 6) where T(x, y) = [3x + 2y, y - x].",
        "output": "import numpy as np\nv = np.array([0, 6])\nT = np.array([[3, 2], [-1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Find the result of T(-3, -2) for T(x, y) = [x + 4y, 2x - 3y].",
        "output": "import numpy as np\nv = np.array([-3, -2])\nT = np.array([[1, 4], [2, -3]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate T(x, y) = [5x - y, x + y] for the vector (2, 3).",
        "output": "import numpy as np\nv = np.array([2, 3])\nT = np.array([[5, -1], [1, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Apply T(x, y) = [2x + y, -x + 2y] to the vector [-1, 2].",
        "output": "import numpy as np\nv = np.array([-1, 2])\nT = np.array([[2, 1], [-1, 2]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Evaluate the transformation T(x, y) = [-x - y, 4x + y] at (1, -2).",
        "output": "import numpy as np\nv = np.array([1, -2])\nT = np.array([[-1, -1], [4, 1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Compute T(3, 3) for the transformation T(x, y) = [x + y, 2x - y].",
        "output": "import numpy as np\nv = np.array([3, 3])\nT = np.array([[1, 1], [2, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Apply T(x, y) = [x, x - y] to the vector [-4, 1].",
        "output": "import numpy as np\nv = np.array([-4, 1])\nT = np.array([[1, 0], [1, -1]])\nresult = T @ v\nprint(\"Transformed vector:\", result)"
    },
    {
        "input": "Apply the linear transformation T(x, y) = [3x - y, 2x + 4y] to the vector [2, -1].",
        "output": "import numpy as np\nv = np.array([2, -1])\nT = np.array([[3, -1], [2, 4]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T(5, 0) where T(x, y) = [x + 2y, 3x - y].",
        "output": "import numpy as np\nv = np.array([5, 0])\nT = np.array([[1, 2], [3, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute the image of vector [-3, 2] under the transformation T(x, y) = [4x + y, x - 2y].",
        "output": "import numpy as np\nv = np.array([-3, 2])\nT = np.array([[4, 1], [1, -2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(-1, 4) for T(x, y) = [2x, y].",
        "output": "import numpy as np\nv = np.array([-1, 4])\nT = np.array([[2, 0], [0, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the result of the transformation T(x, y) = [-x + 2y, 3x + y] on the vector [1, 3].",
        "output": "import numpy as np\nv = np.array([1, 3])\nT = np.array([[-1, 2], [3, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply T(x, y) = [x - y, 2x + 3y] to the vector [0, -2].",
        "output": "import numpy as np\nv = np.array([0, -2])\nT = np.array([[1, -1], [2, 3]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate the transformation T(x, y) = [4x + y, x - y] at (6, 2).",
        "output": "import numpy as np\nv = np.array([6, 2])\nT = np.array([[4, 1], [1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute T(-2, 1) where T(x, y) = [-x + 4y, 3x - y].",
        "output": "import numpy as np\nv = np.array([-2, 1])\nT = np.array([[-1, 4], [3, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "What is T(3, -3) for T(x, y) = [5x + y, -x + 2y]?",
        "output": "import numpy as np\nv = np.array([3, -3])\nT = np.array([[5, 1], [-1, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply T(x, y) = [2x, 3y] to the vector [-1, 4].",
        "output": "import numpy as np\nv = np.array([-1, 4])\nT = np.array([[2, 0], [0, 3]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the image of [0, 7] under T(x, y) = [x - y, 2x + y].",
        "output": "import numpy as np\nv = np.array([0, 7])\nT = np.array([[1, -1], [2, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(1, 2) where T(x, y) = [3x + 4y, 2x - y].",
        "output": "import numpy as np\nv = np.array([1, 2])\nT = np.array([[3, 4], [2, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T(-5, -5) where T(x, y) = [x + y, 3x + 2y].",
        "output": "import numpy as np\nv = np.array([-5, -5])\nT = np.array([[1, 1], [3, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute T(2, 3) where T(x, y) = [-2x + y, x + 5y].",
        "output": "import numpy as np\nv = np.array([2, 3])\nT = np.array([[-2, 1], [1, 5]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate the transformation T(x, y) = [x, x + y] on the vector [4, 6].",
        "output": "import numpy as np\nv = np.array([4, 6])\nT = np.array([[1, 0], [1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T(-1, 0) where T(x, y) = [x - 2y, 4x + y].",
        "output": "import numpy as np\nv = np.array([-1, 0])\nT = np.array([[1, -2], [4, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute the image of vector [2, 1] under T(x, y) = [3x - y, 2x + 2y].",
        "output": "import numpy as np\nv = np.array([2, 1])\nT = np.array([[3, -1], [2, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply T(x, y) = [x + 3y, y - 2x] to the vector [1, -2].",
        "output": "import numpy as np\nv = np.array([1, -2])\nT = np.array([[1, 3], [-2, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the result of T(-3, 1) where T(x, y) = [2x + 3y, x - y].",
        "output": "import numpy as np\nv = np.array([-3, 1])\nT = np.array([[2, 3], [1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(4, -2) for T(x, y) = [x + y, x - 3y].",
        "output": "import numpy as np\nv = np.array([4, -2])\nT = np.array([[1, 1], [1, -3]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply the transformation T(x, y) = [-x, y] to (6, -1).",
        "output": "import numpy as np\nv = np.array([6, -1])\nT = np.array([[-1, 0], [0, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the image of [2, 5] under T(x, y) = [3x, -2y].",
        "output": "import numpy as np\nv = np.array([2, 5])\nT = np.array([[3, 0], [0, -2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute T(-4, 2) where T(x, y) = [x + y, 3x].",
        "output": "import numpy as np\nv = np.array([-4, 2])\nT = np.array([[1, 1], [3, 0]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(1, -5) where T(x, y) = [4x - y, 2y].",
        "output": "import numpy as np\nv = np.array([1, -5])\nT = np.array([[4, -1], [0, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply the transformation T(x, y) = [y, x] to the vector [-7, 8].",
        "output": "import numpy as np\nv = np.array([-7, 8])\nT = np.array([[0, 1], [1, 0]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the matrix representation of the transformation T(x, y) = (2x + y, 3x - y) and apply it to the vector [1, 4].",
        "output": "import numpy as np\nT = np.array([[2, 1], [3, -1]])\nv = np.array([1, 4])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine the matrix representation of T(x, y) = (x - 2y, 4y) and transform the vector [-2, 3].",
        "output": "import numpy as np\nT = np.array([[1, -2], [0, 4]])\nv = np.array([-2, 3])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply the linear transformation T(x, y) = (5x + y, -x + 2y) to the vector [0, 7].",
        "output": "import numpy as np\nT = np.array([[5, 1], [-1, 2]])\nv = np.array([0, 7])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "What is the image of vector [3, 2] under the transformation T(x, y) = (x, x + y)?",
        "output": "import numpy as np\nT = np.array([[1, 0], [1, 1]])\nv = np.array([3, 2])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the transformed vector of [4, -1] using T(x, y) = (2x - 3y, y).",
        "output": "import numpy as np\nT = np.array([[2, -3], [0, 1]])\nv = np.array([4, -1])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Let T(x, y) = (x + 2y, -2x + y). Compute T([5, 2]).",
        "output": "import numpy as np\nT = np.array([[1, 2], [-2, 1]])\nv = np.array([5, 2])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T([1, -3]) for T(x, y) = (3x, 4y - x).",
        "output": "import numpy as np\nT = np.array([[3, 0], [-1, 4]])\nv = np.array([1, -3])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Use the matrix for T(x, y) = (0, x + 2y) to find T([-5, 1]).",
        "output": "import numpy as np\nT = np.array([[0, 0], [1, 2]])\nv = np.array([-5, 1])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the image of [6, 6] under T(x, y) = (x + y, x - y).",
        "output": "import numpy as np\nT = np.array([[1, 1], [1, -1]])\nv = np.array([6, 6])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(2, -2) where T(x, y) = (x, -x + y).",
        "output": "import numpy as np\nT = np.array([[1, 0], [-1, 1]])\nv = np.array([2, -2])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Let T(x, y) = (-2x + y, 3x). Find T([1, 0]).",
        "output": "import numpy as np\nT = np.array([[-2, 1], [3, 0]])\nv = np.array([1, 0])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "What is the output of the transformation T(x, y) = (3x - y, y) on the vector [7, 3]?",
        "output": "import numpy as np\nT = np.array([[3, -1], [0, 1]])\nv = np.array([7, 3])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute the matrix representation of T(x, y) = (x + 3y, 2y) and apply it to [2, 5].",
        "output": "import numpy as np\nT = np.array([[1, 3], [0, 2]])\nv = np.array([2, 5])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate the transformation T(x, y) = (2x, 3x - 4y) on [3, 2].",
        "output": "import numpy as np\nT = np.array([[2, 0], [3, -4]])\nv = np.array([3, 2])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply T(x, y) = (x - y, x + y) to the vector [-1, 4].",
        "output": "import numpy as np\nT = np.array([[1, -1], [1, 1]])\nv = np.array([-1, 4])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T([-2, 2]) where T(x, y) = (x, x + y).",
        "output": "import numpy as np\nT = np.array([[1, 0], [1, 1]])\nv = np.array([-2, 2])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Transform the vector [1, 6] using T(x, y) = (-x, x - y).",
        "output": "import numpy as np\nT = np.array([[-1, 0], [1, -1]])\nv = np.array([1, 6])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine T([4, 2]) for the transformation T(x, y) = (x + 4y, y - x).",
        "output": "import numpy as np\nT = np.array([[1, 4], [-1, 1]])\nv = np.array([4, 2])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute T([1, 1]) for T(x, y) = (2x + y, x - y).",
        "output": "import numpy as np\nT = np.array([[2, 1], [1, -1]])\nv = np.array([1, 1])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply T(x, y) = (4x, x + y) to the vector [0, 3].",
        "output": "import numpy as np\nT = np.array([[4, 0], [1, 1]])\nv = np.array([0, 3])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the image of vector [-3, 5] under the transformation T(x, y) = (x, y - x).",
        "output": "import numpy as np\nT = np.array([[1, 0], [-1, 1]])\nv = np.array([-3, 5])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T([-2, -1]) for T(x, y) = (3x + y, 2y).",
        "output": "import numpy as np\nT = np.array([[3, 1], [0, 2]])\nv = np.array([-2, -1])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Transform the vector [2, -4] using the matrix for T(x, y) = (-x + y, x).",
        "output": "import numpy as np\nT = np.array([[-1, 1], [1, 0]])\nv = np.array([2, -4])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "What is the result of T(1, 3) where T(x, y) = (x - y, 2x + y)?",
        "output": "import numpy as np\nT = np.array([[1, -1], [2, 1]])\nv = np.array([1, 3])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the matrix representation of the transformation T(x, y) = [2x + 3y, x - 4y] and apply it to the vector [3, -1].",
        "output": "import numpy as np\nv = np.array([3, -1])\nT = np.array([[2, 3], [1, -4]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Let T(x, y) = [x + 2y, 5x - y]. Represent T as a matrix and apply it to [1, 2].",
        "output": "import numpy as np\nv = np.array([1, 2])\nT = np.array([[1, 2], [5, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Represent T(x, y, z) = [x + y, y + z, z + x] as a matrix and apply to [1, 0, -1].",
        "output": "import numpy as np\nv = np.array([1, 0, -1])\nT = np.array([[1, 1, 0], [0, 1, 1], [1, 0, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Define the matrix for T(x, y) = [3x, -2y] and find T([4, 3]).",
        "output": "import numpy as np\nv = np.array([4, 3])\nT = np.array([[3, 0], [0, -2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the matrix that represents T(x, y, z) = [2x - y, y - z, z - x] and compute T([2, 1, 3]).",
        "output": "import numpy as np\nv = np.array([2, 1, 3])\nT = np.array([[2, -1, 0], [0, 1, -1], [-1, 0, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine the matrix for T(x, y) = [-x, y] and apply it to [-5, 6].",
        "output": "import numpy as np\nv = np.array([-5, 6])\nT = np.array([[-1, 0], [0, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Represent T(x, y) = [4x + y, -3y] as a matrix and evaluate it on the vector [0, 1].",
        "output": "import numpy as np\nv = np.array([0, 1])\nT = np.array([[4, 1], [0, -3]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Given T(x, y) = [x - y, x + y], represent T as a matrix and evaluate T([7, -3]).",
        "output": "import numpy as np\nv = np.array([7, -3])\nT = np.array([[1, -1], [1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the transformation matrix for T(x, y, z) = [x + 2y + z, 2x - y + 3z, x + y - z] and apply it to [1, 1, 1].",
        "output": "import numpy as np\nv = np.array([1, 1, 1])\nT = np.array([[1, 2, 1], [2, -1, 3], [1, 1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine the matrix representation of T(x, y) = [x, -x + y] and apply it to [2, 5].",
        "output": "import numpy as np\nv = np.array([2, 5])\nT = np.array([[1, 0], [-1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Let T(x, y, z) = [x, y, x + z]. Represent T as a matrix and compute T([3, 2, 4]).",
        "output": "import numpy as np\nv = np.array([3, 2, 4])\nT = np.array([[1, 0, 0], [0, 1, 0], [1, 0, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the matrix representation of T(x, y) = [2x, 3y] and apply it to [-3, 4].",
        "output": "import numpy as np\nv = np.array([-3, 4])\nT = np.array([[2, 0], [0, 3]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Matrix represent T(x, y, z) = [2x - z, y + 2z, x + y + z] and evaluate on [1, 2, 3].",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nT = np.array([[2, 0, -1], [0, 1, 2], [1, 1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Given T(x, y) = [y, x], write its matrix form and apply it to [9, 6].",
        "output": "import numpy as np\nv = np.array([9, 6])\nT = np.array([[0, 1], [1, 0]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Express T(x, y) = [-2x, 3x + y] as a matrix and apply it to [1, 3].",
        "output": "import numpy as np\nv = np.array([1, 3])\nT = np.array([[-2, 0], [3, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Matrix for T(x, y, z) = [x + y, y + z, x + z], apply to [1, 0, -1].",
        "output": "import numpy as np\nv = np.array([1, 0, -1])\nT = np.array([[1, 1, 0], [0, 1, 1], [1, 0, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine the transformation matrix for T(x, y) = [x - 2y, 3x + 4y] and apply it to [2, -2].",
        "output": "import numpy as np\nv = np.array([2, -2])\nT = np.array([[1, -2], [3, 4]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Represent T(x, y) = [x + y, x + 2y] as a matrix and compute T([0, 3]).",
        "output": "import numpy as np\nv = np.array([0, 3])\nT = np.array([[1, 1], [1, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Write matrix for T(x, y) = [2x + y, y] and evaluate T([4, 2]).",
        "output": "import numpy as np\nv = np.array([4, 2])\nT = np.array([[2, 1], [0, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Let T(x, y, z) = [x, y, 2z], express as matrix and apply to [3, 0, 1].",
        "output": "import numpy as np\nv = np.array([3, 0, 1])\nT = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Create a matrix for T(x, y) = [4x, x + y] and apply T([1, 2]).",
        "output": "import numpy as np\nv = np.array([1, 2])\nT = np.array([[4, 0], [1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Represent T(x, y, z) = [y, z, x] as a matrix and apply to [-1, 0, 2].",
        "output": "import numpy as np\nv = np.array([-1, 0, 2])\nT = np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Write T(x, y) = [-y, x] in matrix form and compute T([1, 1]).",
        "output": "import numpy as np\nv = np.array([1, 1])\nT = np.array([[0, -1], [1, 0]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Matrix form of T(x, y) = [3x + 2y, x - y], and apply to [2, 3].",
        "output": "import numpy as np\nv = np.array([2, 3])\nT = np.array([[3, 2], [1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the matrix representation of the linear transformation T: RÂ² â†’ RÂ² defined by T(x, y) = (3x, 4y).",
        "output": "import numpy as np\nT = np.array([[3, 0], [0, 4]])\nv = np.array([1, 1])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine the matrix representing the transformation T(x, y) = (x + y, y - x).",
        "output": "import numpy as np\nT = np.array([[1, 1], [-1, 1]])\nv = np.array([2, 3])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Get the matrix representation of T: RÂ² â†’ RÂ² where T(x, y) = (2x - y, x + 3y).",
        "output": "import numpy as np\nT = np.array([[2, -1], [1, 3]])\nv = np.array([4, 1])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "What is the matrix form of T(x, y) = (5x, -2y)?",
        "output": "import numpy as np\nT = np.array([[5, 0], [0, -2]])\nv = np.array([3, 2])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute the matrix of T(x, y) = (x - 2y, 3x + y).",
        "output": "import numpy as np\nT = np.array([[1, -2], [3, 1]])\nv = np.array([1, 4])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the matrix representing T(x, y) = (-x + y, x + y).",
        "output": "import numpy as np\nT = np.array([[-1, 1], [1, 1]])\nv = np.array([2, 5])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine the matrix for T: RÂ² â†’ RÂ² given by T(x, y) = (x + 2y, y - 3x).",
        "output": "import numpy as np\nT = np.array([[1, 2], [-3, 1]])\nv = np.array([2, 1])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Get the matrix for the transformation T(x, y) = (4x + y, 2y).",
        "output": "import numpy as np\nT = np.array([[4, 1], [0, 2]])\nv = np.array([3, 5])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "What is the matrix representation for T(x, y) = (x + y, 2x + 2y)?",
        "output": "import numpy as np\nT = np.array([[1, 1], [2, 2]])\nv = np.array([2, 2])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate the matrix form of T(x, y) = (0, x + 4y).",
        "output": "import numpy as np\nT = np.array([[0, 0], [1, 4]])\nv = np.array([1, 3])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the matrix of the transformation T(x, y) = (3x - y, -2x).",
        "output": "import numpy as np\nT = np.array([[3, -1], [-2, 0]])\nv = np.array([5, 1])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine the matrix that represents T(x, y) = (x, x - y).",
        "output": "import numpy as np\nT = np.array([[1, 0], [1, -1]])\nv = np.array([2, 7])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "What matrix represents T(x, y) = (2x + y, x - 2y)?",
        "output": "import numpy as np\nT = np.array([[2, 1], [1, -2]])\nv = np.array([3, 1])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute matrix representation for T(x, y) = (x, y + x).",
        "output": "import numpy as np\nT = np.array([[1, 0], [1, 1]])\nv = np.array([4, 6])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Get matrix for T(x, y) = (y, x).",
        "output": "import numpy as np\nT = np.array([[0, 1], [1, 0]])\nv = np.array([8, 3])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "What is the matrix for the linear transformation T(x, y) = (-2x + y, x + y)?",
        "output": "import numpy as np\nT = np.array([[-2, 1], [1, 1]])\nv = np.array([5, 0])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find matrix representation of T(x, y) = (x + 3y, 2x - y).",
        "output": "import numpy as np\nT = np.array([[1, 3], [2, -1]])\nv = np.array([1, 1])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Matrix of T(x, y) = (2x, y - 3x)?",
        "output": "import numpy as np\nT = np.array([[2, 0], [-3, 1]])\nv = np.array([4, 7])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine T(x, y) = (x - y, 4x + y) as a matrix.",
        "output": "import numpy as np\nT = np.array([[1, -1], [4, 1]])\nv = np.array([3, 5])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Matrix form of T(x, y) = (-x - y, y)?",
        "output": "import numpy as np\nT = np.array([[-1, -1], [0, 1]])\nv = np.array([1, 2])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the matrix for T(x, y) = (x + y, 3y - x).",
        "output": "import numpy as np\nT = np.array([[1, 1], [-1, 3]])\nv = np.array([2, 6])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Get the matrix of T(x, y) = (x - y, -x - y).",
        "output": "import numpy as np\nT = np.array([[1, -1], [-1, -1]])\nv = np.array([2, 1])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Compute matrix of T(x, y) = (y - x, x + 2y).",
        "output": "import numpy as np\nT = np.array([[-1, 1], [1, 2]])\nv = np.array([1, 1])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Matrix for T(x, y) = (0, x - y)?",
        "output": "import numpy as np\nT = np.array([[0, 0], [1, -1]])\nv = np.array([2, 2])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Matrix representation for T(x, y) = (5x - y, 2y)?",
        "output": "import numpy as np\nT = np.array([[5, -1], [0, 2]])\nv = np.array([2, 3])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "What is the matrix representation of the transformation T(x, y) = (4x + 2y, -x + y) applied to the vector (2, -3)?",
        "output": "import numpy as np\nv = np.array([2, -3])\nT = np.array([[4, 2], [-1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply the transformation T(x, y) = (x - 2y, 3x + y) to the vector (5, 2).",
        "output": "import numpy as np\nv = np.array([5, 2])\nT = np.array([[1, -2], [3, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Use a matrix to represent the transformation T(x, y) = (-x, 2y) and apply it to the vector (-4, 1).",
        "output": "import numpy as np\nv = np.array([-4, 1])\nT = np.array([[-1, 0], [0, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "What is the result of the matrix transformation T(x, y) = (0, x - y) on the vector (3, 6)?",
        "output": "import numpy as np\nv = np.array([3, 6])\nT = np.array([[0, 0], [1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the result of applying the matrix T = [[2, 0], [0, 3]] to the vector (-3, 5).",
        "output": "import numpy as np\nv = np.array([-3, 5])\nT = np.array([[2, 0], [0, 3]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T(1, -2) where T(x, y) = (5x + y, x + 4y) using matrix representation.",
        "output": "import numpy as np\nv = np.array([1, -2])\nT = np.array([[5, 1], [1, 4]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Transform (2, 3) using the matrix T = [[0, 1], [-2, 0]].",
        "output": "import numpy as np\nv = np.array([2, 3])\nT = np.array([[0, 1], [-2, 0]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply the matrix T = [[3, -1], [2, 2]] to the vector (-1, 4).",
        "output": "import numpy as np\nv = np.array([-1, 4])\nT = np.array([[3, -1], [2, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(0, 7) where T(x, y) = (-3y, x + y) in matrix form.",
        "output": "import numpy as np\nv = np.array([0, 7])\nT = np.array([[0, -3], [1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Use matrix multiplication to apply T(x, y) = (y, x) to the vector (9, -4).",
        "output": "import numpy as np\nv = np.array([9, -4])\nT = np.array([[0, 1], [1, 0]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply the transformation T = [[1, 3], [0, -1]] to the vector (-2, 6).",
        "output": "import numpy as np\nv = np.array([-2, 6])\nT = np.array([[1, 3], [0, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(3, -3) for T(x, y) = (2x + 2y, x - y) using a matrix.",
        "output": "import numpy as np\nv = np.array([3, -3])\nT = np.array([[2, 2], [1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the transformed vector using T = [[0, -1], [1, 0]] on vector (7, 8).",
        "output": "import numpy as np\nv = np.array([7, 8])\nT = np.array([[0, -1], [1, 0]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T(6, -1) where T(x, y) = (x + 3y, 2x - y).",
        "output": "import numpy as np\nv = np.array([6, -1])\nT = np.array([[1, 3], [2, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "What is the result of applying T(x, y) = (x - y, 4y) to (1, 3)?",
        "output": "import numpy as np\nv = np.array([1, 3])\nT = np.array([[1, -1], [0, 4]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Use the matrix representation T = [[2, -3], [1, 0]] on vector (0, 5).",
        "output": "import numpy as np\nv = np.array([0, 5])\nT = np.array([[2, -3], [1, 0]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate the matrix transformation T(x, y) = (-2x, 3y) on the vector (4, -2).",
        "output": "import numpy as np\nv = np.array([4, -2])\nT = np.array([[-2, 0], [0, 3]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the image of (3, 0) under T(x, y) = (5x, -y).",
        "output": "import numpy as np\nv = np.array([3, 0])\nT = np.array([[5, 0], [0, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply T = [[3, 3], [1, -1]] to the vector (1, 2).",
        "output": "import numpy as np\nv = np.array([1, 2])\nT = np.array([[3, 3], [1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(2, 2) where T(x, y) = (x + 2y, 2x - y).",
        "output": "import numpy as np\nv = np.array([2, 2])\nT = np.array([[1, 2], [2, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Transform the vector (-5, -5) using matrix [[1, 0], [2, 3]].",
        "output": "import numpy as np\nv = np.array([-5, -5])\nT = np.array([[1, 0], [2, 3]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the matrix-transformed result of T(x, y) = (0, 2x + 2y) on the vector (1, 1).",
        "output": "import numpy as np\nv = np.array([1, 1])\nT = np.array([[0, 0], [2, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find T(0, 1) using the matrix T = [[4, 1], [1, 4]].",
        "output": "import numpy as np\nv = np.array([0, 1])\nT = np.array([[4, 1], [1, 4]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply the matrix T = [[-1, 4], [3, 2]] to vector (1, -1).",
        "output": "import numpy as np\nv = np.array([1, -1])\nT = np.array([[-1, 4], [3, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate T(x, y) = (2x, -2y) on the vector (-2, 3).",
        "output": "import numpy as np\nv = np.array([-2, 3])\nT = np.array([[2, 0], [0, -2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the matrix representation of the linear transformation T that rotates vectors in RÂ² by 270 degrees counterclockwise, and apply it to the vector [3, 2].",
        "output": "import numpy as np\nv = np.array([3, 2])\nT = np.array([[0, 1], [-1, 0]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine the matrix representation for the transformation T(x, y) = [x, -2y] and compute T on vector [5, 3].",
        "output": "import numpy as np\nv = np.array([5, 3])\nT = np.array([[1, 0], [0, -2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the matrix representation of the reflection of vectors in RÂ² across the line y = -x and apply it to [2, -3].",
        "output": "import numpy as np\nv = np.array([2, -3])\nT = np.array([[0, -1], [-1, 0]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "What is the result of applying the transformation T(x, y) = [2x, x + y] to the vector [4, -2] using matrix representation?",
        "output": "import numpy as np\nv = np.array([4, -2])\nT = np.array([[2, 0], [1, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the matrix for the transformation T(x, y) = [y, x], and evaluate it for vector [7, 1].",
        "output": "import numpy as np\nv = np.array([7, 1])\nT = np.array([[0, 1], [1, 0]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Determine the result of the transformation T(x, y) = [3x + 2y, y] using matrix multiplication for input [1, -1].",
        "output": "import numpy as np\nv = np.array([1, -1])\nT = np.array([[3, 2], [0, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Evaluate the transformation T(x, y) = [x - 2y, 2x + y] for the vector [6, 2] using matrix form.",
        "output": "import numpy as np\nv = np.array([6, 2])\nT = np.array([[1, -2], [2, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the matrix representation of the projection onto the x-axis in RÂ² and apply it to vector [-2, 8].",
        "output": "import numpy as np\nv = np.array([-2, 8])\nT = np.array([[1, 0], [0, 0]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Use matrix representation to apply the transformation T(x, y) = [4x - y, -x + 2y] on [0, 3].",
        "output": "import numpy as np\nv = np.array([0, 3])\nT = np.array([[4, -1], [-1, 2]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Represent the transformation T(x, y) = [x + 3y, x - y] as a matrix and evaluate it on vector [2, 5].",
        "output": "import numpy as np\nv = np.array([2, 5])\nT = np.array([[1, 3], [1, -1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Find the matrix that reflects vectors across the y-axis in RÂ² and use it on [6, -4].",
        "output": "import numpy as np\nv = np.array([6, -4])\nT = np.array([[-1, 0], [0, 1]])\nprint(\"Transformed vector:\", T @ v)"
    },
    {
        "input": "Apply the Gram-Schmidt process to the vectors [[1, 1], [1, -1]].",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, -1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis using Gram-Schmidt: \\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt to find an orthonormal basis for the vectors [[2, 3], [2, 1]].",
        "output": "import numpy as np\nA = np.array([[2, 2], [3, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Find the orthonormal basis of [[1, 0, 1], [1, 1, 0], [0, 1, 1]] using the Gram-Schmidt process.",
        "output": "import numpy as np\nA = np.array([[1, 1, 0], [0, 1, 1], [1, 0, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Perform Gram-Schmidt on the set of vectors [[3, 1], [2, 2]].",
        "output": "import numpy as np\nA = np.array([[3, 2], [1, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Compute an orthonormal basis using Gram-Schmidt for vectors [[4, 0], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[4, 1], [0, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Orthonormalize the matrix [[1, 2], [3, 4]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[1, 3], [2, 4]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized matrix: \\n{Q}')"
    },
    {
        "input": "Use the Gram-Schmidt process on the matrix [[0, 1], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[0, 2], [1, 3]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal matrix: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt to vectors [[2, -1], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [-1, 3]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal vectors: \\n{Q}')"
    },
    {
        "input": "Find orthonormal basis for [[1, 2, 2], [0, 1, 1], [1, 0, 1]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[1, 0, 1], [2, 1, 0], [2, 1, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Apply the Gram-Schmidt procedure on [[5, 1], [2, 4]].",
        "output": "import numpy as np\nA = np.array([[5, 2], [1, 4]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal vectors: \\n{Q}')"
    },
    {
        "input": "Find the orthonormal vectors from [[1, 1, 0], [1, 0, 1], [0, 1, 1]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[1, 1, 0], [1, 0, 1], [0, 1, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal set: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt to matrix [[1, 4], [3, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 3], [4, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Perform Gram-Schmidt orthonormalization on [[1, 1, 1], [1, 2, 3], [1, 3, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, 2, 3], [1, 3, 6]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized matrix: \\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt on the column vectors of [[2, 2], [2, -2]].",
        "output": "import numpy as np\nA = np.array([[2, 2], [2, -2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal set: \\n{Q}')"
    },
    {
        "input": "Compute the orthonormal basis using Gram-Schmidt on [[1, 0], [1, 1], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 0], [0, 1, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt on [[2, 0, 0], [0, 3, 0], [0, 0, 4]].",
        "output": "import numpy as np\nA = np.array([[2, 0, 0], [0, 3, 0], [0, 0, 4]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal matrix: \\n{Q}')"
    },
    {
        "input": "Find the orthonormal basis for the matrix [[2, 4], [6, 8]].",
        "output": "import numpy as np\nA = np.array([[2, 6], [4, 8]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Orthonormalize the vectors [[0, 0, 1], [1, 0, 0], [0, 1, 0]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal vectors: \\n{Q}')"
    },
    {
        "input": "Perform Gram-Schmidt orthogonalization on [[1, 1], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Find orthonormal basis for [[3, 3], [4, 4]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[3, 4], [3, 4]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Apply the Gram-Schmidt process to vectors [[2, 1], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[2, 0], [1, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal set: \\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt to find the orthonormal basis of [[5, 0], [0, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 0], [0, 5]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized matrix: \\n{Q}')"
    },
    {
        "input": "Perform Gram-Schmidt process on matrix [[1, 1], [0, 1], [0, 0]].",
        "output": "import numpy as np\nA = np.array([[1, 0, 0], [1, 1, 0]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal matrix: \\n{Q}')"
    },
    {
        "input": "Find the orthonormal basis of [[1, 2], [2, 5]] using Gram-Schmidt process.",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 5]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt to find an orthonormal basis for the vectors [[1, 3], [2, 2]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt to [[4, 5], [2, 1]].",
        "output": "import numpy as np\nA = np.array([[4, 2], [5, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal vectors: \\n{Q}')"
    },
    {
        "input": "Find an orthonormal basis of the matrix [[1, 1], [2, 4], [3, 9]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [1, 4, 9]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal matrix: \\n{Q}')"
    },
    {
        "input": "Orthonormalize the vectors [[0, 2], [2, 0]] using Gram-Schmidt process.",
        "output": "import numpy as np\nA = np.array([[0, 2], [2, 0]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized set: \\n{Q}')"
    },
    {
        "input": "Perform Gram-Schmidt orthonormalization on [[3, 1], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[3, 0], [1, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt on the matrix [[2, 3, 1], [1, 0, 1], [4, 2, 0]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 4], [3, 0, 2], [1, 1, 0]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal matrix: \\n{Q}')"
    },
    {
        "input": "Apply the Gram-Schmidt process to [[1, 2, 3], [0, 1, 4], [5, 6, 0]].",
        "output": "import numpy as np\nA = np.array([[1, 0, 5], [2, 1, 6], [3, 4, 0]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize [[1, 0], [1, 2], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [0, 2, 3]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized matrix: \\n{Q}')"
    },
    {
        "input": "Perform Gram-Schmidt on the vectors [[0, 0, 1], [0, 1, 0], [1, 0, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 0, 1], [0, 1, 0], [1, 0, 0]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal set: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt to find an orthonormal basis for [[2, 1], [3, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 3], [1, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt to get orthonormal basis for [[1, -1], [-1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, -1], [-1, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Find the orthonormal vectors from [[2, 1], [2, -1], [1, 1]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[2, 2, 1], [1, -1, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal matrix: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt to matrix [[3, 1, 2], [0, 2, 1], [1, 0, 0]].",
        "output": "import numpy as np\nA = np.array([[3, 0, 1], [1, 2, 0], [2, 1, 0]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal set: \\n{Q}')"
    },
    {
        "input": "Perform Gram-Schmidt on the matrix [[2, 2, 2], [2, 2, 2], [2, 2, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 2, 2], [2, 2, 2], [2, 2, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized matrix: \\n{Q}')"
    },
    {
        "input": "Find an orthonormal basis using Gram-Schmidt for [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 4, 7], [2, 5, 8], [3, 6, 9]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt on the vectors [[2, 4], [4, 8]].",
        "output": "import numpy as np\nA = np.array([[2, 4], [4, 8]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal vectors: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt on [[1, 2], [3, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 3], [2, 6]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized basis: \\n{Q}')"
    },
    {
        "input": "Perform Gram-Schmidt orthonormalization on [[2, 0, 0], [2, 0, 0], [2, 0, 0]].",
        "output": "import numpy as np\nA = np.array([[2, 2, 2], [0, 0, 0], [0, 0, 0]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal matrix: \\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt on [[1, 0], [1, 0], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 0], [0, 0, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal set: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt to orthonormalize [[3, 4], [4, -3]].",
        "output": "import numpy as np\nA = np.array([[3, 4], [4, -3]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized set: \\n{Q}')"
    },
    {
        "input": "Orthonormalize the matrix [[7, 0], [0, 7]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[7, 0], [0, 7]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal matrix: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt on [[0, 1, 0], [1, 0, 1]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [1, 0], [0, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal vectors: \\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt to find orthonormal basis for [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Find orthonormal basis using Gram-Schmidt for vectors [[5, 6], [7, 8]].",
        "output": "import numpy as np\nA = np.array([[5, 7], [6, 8]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt process to the matrix [[1, 2], [3, 5], [5, 8]].",
        "output": "import numpy as np\nA = np.array([[1, 3, 5], [2, 5, 8]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal matrix:\\n{Q}')"
    },
    {
        "input": "Orthonormalize the matrix [[4, 2], [1, 3], [0, 5]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[4, 1, 0], [2, 3, 5]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized matrix:\\n{Q}')"
    },
    {
        "input": "Find an orthonormal basis using Gram-Schmidt for [[1, 0, 1], [2, 2, 2]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [0, 2], [1, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis:\\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize [[2, 1, 0], [1, 2, 1], [3, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 3], [1, 2, 1], [0, 1, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized basis:\\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt to matrix [[1, 3, 2], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 4, 7], [3, 5, 8], [2, 6, 9]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal matrix:\\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt on the vectors [[5, 5], [1, -2], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[5, 1, 2], [5, -2, 3]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized set:\\n{Q}')"
    },
    {
        "input": "Perform Gram-Schmidt on the matrix [[1, 1], [0, 2], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 0, 1], [1, 2, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal matrix:\\n{Q}')"
    },
    {
        "input": "Find an orthonormal basis for the set [[2, 2, 1], [1, 1, 3]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[2, 1], [2, 1], [1, 3]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis:\\n{Q}')"
    },
    {
        "input": "Orthonormalize the matrix [[3, 4, 1], [1, 1, 0], [2, 2, 2]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[3, 1, 2], [4, 1, 2], [1, 0, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized matrix:\\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt to the matrix [[0, 1, 2], [2, 3, 4], [4, 5, 6]].",
        "output": "import numpy as np\nA = np.array([[0, 2, 4], [1, 3, 5], [2, 4, 6]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal matrix:\\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt to find orthonormal vectors from [[6, 1], [3, 2], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[6, 3, 0], [1, 2, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal vectors:\\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt to matrix [[2, 2], [2, -2], [0, 4]].",
        "output": "import numpy as np\nA = np.array([[2, 2, 0], [2, -2, 4]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized basis:\\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt process on the vectors [[1, 0, 0], [1, 1, 0], [1, 1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [0, 1, 1], [0, 0, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized set:\\n{Q}')"
    },
    {
        "input": "Find orthonormal vectors using Gram-Schmidt for matrix [[2, 0, 0], [1, 2, 0], [1, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 1], [0, 2, 1], [0, 0, 3]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis:\\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt to matrix [[3, 1, 4], [2, 5, 1], [0, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[3, 2, 0], [1, 5, 1], [4, 1, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized set:\\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize [[2, 3], [4, 6], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 4, 1], [3, 6, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis:\\n{Q}')"
    },
    {
        "input": "Find orthonormal vectors from matrix [[0, 2, 1], [2, 3, 4], [3, 1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 2, 3], [2, 3, 1], [1, 4, 0]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized basis:\\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize [[7, 1, 2], [0, 3, 5]].",
        "output": "import numpy as np\nA = np.array([[7, 0], [1, 3], [2, 5]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal matrix:\\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt process on the matrix [[1, 2], [3, 6], [5, 10]].",
        "output": "import numpy as np\nA = np.array([[1, 3, 5], [2, 6, 10]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal matrix:\\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt on [[1, 1, 1], [1, 2, 3], [2, 3, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 2], [1, 2, 3], [1, 3, 4]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized matrix:\\n{Q}')"
    },
    {
        "input": "Orthonormalize the vectors [[4, 1], [5, 1], [6, 2]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[4, 5, 6], [1, 1, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis:\\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt to [[0, 1, 0], [1, 0, 1], [0, 1, 1]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal set:\\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize [[3, 2, 1], [2, 3, 4]].",
        "output": "import numpy as np\nA = np.array([[3, 2], [2, 3], [1, 4]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormalized matrix:\\n{Q}')"
    },
    {
        "input": "Find orthonormal basis using Gram-Schmidt for [[2, 4, 6], [1, 2, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [4, 2], [6, 3]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis:\\n{Q}')"
    },
    {
        "input": "Apply the Gram-Schmidt process to the vectors [2, 1, 0] and [1, 0, 1].",
        "output": "import numpy as np\nv1 = np.array([2, 1, 0], dtype=float)\nv2 = np.array([1, 0, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 /= np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize the vectors [4, 0] and [1, 2].",
        "output": "import numpy as np\nv1 = np.array([4, 0], dtype=float)\nv2 = np.array([1, 2], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 /= np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Perform Gram-Schmidt on the set of vectors [1, 2, 2], [2, 4, 1], and [3, 6, 0].",
        "output": "import numpy as np\nA = np.array([[1, 2, 2], [2, 4, 1], [3, 6, 0]], dtype=float).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: {Q.T}')"
    },
    {
        "input": "Orthonormalize [3, 1] and [2, 2] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([3, 1], dtype=float)\nv2 = np.array([2, 2], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 /= np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Apply the Gram-Schmidt process to vectors [1, 0, 0], [1, 1, 0], and [1, 1, 1].",
        "output": "import numpy as np\nA = np.array([[1, 0, 0], [1, 1, 0], [1, 1, 1]], dtype=float).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: {Q.T}')"
    },
    {
        "input": "Find orthonormal basis using Gram-Schmidt for [1, 3, 1], [2, 6, 2].",
        "output": "import numpy as np\nv1 = np.array([1, 3, 1], dtype=float)\nv2 = np.array([2, 6, 2], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 /= np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt to find an orthonormal basis for vectors [1, 2, 1], [0, 1, 0], [1, 0, 1].",
        "output": "import numpy as np\nA = np.array([[1, 2, 1], [0, 1, 0], [1, 0, 1]], dtype=float).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: {Q.T}')"
    },
    {
        "input": "Apply Gram-Schmidt on vectors [5, 0], [1, 1].",
        "output": "import numpy as np\nv1 = np.array([5, 0], dtype=float)\nv2 = np.array([1, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 /= np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Perform Gram-Schmidt orthonormalization for the set {[1, 0], [1, 1]}.",
        "output": "import numpy as np\nv1 = np.array([1, 0], dtype=float)\nv2 = np.array([1, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 /= np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Find orthonormal basis using Gram-Schmidt for vectors [1, 1, 0], [1, 1, 1].",
        "output": "import numpy as np\nv1 = np.array([1, 1, 0], dtype=float)\nv2 = np.array([1, 1, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 /= np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Orthonormalize the 3D vectors [0, 1, 2], [2, 0, 1], [1, 1, 1].",
        "output": "import numpy as np\nA = np.array([[0, 1, 2], [2, 0, 1], [1, 1, 1]], dtype=float).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: {Q.T}')"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize the vectors [1, 2, 0], [0, 1, 2].",
        "output": "import numpy as np\nv1 = np.array([1, 2, 0], dtype=float)\nv2 = np.array([0, 1, 2], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 /= np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Find orthonormal vectors using Gram-Schmidt for [3, 1, 0], [2, 2, 2].",
        "output": "import numpy as np\nv1 = np.array([3, 1, 0], dtype=float)\nv2 = np.array([2, 2, 2], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 /= np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Perform Gram-Schmidt process on vectors [1, 2, 2], [2, 1, 2], [2, 2, 1].",
        "output": "import numpy as np\nA = np.array([[1, 2, 2], [2, 1, 2], [2, 2, 1]], dtype=float).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: {Q.T}')"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize the set of vectors [4, 2], [1, 3].",
        "output": "import numpy as np\nv1 = np.array([4, 2], dtype=float)\nv2 = np.array([1, 3], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 /= np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Orthonormalize the vectors [6, 2, 1], [2, 4, 6], and [1, 3, 5].",
        "output": "import numpy as np\nA = np.array([[6, 2, 1], [2, 4, 6], [1, 3, 5]], dtype=float).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: {Q.T}')"
    },
    {
        "input": "Apply Gram-Schmidt to vectors [1, 1], [1, -1].",
        "output": "import numpy as np\nv1 = np.array([1, 1], dtype=float)\nv2 = np.array([1, -1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 /= np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt for orthonormalizing [1, 1, 1], [2, 3, 4].",
        "output": "import numpy as np\nv1 = np.array([1, 1, 1], dtype=float)\nv2 = np.array([2, 3, 4], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 /= np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Perform Gram-Schmidt on the vectors [1, 0], [0, 1].",
        "output": "import numpy as np\nv1 = np.array([1, 0], dtype=float)\nv2 = np.array([0, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nu2 = v2 / np.linalg.norm(v2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Find orthonormal basis using Gram-Schmidt for vectors [3, 0, 4], [4, 3, 0].",
        "output": "import numpy as np\nv1 = np.array([3, 0, 4], dtype=float)\nv2 = np.array([4, 3, 0], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 /= np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt to get orthonormal basis for [5, 5], [1, -1].",
        "output": "import numpy as np\nv1 = np.array([5, 5], dtype=float)\nv2 = np.array([1, -1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 /= np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Apply the Gram-Schmidt process to the vectors [1, 1, 0] and [1, 0, 1].",
        "output": "import numpy as np\nA = np.array([[1, 1, 0], [1, 0, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize the set of vectors [2, 0, 0], [1, 1, 0], and [1, 1, 1].",
        "output": "import numpy as np\nA = np.array([[2, 0, 0], [1, 1, 0], [1, 1, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Find the orthonormal basis using Gram-Schmidt for the matrix [[3, 1], [2, 2], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [2, 2], [1, 3]])\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Perform Gram-Schmidt process on vectors [4, 2], [2, 3].",
        "output": "import numpy as np\nA = np.array([[4, 2], [2, 3]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt to orthonormalize the vectors [1, 2, 2] and [2, 1, 2].",
        "output": "import numpy as np\nA = np.array([[1, 2, 2], [2, 1, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "What is the result of applying Gram-Schmidt to [[0, 1], [1, 1], [2, 3]]?",
        "output": "import numpy as np\nA = np.array([[0, 1], [1, 1], [2, 3]])\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt on the vectors [1, 0, 0], [1, 1, 0], [1, 1, 1].",
        "output": "import numpy as np\nA = np.array([[1, 0, 0], [1, 1, 0], [1, 1, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Use the Gram-Schmidt process for vectors [2, 1, -1] and [1, -1, 2].",
        "output": "import numpy as np\nA = np.array([[2, 1, -1], [1, -1, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Find an orthonormal basis for vectors [3, 3, 0] and [3, -3, 0] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[3, 3, 0], [3, -3, 0]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt to [2, 2, 1], [1, 3, 1], [1, 2, 3].",
        "output": "import numpy as np\nA = np.array([[2, 2, 1], [1, 3, 1], [1, 2, 3]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Perform Gram-Schmidt process on [3, 0, 0], [3, 3, 0], [3, 3, 3].",
        "output": "import numpy as np\nA = np.array([[3, 0, 0], [3, 3, 0], [3, 3, 3]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize vectors [1, 2], [2, 4].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt to vectors [1, 1, 1], [1, 0, -1], [0, 1, 1].",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, 0, -1], [0, 1, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt on the vectors [1, 2, 3], [2, 3, 4], [3, 4, 5].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 5]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Find orthonormal basis using Gram-Schmidt for [0, 1, 2], [2, 0, 1], [1, 2, 0].",
        "output": "import numpy as np\nA = np.array([[0, 1, 2], [2, 0, 1], [1, 2, 0]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Orthonormalize the matrix [[1, 2], [2, 1], [3, 4]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 1], [3, 4]])\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Perform Gram-Schmidt for vectors [1, 2, 3], [4, 5, 6].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt process to [1, 0], [1, 1].",
        "output": "import numpy as np\nA = np.array([[1, 0], [1, 1]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt to find orthonormal basis for [1, 2], [2, 3], [3, 5].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 3], [3, 5]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Use Gram-Schmidt process to orthonormalize [[2, 3], [4, 5], [6, 7]].",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5], [6, 7]])\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt on matrix [[1, 2, 3], [2, 3, 4], [3, 4, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 6]])\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Perform Gram-Schmidt on vectors [1, -1, 0], [1, 1, 0].",
        "output": "import numpy as np\nA = np.array([[1, -1, 0], [1, 1, 0]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Find orthonormal vectors for [2, 1], [1, 2] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]]).T\nQ, _ = np.linalg.qr(A)\nprint(f'Orthonormal basis: \\n{Q}')"
    },
    {
        "input": "Apply Gram-Schmidt to the vectors [6, 0, 0], [0, 6, 0], [0, 0, 6].",
        "output": "import numpy as np\nv = [np.array([6, 0, 0]), np.array([0, 6, 0]), np.array([0, 0, 6])]\nu = [vi / np.linalg.norm(vi) for vi in v]\nfor i, ui in enumerate(u):\n    print(f'Orthonormal vector u{i+1}: {ui}')"
    },
    {
        "input": "Perform Gram-Schmidt on vectors [3, 1], [6, 2].",
        "output": "import numpy as np\nv1 = np.array([3, 1])\nv2 = np.array([6, 2])\nu1 = v1\nproj = np.dot(v2, u1) / np.dot(u1, u1) * u1\nu2 = v2 - proj\nprint(f'Orthogonal vectors: {u1}, {u2}')"
    },
    {
        "input": "Apply the Gram-Schmidt process to vectors [1.1, 2.2] and [3.3, 4.4].",
        "output": "import numpy as np\nv1 = np.array([1.1, 2.2])\nv2 = np.array([3.3, 4.4])\nu1 = v1\nproj = np.dot(v2, u1) / np.dot(u1, u1) * u1\nu2 = v2 - proj\nprint(f'Orthogonal vectors: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize the vectors [1.5, 2.5] and [3.0, 1.5].",
        "output": "import numpy as np\nv1 = np.array([1.5, 2.5])\nv2 = np.array([3.0, 1.5])\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Find orthogonal vectors from [2.4, 3.6, 1.2] and [4.8, 1.8, 2.1] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([2.4, 3.6, 1.2])\nv2 = np.array([4.8, 1.8, 2.1])\nu1 = v1\nproj = np.dot(v2, u1) / np.dot(u1, u1) * u1\nu2 = v2 - proj\nprint(f'Orthogonal vectors: {u1}, {u2}')"
    },
    {
        "input": "Apply the Gram-Schmidt process to [0.5, 1.5, 2.5] and [2.5, 1.5, 0.5].",
        "output": "import numpy as np\nv1 = np.array([0.5, 1.5, 2.5])\nv2 = np.array([2.5, 1.5, 0.5])\nu1 = v1\nproj = np.dot(v2, u1)/np.dot(u1,u1)*u1\nu2 = v2 - proj\nprint(f'Orthogonal basis: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt to convert vectors [1.2, 0.8] and [0.6, 2.4] into an orthogonal set.",
        "output": "import numpy as np\nv1 = np.array([1.2, 0.8])\nv2 = np.array([0.6, 2.4])\nu1 = v1\nproj = np.dot(v2, u1)/np.dot(u1,u1)*u1\nu2 = v2 - proj\nprint(f'Orthogonal set: {u1}, {u2}')"
    },
    {
        "input": "Perform Gram-Schmidt orthogonalization on [1.5, 0.5, 1.0] and [1.0, 1.0, 0.5].",
        "output": "import numpy as np\nv1 = np.array([1.5, 0.5, 1.0])\nv2 = np.array([1.0, 1.0, 0.5])\nu1 = v1\nproj = np.dot(v2, u1)/np.dot(u1,u1)*u1\nu2 = v2 - proj\nprint(f'Orthogonal vectors: {u1}, {u2}')"
    },
    {
        "input": "Orthonormalize vectors [0.5, 0.5] and [1.5, 2.5] using Gram-Schmidt process.",
        "output": "import numpy as np\nv1 = np.array([0.5, 0.5])\nv2 = np.array([1.5, 2.5])\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Apply Gram-Schmidt to get orthogonal basis from [1.1, 2.2, 3.3] and [3.3, 2.2, 1.1].",
        "output": "import numpy as np\nv1 = np.array([1.1, 2.2, 3.3])\nv2 = np.array([3.3, 2.2, 1.1])\nu1 = v1\nproj = np.dot(v2,u1)/np.dot(u1,u1)*u1\nu2 = v2 - proj\nprint(f'Orthogonal basis: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt to get orthonormal vectors from [0.2, 0.6] and [0.6, 0.8].",
        "output": "import numpy as np\nv1 = np.array([0.2, 0.6])\nv2 = np.array([0.6, 0.8])\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Find orthonormal set using Gram-Schmidt for vectors [2.2, 1.1, 0.3] and [1.1, 0.3, 2.2].",
        "output": "import numpy as np\nv1 = np.array([2.2, 1.1, 0.3])\nv2 = np.array([1.1, 0.3, 2.2])\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2,u1)*u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Apply Gram-Schmidt to [1.3, 0.9, 2.2] and [0.7, 2.5, 1.1].",
        "output": "import numpy as np\nv1 = np.array([1.3, 0.9, 2.2])\nv2 = np.array([0.7, 2.5, 1.1])\nu1 = v1\nproj = np.dot(v2, u1)/np.dot(u1,u1)*u1\nu2 = v2 - proj\nprint(f'Orthogonal vectors: {u1}, {u2}')"
    },
    {
        "input": "Find orthonormal basis for [2.5, 1.8] and [1.1, 0.4] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([2.5, 1.8])\nv2 = np.array([1.1, 0.4])\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2,u1)*u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Perform Gram-Schmidt on [0.9, 1.4, 3.1] and [2.2, 1.1, 0.3].",
        "output": "import numpy as np\nv1 = np.array([0.9, 1.4, 3.1])\nv2 = np.array([2.2, 1.1, 0.3])\nu1 = v1\nproj = np.dot(v2, u1)/np.dot(u1,u1)*u1\nu2 = v2 - proj\nprint(f'Orthogonal basis: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt to orthogonalize vectors [1.6, 0.7] and [0.4, 2.3].",
        "output": "import numpy as np\nv1 = np.array([1.6, 0.7])\nv2 = np.array([0.4, 2.3])\nu1 = v1\nproj = np.dot(v2, u1)/np.dot(u1,u1)*u1\nu2 = v2 - proj\nprint(f'Orthogonalized vectors: {u1}, {u2}')"
    },
    {
        "input": "Compute orthonormal basis using Gram-Schmidt on vectors [2.2, 3.4] and [1.3, 0.8].",
        "output": "import numpy as np\nv1 = np.array([2.2, 3.4])\nv2 = np.array([1.3, 0.8])\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Apply Gram-Schmidt process to [0.6, 0.4, 0.9] and [1.1, 1.2, 2.3].",
        "output": "import numpy as np\nv1 = np.array([0.6, 0.4, 0.9])\nv2 = np.array([1.1, 1.2, 2.3])\nu1 = v1\nproj = np.dot(v2, u1) / np.dot(u1, u1) * u1\nu2 = v2 - proj\nprint(f'Orthogonal basis: {u1}, {u2}')"
    },
    {
        "input": "Orthonormalize [2.1, 3.3] and [1.7, 0.5] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([2.1, 3.3])\nv2 = np.array([1.7, 0.5])\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt to orthogonalize the set [0.5, 1.8, 2.6] and [3.3, 2.1, 1.2].",
        "output": "import numpy as np\nv1 = np.array([0.5, 1.8, 2.6])\nv2 = np.array([3.3, 2.1, 1.2])\nu1 = v1\nproj = np.dot(v2, u1) / np.dot(u1, u1) * u1\nu2 = v2 - proj\nprint(f'Orthogonal vectors: {u1}, {u2}')"
    },
    {
        "input": "Find orthonormal vectors from [1.0, 2.2] and [2.8, 1.7] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([1.0, 2.2])\nv2 = np.array([2.8, 1.7])\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Apply Gram-Schmidt on vectors [0.3, 0.7, 1.5] and [1.1, 2.2, 3.3].",
        "output": "import numpy as np\nv1 = np.array([0.3, 0.7, 1.5])\nv2 = np.array([1.1, 2.2, 3.3])\nu1 = v1\nproj = np.dot(v2,u1)/np.dot(u1,u1)*u1\nu2 = v2 - proj\nprint(f'Orthogonal basis: {u1}, {u2}')"
    },
    {
        "input": "Orthonormalize [3.2, 2.1] and [0.9, 0.4] using Gram-Schmidt process.",
        "output": "import numpy as np\nv1 = np.array([3.2, 2.1])\nv2 = np.array([0.9, 0.4])\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2,u1)*u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Perform Gram-Schmidt on [1.3, 2.6, 3.9] and [0.5, 1.0, 1.5].",
        "output": "import numpy as np\nv1 = np.array([1.3, 2.6, 3.9])\nv2 = np.array([0.5, 1.0, 1.5])\nu1 = v1\nproj = np.dot(v2,u1)/np.dot(u1,u1)*u1\nu2 = v2 - proj\nprint(f'Orthogonal vectors: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt on [0.4, 0.8] and [1.6, 0.3] to find an orthonormal set.",
        "output": "import numpy as np\nv1 = np.array([0.4, 0.8])\nv2 = np.array([1.6, 0.3])\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2,u1)*u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal set: {u1}, {u2}')"
    },
    {
        "input": "Orthonormalize [0.6, 0.2, 1.7] and [1.5, 2.5, 0.9] using Gram-Schmidt method.",
        "output": "import numpy as np\nv1 = np.array([0.6, 0.2, 1.7])\nv2 = np.array([1.5, 2.5, 0.9])\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2,u1)*u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Apply Gram-Schmidt to [2.0, 3.0] and [1.2, 0.4].",
        "output": "import numpy as np\nv1 = np.array([2.0, 3.0])\nv2 = np.array([1.2, 0.4])\nu1 = v1\nproj = np.dot(v2, u1)/np.dot(u1,u1)*u1\nu2 = v2 - proj\nprint(f'Orthogonal vectors: {u1}, {u2}')"
    },
    {
        "input": "Perform Gram-Schmidt orthonormalization on the vectors [[2.5, 3.5], [4.5, 5.5]].",
        "output": "import numpy as np\nA = np.array([[2.5, 3.5], [4.5, 5.5]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis:')\nprint(Q.T)"
    },
    {
        "input": "Apply the Gram-Schmidt process to the matrix [[1.6, 0.4], [2.8, 3.3]].",
        "output": "import numpy as np\nA = np.array([[1.6, 0.4], [2.8, 3.3]])\nQ, _ = np.linalg.qr(A.T)\nprint('The orthogonal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Find the orthogonal basis for the vectors [[0.2, 0.3, 0.5], [0.6, 0.7, 0.9]].",
        "output": "import numpy as np\nA = np.array([[0.2, 0.3, 0.5], [0.6, 0.7, 0.9]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthogonal basis:')\nprint(Q.T)"
    },
    {
        "input": "Use Gram-Schmidt on matrix [[4.2, 5.3], [6.4, 7.5]].",
        "output": "import numpy as np\nA = np.array([[4.2, 5.3], [6.4, 7.5]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Perform Gram-Schmidt process on [[1.9, 2.8], [3.7, 4.6]].",
        "output": "import numpy as np\nA = np.array([[1.9, 2.8], [3.7, 4.6]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthogonal vectors:')\nprint(Q.T)"
    },
    {
        "input": "Orthonormalize the matrix [[0.5, 0.6, 0.7], [0.8, 0.9, 1.0]].",
        "output": "import numpy as np\nA = np.array([[0.5, 0.6, 0.7], [0.8, 0.9, 1.0]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal vectors:')\nprint(Q.T)"
    },
    {
        "input": "Apply Gram-Schmidt on [[3.3, 1.4], [2.2, 4.1]].",
        "output": "import numpy as np\nA = np.array([[3.3, 1.4], [2.2, 4.1]])\nQ, _ = np.linalg.qr(A.T)\nprint('The orthonormal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Compute the orthogonal basis for [[0.7, 0.2], [0.4, 0.6]].",
        "output": "import numpy as np\nA = np.array([[0.7, 0.2], [0.4, 0.6]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthogonal basis:')\nprint(Q.T)"
    },
    {
        "input": "Find the Gram-Schmidt orthonormal basis of [[5.5, 1.1], [2.2, 3.3]].",
        "output": "import numpy as np\nA = np.array([[5.5, 1.1], [2.2, 3.3]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis:')\nprint(Q.T)"
    },
    {
        "input": "Use Gram-Schmidt to find orthonormal basis of [[0.11, 0.22], [0.33, 0.44]].",
        "output": "import numpy as np\nA = np.array([[0.11, 0.22], [0.33, 0.44]])\nQ, _ = np.linalg.qr(A.T)\nprint('The orthonormal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Orthonormalize matrix [[6.6, 7.7], [8.8, 9.9]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[6.6, 7.7], [8.8, 9.9]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis:')\nprint(Q.T)"
    },
    {
        "input": "Apply Gram-Schmidt to matrix [[2.5, 0.3], [0.9, 1.7]].",
        "output": "import numpy as np\nA = np.array([[2.5, 0.3], [0.9, 1.7]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthogonal basis:')\nprint(Q.T)"
    },
    {
        "input": "Find orthonormal basis for [[1.8, 2.4], [3.5, 4.1]] using Gram-Schmidt process.",
        "output": "import numpy as np\nA = np.array([[1.8, 2.4], [3.5, 4.1]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Perform Gram-Schmidt orthonormalization on matrix [[0.9, 1.8], [2.7, 3.6]].",
        "output": "import numpy as np\nA = np.array([[0.9, 1.8], [2.7, 3.6]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthogonal basis:')\nprint(Q.T)"
    },
    {
        "input": "Use Gram-Schmidt process to orthonormalize [[3.3, 2.2], [1.1, 0.9]].",
        "output": "import numpy as np\nA = np.array([[3.3, 2.2], [1.1, 0.9]])\nQ, _ = np.linalg.qr(A.T)\nprint('The orthonormal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Apply Gram-Schmidt to matrix [[0.45, 0.78], [0.56, 0.89]].",
        "output": "import numpy as np\nA = np.array([[0.45, 0.78], [0.56, 0.89]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis:')\nprint(Q.T)"
    },
    {
        "input": "Compute orthonormal vectors using Gram-Schmidt for [[2.9, 1.1], [0.5, 3.3]].",
        "output": "import numpy as np\nA = np.array([[2.9, 1.1], [0.5, 3.3]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthogonal basis:')\nprint(Q.T)"
    },
    {
        "input": "Find the orthonormal basis using Gram-Schmidt for matrix [[0.33, 0.66], [0.99, 1.32]].",
        "output": "import numpy as np\nA = np.array([[0.33, 0.66], [0.99, 1.32]])\nQ, _ = np.linalg.qr(A.T)\nprint('The orthonormal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Perform Gram-Schmidt on [[1.1, 0.1], [0.3, 2.7]].",
        "output": "import numpy as np\nA = np.array([[1.1, 0.1], [0.3, 2.7]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthogonal basis:')\nprint(Q.T)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize [[0.02, 0.04], [0.06, 0.08]].",
        "output": "import numpy as np\nA = np.array([[0.02, 0.04], [0.06, 0.08]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis:')\nprint(Q.T)"
    },
    {
        "input": "Apply Gram-Schmidt process to matrix [[4.9, 1.2], [3.8, 0.7]].",
        "output": "import numpy as np\nA = np.array([[4.9, 1.2], [3.8, 0.7]])\nQ, _ = np.linalg.qr(A.T)\nprint('The orthogonal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Compute Gram-Schmidt orthonormal vectors for [[0.17, 0.29], [0.41, 0.53]].",
        "output": "import numpy as np\nA = np.array([[0.17, 0.29], [0.41, 0.53]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Orthonormalize the matrix [[3.33, 4.44], [5.55, 6.66]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[3.33, 4.44], [5.55, 6.66]])\nQ, _ = np.linalg.qr(A.T)\nprint('The orthonormal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Find orthogonal vectors for matrix [[1.12, 2.24], [3.36, 4.48]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[1.12, 2.24], [3.36, 4.48]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthogonal basis:')\nprint(Q.T)"
    },
    {
        "input": "Apply Gram-Schmidt orthonormalization on the vectors [[0.31, 0.42], [0.53, 0.64]].",
        "output": "import numpy as np\nA = np.array([[0.31, 0.42], [0.53, 0.64]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis:')\nprint(Q.T)"
    },
    {
        "input": "Find the orthonormal basis for matrix [[1.15, 2.25], [3.35, 4.45]].",
        "output": "import numpy as np\nA = np.array([[1.15, 2.25], [3.35, 4.45]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis:')\nprint(Q.T)"
    },
    {
        "input": "Use Gram-Schmidt on matrix [[2.9, 1.7], [3.6, 2.5]].",
        "output": "import numpy as np\nA = np.array([[2.9, 1.7], [3.6, 2.5]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthogonal basis:')\nprint(Q.T)"
    },
    {
        "input": "Perform Gram-Schmidt process on [[4.1, 3.3], [2.2, 1.4]].",
        "output": "import numpy as np\nA = np.array([[4.1, 3.3], [2.2, 1.4]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Orthonormalize the matrix [[0.45, 0.55], [0.65, 0.75]].",
        "output": "import numpy as np\nA = np.array([[0.45, 0.55], [0.65, 0.75]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal vectors:')\nprint(Q.T)"
    },
    {
        "input": "Apply Gram-Schmidt to [[1.2, 3.4], [5.6, 7.8]].",
        "output": "import numpy as np\nA = np.array([[1.2, 3.4], [5.6, 7.8]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthogonal basis:')\nprint(Q.T)"
    },
    {
        "input": "Perform Gram-Schmidt on the vectors [[2.3, 4.5], [6.7, 8.9]].",
        "output": "import numpy as np\nA = np.array([[2.3, 4.5], [6.7, 8.9]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal vectors:')\nprint(Q.T)"
    },
    {
        "input": "Orthonormalize matrix [[0.91, 0.81], [0.71, 0.61]].",
        "output": "import numpy as np\nA = np.array([[0.91, 0.81], [0.71, 0.61]])\nQ, _ = np.linalg.qr(A.T)\nprint('The orthonormal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Use Gram-Schmidt on [[1.11, 1.22], [1.33, 1.44]].",
        "output": "import numpy as np\nA = np.array([[1.11, 1.22], [1.33, 1.44]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthogonal basis:')\nprint(Q.T)"
    },
    {
        "input": "Compute the orthonormal basis of [[2.02, 2.12], [2.22, 2.32]].",
        "output": "import numpy as np\nA = np.array([[2.02, 2.12], [2.22, 2.32]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis:')\nprint(Q.T)"
    },
    {
        "input": "Perform Gram-Schmidt on matrix [[3.14, 2.71], [1.61, 0.57]].",
        "output": "import numpy as np\nA = np.array([[3.14, 2.71], [1.61, 0.57]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis:')\nprint(Q.T)"
    },
    {
        "input": "Orthonormalize [[0.33, 0.66], [0.99, 1.32]].",
        "output": "import numpy as np\nA = np.array([[0.33, 0.66], [0.99, 1.32]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize [[1.7, 3.1], [2.4, 4.6]].",
        "output": "import numpy as np\nA = np.array([[1.7, 3.1], [2.4, 4.6]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthogonal vectors:')\nprint(Q.T)"
    },
    {
        "input": "Perform Gram-Schmidt process on matrix [[5.5, 6.6], [7.7, 8.8]].",
        "output": "import numpy as np\nA = np.array([[5.5, 6.6], [7.7, 8.8]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis:')\nprint(Q.T)"
    },
    {
        "input": "Apply Gram-Schmidt on [[9.1, 0.1], [1.2, 2.3]].",
        "output": "import numpy as np\nA = np.array([[9.1, 0.1], [1.2, 2.3]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal vectors:')\nprint(Q.T)"
    },
    {
        "input": "Use Gram-Schmidt for orthonormalizing [[0.07, 0.14], [0.21, 0.28]].",
        "output": "import numpy as np\nA = np.array([[0.07, 0.14], [0.21, 0.28]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Find orthonormal basis for matrix [[6.66, 5.55], [4.44, 3.33]].",
        "output": "import numpy as np\nA = np.array([[6.66, 5.55], [4.44, 3.33]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthogonal basis:')\nprint(Q.T)"
    },
    {
        "input": "Perform Gram-Schmidt on matrix [[7.2, 3.1], [4.3, 2.2]].",
        "output": "import numpy as np\nA = np.array([[7.2, 3.1], [4.3, 2.2]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Apply Gram-Schmidt to matrix [[0.98, 1.76], [2.54, 3.32]].",
        "output": "import numpy as np\nA = np.array([[0.98, 1.76], [2.54, 3.32]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis:')\nprint(Q.T)"
    },
    {
        "input": "Compute orthogonal vectors using Gram-Schmidt for [[3.25, 1.5], [4.5, 2.75]].",
        "output": "import numpy as np\nA = np.array([[3.25, 1.5], [4.5, 2.75]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthogonal basis:')\nprint(Q.T)"
    },
    {
        "input": "Perform Gram-Schmidt on [[0.6, 1.2], [1.8, 2.4]].",
        "output": "import numpy as np\nA = np.array([[0.6, 1.2], [1.8, 2.4]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Orthonormalize the matrix [[3.33, 2.22], [1.11, 0.99]].",
        "output": "import numpy as np\nA = np.array([[3.33, 2.22], [1.11, 0.99]])\nQ, _ = np.linalg.qr(A.T)\nprint('The orthogonal basis is:')\nprint(Q.T)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize matrix [[0.45, 0.78], [0.56, 0.89]].",
        "output": "import numpy as np\nA = np.array([[0.45, 0.78], [0.56, 0.89]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis:')\nprint(Q.T)"
    },
    {
        "input": "Find orthonormal basis for [[0.81, 0.18], [0.27, 0.63]].",
        "output": "import numpy as np\nA = np.array([[0.81, 0.18], [0.27, 0.63]])\nQ, _ = np.linalg.qr(A.T)\nprint('Orthonormal basis:')\nprint(Q.T)"
    },
    {
        "input": "Apply the Gram-Schmidt process to the vectors [[1.2, 2.4], [3.6, 4.8]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[1.2, 2.4], [3.6, 4.8]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize the matrix [[0.5, 1.0], [1.5, 2.0]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[0.5, 1.0], [1.5, 2.0]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Find an orthonormal basis for the column vectors [[2.1, 3.3], [4.5, 5.7]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[2.1, 3.3], [4.5, 5.7]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Perform Gram-Schmidt on [[1.5, 0.7, 2.3], [2.1, 1.8, 3.9], [0.6, 1.2, 1.4]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[1.5, 0.7, 2.3], [2.1, 1.8, 3.9], [0.6, 1.2, 1.4]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Orthonormalize the matrix [[2.4, 1.5], [3.1, 4.2]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[2.4, 1.5], [3.1, 4.2]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Use the Gram-Schmidt process to orthonormalize the vectors [[1.1, 2.2], [3.3, 4.4]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[1.1, 2.2], [3.3, 4.4]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Apply Gram-Schmidt to the matrix [[1.25, 0.75], [2.5, 1.0]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[1.25, 0.75], [2.5, 1.0]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Orthonormalize the columns of the matrix [[0.5, 0.3, 0.2], [1.2, 0.7, 0.6], [1.8, 1.5, 1.1]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[0.5, 0.3, 0.2], [1.2, 0.7, 0.6], [1.8, 1.5, 1.1]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Perform Gram-Schmidt orthonormalization for [[2.8, 1.2], [4.6, 3.3]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[2.8, 1.2], [4.6, 3.3]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Find the orthonormal basis using Gram-Schmidt for matrix [[0.75, 1.5, 2.25], [1.25, 2.0, 2.75], [0.5, 1.0, 1.5]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[0.75, 1.5, 2.25], [1.25, 2.0, 2.75], [0.5, 1.0, 1.5]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Use Gram-Schmidt to obtain orthonormal columns from matrix [[1.1, 0.9], [2.3, 1.7]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[1.1, 0.9], [2.3, 1.7]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Apply the Gram-Schmidt procedure to [[0.3, 0.6], [0.9, 1.5]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[0.3, 0.6], [0.9, 1.5]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Perform Gram-Schmidt on the vectors [[1.3, 1.1], [2.6, 2.2]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[1.3, 1.1], [2.6, 2.2]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Orthonormalize the matrix [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]] using the Gram-Schmidt process.",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Apply Gram-Schmidt to orthonormalize the matrix [[2.2, 1.1, 0.5], [0.5, 1.3, 2.1], [1.4, 2.2, 1.6]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[2.2, 1.1, 0.5], [0.5, 1.3, 2.1], [1.4, 2.2, 1.6]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize the vectors [[1.75, 2.25], [3.1, 4.8]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[1.75, 2.25], [3.1, 4.8]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Perform Gram-Schmidt orthonormalization on matrix [[1.4, 1.8], [2.7, 3.2]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[1.4, 1.8], [2.7, 3.2]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Orthonormalize the columns of [[0.25, 0.5], [0.75, 1.0]] using Gram-Schmidt process.",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[0.25, 0.5], [0.75, 1.0]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Apply Gram-Schmidt to [[0.6, 0.2], [0.4, 0.8]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[0.6, 0.2], [0.4, 0.8]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Use Gram-Schmidt process to orthonormalize the matrix [[2.6, 1.2], [3.9, 2.4]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[2.6, 1.2], [3.9, 2.4]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Perform Gram-Schmidt on the matrix [[0.5, 0.7, 1.2], [1.0, 1.5, 2.0], [1.5, 2.1, 2.8]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[0.5, 0.7, 1.2], [1.0, 1.5, 2.0], [1.5, 2.1, 2.8]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Orthonormalize matrix [[1.2, 2.4, 3.6], [4.8, 6.0, 7.2], [8.4, 9.6, 10.8]] using Gram-Schmidt.",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[1.2, 2.4, 3.6], [4.8, 6.0, 7.2], [8.4, 9.6, 10.8]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Use Gram-Schmidt process on the matrix [[1.01, 0.99], [0.98, 1.02]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[1.01, 0.99], [0.98, 1.02]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Perform Gram-Schmidt orthonormalization for matrix [[2.45, 3.6], [1.5, 0.75]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[2.45, 3.6], [1.5, 0.75]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Apply Gram-Schmidt to the matrix [[0.33, 0.66], [0.99, 1.32]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[0.33, 0.66], [0.99, 1.32]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Find orthonormal basis for [[3.5, 1.5], [2.0, 2.5]] using Gram-Schmidt.",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[3.5, 1.5], [2.0, 2.5]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize [[4.4, 2.2], [1.1, 3.3]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[4.4, 2.2], [1.1, 3.3]]).T\nQ = []\nfor a in A.T:\n    u = a.copy()\n    for q in Q:\n        u -= np.dot(q, a) * q\n    q = u / norm(u)\n    Q.append(q)\nQ = np.array(Q).T\nprint('Orthonormal basis:', Q)"
    },
    {
        "input": "Apply the Gram-Schmidt process to the vectors [1.2, 2.4, 3.6] and [0.5, 1.1, 1.7].",
        "output": "import numpy as np\nv1 = np.array([1.2, 2.4, 3.6])\nv2 = np.array([0.5, 1.1, 1.7])\nu1 = v1\nproj = np.dot(v2, u1) / np.dot(u1, u1) * u1\nu2 = v2 - proj\nprint('Orthogonal vectors:', u1, u2)"
    },
    {
        "input": "Perform Gram-Schmidt orthogonalization on [3.3, 0.8] and [1.1, 4.4].",
        "output": "import numpy as np\nv1 = np.array([3.3, 0.8])\nv2 = np.array([1.1, 4.4])\nu1 = v1\nproj = np.dot(v2, u1)/np.dot(u1, u1)*u1\nu2 = v2 - proj\nprint('Orthogonal vectors:', u1, u2)"
    },
    {
        "input": "Use the Gram-Schmidt process for vectors [2.1, 1.5, 0.3] and [4.0, 3.3, 1.1].",
        "output": "import numpy as np\nv1 = np.array([2.1, 1.5, 0.3])\nv2 = np.array([4.0, 3.3, 1.1])\nu1 = v1\nproj = np.dot(v2, u1)/np.dot(u1, u1)*u1\nu2 = v2 - proj\nprint('Orthogonal vectors:', u1, u2)"
    },
    {
        "input": "Orthogonalize vectors [1.7, 2.5] and [3.2, 0.6] using the Gram-Schmidt process.",
        "output": "import numpy as np\nv1 = np.array([1.7, 2.5])\nv2 = np.array([3.2, 0.6])\nu1 = v1\nproj = np.dot(v2, u1)/np.dot(u1, u1)*u1\nu2 = v2 - proj\nprint('Orthogonal vectors:', u1, u2)"
    },
    {
        "input": "Find orthonormal basis for vectors [0.2, 0.8, 1.6] and [2.3, 1.1, 0.9].",
        "output": "import numpy as np\nv1 = np.array([0.2, 0.8, 1.6])\nv2 = np.array([2.3, 1.1, 0.9])\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1)*u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint('Orthonormal basis:', u1, u2)"
    },
    {
        "input": "Apply Gram-Schmidt process to matrix [[1.1, 2.3], [3.4, 4.5], [5.6, 6.7]].",
        "output": "import numpy as np\nA = np.array([[1.1, 2.3], [3.4, 4.5], [5.6, 6.7]])\nQ, R = np.linalg.qr(A)\nprint('Orthogonal matrix Q:', Q)"
    },
    {
        "input": "Use Gram-Schmidt on [0.4, 1.5, 2.9] and [3.3, 4.2, 5.1].",
        "output": "import numpy as np\nv1 = np.array([0.4, 1.5, 2.9])\nv2 = np.array([3.3, 4.2, 5.1])\nu1 = v1\nproj = np.dot(v2, u1)/np.dot(u1, u1)*u1\nu2 = v2 - proj\nprint('Orthogonal vectors:', u1, u2)"
    },
    {
        "input": "Find orthonormal vectors for [2.2, 0.7] and [1.5, 3.6] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([2.2, 0.7])\nv2 = np.array([1.5, 3.6])\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1)*u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint('Orthonormal basis:', u1, u2)"
    },
    {
        "input": "Orthogonalize [1.6, 0.9, 3.3] and [0.5, 2.2, 4.4] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([1.6, 0.9, 3.3])\nv2 = np.array([0.5, 2.2, 4.4])\nu1 = v1\nproj = np.dot(v2, u1)/np.dot(u1, u1)*u1\nu2 = v2 - proj\nprint('Orthogonal vectors:', u1, u2)"
    },
    {
        "input": "Perform Gram-Schmidt orthonormalization on [0.6, 1.2] and [1.7, 3.8].",
        "output": "import numpy as np\nv1 = np.array([0.6, 1.2])\nv2 = np.array([1.7, 3.8])\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1)*u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint('Orthonormal basis:', u1, u2)"
    },
    {
        "input": "Apply Gram-Schmidt to [4.2, 2.1, 1.0] and [1.1, 0.5, 3.3].",
        "output": "import numpy as np\nv1 = np.array([4.2, 2.1, 1.0])\nv2 = np.array([1.1, 0.5, 3.3])\nu1 = v1\nproj = np.dot(v2, u1)/np.dot(u1, u1)*u1\nu2 = v2 - proj\nprint('Orthogonal vectors:', u1, u2)"
    },
    {
        "input": "Orthonormalize vectors [0.9, 1.4] and [2.3, 0.6].",
        "output": "import numpy as np\nv1 = np.array([0.9, 1.4])\nv2 = np.array([2.3, 0.6])\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1)*u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint('Orthonormal basis:', u1, u2)"
    },
    {
        "input": "Apply Gram-Schmidt to [3.1, 1.5, 2.2] and [2.0, 0.7, 4.1].",
        "output": "import numpy as np\nv1 = np.array([3.1, 1.5, 2.2])\nv2 = np.array([2.0, 0.7, 4.1])\nu1 = v1\nproj = np.dot(v2, u1)/np.dot(u1, u1)*u1\nu2 = v2 - proj\nprint('Orthogonal vectors:', u1, u2)"
    },
    {
        "input": "Use Gram-Schmidt on matrix [[0.5, 1.2], [1.1, 2.3], [3.3, 0.9]].",
        "output": "import numpy as np\nA = np.array([[0.5, 1.2], [1.1, 2.3], [3.3, 0.9]])\nQ, R = np.linalg.qr(A)\nprint('Orthogonal matrix Q:', Q)"
    },
    {
        "input": "Perform Gram-Schmidt orthogonalization on [1.3, 1.8, 2.1] and [3.4, 0.9, 1.1].",
        "output": "import numpy as np\nv1 = np.array([1.3, 1.8, 2.1])\nv2 = np.array([3.4, 0.9, 1.1])\nu1 = v1\nproj = np.dot(v2, u1)/np.dot(u1, u1)*u1\nu2 = v2 - proj\nprint('Orthogonal vectors:', u1, u2)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize [1, 0], [1, 1].",
        "output": "import numpy as np\nv1 = np.array([1, 0], dtype=float)\nv2 = np.array([1, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Find an orthonormal basis for [2, 2], [1, -1].",
        "output": "import numpy as np\nv1 = np.array([2, 2], dtype=float)\nv2 = np.array([1, -1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Perform Gram-Schmidt on [1, 2, 3], [4, 5, 6], [7, 8, 10].",
        "output": "import numpy as np\nv = [np.array([1, 2, 3], dtype=float), np.array([4, 5, 6], dtype=float), np.array([7, 8, 10], dtype=float)]\nu = []\nfor i in range(3):\n    ui = v[i].copy()\n    for j in range(i):\n        ui -= np.dot(v[i], u[j]) / np.dot(u[j], u[j]) * u[j]\n    u.append(ui / np.linalg.norm(ui))\nfor i, ui in enumerate(u):\n    print(f'Orthonormal vector u{i+1}: {ui}')"
    },
    {
        "input": "Apply Gram-Schmidt to [2, 0], [0, 2].",
        "output": "import numpy as np\nv1 = np.array([2, 0], dtype=float)\nv2 = np.array([0, 2], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt on [3, 1], [1, 3].",
        "output": "import numpy as np\nv1 = np.array([3, 1], dtype=float)\nv2 = np.array([1, 3], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Orthonormalize [1, 1, 0], [1, 0, 1], [0, 1, 1] using Gram-Schmidt.",
        "output": "import numpy as np\nv = [np.array([1, 1, 0], dtype=float), np.array([1, 0, 1], dtype=float), np.array([0, 1, 1], dtype=float)]\nu = []\nfor i in range(3):\n    ui = v[i].copy()\n    for j in range(i):\n        ui -= np.dot(v[i], u[j]) / np.dot(u[j], u[j]) * u[j]\n    u.append(ui / np.linalg.norm(ui))\nfor i, ui in enumerate(u):\n    print(f'Orthonormal vector u{i+1}: {ui}')"
    },
    {
        "input": "Find orthogonal basis for [1, 2, 1], [2, 1, -1].",
        "output": "import numpy as np\nv1 = np.array([1, 2, 1], dtype=float)\nv2 = np.array([2, 1, -1], dtype=float)\nu1 = v1\nproj = np.dot(v2, u1)/np.dot(u1, u1) * u1\nu2 = v2 - proj\nprint(f'Orthogonal basis: {u1}, {u2}')"
    },
    {
        "input": "Apply Gram-Schmidt to [1, 1, 1], [1, 2, 3].",
        "output": "import numpy as np\nv1 = np.array([1, 1, 1], dtype=float)\nv2 = np.array([1, 2, 3], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1)*u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Orthonormalize [1, 2], [2, 1].",
        "output": "import numpy as np\nv1 = np.array([1, 2], dtype=float)\nv2 = np.array([2, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1)*u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Find orthonormal set for [0, 1, 0], [1, 0, 1].",
        "output": "import numpy as np\nv1 = np.array([0, 1, 0], dtype=float)\nv2 = np.array([1, 0, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1)*u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize [2, 1, 3], [1, 0, 1].",
        "output": "import numpy as np\nv1 = np.array([2, 1, 3], dtype=float)\nv2 = np.array([1, 0, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Find an orthonormal basis for [1, 1, 0], [0, 1, 1].",
        "output": "import numpy as np\nv1 = np.array([1, 1, 0], dtype=float)\nv2 = np.array([0, 1, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Apply Gram-Schmidt to [3, 0, 1], [2, 1, 0], [1, 1, 1].",
        "output": "import numpy as np\nv = [np.array([3, 0, 1], dtype=float), np.array([2, 1, 0], dtype=float), np.array([1, 1, 1], dtype=float)]\nu = []\nfor i in range(3):\n    ui = v[i].copy()\n    for j in range(i):\n        ui -= np.dot(v[i], u[j]) / np.dot(u[j], u[j]) * u[j]\n    u.append(ui / np.linalg.norm(ui))\nfor i, ui in enumerate(u):\n    print(f'Orthonormal vector u{i+1}: {ui}')"
    },
    {
        "input": "Orthonormalize [1, 0, 1], [0, 1, 1].",
        "output": "import numpy as np\nv1 = np.array([1, 0, 1], dtype=float)\nv2 = np.array([0, 1, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Perform Gram-Schmidt on [2, 1], [3, 4].",
        "output": "import numpy as np\nv1 = np.array([2, 1], dtype=float)\nv2 = np.array([3, 4], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt to find orthonormal vectors from [2, 2, 1], [1, -1, 0].",
        "output": "import numpy as np\nv1 = np.array([2, 2, 1], dtype=float)\nv2 = np.array([1, -1, 0], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Apply Gram-Schmidt on [1, 1, 1], [1, -1, 0], [0, 1, -1].",
        "output": "import numpy as np\nv = [np.array([1, 1, 1], dtype=float), np.array([1, -1, 0], dtype=float), np.array([0, 1, -1], dtype=float)]\nu = []\nfor i in range(3):\n    ui = v[i].copy()\n    for j in range(i):\n        ui -= np.dot(v[i], u[j]) / np.dot(u[j], u[j]) * u[j]\n    u.append(ui / np.linalg.norm(ui))\nfor i, ui in enumerate(u):\n    print(f'Orthonormal vector u{i+1}: {ui}')"
    },
    {
        "input": "Find orthonormal basis using Gram-Schmidt for [1, 2, 2], [2, 1, -1].",
        "output": "import numpy as np\nv1 = np.array([1, 2, 2], dtype=float)\nv2 = np.array([2, 1, -1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Orthonormalize [1, 0], [2, 1].",
        "output": "import numpy as np\nv1 = np.array([1, 0], dtype=float)\nv2 = np.array([2, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Perform Gram-Schmidt on [2, 1, 0], [0, 1, 2].",
        "output": "import numpy as np\nv1 = np.array([2, 1, 0], dtype=float)\nv2 = np.array([0, 1, 2], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt on [1, 3], [3, 1].",
        "output": "import numpy as np\nv1 = np.array([1, 3], dtype=float)\nv2 = np.array([3, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Apply Gram-Schmidt to [4, 0, 0], [1, 1, 0], [0, 1, 1].",
        "output": "import numpy as np\nv = [np.array([4, 0, 0], dtype=float), np.array([1, 1, 0], dtype=float), np.array([0, 1, 1], dtype=float)]\nu = []\nfor i in range(3):\n    ui = v[i].copy()\n    for j in range(i):\n        ui -= np.dot(v[i], u[j]) / np.dot(u[j], u[j]) * u[j]\n    u.append(ui / np.linalg.norm(ui))\nfor i, ui in enumerate(u):\n    print(f'Orthonormal vector u{i+1}: {ui}')"
    },
    {
        "input": "Find orthonormal set for [1, 0, 0], [0, 2, 0], [0, 0, 3].",
        "output": "import numpy as np\nv = [np.array([1, 0, 0], dtype=float), np.array([0, 2, 0], dtype=float), np.array([0, 0, 3], dtype=float)]\nu = [v[i]/np.linalg.norm(v[i]) for i in range(3)]\nfor i, ui in enumerate(u):\n    print(f'Orthonormal vector u{i+1}: {ui}')"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize [1, -1, 0], [1, 1, 1].",
        "output": "import numpy as np\nv1 = np.array([1, -1, 0], dtype=float)\nv2 = np.array([1, 1, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Find orthonormal basis for [0, 1, 0], [1, 1, 1].",
        "output": "import numpy as np\nv1 = np.array([0, 1, 0], dtype=float)\nv2 = np.array([1, 1, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize [1, 2, 2], [2, 4, 4].",
        "output": "import numpy as np\nv1 = np.array([1, 2, 2], dtype=float)\nv2 = np.array([2, 4, 4], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nif np.linalg.norm(u2) != 0:\n    u2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Apply Gram-Schmidt on [3, 1, 2], [1, 0, 1], [1, 2, 0].",
        "output": "import numpy as np\nv = [np.array([3, 1, 2], dtype=float), np.array([1, 0, 1], dtype=float), np.array([1, 2, 0], dtype=float)]\nu = []\nfor i in range(3):\n    ui = v[i].copy()\n    for j in range(i):\n        ui -= np.dot(v[i], u[j]) / np.dot(u[j], u[j]) * u[j]\n    u.append(ui / np.linalg.norm(ui))\nfor i, vec in enumerate(u):\n    print(f'Orthonormal vector u{i+1}: {vec}')"
    },
    {
        "input": "Find orthonormal set for [2, 1], [1, 3].",
        "output": "import numpy as np\nv1 = np.array([2, 1], dtype=float)\nv2 = np.array([1, 3], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal set: {u1}, {u2}')"
    },
    {
        "input": "Perform Gram-Schmidt on [4, 1, 3], [2, 1, 0].",
        "output": "import numpy as np\nv1 = np.array([4, 1, 3], dtype=float)\nv2 = np.array([2, 1, 0], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Orthonormalize [0, 3, 4], [1, 2, 3].",
        "output": "import numpy as np\nv1 = np.array([0, 3, 4], dtype=float)\nv2 = np.array([1, 2, 3], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt on [2, 0, 1], [1, 1, 0], [0, 1, 1].",
        "output": "import numpy as np\nv = [np.array([2, 0, 1], dtype=float), np.array([1, 1, 0], dtype=float), np.array([0, 1, 1], dtype=float)]\nu = []\nfor i in range(3):\n    ui = v[i].copy()\n    for j in range(i):\n        ui -= np.dot(v[i], u[j]) / np.dot(u[j], u[j]) * u[j]\n    u.append(ui / np.linalg.norm(ui))\nfor i, ui in enumerate(u):\n    print(f'Orthonormal vector u{i+1}: {ui}')"
    },
    {
        "input": "Find an orthonormal basis from [3, 3, 1], [1, 2, 3].",
        "output": "import numpy as np\nv1 = np.array([3, 3, 1], dtype=float)\nv2 = np.array([1, 2, 3], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Orthonormalize the set [1, 1], [1, -1].",
        "output": "import numpy as np\nv1 = np.array([1, 1], dtype=float)\nv2 = np.array([1, -1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Apply Gram-Schmidt to [0, 0, 1], [0, 1, 0], [1, 0, 0].",
        "output": "import numpy as np\nv = [np.array([0, 0, 1], dtype=float), np.array([0, 1, 0], dtype=float), np.array([1, 0, 0], dtype=float)]\nu = [v[i]/np.linalg.norm(v[i]) for i in range(3)]\nfor i, ui in enumerate(u):\n    print(f'Orthonormal vector u{i+1}: {ui}')"
    },
    {
        "input": "Use Gram-Schmidt for [1, 2], [2, -1].",
        "output": "import numpy as np\nv1 = np.array([1, 2], dtype=float)\nv2 = np.array([2, -1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Orthonormalize [2, 2], [2, -2].",
        "output": "import numpy as np\nv1 = np.array([2, 2], dtype=float)\nv2 = np.array([2, -2], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nif np.linalg.norm(u2) != 0:\n    u2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal set: {u1}, {u2}')"
    },
    {
        "input": "Apply Gram-Schmidt to [4, 0, 0], [0, 3, 0], [0, 0, 2].",
        "output": "import numpy as np\nv = [np.array([4, 0, 0], dtype=float), np.array([0, 3, 0], dtype=float), np.array([0, 0, 2], dtype=float)]\nu = [v[i]/np.linalg.norm(v[i]) for i in range(3)]\nfor i, ui in enumerate(u):\n    print(f'Orthonormal vector u{i+1}: {ui}')"
    },
    {
        "input": "Use Gram-Schmidt on [2, 3], [5, 7].",
        "output": "import numpy as np\nv1 = np.array([2, 3], dtype=float)\nv2 = np.array([5, 7], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Find orthonormal basis for [1, 2, 3], [4, 5, 6].",
        "output": "import numpy as np\nv1 = np.array([1, 2, 3], dtype=float)\nv2 = np.array([4, 5, 6], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Perform Gram-Schmidt on [2, 1, 1], [1, 2, 2].",
        "output": "import numpy as np\nv1 = np.array([2, 1, 1], dtype=float)\nv2 = np.array([1, 2, 2], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal set: {u1}, {u2}')"
    },
    {
        "input": "Orthonormalize [3, 2], [2, 3].",
        "output": "import numpy as np\nv1 = np.array([3, 2], dtype=float)\nv2 = np.array([2, 3], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal basis: {u1}, {u2}')"
    },
    {
        "input": "Apply Gram-Schmidt on [5, 0], [0, 12].",
        "output": "import numpy as np\nv1 = np.array([5, 0], dtype=float)\nv2 = np.array([0, 12], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nu2 = v2 / np.linalg.norm(v2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Use Gram-Schmidt to find orthonormal vectors from [1, 4, 5], [2, 0, 1].",
        "output": "import numpy as np\nv1 = np.array([1, 4, 5], dtype=float)\nv2 = np.array([2, 0, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(f'Orthonormal vectors: {u1}, {u2}')"
    },
    {
        "input": "Perform Gram-Schmidt on [2, 2, 2], [1, 0, 0], [0, 1, 1].",
        "output": "import numpy as np\nv = [np.array([2, 2, 2], dtype=float), np.array([1, 0, 0], dtype=float), np.array([0, 1, 1], dtype=float)]\nu = []\nfor i in range(3):\n    ui = v[i].copy()\n    for j in range(i):\n        ui -= np.dot(v[i], u[j]) / np.dot(u[j], u[j]) * u[j]\n    u.append(ui / np.linalg.norm(ui))\nfor i, vec in enumerate(u):\n    print(f'Orthonormal vector u{i+1}: {vec}')"
    },
    {
        "input": "Find the QR decomposition of the matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2], [3, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[2, 1], [1, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 1], [1, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute the QR decomposition of the matrix [[4, 3], [6, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 3], [6, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get the QR decomposition of matrix [[1, 0], [0, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 0], [0, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Determine the QR decomposition of [[1, 1], [1, -1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 1], [1, -1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "What is the QR decomposition of [[3, 1], [2, 2]]?",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 1], [2, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition for matrix [[2, 2], [2, -2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 2], [2, -2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get QR decomposition of matrix [[5, 2], [2, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5, 2], [2, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[0, 1], [1, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0, 1], [1, 0]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition for [[6, 8], [3, 4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6, 8], [3, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]] using QR decomposition.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of matrix [[9, 8, 7], [6, 5, 4], [3, 2, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[9, 8, 7], [6, 5, 4], [3, 2, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute the QR decomposition for [[1, 0, 0], [0, 1, 0], [0, 0, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get QR decomposition of the matrix [[2, 3, 4], [1, 0, 1], [3, 2, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 3, 4], [1, 0, 1], [3, 2, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Determine QR decomposition of [[4, 1, 3], [2, 6, 8], [1, 1, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 1, 3], [2, 6, 8], [1, 1, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of matrix [[7, 5, 3], [2, 1, 6], [8, 4, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7, 5, 3], [2, 1, 6], [8, 4, 0]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[1, 2, 1], [3, 4, 1], [5, 6, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2, 1], [3, 4, 1], [5, 6, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose matrix [[5, 3], [1, 7], [4, 2]] using QR decomposition.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5, 3], [1, 7], [4, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on matrix [[1, 4], [2, 5], [3, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 4], [2, 5], [3, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get QR decomposition of matrix [[6, 5], [3, 2], [0, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6, 5], [3, 2], [0, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose matrix [[7, 8], [9, 10], [11, 12]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7, 8], [9, 10], [11, 12]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute the QR decomposition of [[3, 1, 4], [1, 5, 9], [2, 6, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 1, 4], [1, 5, 9], [2, 6, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose matrix [[2, 7], [1, 8], [2, 8]] using QR decomposition.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 7], [1, 8], [2, 8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition of [[0, 2, 4], [1, 3, 5], [2, 4, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0, 2, 4], [1, 3, 5], [2, 4, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get the QR decomposition of matrix [[1, 2, 3], [4, 5, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2, 3], [4, 5, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of the matrix [[3, 4], [4, -3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 4], [4, -3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[0, 1], [2, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0, 1], [2, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute the QR decomposition of the matrix [[8, 6], [6, 8]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[8, 6], [6, 8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get the QR decomposition of matrix [[5, 0], [0, 12]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5, 0], [0, 12]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Determine the QR decomposition of [[6, 0], [8, 15]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6, 0], [8, 15]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "What is the QR decomposition of [[1, 1, 1], [1, 2, 3], [1, 3, 6]]?",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 1, 1], [1, 2, 3], [1, 3, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition for matrix [[2, 4], [1, 3], [0, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 4], [1, 3], [0, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get QR decomposition of matrix [[9, 6], [6, 9], [3, 12]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[9, 6], [6, 9], [3, 12]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[7, 2], [4, 6], [1, 8]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7, 2], [4, 6], [1, 8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition for [[2, 0], [2, 2], [2, 4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 0], [2, 2], [2, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose matrix [[1, 1], [2, 2], [3, 3]] using QR decomposition.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 1], [2, 2], [3, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[10, 2], [5, 1], [0, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[10, 2], [5, 1], [0, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose the matrix [[2, 3], [5, 7], [1, 1]] using QR decomposition.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 3], [5, 7], [1, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of matrix [[2, 3, 1], [4, 6, 2], [0, 0, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 3, 1], [4, 6, 2], [0, 0, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition for [[4, 0, 0], [3, 3, 0], [2, 2, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 0, 0], [3, 3, 0], [2, 2, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[1, 2, 4], [2, 3, 5], [3, 4, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2, 4], [2, 3, 5], [3, 4, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get QR decomposition of matrix [[6, 5, 4], [3, 2, 1], [0, -1, -2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6, 5, 4], [3, 2, 1], [0, -1, -2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition of [[8, 1, 6], [3, 5, 7], [4, 9, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[8, 1, 6], [3, 5, 7], [4, 9, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose matrix [[2, 4, 6], [1, 3, 5], [0, 2, 4]] using QR decomposition.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 4, 6], [1, 3, 5], [0, 2, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition for [[5, 4, 3], [2, 1, 0], [-1, -2, -3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5, 4, 3], [2, 1, 0], [-1, -2, -3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose matrix [[3, 1, 0], [0, 4, 2], [0, 0, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 1, 0], [0, 4, 2], [0, 0, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get the QR decomposition of [[1, 3], [0, 4], [5, 9]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 3], [0, 4], [5, 9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose matrix [[9, 0], [4, 1], [6, 2]] using QR decomposition.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[9, 0], [4, 1], [6, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on matrix [[5, 5], [5, -5], [10, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5, 5], [5, -5], [10, 0]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of matrix [[2, 3, 4], [0, 1, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 3, 4], [0, 1, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of the matrix [[1, 0], [1, 1], [1, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 0], [1, 1], [1, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[2, 1], [1, 2], [0, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 1], [1, 2], [0, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition of matrix [[4, 3], [2, 1], [1, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 3], [2, 1], [1, 0]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get the QR decomposition of [[0, 1], [1, 0], [1, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0, 1], [1, 0], [1, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Determine QR decomposition for matrix [[3, 2, 1], [1, 0, 1], [4, 1, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 2, 1], [1, 0, 1], [4, 1, 0]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[1, 2, 3], [4, 5, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2, 3], [4, 5, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[2, 3, 5], [4, 6, 10]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 3, 5], [4, 6, 10]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition for [[7, 0, 5], [0, 7, 1], [5, 1, 7]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7, 0, 5], [0, 7, 1], [5, 1, 7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[5, 5, 5], [1, 1, 1], [3, 3, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5, 5, 5], [1, 1, 1], [3, 3, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get the QR decomposition of [[3, 4], [0, 5], [8, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 4], [0, 5], [8, 0]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition of matrix [[2, 0, 1], [1, 1, 1], [3, 5, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 0, 1], [1, 1, 1], [3, 5, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute the QR decomposition of [[9, 8, 7], [6, 5, 4], [3, 2, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[9, 8, 7], [6, 5, 4], [3, 2, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[10, 0, 0], [0, 10, 0], [0, 0, 10]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[10, 0, 0], [0, 10, 0], [0, 0, 10]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[1, 4], [2, 5], [3, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 4], [2, 5], [3, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition of matrix [[0, 0, 1], [0, 1, 0], [1, 0, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0, 0, 1], [0, 1, 0], [1, 0, 0]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose matrix [[6, 1, 0], [1, 6, 1], [0, 1, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6, 1, 0], [1, 6, 1], [0, 1, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[3, 2, 1], [6, 5, 4], [9, 8, 7]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 2, 1], [6, 5, 4], [9, 8, 7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition of matrix [[4, 3, 2], [1, 6, 5], [7, 8, 9]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 3, 2], [1, 6, 5], [7, 8, 9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose matrix [[1, 3], [2, 6], [3, 9]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 3], [2, 6], [3, 9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition of matrix [[3, 0, 4], [0, 5, 0], [4, 0, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 0, 4], [0, 5, 0], [4, 0, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose matrix [[2, 3, 1], [6, 9, 3], [1, 1, 1]] using QR.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 3, 1], [6, 9, 3], [1, 1, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[1, 2], [2, 4], [3, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2], [2, 4], [3, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get QR decomposition of matrix [[4, 1, 2], [2, 3, 0], [6, 5, 9]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 1, 2], [2, 3, 0], [6, 5, 9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition of [[2, 1, 3], [1, 1, 1], [0, 1, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 1, 3], [1, 1, 1], [0, 1, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[2, 2], [1, 3], [0, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 2], [1, 3], [0, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute the QR decomposition of [[4, 0], [3, 1], [2, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 0], [3, 1], [2, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get QR decomposition of [[0, 1], [2, 2], [4, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0, 1], [2, 2], [4, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[1, 2, 3], [0, 1, 4], [5, 6, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2, 3], [0, 1, 4], [5, 6, 0]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[3, 0, 1], [1, 2, 3], [2, 1, 4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 0, 1], [1, 2, 3], [2, 1, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on matrix [[4, 2], [3, 5], [1, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 2], [3, 5], [1, 0]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute the QR decomposition of [[1, 0, 0], [0, 1, 0], [0, 0, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[2, 3], [2, 3], [2, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 3], [2, 3], [2, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get the QR decomposition of [[7, 1], [2, 5], [3, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7, 1], [2, 5], [3, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose matrix [[3, 2], [1, 4], [6, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 2], [1, 4], [6, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition of [[5, 1], [6, 2], [7, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5, 1], [6, 2], [7, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[1, 4, 7], [2, 5, 8], [3, 6, 9]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 4, 7], [2, 5, 8], [3, 6, 9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition of [[3, 0, 1], [2, 4, 0], [1, 2, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 0, 1], [2, 4, 0], [1, 2, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose matrix [[6, 2], [3, 5], [0, 1]] using QR.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6, 2], [3, 5], [0, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition for [[2, 5, 8], [1, 3, 6], [0, 2, 4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 5, 8], [1, 3, 6], [0, 2, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[0, 2, 1], [1, 0, 3], [2, 1, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0, 2, 1], [1, 0, 3], [2, 1, 0]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[1, 2, 3], [4, 5, 6], [7, 8, 10]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 10]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on matrix [[2, 0], [2, 2], [1, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 0], [2, 2], [1, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get the QR decomposition of [[0, 1, 2], [2, 4, 6], [3, 6, 9]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0, 1, 2], [2, 4, 6], [3, 6, 9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose matrix [[3, 5], [2, 4], [1, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 5], [2, 4], [1, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose matrix [[5, 0], [4, 1], [3, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5, 0], [4, 1], [3, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition of [[2, 1], [1, 2], [0, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 1], [1, 2], [0, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[4, 4], [2, 2], [1, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 4], [2, 2], [1, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose matrix [[1, 3, 5], [2, 4, 6], [0, 1, 2]] using QR.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 3, 5], [2, 4, 6], [0, 1, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition of matrix [[2, 4], [0, 3], [1, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 4], [0, 3], [1, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[6, 1], [3, 5], [2, 4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6, 1], [3, 5], [2, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose matrix [[5, 5], [1, 2], [3, 4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5, 5], [1, 2], [3, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decomposition of [[1, 0], [2, 2], [3, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 0], [2, 2], [3, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose [[4, 1], [1, 3], [5, 2]] using QR method.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 1], [1, 3], [5, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decomposition of [[1, 2, 3], [4, 5, 6], [7, 9, 8]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 9, 8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get the QR decomposition of [[3, 1], [2, 6], [1, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 1], [2, 6], [1, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on [[4, 0, 1], [2, 1, 3], [0, 3, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 0, 1], [2, 1, 3], [0, 3, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[3, 4, 5], [6, 7, 8], [9, 0, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 4, 5], [6, 7, 8], [9, 0, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition of [[0, 2], [1, 4], [2, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0, 2], [1, 4], [2, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose matrix [[5, 1], [6, 0], [7, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5, 1], [6, 0], [7, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition of [[1, 1, 1], [2, 3, 4], [3, 5, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 1, 1], [2, 3, 4], [3, 5, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get the QR decomposition of [[2, 3], [5, 1], [4, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 3], [5, 1], [4, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose matrix [[0, 1], [1, 0], [1, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0, 1], [1, 0], [1, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose [[7, 8], [2, 3], [1, 4]] using QR.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7, 8], [2, 3], [1, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[3, 2, 1], [6, 5, 4], [9, 8, 7]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 2, 1], [6, 5, 4], [9, 8, 7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[4, 6], [5, 3], [7, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 6], [5, 3], [7, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decomposition of matrix [[8, 3], [6, 4], [5, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[8, 3], [6, 4], [5, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get the QR decomposition of [[2, 5], [1, 3], [3, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 5], [1, 3], [3, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose matrix [[9, 2], [7, 4], [3, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[9, 2], [7, 4], [3, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition of [[1, 2], [3, 4], [4, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2], [3, 4], [4, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[1, 3, 2], [4, 1, 5], [6, 2, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 3, 2], [4, 1, 5], [6, 2, 0]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[1, 4], [0, 2], [5, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 4], [0, 2], [5, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute the QR decomposition of [[2, 2], [4, 1], [1, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 2], [4, 1], [1, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of matrix [[1, 3], [2, 5], [4, 7]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 3], [2, 5], [4, 7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on [[2, 4, 6], [1, 3, 5], [0, 2, 4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 4, 6], [1, 3, 5], [0, 2, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[4, 3], [2, 1], [6, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 3], [2, 1], [6, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition of matrix [[7, 2], [4, 3], [5, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7, 2], [4, 3], [5, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose matrix [[9, 1], [3, 7], [2, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[9, 1], [3, 7], [2, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decomposition of [[3, 6], [5, 2], [7, 8]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 6], [5, 2], [7, 8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition of [[1, 0, 2], [0, 1, 3], [4, 5, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 0, 2], [0, 1, 3], [4, 5, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition of [[2, 0], [1, 2], [3, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 0], [1, 2], [3, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[6, 1], [3, 2], [1, 4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6, 1], [3, 2], [1, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[8, 3, 1], [2, 6, 4], [0, 5, 7]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[8, 3, 1], [2, 6, 4], [0, 5, 7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decomposition of [[5, 5], [3, 1], [0, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5, 5], [3, 1], [0, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[0, 6], [7, 2], [4, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0, 6], [7, 2], [4, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose matrix [[1, 1, 1], [2, 4, 2], [3, 6, 3]] using QR.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 1, 1], [2, 4, 2], [3, 6, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute the QR decomposition of [[3, 1], [0, 2], [4, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 1], [0, 2], [4, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose matrix [[2, 3, 1], [4, 5, 0], [6, 7, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 3, 1], [4, 5, 0], [6, 7, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decomposition of [[1, 2], [3, 0], [5, 4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2], [3, 0], [5, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition of [[1, 3, 5], [2, 4, 6], [0, 1, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 3, 5], [2, 4, 6], [0, 1, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on [[7, 8], [2, 1], [3, 4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7, 8], [2, 1], [3, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[2, 1, 0], [4, 3, 5], [6, 7, 8]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 1, 0], [4, 3, 5], [6, 7, 8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get QR decomposition of [[3, 0], [0, 4], [5, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 0], [0, 4], [5, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[1, 1], [2, 3], [3, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 1], [2, 3], [3, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute the QR decomposition of [[4, 2], [3, 1], [7, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 2], [3, 1], [7, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[1, 0, 1], [2, 1, 2], [3, 2, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 0, 1], [2, 1, 2], [3, 2, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[5, 4], [0, 3], [6, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5, 4], [0, 3], [6, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of matrix [[3, 1], [6, 5], [2, 4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 1], [6, 5], [2, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on matrix [[2, 3, 1], [1, 0, 4], [5, 2, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 3, 1], [1, 0, 4], [5, 2, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[4, 5], [2, 1], [6, 7]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 5], [2, 1], [6, 7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[1, 3], [4, 2], [7, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 3], [4, 2], [7, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition of [[0, 1, 2], [3, 4, 5], [6, 7, 8]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose matrix [[2, 1], [3, 2], [4, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 1], [3, 2], [4, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition of matrix [[9, 8], [4, 3], [7, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[9, 8], [4, 3], [7, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition of [[2, 4, 1], [0, 5, 3], [1, 2, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 4, 1], [0, 5, 3], [1, 2, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[3, 5], [1, 2], [6, 4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 5], [1, 2], [6, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition of matrix [[5, 0, 1], [2, 3, 4], [6, 7, 8]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5, 0, 1], [2, 3, 4], [6, 7, 8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decomposition of [[4, 2], [0, 3], [5, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 2], [0, 3], [5, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[1, 5, 3], [2, 6, 4], [3, 7, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 5, 3], [2, 6, 4], [3, 7, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get QR decomposition of [[8, 2], [1, 3], [5, 7]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[8, 2], [1, 3], [5, 7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[3, 6], [2, 5], [7, 8]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 6], [2, 5], [7, 8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decomposition of [[1, 4, 7], [2, 5, 8], [3, 6, 9]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 4, 7], [2, 5, 8], [3, 6, 9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition for [[4, 0], [3, 2], [1, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 0], [3, 2], [1, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose matrix [[5, 1, 0], [6, 2, 1], [7, 3, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5, 1, 0], [6, 2, 1], [7, 3, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[2, 3], [4, 5], [0, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 3], [4, 5], [0, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decomposition of [[7, 8], [5, 2], [3, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7, 8], [5, 2], [3, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[0, 1], [1, 2], [2, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0, 1], [1, 2], [2, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decomposition of matrix [[6, 5, 4], [3, 2, 1], [9, 8, 7]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6, 5, 4], [3, 2, 1], [9, 8, 7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition of [[1, 2], [2, 3], [3, 4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2], [2, 3], [3, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[3, 1, 2], [4, 2, 1], [5, 3, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 1, 2], [4, 2, 1], [5, 3, 0]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute the QR decomposition of [[8, 4], [2, 1], [3, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[8, 4], [2, 1], [3, 0]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[6.12, 3.94, 2.25], [0.78, 4.34, 0.14], [7.17, 5.1, 4.4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6.12, 3.94, 2.25], [0.78, 4.34, 0.14], [7.17, 5.1, 4.4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[7.46, 2.0, 6.7], [6.49, 5.83, 0.2], [0.26, 1.08, 4.69]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7.46, 2.0, 6.7], [6.49, 5.83, 0.2], [0.26, 1.08, 4.69]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[4.47, 6.76, 5.27], [7.36, 2.7, 5.28], [0.59, 2.38, 3.34]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4.47, 6.76, 5.27], [7.36, 2.7, 5.28], [0.59, 2.38, 3.34]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[1.56, 4.82, 6.19], [3.91, 2.85, 5.6], [4.8, 7.1, 1.09]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.56, 4.82, 6.19], [3.91, 2.85, 5.6], [4.8, 7.1, 1.09]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[5.99, 1.72, 4.46], [4.89, 2.33, 7.91], [1.77, 3.8, 5.62]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5.99, 1.72, 4.46], [4.89, 2.33, 7.91], [1.77, 3.8, 5.62]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[6.42, 4.78, 2.56], [3.96, 1.19, 5.37], [7.81, 6.92, 0.64]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6.42, 4.78, 2.56], [3.96, 1.19, 5.37], [7.81, 6.92, 0.64]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[2.13, 5.42, 3.31], [4.78, 6.23, 0.58], [1.9, 2.95, 4.26]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.13, 5.42, 3.31], [4.78, 6.23, 0.58], [1.9, 2.95, 4.26]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[7.67, 2.15, 6.78], [4.36, 5.27, 1.46], [3.88, 4.44, 2.96]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7.67, 2.15, 6.78], [4.36, 5.27, 1.46], [3.88, 4.44, 2.96]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[1.35, 3.9, 6.04], [2.64, 4.73, 0.72], [6.88, 2.95, 1.81]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.35, 3.9, 6.04], [2.64, 4.73, 0.72], [6.88, 2.95, 1.81]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[4.9, 1.26, 7.13], [5.85, 6.77, 3.25], [0.38, 2.49, 1.62]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4.9, 1.26, 7.13], [5.85, 6.77, 3.25], [0.38, 2.49, 1.62]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[6.22, 2.53, 4.75], [0.83, 3.67, 5.04], [5.91, 6.13, 0.79]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6.22, 2.53, 4.75], [0.83, 3.67, 5.04], [5.91, 6.13, 0.79]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[2.18, 6.31, 3.94], [5.27, 3.07, 2.16], [7.74, 0.98, 4.88]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.18, 6.31, 3.94], [5.27, 3.07, 2.16], [7.74, 0.98, 4.88]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[5.33, 4.19, 6.42], [1.97, 3.85, 0.64], [2.91, 5.17, 7.53]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5.33, 4.19, 6.42], [1.97, 3.85, 0.64], [2.91, 5.17, 7.53]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[6.11, 2.88, 5.93], [7.28, 4.91, 1.3], [0.55, 3.67, 2.48]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6.11, 2.88, 5.93], [7.28, 4.91, 1.3], [0.55, 3.67, 2.48]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[1.89, 7.04, 3.27], [2.46, 5.62, 4.15], [3.61, 0.98, 6.79]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.89, 7.04, 3.27], [2.46, 5.62, 4.15], [3.61, 0.98, 6.79]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[0.96, 3.48, 6.79], [4.55, 1.89, 7.25], [2.73, 6.01, 0.77]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0.96, 3.48, 6.79], [4.55, 1.89, 7.25], [2.73, 6.01, 0.77]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[7.85, 2.14, 5.66], [3.32, 4.58, 1.12], [6.47, 3.79, 2.83]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7.85, 2.14, 5.66], [3.32, 4.58, 1.12], [6.47, 3.79, 2.83]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[1.24, 5.91, 2.47], [6.81, 3.03, 4.62], [3.89, 0.78, 7.18]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.24, 5.91, 2.47], [6.81, 3.03, 4.62], [3.89, 0.78, 7.18]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[4.26, 6.38, 0.94], [2.67, 1.88, 5.27], [5.9, 3.61, 4.05]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4.26, 6.38, 0.94], [2.67, 1.88, 5.27], [5.9, 3.61, 4.05]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[3.74, 1.82, 6.54], [4.97, 7.09, 0.68], [2.45, 5.16, 3.27]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3.74, 1.82, 6.54], [4.97, 7.09, 0.68], [2.45, 5.16, 3.27]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[2.34, 4.25, 5.91], [6.13, 0.67, 3.86], [1.29, 7.42, 2.78]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.34, 4.25, 5.91], [6.13, 0.67, 3.86], [1.29, 7.42, 2.78]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[5.48, 3.3, 1.76], [2.53, 6.86, 4.18], [7.07, 0.94, 5.92]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5.48, 3.3, 1.76], [2.53, 6.86, 4.18], [7.07, 0.94, 5.92]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[3.05, 6.14, 2.97], [5.74, 1.26, 4.87], [0.93, 3.78, 7.61]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3.05, 6.14, 2.97], [5.74, 1.26, 4.87], [0.93, 3.78, 7.61]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[2.64, 7.53, 1.48], [3.25, 4.61, 5.98], [6.87, 2.49, 3.65]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.64, 7.53, 1.48], [3.25, 4.61, 5.98], [6.87, 2.49, 3.65]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[6.03, 1.18, 3.79], [5.45, 4.62, 2.34], [0.67, 6.95, 7.22]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6.03, 1.18, 3.79], [5.45, 4.62, 2.34], [0.67, 6.95, 7.22]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[4.21, 3.17, 6.88], [0.88, 5.69, 2.31], [6.49, 1.85, 7.67]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4.21, 3.17, 6.88], [0.88, 5.69, 2.31], [6.49, 1.85, 7.67]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[7.55, 2.62, 4.41], [1.38, 3.53, 6.11], [5.6, 0.84, 3.96]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7.55, 2.62, 4.41], [1.38, 3.53, 6.11], [5.6, 0.84, 3.96]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of the matrix [[1.5, 2.3], [3.1, 4.7]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.5, 2.3], [3.1, 4.7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose the matrix [[0.9, 1.4, 2.1], [3.2, 0.5, 1.3]] using QR decomposition.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0.9, 1.4, 2.1], [3.2, 0.5, 1.3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Calculate the QR decomposition of [[2.4, 0.6], [1.8, 3.3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.4, 0.6], [1.8, 3.3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[3.5, 1.1], [2.2, 4.6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3.5, 1.1], [2.2, 4.6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute the QR decomposition of the matrix [[1.2, 0.7, 2.6], [3.5, 4.2, 1.9]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.2, 0.7, 2.6], [3.5, 4.2, 1.9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition for [[2.1, 1.1], [1.3, 3.7]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.1, 1.1], [1.3, 3.7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on [[4.5, 2.1], [0.3, 1.7]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4.5, 2.1], [0.3, 1.7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get the QR decomposition of [[1.6, 0.9], [2.2, 4.8]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.6, 0.9], [2.2, 4.8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition of the matrix [[3.1, 2.7], [0.4, 1.6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3.1, 2.7], [0.4, 1.6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition for matrix [[2.9, 0.8, 3.3], [1.1, 2.6, 0.4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.9, 0.8, 3.3], [1.1, 2.6, 0.4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition of [[0.6, 3.4], [2.5, 1.9]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0.6, 3.4], [2.5, 1.9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[1.3, 2.1, 0.5], [3.6, 4.1, 1.8]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.3, 2.1, 0.5], [3.6, 4.1, 1.8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Use QR decomposition on matrix [[4.2, 0.9], [3.3, 1.5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4.2, 0.9], [3.3, 1.5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[1.5, 3.2], [2.8, 0.4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.5, 3.2], [2.8, 0.4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[0.2, 1.1, 2.9], [3.4, 0.7, 1.2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0.2, 1.1, 2.9], [3.4, 0.7, 1.2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition for [[2.6, 1.3], [4.0, 2.5]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.6, 1.3], [4.0, 2.5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose [[1.8, 2.2], [3.9, 0.6]] using QR method.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.8, 2.2], [3.9, 0.6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[0.4, 1.9, 2.5], [3.7, 2.6, 1.1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0.4, 1.9, 2.5], [3.7, 2.6, 1.1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on matrix [[2.2, 3.6], [1.0, 4.4]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.2, 3.6], [1.0, 4.4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition for matrix [[3.0, 1.5], [2.1, 0.6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3.0, 1.5], [2.1, 0.6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition of matrix [[4.1, 2.3], [0.8, 1.6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4.1, 2.3], [0.8, 1.6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get the QR decomposition of matrix [[0.3, 1.6, 2.8], [3.9, 0.4, 1.7]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0.3, 1.6, 2.8], [3.9, 0.4, 1.7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on [[1.9, 2.3], [0.5, 3.2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.9, 2.3], [0.5, 3.2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[2.0, 3.1], [4.3, 1.8]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.0, 3.1], [4.3, 1.8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[3.2, -4.5], [1.1, 2.6]] and print Q and R.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3.2, -4.5], [1.1, 2.6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of the matrix [[-5.1, 3.3], [2.7, -1.4]] and display Q and R.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[-5.1, 3.3], [2.7, -1.4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Using QR decomposition, decompose the matrix [[4.5, 7.2], [1.3, -2.1]] and print the result.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4.5, 7.2], [1.3, -2.1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose the matrix [[6.1, -3.2, 4.4], [2.9, 7.3, -1.1], [1.5, 0.6, 3.2]] using QR decomposition.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6.1, -3.2, 4.4], [2.9, 7.3, -1.1], [1.5, 0.6, 3.2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find Q and R from the QR decomposition of [[1.2, 2.5], [3.1, 4.8]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.2, 2.5], [3.1, 4.8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the 3x3 matrix [[7.4, -2.1, 3.6], [1.3, 6.2, -4.9], [5.2, -3.8, 1.1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7.4, -2.1, 3.6], [1.3, 6.2, -4.9], [5.2, -3.8, 1.1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Using QR decomposition, decompose the matrix [[0.5, 2.4], [3.3, 1.1]] and print Q and R.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0.5, 2.4], [3.3, 1.1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute the QR decomposition of [[5.5, 6.7], [7.1, 8.2]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5.5, 6.7], [7.1, 8.2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose [[-3.2, 4.6], [2.1, -5.5]] using QR decomposition and print Q and R.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[-3.2, 4.6], [2.1, -5.5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of the matrix [[3.7, -0.8], [1.9, 2.3]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3.7, -0.8], [1.9, 2.3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[4.5, 5.5, 6.6], [1.1, 2.2, 3.3], [7.7, 8.8, 9.9]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4.5, 5.5, 6.6], [1.1, 2.2, 3.3], [7.7, 8.8, 9.9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Use QR decomposition to decompose [[1.5, 0.5], [0.7, 1.9]] and show Q and R.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.5, 0.5], [0.7, 1.9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Calculate QR decomposition for matrix [[2.3, -3.4], [1.2, 4.8]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.3, -3.4], [1.2, 4.8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find Q and R by decomposing [[9.1, 1.3], [2.4, 8.7]] using QR decomposition.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[9.1, 1.3], [2.4, 8.7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on [[0.2, 3.4], [5.6, -1.1]] and display Q and R.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0.2, 3.4], [5.6, -1.1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute the QR decomposition for [[-1.2, -3.3], [4.5, 6.7]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[-1.2, -3.3], [4.5, 6.7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Use QR decomposition to decompose matrix [[1.4, -2.3], [3.6, 5.8]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.4, -2.3], [3.6, 5.8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[-6.2, 0.9], [3.4, -7.8]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[-6.2, 0.9], [3.4, -7.8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[1.2, 2.4], [3.5, 4.7]] and print both matrices.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.2, 2.4], [3.5, 4.7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get Q and R matrices by decomposing [[0.6, 1.3], [2.8, 3.9]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0.6, 1.3], [2.8, 3.9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition for [[7.2, 5.3], [6.6, 2.1]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7.2, 5.3], [6.6, 2.1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[3.9, -2.4], [1.8, 5.6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3.9, -2.4], [1.8, 5.6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Use QR decomposition to find Q and R of [[4.4, 1.5], [0.3, 2.9]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4.4, 1.5], [0.3, 2.9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition of [[2.5, -0.9], [4.1, 6.6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.5, -0.9], [4.1, 6.6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on the matrix [[1.2, 2.5], [3.6, 4.7]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.2, 2.5], [3.6, 4.7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of the matrix [[5.1, 2.2], [1.0, 3.3]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5.1, 2.2], [1.0, 3.3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition of [[2.4, 3.6], [1.1, 5.9]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.4, 3.6], [1.1, 5.9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find Q and R for matrix [[0.9, 4.2], [3.3, 1.7]] using QR decomposition",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0.9, 4.2], [3.3, 1.7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Use QR decomposition on the matrix [[3.8, 2.6], [6.1, 1.3]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3.8, 2.6], [6.1, 1.3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Do QR decomposition on [[7.4, 2.1], [3.6, 0.4]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7.4, 2.1], [3.6, 0.4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Calculate QR decomposition for [[4.2, 5.5], [2.3, 3.4]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4.2, 5.5], [2.3, 3.4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Break down matrix [[6.5, 7.2], [1.3, 0.8]] using QR decomposition",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6.5, 7.2], [1.3, 0.8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR for [[3.3, 2.2], [4.4, 5.5]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3.3, 2.2], [4.4, 5.5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get the QR decomposition of matrix [[2.6, 4.8], [5.5, 1.2]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.6, 4.8], [5.5, 1.2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[8.1, 3.3], [4.6, 1.5]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[8.1, 3.3], [4.6, 1.5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Use QR method to decompose [[9.2, 2.7], [4.1, 6.6]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[9.2, 2.7], [4.1, 6.6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose matrix [[5.3, 6.6], [2.8, 3.7]] using QR decomposition",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5.3, 6.6], [2.8, 3.7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[7.7, 4.4], [5.5, 1.1]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7.7, 4.4], [5.5, 1.1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "What is the QR decomposition of [[3.5, 1.6], [2.2, 4.3]]?",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3.5, 1.6], [2.2, 4.3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on matrix [[4.5, 2.2], [6.6, 1.4]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4.5, 2.2], [6.6, 1.4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get Q and R matrices from QR decomposition of [[1.2, 0.5], [2.3, 3.8]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.2, 0.5], [2.3, 3.8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[0.8, 2.2], [5.5, 3.1]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0.8, 2.2], [5.5, 3.1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose [[6.2, 1.9], [2.4, 0.6]] using QR decomposition",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6.2, 1.9], [2.4, 0.6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[5.0, 3.3], [7.1, 2.8]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5.0, 3.3], [7.1, 2.8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Break [[3.9, 4.4], [6.6, 7.3]] into Q and R using QR decomposition",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3.9, 4.4], [6.6, 7.3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[2.7, 1.8], [0.9, 4.1]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.7, 1.8], [0.9, 4.1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get Q and R from QR decomposition of [[6.4, 3.2], [4.5, 1.2]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6.4, 3.2], [4.5, 1.2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decomposition for [[3.1, 6.2], [1.1, 2.2]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3.1, 6.2], [1.1, 2.2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Calculate QR decomposition for [[7.2, 1.3], [4.6, 3.9]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7.2, 1.3], [4.6, 3.9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on matrix [[2.5, 3.2], [4.1, 1.7]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.5, 3.2], [4.1, 1.7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of matrix [[0.8, 5.4], [3.3, 2.2]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0.8, 5.4], [3.3, 2.2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Use QR method to decompose [[6.6, 1.5], [2.8, 3.7]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6.6, 1.5], [2.8, 3.7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Calculate QR decomposition of [[4.4, 2.9], [5.1, 3.3]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4.4, 2.9], [5.1, 3.3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get Q and R matrices for [[2.3, 1.1], [6.4, 3.8]] using QR decomposition",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.3, 1.1], [6.4, 3.8]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[7.2, 4.5], [1.8, 0.9]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7.2, 4.5], [1.8, 0.9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Break matrix [[6.3, 1.2], [5.5, 3.4]] using QR decomposition",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6.3, 1.2], [5.5, 3.4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of [[1.7, 3.3], [2.9, 6.1]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.7, 3.3], [2.9, 6.1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition of [[3.6, 2.5], [0.7, 4.9]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3.6, 2.5], [0.7, 4.9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on matrix [[2.2, 1.6], [3.8, 4.7]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.2, 1.6], [3.8, 4.7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Use QR to break [[5.2, 6.3], [1.1, 0.4]] into Q and R",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5.2, 6.3], [1.1, 0.4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR decomposition of [[3.4, 2.2], [1.5, 7.1]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3.4, 2.2], [1.5, 7.1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get the QR decomposition of matrix [[4.6, 1.3], [5.8, 2.7]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4.6, 1.3], [5.8, 2.7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on [[6.9, 5.1], [2.0, 1.5]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6.9, 5.1], [2.0, 1.5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose matrix [[0.7, 4.4], [6.6, 1.2]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0.7, 4.4], [6.6, 1.2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Break down [[2.8, 6.2], [3.3, 1.6]] using QR decomposition",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.8, 6.2], [3.3, 1.6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find Q and R matrices from QR decomposition of [[5.5, 3.8], [0.9, 2.6]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5.5, 3.8], [0.9, 2.6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[1.3, 0.5], [2.2, 3.3]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1.3, 0.5], [2.2, 3.3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR decomposition for [[6.7, 2.1], [3.9, 4.4]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6.7, 2.1], [3.9, 4.4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose [[4.1, 5.9], [1.8, 6.0]] using QR method",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4.1, 5.9], [1.8, 6.0]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of matrix [[3.7, 0.9], [7.2, 3.6]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3.7, 0.9], [7.2, 3.6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Do QR decomposition on matrix [[2.4, 3.5], [5.1, 0.6]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2.4, 3.5], [5.1, 0.6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Break [[0.8, 1.7], [2.6, 4.9]] into Q and R using QR decomposition",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[0.8, 1.7], [2.6, 4.9]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decomposition of [[4.8, 3.2], [1.0, 5.7]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4.8, 3.2], [1.0, 5.7]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR decomposition on matrix [[2, 1], [1, 3]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 1], [1, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[4, 2], [3, 1]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 2], [3, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get Q and R matrices from [[5, 4], [2, 1]] using QR decomposition",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5, 4], [2, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find the QR decomposition of matrix [[1, 7], [2, 6]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 7], [2, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute the QR decomposition of [[3, 5], [2, 4]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 5], [2, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[6, 1], [2, 3]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6, 1], [2, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get QR decomposition of [[7, 2], [4, 3]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7, 2], [4, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Break matrix [[1, 2], [3, 4]] using QR method",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2], [3, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform QR on matrix [[3, 2], [7, 4]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 2], [7, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decomposition of [[8, 5], [1, 3]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[8, 5], [1, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Decompose matrix [[2, 6], [5, 3]] using QR",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 6], [5, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR for matrix [[9, 4], [2, 1]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[9, 4], [2, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get Q and R from [[6, 7], [5, 1]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6, 7], [5, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Break [[4, 8], [1, 6]] into QR form",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 8], [1, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose the matrix [[5, 2], [6, 1]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[5, 2], [6, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR method on matrix [[3, 4], [7, 1]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 4], [7, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Apply QR on matrix [[2, 3], [1, 5]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[2, 3], [1, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get QR decomposition of [[1, 5], [3, 2]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 5], [3, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Compute QR of [[4, 7], [2, 3]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[4, 7], [2, 3]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decompose [[8, 2], [5, 6]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[8, 2], [5, 6]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "QR decomposition of [[3, 6], [4, 2]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[3, 6], [4, 2]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Do QR decomposition on [[7, 5], [2, 4]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[7, 5], [2, 4]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Apply QR method on [[1, 2], [6, 5]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2], [6, 5]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Get QR matrices from [[9, 3], [7, 1]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[9, 3], [7, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Find QR of [[6, 4], [3, 1]]",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[6, 4], [3, 1]])\nQ, R = qr(A)\nprint(\"Q =\", Q)\nprint(\"R =\", R)"
    },
    {
        "input": "Perform PCA on the dataset [[2.5, 2.4], [0.5, 0.7], [2.2, 2.9], [1.9, 2.2], [3.1, 3.0], [2.3, 2.7], [2.0, 1.6], [1.0, 1.1], [1.5, 1.6], [1.1, 0.9]] and reduce it to 1 principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2.5, 2.4],\n              [0.5, 0.7],\n              [2.2, 2.9],\n              [1.9, 2.2],\n              [3.1, 3.0],\n              [2.3, 2.7],\n              [2.0, 1.6],\n              [1.0, 1.1],\n              [1.5, 1.6],\n              [1.1, 0.9]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nprint(\"Reduced Data (1D):\\n\", X_pca)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Perform PCA on 3D data [[1,2,3],[4,5,6],[7,8,9],[10,11,12]] and reduce it to 2 dimensions.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9],\n              [10, 11, 12]])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nprint(\"Reduced Data (2D):\\n\", X_pca)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Given the dataset [[4, 2], [2, 4], [2, 3], [3, 6], [4, 4], [9, 10], [6, 8], [9, 5], [8, 7], [10, 8]], perform PCA and reduce to 2 components. Also print the principal components (eigenvectors).",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4, 2], [2, 4], [2, 3], [3, 6], [4, 4],\n              [9, 10], [6, 8], [9, 5], [8, 7], [10, 8]])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nprint(\"Reduced Data (2D):\\n\", X_pca)\nprint(\"Principal Components (Eigenvectors):\\n\", pca.components_)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 2], [3, 4], [5, 6], [7, 8]] and reduce it to 1 principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nprint(\"Reduced Data (1D):\\n\", X_pca)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Given the dataset [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]], perform PCA and reduce it to 2 dimensions. Also, print the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nprint(\"Reduced Data (2D):\\n\", X_pca)\nprint(\"Principal Components:\\n\", pca.components_)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "For the dataset [[2, 4], [3, 6], [4, 8], [5, 10]], perform PCA and determine the explained variance ratio for each principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 4], [3, 6], [4, 8], [5, 10]])\npca = PCA()\nX_pca = pca.fit_transform(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1]] and reduce it to 2 dimensions. Print the transformed data and the explained variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1]])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nprint(\"Reduced Data (2D):\\n\", X_pca)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Given the dataset [[1, 2], [2, 3], [3, 4], [4, 5]], perform PCA without specifying the number of components and print the cumulative explained variance ratio.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [2, 3], [3, 4], [4, 5]])\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nprint(\"Cumulative Explained Variance Ratio:\", cumulative_variance)"
    },
    {
        "input": "For the dataset [[1, 2], [3, 4], [5, 6], [7, 8]], standardize the data, perform PCA to reduce it to 1 component, and print the transformed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nX = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X_scaled)\nprint(\"Standardized Reduced Data (1D):\\n\", X_pca)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]] to find the principal components. Then, reconstruct the original data from the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\npca = PCA()\nX_pca = pca.fit_transform(X)\nX_reconstructed = pca.inverse_transform(X_pca)\nprint(\"Reconstructed Data:\\n\", X_reconstructed)"
    },
    {
        "input": "Given the dataset [[1, 2], [3, 4], [5, 6], [7, 8]], perform PCA and output the explained variance ratio.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\npca = PCA()\nX_pca = pca.fit_transform(X)\nexplained_variance = pca.explained_variance_ratio_\nprint('Explained Variance Ratio:', explained_variance)"
    },
    {
        "input": "Given the dataset [[2, 4], [3, 6], [4, 8], [5, 10]], perform PCA and determine the explained variance ratio for each principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 4], [3, 6], [4, 8], [5, 10]])\npca = PCA()\nX_pca = pca.fit_transform(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "For the dataset [[1, 2], [3, 4], [5, 6], [7, 8]], perform PCA and determine the number of components required to explain at least 95% of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nnum_components = np.argmax(cumulative_variance >= 0.95) + 1\nprint(\"Number of components to explain at least 95% variance:\", num_components)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]] and project the data onto the first principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nprint(\"Projected Data onto First Principal Component:\\n\", X_pca)"
    },
    {
        "input": "Perform PCA on the dataset [[2, 3, 4], [5, 6, 7], [8, 9, 10], [11, 12, 13]] and project the data onto the first two principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 3, 4], [5, 6, 7], [8, 9, 10], [11, 12, 13]])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nprint(\"Projected Data onto First Two Principal Components:\\n\", X_pca)"
    },
    {
        "input": "Given the dataset [[1, 2], [3, 4], [5, 6], [7, 8]], standardize the data and perform PCA to reduce it to 1 component. Print the transformed data and the explained variance ratio.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nX = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X_scaled)\nprint(\"Standardized Reduced Data (1D):\\n\", X_pca)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]] and determine the explained variance of each principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance of Each Principal Component:\", pca.explained_variance_)"
    },
    {
        "input": "For the dataset [[1, 2], [3, 4], [5, 6], [7, 8]], perform PCA and reconstruct the original data from the principal components. Compare the reconstructed data with the original.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\npca = PCA()\nX_pca = pca.fit_transform(X)\nX_reconstructed = pca.inverse_transform(X_pca)\nprint(\"Original Data:\\n\", X)\nprint(\"Reconstructed Data:\\n\", X_reconstructed)"
    },
    {
        "input": "Perform PCA on the dataset [[2, 4, 6], [3, 6, 9], [4, 8, 12], [5, 10, 15]] and determine if any principal components can be dropped without significant loss of information.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 4, 6], [3, 6, 9], [4, 8, 12], [5, 10, 15]])\npca = PCA()\npca.fit(X)\nexplained_variance_ratio = pca.explained_variance_ratio_\ncumulative_variance = np.cumsum(explained_variance_ratio)\nprint(\"Explained Variance Ratio:\", explained_variance_ratio)\nprint(\"Cumulative Explained Variance Ratio:\", cumulative_variance)\nnum_components = np.argmax(cumulative_variance >= 0.95) + 1\nprint(\"Number of components to retain at least 95% variance:\", num_components)"
    },
    {
        "input": "Given the dataset [[2, 3, 4], [5, 6, 7], [8, 9, 10], [11, 12, 13]], perform PCA and determine the number of components required to explain at least 95% of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 3, 4], [5, 6, 7], [8, 9, 10], [11, 12, 13]])\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nnum_components = np.argmax(cumulative_variance >= 0.95) + 1\nprint(\"Number of components to explain at least 95% variance:\", num_components)"
    },
    {
        "input": "Given a dataset with 5 features and 100 samples, perform PCA and determine the minimum number of principal components required to retain 90% of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(100, 5)\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nnum_components = np.argmax(cumulative_variance >= 0.90) + 1\nprint(\"Number of components to retain 90% variance:\", num_components)"
    },
    {
        "input": "Given a dataset with 6 features and 150 samples, perform PCA and determine the minimum number of principal components required to retain 95% of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(150, 6)\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nnum_components = np.argmax(cumulative_variance >= 0.95) + 1\nprint(\"Number of components to retain 95% variance:\", num_components)"
    },
    {
        "input": "Perform PCA on the dataset [[3, 5, 7], [2, 4, 6], [1, 3, 5], [0, 2, 4]] and project the data onto the first two principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3, 5, 7], [2, 4, 6], [1, 3, 5], [0, 2, 4]])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nprint(\"Projected Data onto First Two Principal Components:\\n\", X_pca)"
    },
    {
        "input": "Given the dataset [[2, 3], [4, 6], [6, 9], [8, 12]], standardize the data and perform PCA to reduce it to 1 component. Print the transformed data and the explained variance ratio.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nX = np.array([[2, 3], [4, 6], [6, 9], [8, 12]])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X_scaled)\nprint(\"Standardized Reduced Data (1D):\\n\", X_pca)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Perform PCA on the dataset [[4, 7, 10], [3, 6, 9], [2, 5, 8], [1, 4, 7]] and determine the explained variance of each principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4, 7, 10], [3, 6, 9], [2, 5, 8], [1, 4, 7]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance of Each Principal Component:\", pca.explained_variance_)"
    },
    {
        "input": "Given a dataset with 4 features and 120 samples, perform PCA and determine the number of components required to explain at least 85% of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(120, 4)\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nnum_components = np.argmax(cumulative_variance >= 0.85) + 1\nprint(\"Number of components to explain at least 85% variance:\", num_components)"
    },
    {
        "input": "For the dataset [[2, 4], [3, 5], [4, 6], [5, 7]], standardize the data, perform PCA to reduce it to 1 component, and print the transformed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nX = np.array([[2, 4], [3, 5], [4, 6], [5, 7]])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X_scaled)\nprint(\"Standardized Reduced Data (1D):\\n\", X_pca)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 3, 5], [2, 4, 6], [3, 5, 7], [4, 6, 8]] and reconstruct the original data from the principal components. Compare the reconstructed data with the original.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 3, 5], [2, 4, 6], [3, 5, 7], [4, 6, 8]])\npca = PCA()\nX_pca = pca.fit_transform(X)\nX_reconstructed = pca.inverse_transform(X_pca)\nprint(\"Original Data:\\n\", X)\nprint(\"Reconstructed Data:\\n\", X_reconstructed)"
    },
    {
        "input": "Given a dataset with 3 features and 80 samples, perform PCA and determine the explained variance ratio for each principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(80, 3)\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Perform PCA on the dataset [[5, 10, 15], [4, 8, 12], [3, 6, 9], [2, 4, 6]] and project the data onto the first principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[5, 10, 15], [4, 8, 12], [3, 6, 9], [2, 4, 6]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nprint(\"Projected Data onto First Principal Component:\\n\", X_pca)"
    },
    {
        "input": "Perform PCA on the dataset [[2, 4], [3, 6], [4, 8], [5, 10]] and print the explained variance ratio for each principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 4], [3, 6], [4, 8], [5, 10]])\npca = PCA()\npca.fit(X)\nprint('Explained Variance Ratio:', pca.explained_variance_ratio_)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]] and reduce it to 2 dimensions. Print the transformed data and principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nprint('Reduced Data (2D):\\n', X_pca)\nprint('Principal Components:\\n', pca.components_)"
    },
    {
        "input": "Given the dataset [[1, 2], [2, 3], [3, 4], [4, 5]], perform PCA without specifying n_components and print the cumulative explained variance ratio.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [2, 3], [3, 4], [4, 5]])\npca = PCA()\npca.fit(X)\ncum_var = np.cumsum(pca.explained_variance_ratio_)\nprint('Cumulative Explained Variance Ratio:', cum_var)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]] and reconstruct the original data using the PCA components. Print the reconstructed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\npca = PCA()\nX_pca = pca.fit_transform(X)\nX_reconstructed = pca.inverse_transform(X_pca)\nprint('Reconstructed Data:\\n', X_reconstructed)"
    },
    {
        "input": "For the dataset [[2, 3, 4], [5, 6, 7], [8, 9, 10], [11, 12, 13]], perform PCA and determine the number of components needed to explain at least 95% of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 3, 4], [5, 6, 7], [8, 9, 10], [11, 12, 13]])\npca = PCA()\npca.fit(X)\ncum_var = np.cumsum(pca.explained_variance_ratio_)\nnum_comp = np.argmax(cum_var >= 0.95) + 1\nprint('Number of components to explain at least 95% variance:', num_comp)"
    },
    {
        "input": "Given a dataset with 5 features and 100 samples (simulate using random numbers), perform PCA and determine the minimum number of components needed to retain 90% variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(100, 5)\npca = PCA()\npca.fit(X)\ncum_var = np.cumsum(pca.explained_variance_ratio_)\nnum_comp = np.argmax(cum_var >= 0.90) + 1\nprint('Number of components to retain 90% variance:', num_comp)"
    },
    {
        "input": "Perform PCA on the dataset [[2, 4, 6], [3, 6, 9], [4, 8, 12], [5, 10, 15]] and project the data onto the first principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 4, 6], [3, 6, 9], [4, 8, 12], [5, 10, 15]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nprint('Projected Data onto First Principal Component:\\n', X_pca)"
    },
    {
        "input": "Given the dataset [[1, 3, 5], [2, 4, 6], [3, 5, 7], [4, 6, 8]], perform PCA and print the principal components and their corresponding explained variance ratios.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 3, 5], [2, 4, 6], [3, 5, 7], [4, 6, 8]])\npca = PCA()\npca.fit(X)\nprint('Principal Components:\\n', pca.components_)\nprint('Explained Variance Ratio:', pca.explained_variance_ratio_)"
    },
    {
        "input": "For a dataset with 4 features and 120 samples (simulate using random numbers), perform PCA and print the shape of the transformed data when reduced to 2 components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(120, 4)\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nprint('Shape of Transformed Data:', X_pca.shape)"
    },
    {
        "input": "Perform PCA on the dataset [[4, 7, 10], [3, 6, 9], [2, 5, 8], [1, 4, 7]] and print the explained variance of each principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4, 7, 10], [3, 6, 9], [2, 5, 8], [1, 4, 7]])\npca = PCA()\npca.fit(X)\nprint('Explained Variance:', pca.explained_variance_)"
    },
    {
        "input": "Given the dataset [[1, 2], [3, 4], [5, 6], [7, 8]], perform PCA and print the singular values of the decomposition.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\npca = PCA()\npca.fit(X)\nprint('Singular Values:', pca.singular_values_)"
    },
    {
        "input": "For the dataset [[2, 4, 6], [4, 8, 12], [6, 12, 18], [8, 16, 24]], perform PCA and print the ratio of variance explained by the first principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 4, 6], [4, 8, 12], [6, 12, 18], [8, 16, 24]])\npca = PCA(n_components=1)\npca.fit(X)\nprint('Variance Ratio of First Component:', pca.explained_variance_ratio_[0])"
    },
    {
        "input": "Perform PCA on the dataset [[1, 3], [2, 4], [3, 5], [4, 6]] and print the PCA components matrix.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 3], [2, 4], [3, 5], [4, 6]])\npca = PCA()\npca.fit(X)\nprint('PCA Components Matrix:\\n', pca.components_)"
    },
    {
        "input": "Given the dataset [[5, 10], [6, 12], [7, 14], [8, 16]], perform PCA and print the total variance explained by all components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[5, 10], [6, 12], [7, 14], [8, 16]])\npca = PCA()\npca.fit(X)\ntotal_variance = np.sum(pca.explained_variance_ratio_)\nprint('Total Variance Explained:', total_variance)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 2, 3], [3, 4, 5], [5, 6, 7], [7, 8, 9]] and print the transformed data when reduced to 2 components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2, 3], [3, 4, 5], [5, 6, 7], [7, 8, 9]])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nprint('Reduced Data (2D):\\n', X_pca)"
    },
    {
        "input": "Given a dataset with 3 features and 80 samples (simulate using random numbers), perform PCA and print the explained variance ratio for each component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(80, 3)\npca = PCA()\npca.fit(X)\nprint('Explained Variance Ratio:', pca.explained_variance_ratio_)"
    },
    {
        "input": "Perform PCA on the dataset [[2, 5], [3, 6], [4, 7], [5, 8]] and print the shape of the principal components matrix.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 5], [3, 6], [4, 7], [5, 8]])\npca = PCA()\npca.fit(X)\nprint('Shape of Principal Components Matrix:', pca.components_.shape)"
    },
    {
        "input": "Given the dataset [[1, 2], [3, 4], [5, 6], [7, 8]], perform PCA and print both the singular values and the explained variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\npca = PCA()\npca.fit(X)\nprint('Singular Values:', pca.singular_values_)\nprint('Explained Variance:', pca.explained_variance_)"
    },
    {
        "input": "For the dataset [[2, 3], [4, 5], [6, 7], [8, 9]], perform PCA and print the PCA object's attributes: components_, explained_variance, and explained_variance_ratio_.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 3], [4, 5], [6, 7], [8, 9]])\npca = PCA()\npca.fit(X)\nprint('Components:\\n', pca.components_)\nprint('Explained Variance:', pca.explained_variance_)\nprint('Explained Variance Ratio:', pca.explained_variance_ratio_)"
    },
    {
        "input": "Perform PCA on a synthetic dataset with 4 features and 200 samples (simulate using random numbers) and print the number of components needed to retain 80% of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(200, 4)\npca = PCA()\npca.fit(X)\ncum_var = np.cumsum(pca.explained_variance_ratio_)\nnum_components = np.argmax(cum_var >= 0.80) + 1\nprint('Number of components to retain 80% variance:', num_components)"
    },
    {
        "input": "Given the dataset [[3, 6, 9], [4, 8, 12], [5, 10, 15], [6, 12, 18]], perform PCA and print the ratio of variance explained by the first principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3, 6, 9], [4, 8, 12], [5, 10, 15], [6, 12, 18]])\npca = PCA(n_components=1)\npca.fit(X)\nprint('Variance Ratio of First Component:', pca.explained_variance_ratio_[0])"
    },
    {
        "input": "Perform PCA on the dataset [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]] and print the transformed data when reduced to 2 components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nprint('Transformed Data:\\n', X_pca)"
    },
    {
        "input": "Given the dataset [[1, 2], [3, 4], [5, 6], [7, 8]], perform PCA and compute the reconstruction error (mean squared error) between the original and reconstructed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nX_reconstructed = pca.inverse_transform(X_pca)\nmse = np.mean((X - X_reconstructed) ** 2)\nprint('Reconstruction Error (MSE):', mse)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 3], [2, 4], [3, 5], [4, 6]] and print the total variance explained by all components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 3], [2, 4], [3, 5], [4, 6]])\npca = PCA()\npca.fit(X)\ntotal_variance = np.sum(pca.explained_variance_ratio_)\nprint('Total Variance Explained:', total_variance)"
    },
    {
        "input": "Given a dataset with 10 features and 200 samples, perform PCA and determine the number of components required to explain at least 90% of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(200, 10)\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nnum_components = np.argmax(cumulative_variance >= 0.90) + 1\nprint(\"Number of components to explain at least 90% variance:\", num_components)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]] and print the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\npca = PCA()\npca.fit(X)\nprint(\"Principal Components:\\n\", pca.components_)"
    },
    {
        "input": "Given the dataset [[2, 4], [3, 6], [4, 8], [5, 10]], perform PCA and print the singular values.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 4], [3, 6], [4, 8], [5, 10]])\npca = PCA()\npca.fit(X)\nprint(\"Singular Values:\", pca.singular_values_)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 0], [0, 1], [-1, 0], [0, -1]] and print the mean of each feature.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 0], [0, 1], [-1, 0], [0, -1]])\npca = PCA()\npca.fit(X)\nprint(\"Feature Means:\", pca.mean_)"
    },
    {
        "input": "Given a dataset with 5 features and 100 samples, standardize the data and perform PCA to reduce it to 3 components. Print the transformed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nnp.random.seed(0)\nX = np.random.rand(100, 5)\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\npca = PCA(n_components=3)\nX_pca = pca.fit_transform(X_scaled)\nprint(\"Transformed Data:\\n\", X_pca)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 2], [2, 3], [3, 4], [4, 5]] and print the covariance matrix of the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [2, 3], [3, 4], [4, 5]])\npca = PCA()\nX_pca = pca.fit_transform(X)\ncov_matrix = np.cov(X_pca.T)\nprint(\"Covariance Matrix:\\n\", cov_matrix)"
    },
    {
        "input": "Given the dataset [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]], perform PCA and print the explained variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Perform PCA on the dataset [[2, 3], [3, 4], [4, 5], [5, 6]] and print the loadings (eigenvectors).",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 3], [3, 4], [4, 5], [5, 6]])\npca = PCA()\npca.fit(X)\nprint(\"Loadings (Eigenvectors):\\n\", pca.components_.T)"
    },
    {
        "input": "Given a dataset with 4 features and 50 samples, perform PCA and print the proportion of variance explained by each component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(50, 4)\npca = PCA()\npca.fit(X)\nprint(\"Proportion of Variance Explained:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 2], [3, 4], [5, 6], [7, 8]] and print the cumulative explained variance ratio.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nprint(\"Cumulative Explained Variance Ratio:\", cumulative_variance)"
    },
    {
        "input": "Given the dataset [[2, 4, 6], [3, 6, 9], [4, 8, 12], [5, 10, 15]], perform PCA and print the principal axes in feature space.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 4, 6], [3, 6, 9], [4, 8, 12], [5, 10, 15]])\npca = PCA()\npca.fit(X)\nprint(\"Principal axes in feature space:\")\nprint(pca.components_)"
    },
    {
        "input": "Given a dataset with 12 features and 300 samples, perform PCA and determine the number of components required to explain at least 95% of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(300, 12)\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nnum_components = np.argmax(cumulative_variance >= 0.95) + 1\nprint(\"Number of components to explain at least 95% variance:\", num_components)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]] and print the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])\npca = PCA()\npca.fit(X)\nprint(\"Principal Components:\\n\", pca.components_)"
    },
    {
        "input": "Given the dataset [[3, 6], [4, 8], [5, 10], [6, 12]], perform PCA and print the singular values.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3, 6], [4, 8], [5, 10], [6, 12]])\npca = PCA()\npca.fit(X)\nprint(\"Singular Values:\", pca.singular_values_)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 0, 0], [0, 1, 0], [0, 0, 1], [-1, -1, -1]] and print the mean of each feature.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1], [-1, -1, -1]])\npca = PCA()\npca.fit(X)\nprint(\"Feature Means:\", pca.mean_)"
    },
    {
        "input": "Given a dataset with 7 features and 150 samples, standardize the data and perform PCA to reduce it to 4 components. Print the transformed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nnp.random.seed(0)\nX = np.random.rand(150, 7)\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\npca = PCA(n_components=4)\nX_pca = pca.fit_transform(X_scaled)\nprint(\"Transformed Data:\\n\", X_pca)"
    },
    {
        "input": "Perform PCA on the dataset [[2, 4], [4, 6], [6, 8], [8, 10]] and print the covariance matrix of the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 4], [4, 6], [6, 8], [8, 10]])\npca = PCA()\nX_pca = pca.fit_transform(X)\ncov_matrix = np.cov(X_pca.T)\nprint(\"Covariance Matrix:\\n\", cov_matrix)"
    },
    {
        "input": "Perform PCA on the dataset [[3, 5], [5, 7], [7, 9], [9, 11]] and print the loadings (eigenvectors).",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3, 5], [5, 7], [7, 9], [9, 11]])\npca = PCA()\npca.fit(X)\nprint(\"Loadings (Eigenvectors):\\n\", pca.components_.T)"
    },
    {
        "input": "Given a dataset with 5 features and 60 samples, perform PCA and print the proportion of variance explained by each component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(60, 5)\npca = PCA()\npca.fit(X)\nprint(\"Proportion of Variance Explained:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Perform PCA on the dataset [[2, 3], [4, 5], [6, 7], [8, 9]] and print the cumulative explained variance ratio.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 3], [4, 5], [6, 7], [8, 9]])\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nprint(\"Cumulative Explained Variance Ratio:\", cumulative_variance)"
    },
    {
        "input": "Given a dataset with 15 features and 500 samples, perform PCA and determine the number of components required to explain at least 95% of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(500, 15)\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nnum_components = np.argmax(cumulative_variance >= 0.95) + 1\nprint(\"Number of components to explain at least 95% variance:\", num_components)"
    },
    {
        "input": "Perform PCA on the dataset [[2, 4, 6], [3, 6, 9], [4, 8, 12], [5, 10, 15]] and print the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 4, 6], [3, 6, 9], [4, 8, 12], [5, 10, 15]])\npca = PCA()\npca.fit(X)\nprint(\"Principal Components:\\n\", pca.components_)"
    },
    {
        "input": "Given the dataset [[1, 2], [2, 3], [3, 4], [4, 5]], perform PCA and print the singular values.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [2, 3], [3, 4], [4, 5]])\npca = PCA()\npca.fit(X)\nprint(\"Singular Values:\", pca.singular_values_)"
    },
    {
        "input": "Given a dataset with 8 features and 300 samples, standardize the data and perform PCA to reduce it to 4 components. Print the transformed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nnp.random.seed(0)\nX = np.random.rand(300, 8)\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\npca = PCA(n_components=4)\nX_pca = pca.fit_transform(X_scaled)\nprint(\"Transformed Data:\\n\", X_pca)"
    },
    {
        "input": "Perform PCA on the dataset [[3, 5], [4, 6], [5, 7], [6, 8]] and print the covariance matrix of the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3, 5], [4, 6], [5, 7], [6, 8]])\npca = PCA()\nX_pca = pca.fit_transform(X)\ncov_matrix = np.cov(X_pca.T)\nprint(\"Covariance Matrix:\\n\", cov_matrix)"
    },
    {
        "input": "Given the dataset [[2, 3, 4], [5, 6, 7], [8, 9, 10], [11, 12, 13]], perform PCA and print the explained variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 3, 4], [5, 6, 7], [8, 9, 10], [11, 12, 13]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Given a dataset with 6 features and 150 samples, perform PCA and print the proportion of variance explained by each component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(150, 6)\npca = PCA()\npca.fit(X)\nprint(\"Proportion of Variance Explained:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Given a dataset with 20 features and 1000 samples, perform PCA and determine the number of components required to explain at least 95% of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(1000, 20)\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nnum_components = np.argmax(cumulative_variance >= 0.95) + 1\nprint(\"Number of components to explain at least 95% variance:\", num_components)"
    },
    {
        "input": "Perform PCA on the dataset [[3, 6, 9], [2, 4, 6], [4, 8, 12], [5, 10, 15]] and print the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3, 6, 9], [2, 4, 6], [4, 8, 12], [5, 10, 15]])\npca = PCA()\npca.fit(X)\nprint(\"Principal Components:\\n\", pca.components_)"
    },
    {
        "input": "Given the dataset [[1, 3], [2, 5], [3, 7], [4, 9]], perform PCA and print the singular values.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 3], [2, 5], [3, 7], [4, 9]])\npca = PCA()\npca.fit(X)\nprint(\"Singular Values:\", pca.singular_values_)"
    },
    {
        "input": "Perform PCA on the dataset [[0, 1], [1, 0], [-1, 0], [0, -1]] and print the mean of each feature.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[0, 1], [1, 0], [-1, 0], [0, -1]])\npca = PCA()\npca.fit(X)\nprint(\"Feature Means:\", pca.mean_)"
    },
    {
        "input": "Given a dataset with 10 features and 500 samples, standardize the data and perform PCA to reduce it to 5 components. Print the transformed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nnp.random.seed(0)\nX = np.random.rand(500, 10)\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\npca = PCA(n_components=5)\nX_pca = pca.fit_transform(X_scaled)\nprint(\"Transformed Data:\\n\", X_pca)"
    },
    {
        "input": "Perform PCA on the dataset [[4, 7], [5, 8], [6, 9], [7, 10]] and print the covariance matrix of the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4, 7], [5, 8], [6, 9], [7, 10]])\npca = PCA()\nX_pca = pca.fit_transform(X)\ncov_matrix = np.cov(X_pca.T)\nprint(\"Covariance Matrix:\\n\", cov_matrix)"
    },
    {
        "input": "Given the dataset [[3, 5, 7], [6, 8, 10], [9, 11, 13], [12, 14, 16]], perform PCA and print the explained variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3, 5, 7], [6, 8, 10], [9, 11, 13], [12, 14, 16]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Perform PCA on the dataset [[3, 4], [4, 5], [5, 6], [6, 7]] and print the loadings (eigenvectors).",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3, 4], [4, 5], [5, 6], [6, 7]])\npca = PCA()\npca.fit(X)\nprint(\"Loadings (Eigenvectors):\\n\", pca.components_.T)"
    },
    {
        "input": "Given a dataset with 7 features and 200 samples, perform PCA and print the proportion of variance explained by each component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(200, 7)\npca = PCA()\npca.fit(X)\nprint(\"Proportion of Variance Explained:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Given the dataset [[3, 6, 9], [4, 8, 12], [5, 10, 15], [6, 12, 18]], perform PCA and print the principal axes in feature space.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3, 6, 9], [4, 8, 12], [5, 10, 15], [6, 12, 18]])\npca = PCA()\npca.fit(X)\nprint(\"Principal axes in feature space:\")\nprint(pca.components_)"
    },
    {
        "input": "Given a dataset with 50 features and 1000 samples, perform PCA and determine the number of components required to explain at least 90% of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(1000, 50)\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nnum_components = np.argmax(cumulative_variance >= 0.90) + 1\nprint(\"Number of components to explain at least 90% variance:\", num_components)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 2, 3], [2, 4, 6], [3, 6, 9], [4, 8, 12]] and print the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2, 3], [2, 4, 6], [3, 6, 9], [4, 8, 12]])\npca = PCA()\npca.fit(X)\nprint(\"Principal Components:\\n\", pca.components_)"
    },
    {
        "input": "Given a dataset with 30 features and 1500 samples, perform PCA and determine the number of components required to explain at least 95% of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(1500, 30)\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nnum_components = np.argmax(cumulative_variance >= 0.95) + 1\nprint(\"Number of components to explain at least 95% variance:\", num_components)"
    },
    {
        "input": "Given the dataset [[1, 3], [2, 4], [3, 5], [4, 6]], perform PCA and print the singular values.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 3], [2, 4], [3, 5], [4, 6]])\npca = PCA()\npca.fit(X)\nprint(\"Singular Values:\", pca.singular_values_)"
    },
    {
        "input": "Given a dataset with 15 features and 800 samples, standardize the data and perform PCA to reduce it to 7 components. Print the transformed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nnp.random.seed(0)\nX = np.random.rand(800, 15)\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\npca = PCA(n_components=7)\nX_pca = pca.fit_transform(X_scaled)\nprint(\"Transformed Data:\\n\", X_pca)"
    },
    {
        "input": "Perform PCA on the dataset [[5, 9], [6, 10], [7, 11], [8, 12]] and print the covariance matrix of the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[5, 9], [6, 10], [7, 11], [8, 12]])\npca = PCA()\nX_pca = pca.fit_transform(X)\ncov_matrix = np.cov(X_pca.T)\nprint(\"Covariance Matrix:\\n\", cov_matrix)"
    },
    {
        "input": "Given the dataset [[4, 6, 8], [7, 9, 11], [10, 12, 14], [13, 15, 17]], perform PCA and print the explained variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4, 6, 8], [7, 9, 11], [10, 12, 14], [13, 15, 17]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Perform PCA on the dataset [[4, 5], [5, 6], [6, 7], [7, 8]] and print the loadings (eigenvectors).",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4, 5], [5, 6], [6, 7], [7, 8]])\npca = PCA()\npca.fit(X)\nprint(\"Loadings (Eigenvectors):\\n\", pca.components_.T)"
    },
    {
        "input": "Given a dataset with 9 features and 300 samples, perform PCA and print the proportion of variance explained by each component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(300, 9)\npca = PCA()\npca.fit(X)\nprint(\"Proportion of Variance Explained:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Perform PCA on the dataset [[3, 4], [5, 6], [7, 8], [9, 10]] and print the cumulative explained variance ratio.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3, 4], [5, 6], [7, 8], [9, 10]])\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nprint(\"Cumulative Explained Variance Ratio:\", cumulative_variance)"
    },
    {
        "input": "Given the dataset [[4, 8, 12], [5, 10, 15], [6, 12, 18], [7, 14, 21]], perform PCA and print the principal axes in feature space.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4, 8, 12], [5, 10, 15], [6, 12, 18], [7, 14, 21]])\npca = PCA()\npca.fit(X)\nprint(\"Principal axes in feature space:\")\nprint(pca.components_)"
    },
    {
        "input": "Given a dataset with 20 features and 500 samples, perform PCA and determine the number of components required to explain at least 85% of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(500, 20)\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nnum_components = np.argmax(cumulative_variance >= 0.85) + 1\nprint(\"Number of components to explain at least 85% variance:\", num_components)"
    },
    {
        "input": "Perform PCA on the dataset [[2, 3, 4], [5, 6, 7], [8, 9, 10], [11, 12, 13]] and print the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 3, 4], [5, 6, 7], [8, 9, 10], [11, 12, 13]])\npca = PCA()\npca.fit(X)\nprint(\"Principal Components:\\n\", pca.components_)"
    },
    {
        "input": "Given the dataset [[1, 2], [2, 3], [3, 4], [4, 5]], perform PCA and print the explained variance ratio.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [2, 3], [3, 4], [4, 5]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Perform PCA on the dataset [[0, 1], [1, 0], [-1, 0], [0, -1]] and print the transformed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[0, 1], [1, 0], [-1, 0], [0, -1]])\npca = PCA()\nX_pca = pca.fit_transform(X)\nprint(\"Transformed Data:\\n\", X_pca)"
    },
    {
        "input": "Given a dataset with 15 features and 300 samples, standardize the data and perform PCA to reduce it to 5 components. Print the explained variance of each component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nnp.random.seed(0)\nX = np.random.rand(300, 15)\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\npca = PCA(n_components=5)\npca.fit(X_scaled)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Given the dataset [[2, 4, 6], [3, 5, 7], [4, 6, 8], [5, 7, 9]], perform PCA and print the singular values.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 4, 6], [3, 5, 7], [4, 6, 8], [5, 7, 9]])\npca = PCA()\npca.fit(X)\nprint(\"Singular Values:\", pca.singular_values_)"
    },
    {
        "input": "Perform PCA on the dataset [[1, 2], [3, 4], [5, 6], [7, 8]] and print the loadings (eigenvectors).",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\npca = PCA()\npca.fit(X)\nprint(\"Loadings (Eigenvectors):\\n\", pca.components_.T)"
    },
    {
        "input": "Given a dataset with 10 features and 200 samples, perform PCA and print the proportion of variance explained by each component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nnp.random.seed(0)\nX = np.random.rand(200, 10)\npca = PCA()\npca.fit(X)\nprint(\"Proportion of Variance Explained:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Given the dataset X = [[2, 0, -1], [3, 1, 0], [4, 2, 1]], perform PCA and return the top 2 principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 0, -1], [3, 1, 0], [4, 2, 1]])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nprint(\"Top 2 Principal Components:\\n\", X_pca)"
    },
    {
        "input": "Using the dataset X = [[1, 2], [2, 3], [3, 4], [4, 5]], perform PCA and find the variance explained by the first component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [2, 3], [3, 4], [4, 5]])\npca = PCA()\npca.fit(X)\nprint(\"Variance Explained by First Component:\", pca.explained_variance_ratio_[0])"
    },
    {
        "input": "Given a dataset X = [[2, 4], [1, 3], [0, 2], [-1, 1]], perform PCA and return the eigenvalues of the covariance matrix.",
        "output": "import numpy as np\nfrom numpy.linalg import eig\nX = np.array([[2, 4], [1, 3], [0, 2], [-1, 1]])\nX_centered = X - np.mean(X, axis=0)\ncov_matrix = np.cov(X_centered.T)\neigenvalues, _ = eig(cov_matrix)\nprint(\"Eigenvalues:\", eigenvalues)"
    },
    {
        "input": "Given the dataset X = [[5, 1], [6, 2], [7, 3], [8, 4]], perform PCA and reconstruct the data using only the first principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[5, 1], [6, 2], [7, 3], [8, 4]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nX_reconstructed = pca.inverse_transform(X_pca)\nprint(\"Reconstructed Data:\\n\", X_reconstructed)"
    },
    {
        "input": "Perform PCA on the dataset X = [[10, 0, 3], [2, 8, 1], [5, 6, 2]] and return the principal component directions.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[10, 0, 3], [2, 8, 1], [5, 6, 2]])\npca = PCA()\npca.fit(X)\nprint(\"Principal Component Directions:\\n\", pca.components_)"
    },
    {
        "input": "Given dataset X = [[1, 3], [3, 7], [5, 11], [7, 15]], perform PCA and calculate the cumulative explained variance ratio.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 3], [3, 7], [5, 11], [7, 15]])\npca = PCA()\npca.fit(X)\ncumulative_variance = np.cumsum(pca.explained_variance_ratio_)\nprint(\"Cumulative Explained Variance:\", cumulative_variance)"
    },
    {
        "input": "Apply PCA on dataset X = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] and return the explained variance ratio of each component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Given dataset X = [[2, 3, 4], [1, 2, 3], [0, 1, 2], [-1, 0, 1]], perform PCA and find the rank of the covariance matrix.",
        "output": "import numpy as np\nX = np.array([[2, 3, 4], [1, 2, 3], [0, 1, 2], [-1, 0, 1]])\nX_centered = X - np.mean(X, axis=0)\ncov_matrix = np.cov(X_centered.T)\nrank = np.linalg.matrix_rank(cov_matrix)\nprint(\"Rank of Covariance Matrix:\", rank)"
    },
    {
        "input": "Using the dataset X = [[1, 1], [2, 2], [3, 3], [4, 4]], apply PCA and identify any redundancy in features based on the eigenvalues.",
        "output": "import numpy as np\nfrom numpy.linalg import eig\nX = np.array([[1, 1], [2, 2], [3, 3], [4, 4]])\nX_centered = X - np.mean(X, axis=0)\ncov_matrix = np.cov(X_centered.T)\neigenvalues, _ = eig(cov_matrix)\nprint(\"Eigenvalues:\", eigenvalues)"
    },
    {
        "input": "Given X = [[10, 10], [20, 20], [30, 30]], apply PCA and return the number of non-zero principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[10, 10], [20, 20], [30, 30]])\npca = PCA()\npca.fit(X)\nnon_zero_components = np.sum(pca.explained_variance_ > 1e-10)\nprint(\"Non-zero Principal Components:\", non_zero_components)"
    },
    {
        "input": "Perform PCA on X = [[5, 6], [6, 7], [7, 8], [8, 9]], and calculate the total variance captured by PCA.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[5, 6], [6, 7], [7, 8], [8, 9]])\npca = PCA()\npca.fit(X)\ntotal_variance = np.sum(pca.explained_variance_)\nprint(\"Total Variance:\", total_variance)"
    },
    {
        "input": "Given dataset X = [[1, 0], [0, 1], [1, 1], [2, 2]], apply PCA and find the loading scores (component weights).",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 0], [0, 1], [1, 1], [2, 2]])\npca = PCA()\npca.fit(X)\nprint(\"Component Weights (Loadings):\\n\", pca.components_)"
    },
    {
        "input": "Using dataset X = [[1, 2], [2, 1], [3, 4], [4, 3]], apply PCA and project the data onto the first principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [2, 1], [3, 4], [4, 3]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nprint(\"Projected Data:\\n\", X_pca)"
    },
    {
        "input": "Given a 2D dataset X = [[1, 2], [3, 4], [5, 6], [7, 8]], calculate the covariance matrix before applying PCA.",
        "output": "import numpy as np\nX = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\nX_centered = X - np.mean(X, axis=0)\ncov_matrix = np.cov(X_centered.T)\nprint(\"Covariance Matrix:\\n\", cov_matrix)"
    },
    {
        "input": "Given the dataset X = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], perform PCA and return the number of components with non-zero variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\npca = PCA()\npca.fit(X)\nnon_zero = np.sum(pca.explained_variance_ > 1e-10)\nprint(\"Non-zero Components:\", non_zero)"
    },
    {
        "input": "Apply PCA on dataset X = [[5, 7], [3, 2], [8, 6], [2, 4]], and return the direction of the first principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[5, 7], [3, 2], [8, 6], [2, 4]])\npca = PCA(n_components=1)\npca.fit(X)\nprint(\"First Principal Component Direction:\", pca.components_[0])"
    },
    {
        "input": "Given the dataset X = [[4, 2], [2, 4], [6, 6], [4, 6]], perform PCA and return the score matrix (transformed values).",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4, 2], [2, 4], [6, 6], [4, 6]])\npca = PCA(n_components=2)\nX_transformed = pca.fit_transform(X)\nprint(\"PCA Transformed Matrix:\\n\", X_transformed)"
    },
    {
        "input": "Using the dataset X = [[9, 5], [4, 7], [6, 2], [3, 8]], perform PCA and calculate the explained variance of the second principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[9, 5], [4, 7], [6, 2], [3, 8]])\npca = PCA(n_components=2)\npca.fit(X)\nprint(\"Explained Variance (2nd PC):\", pca.explained_variance_[1])"
    },
    {
        "input": "Given the dataset X = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1]], apply PCA and find the principal component directions.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1]])\npca = PCA()\npca.fit(X)\nprint(\"Principal Component Directions:\\n\", pca.components_)"
    },
    {
        "input": "Using dataset X = [[2, 3], [3, 4], [4, 5]], perform PCA and find how many dimensions are needed to retain 99% variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 3], [3, 4], [4, 5]])\npca = PCA()\npca.fit(X)\ncumsum = np.cumsum(pca.explained_variance_ratio_)\ndims = np.searchsorted(cumsum, 0.99) + 1\nprint(\"Dimensions for 99% Variance:\", dims)"
    },
    {
        "input": "Given dataset X = [[2, 2], [4, 4], [6, 6]], perform PCA and reconstruct the data from 1D projection.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 2], [4, 4], [6, 6]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nX_inv = pca.inverse_transform(X_pca)\nprint(\"Reconstructed Data:\\n\", X_inv)"
    },
    {
        "input": "Apply PCA on dataset X = [[7, 8], [9, 10], [11, 12]], and return the mean of the transformed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[7, 8], [9, 10], [11, 12]])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nprint(\"Mean of Transformed Data:\", np.mean(X_pca, axis=0))"
    },
    {
        "input": "Using dataset X = [[2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7]], perform PCA and return the shape of the reduced matrix for 2 components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7]])\npca = PCA(n_components=2)\nX_reduced = pca.fit_transform(X)\nprint(\"Shape of Reduced Matrix:\", X_reduced.shape)"
    },
    {
        "input": "Apply PCA on dataset X = [[4, 0], [0, 4], [2, 2]], and calculate the angle between the first component and x-axis.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4, 0], [0, 4], [2, 2]])\npca = PCA(n_components=1)\npca.fit(X)\nimport math\nangle = math.degrees(math.atan2(pca.components_[0][1], pca.components_[0][0]))\nprint(\"Angle with X-axis:\", angle)"
    },
    {
        "input": "Given dataset X = [[0, 1], [1, 0], [2, 3], [3, 2]], perform PCA and calculate total explained variance ratio.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[0, 1], [1, 0], [2, 3], [3, 2]])\npca = PCA()\npca.fit(X)\ntotal_ratio = np.sum(pca.explained_variance_ratio_)\nprint(\"Total Explained Variance Ratio:\", total_ratio)"
    },
    {
        "input": "Apply PCA on dataset X = [[1, 0, 1], [0, 1, 1], [1, 1, 0]], and return the first principal axis.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 0, 1], [0, 1, 1], [1, 1, 0]])\npca = PCA(n_components=1)\npca.fit(X)\nprint(\"First Principal Axis:\", pca.components_[0])"
    },
    {
        "input": "Using dataset X = [[10, 0], [0, 10], [10, 10]], perform PCA and determine how many components are required to retain 95% variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[10, 0], [0, 10], [10, 10]])\npca = PCA()\npca.fit(X)\ncum_var = np.cumsum(pca.explained_variance_ratio_)\ncomponents = np.searchsorted(cum_var, 0.95) + 1\nprint(\"Components for 95% Variance:\", components)"
    },
    {
        "input": "Given dataset X = [[1, 2], [2, 1], [3, 4], [4, 3]], perform PCA and calculate the variance retained after dimensionality reduction to 1D.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2], [2, 1], [3, 4], [4, 3]])\npca = PCA(n_components=1)\npca.fit(X)\nprint(\"Variance Retained:\", np.sum(pca.explained_variance_ratio_))"
    },
    {
        "input": "Apply PCA on dataset X = [[5, 5], [6, 5], [7, 6], [8, 6]] and return the loading matrix.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[5, 5], [6, 5], [7, 6], [8, 6]])\npca = PCA()\npca.fit(X)\nprint(\"Loading Matrix (Components):\\n\", pca.components_)"
    },
    {
        "input": "Given dataset X = [[1, 2], [3, 4], [5, 6], [7, 8]], perform PCA and return eigenvalues of the covariance matrix.",
        "output": "import numpy as np\nX = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\nX_centered = X - np.mean(X, axis=0)\ncov = np.cov(X_centered.T)\neigvals = np.linalg.eigvals(cov)\nprint(\"Eigenvalues:\", eigvals)"
    },
    {
        "input": "Given the dataset [[2, 0], [0, 2], [1, 1]], perform PCA and return the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 0], [0, 2], [1, 1]])\npca = PCA(n_components=2)\npca.fit(X)\nprint(\"Principal Components:\\n\", pca.components_)"
    },
    {
        "input": "Given the dataset [[3, 3, 3], [4, 4, 4], [5, 5, 5]], compute the variance explained by each principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3, 3, 3], [4, 4, 4], [5, 5, 5]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Given the dataset [[2, 4], [1, 3], [0, 2]], perform PCA and return the transformed data using 1 component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 4], [1, 3], [0, 2]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nprint(\"Transformed Data:\\n\", X_pca)"
    },
    {
        "input": "Given the dataset [[6, 7, 8], [9, 10, 11], [12, 13, 14]], perform PCA and print the covariance matrix of the standardized dataset.",
        "output": "import numpy as np\nfrom sklearn.preprocessing import StandardScaler\nX = np.array([[6, 7, 8], [9, 10, 11], [12, 13, 14]])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\ncov_matrix = np.cov(X_scaled.T)\nprint(\"Covariance Matrix:\\n\", cov_matrix)"
    },
    {
        "input": "Given the dataset [[1, 2], [3, 4], [5, 6]], perform PCA and output the eigenvalues of the covariance matrix.",
        "output": "import numpy as np\nfrom numpy.linalg import eig\nX = np.array([[1, 2], [3, 4], [5, 6]])\nX_centered = X - np.mean(X, axis=0)\ncov_matrix = np.cov(X_centered.T)\neigenvalues, _ = eig(cov_matrix)\nprint(\"Eigenvalues:\", eigenvalues)"
    },
    {
        "input": "Given the dataset [[4, 2], [2, 4], [6, 6]], compute and print the eigenvectors of its covariance matrix.",
        "output": "import numpy as np\nfrom numpy.linalg import eig\nX = np.array([[4, 2], [2, 4], [6, 6]])\nX_centered = X - np.mean(X, axis=0)\ncov_matrix = np.cov(X_centered.T)\n_, eigenvectors = eig(cov_matrix)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
    },
    {
        "input": "Given the dataset [[1, 1], [0, 0], [-1, -1]], perform PCA and reconstruct the original data from 1 principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 1], [0, 0], [-1, -1]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nX_reconstructed = pca.inverse_transform(X_pca)\nprint(\"Reconstructed Data:\\n\", X_reconstructed)"
    },
    {
        "input": "Given the dataset [[3, 1], [2, 3], [4, 5]], use PCA to reduce it to 1 dimension and print the result.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3, 1], [2, 3], [4, 5]])\npca = PCA(n_components=1)\nX_reduced = pca.fit_transform(X)\nprint(\"Reduced Data:\\n\", X_reduced)"
    },
    {
        "input": "Given the dataset [[1, 4, 7], [2, 5, 8], [3, 6, 9]], perform PCA and display the explained variance ratio.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 4, 7], [2, 5, 8], [3, 6, 9]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Given the dataset [[3, 3], [3, 3], [3, 3]], apply PCA and explain the number of meaningful principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3, 3], [3, 3], [3, 3]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)\nprint(\"Number of meaningful components:\", np.sum(pca.explained_variance_ > 1e-5))"
    },
    {
        "input": "Given the dataset [[1, 2, 1], [2, 1, 2], [3, 3, 3]], perform PCA and return the component with the highest variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2, 1], [2, 1, 2], [3, 3, 3]])\npca = PCA()\npca.fit(X)\nprint(\"Principal Component with Highest Variance:\\n\", pca.components_[0])"
    },
    {
        "input": "Given the dataset [[2, 0], [0, 2], [2, 2]], perform PCA and determine if the two features are correlated.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 0], [0, 2], [2, 2]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Given the dataset [[4, 5], [5, 4], [6, 6]], calculate the percentage of variance captured by the first component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4, 5], [5, 4], [6, 6]])\npca = PCA()\npca.fit(X)\nprint(\"% Variance by 1st component:\", pca.explained_variance_ratio_[0] * 100)"
    },
    {
        "input": "Given the dataset [[1, 2, 3], [4, 5, 6], [7, 8, 9]], perform PCA and determine the number of components required to capture 95% variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\npca = PCA(n_components=0.95)\npca.fit(X)\nprint(\"Number of Components:\", pca.n_components_)"
    },
    {
        "input": "Given the dataset [[10, 0], [0, 10], [5, 5]], perform PCA and print the mean of the dataset.",
        "output": "import numpy as np\nX = np.array([[10, 0], [0, 10], [5, 5]])\nmean = np.mean(X, axis=0)\nprint(\"Mean:\", mean)"
    },
    {
        "input": "Given the dataset [[2, 3, 4], [4, 6, 8], [6, 9, 12]], perform PCA and show that the data lies in a single direction.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2,3,4],[4,6,8],[6,9,12]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Given the dataset [[1, 2], [2, 3], [3, 4], [4, 5]], perform PCA and print the shape of transformed data with 1 component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,2],[2,3],[3,4],[4,5]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nprint(\"Shape:\", X_pca.shape)"
    },
    {
        "input": "Given the dataset [[7, 2], [8, 3], [9, 4]], perform PCA and show that the first component captures most of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[7,2],[8,3],[9,4]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Given the dataset [[3, 4], [3, 4], [3, 4]], perform PCA and print the transformed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3,4],[3,4],[3,4]])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nprint(\"Transformed Data:\\n\", X_pca)"
    },
    {
        "input": "Given the dataset [[2, 4], [4, 8], [6, 12]], perform PCA and print the loadings of the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2,4],[4,8],[6,12]])\npca = PCA()\npca.fit(X)\nprint(\"Loadings:\\n\", pca.components_)"
    },
    {
        "input": "Given the dataset [[10, 20, 30], [20, 30, 40], [30, 40, 50]], apply PCA and determine the number of components that explain at least 90% of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[10,20,30],[20,30,40],[30,40,50]])\npca = PCA(n_components=0.9)\npca.fit(X)\nprint(\"Number of components:\", pca.n_components_)"
    },
    {
        "input": "Given the dataset [[0, 1], [1, 0], [1, 1]], apply PCA and print both eigenvalues and eigenvectors.",
        "output": "import numpy as np\nfrom numpy.linalg import eig\nX = np.array([[0,1],[1,0],[1,1]])\nX = X - np.mean(X, axis=0)\ncov = np.cov(X.T)\neigvals, eigvecs = eig(cov)\nprint(\"Eigenvalues:\", eigvals)\nprint(\"Eigenvectors:\\n\", eigvecs)"
    },
    {
        "input": "Given the dataset [[2, 2], [4, 4], [6, 6]], apply PCA and confirm that one of the components has zero variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2,2],[4,4],[6,6]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Given the dataset [[1, 0], [0, 1], [1, 1]], perform PCA and print the projection matrix.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,0],[0,1],[1,1]])\npca = PCA(n_components=2)\npca.fit(X)\nprint(\"Projection Matrix (Components):\\n\", pca.components_)"
    },
    {
        "input": "Given the dataset [[1, 2], [2, 3], [3, 5]], use PCA to reduce to 1D and reconstruct the original data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,2],[2,3],[3,5]])\npca = PCA(n_components=1)\nX_reduced = pca.fit_transform(X)\nX_reconstructed = pca.inverse_transform(X_reduced)\nprint(\"Reconstructed Data:\\n\", X_reconstructed)"
    },
    {
        "input": "Given the dataset [[4, 4, 4], [5, 5, 5], [6, 6, 6]], perform PCA and show that the second and third components have zero variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4,4,4],[5,5,5],[6,6,6]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Given the dataset [[5, 0], [10, 5], [15, 10]], apply PCA and display the variance captured by each component as a percentage.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[5,0],[10,5],[15,10]])\npca = PCA()\npca.fit(X)\nprint(\"% Variance:\", pca.explained_variance_ratio_ * 100)"
    },
    {
        "input": "Given the dataset [[1, 2, 3], [4, 5, 6], [7, 8, 9]], calculate the eigen decomposition of the covariance matrix.",
        "output": "import numpy as np\nfrom numpy.linalg import eig\nX = np.array([[1,2,3],[4,5,6],[7,8,9]])\nX = X - np.mean(X, axis=0)\ncov = np.cov(X.T)\neigvals, eigvecs = eig(cov)\nprint(\"Eigenvalues:\", eigvals)\nprint(\"Eigenvectors:\\n\", eigvecs)"
    },
    {
        "input": "Given the dataset [[1, 3], [2, 6], [3, 9]], perform PCA and explain why the data lies in 1 dimension.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,3],[2,6],[3,9]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Given the dataset [[1, 0], [0, 1], [-1, 0], [0, -1]], apply PCA and print the projected 2D data using 2 components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,0],[0,1],[-1,0],[0,-1]])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nprint(\"Projected Data:\\n\", X_pca)"
    },
    {
        "input": "Given the dataset [[3, 3], [6, 6], [9, 9]], perform PCA and verify that both components point in the same direction.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3,3],[6,6],[9,9]])\npca = PCA()\npca.fit(X)\nprint(\"Principal Components:\\n\", pca.components_)"
    },
    {
        "input": "Given the dataset [[2, 3], [4, 6], [6, 9]], apply PCA and print the transformed coordinates using the first component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2,3],[4,6],[6,9]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nprint(\"Transformed Coordinates:\\n\", X_pca)"
    },
    {
        "input": "Given the dataset [[2, 4, 6], [4, 8, 12], [6, 12, 18]], perform PCA and show that the data lies along a single axis.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2,4,6],[4,8,12],[6,12,18]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Given the dataset [[5, 5, 5], [5, 5, 5], [5, 5, 5]], perform PCA and explain the output of transformed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[5,5,5],[5,5,5],[5,5,5]])\npca = PCA()\nX_pca = pca.fit_transform(X)\nprint(\"Transformed Data:\\n\", X_pca)"
    },
    {
        "input": "Given the dataset [[1, 2], [2, 4], [3, 6]], apply PCA and print the direction of the first component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,2],[2,4],[3,6]])\npca = PCA(n_components=1)\npca.fit(X)\nprint(\"First Principal Component:\", pca.components_[0])"
    },
    {
        "input": "Given the dataset [[1, 3], [3, 7], [5, 11]], perform PCA and reduce to 1D then inverse transform.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,3],[3,7],[5,11]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nX_orig = pca.inverse_transform(X_pca)\nprint(\"Reconstructed Data:\\n\", X_orig)"
    },
    {
        "input": "Given the dataset [[10, 2], [9, 3], [8, 4], [7, 5]], perform PCA and print the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[10,2],[9,3],[8,4],[7,5]])\npca = PCA()\npca.fit(X)\nprint(\"Principal Components:\\n\", pca.components_)"
    },
    {
        "input": "Given the dataset [[5, 1], [10, 2], [15, 3]], perform PCA and print the explained variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[5,1],[10,2],[15,3]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Given the dataset [[1, 1], [2, 2], [3, 3]], apply PCA and verify the components and variance ratios.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,1],[2,2],[3,3]])\npca = PCA()\npca.fit(X)\nprint(\"Components:\\n\", pca.components_)\nprint(\"Variance Ratios:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Given the dataset [[1, 3], [2, 2], [3, 1]], apply PCA and reduce to 1 component. Print the transformed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,3],[2,2],[3,1]])\npca = PCA(n_components=1)\nX_reduced = pca.fit_transform(X)\nprint(\"Reduced Data:\\n\", X_reduced)"
    },
    {
        "input": "Given the dataset [[1, 2, 3], [3, 2, 1], [2, 2, 2]], perform PCA and print the variance ratio of each component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,2,3],[3,2,1],[2,2,2]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Given the dataset [[4, 0], [0, 4], [-4, 0], [0, -4]], use PCA to reduce to 1D.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4, 0], [0, 4], [-4, 0], [0, -4]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nprint(\"1D PCA Projection:\", X_pca)"
    },
    {
        "input": "Given the dataset [[2, 3, 4], [6, 7, 8], [10, 11, 12]], apply PCA and print the singular values.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2,3,4],[6,7,8],[10,11,12]])\npca = PCA()\npca.fit(X)\nprint(\"Singular Values:\", pca.singular_values_)"
    },
    {
        "input": "Given the dataset [[1, 0], [0, 1], [-1, 0], [0, -1]], perform PCA and plot the transformed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1, 0], [0, 1], [-1, 0], [0, -1]])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nprint(\"PCA Transformed Data:\\n\", X_pca)"
    },
    {
        "input": "Given the dataset [[3, 3], [6, 6], [9, 9]], verify using PCA that the second principal component has near zero variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3,3],[6,6],[9,9]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Given the dataset [[4, 2], [2, 4], [4, 4], [2, 2]], apply PCA and print both the mean and components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4,2],[2,4],[4,4],[2,2]])\npca = PCA()\npca.fit(X)\nprint(\"Mean:\", pca.mean_)\nprint(\"Components:\\n\", pca.components_)"
    },
    {
        "input": "Given the dataset [[1, 1], [2, 2], [3, 3]], apply PCA and reconstruct the data after dimensionality reduction to 1D.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,1],[2,2],[3,3]])\npca = PCA(n_components=1)\nX_reduced = pca.fit_transform(X)\nX_reconstructed = pca.inverse_transform(X_reduced)\nprint(\"Reconstructed Data:\\n\", X_reconstructed)"
    },
    {
        "input": "Given the dataset [[2, 1], [1, 2], [3, 3]], apply PCA and print the cumulative explained variance ratio.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2,1],[1,2],[3,3]])\npca = PCA()\npca.fit(X)\ncumulative = np.cumsum(pca.explained_variance_ratio_)\nprint(\"Cumulative Explained Variance:\", cumulative)"
    },
    {
        "input": "Given the dataset [[10, 15], [20, 25], [30, 35]], apply PCA and verify if 1D representation retains most of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[10,15],[20,25],[30,35]])\npca = PCA(n_components=1)\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Given the dataset [[3, 3], [3, 3], [3, 3]], apply PCA and explain why all components have zero variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3,3],[3,3],[3,3]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Given the dataset [[2, 2], [4, 4], [6, 6]], perform PCA and verify both components and explained variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2,2],[4,4],[6,6]])\npca = PCA()\npca.fit(X)\nprint(\"Components:\\n\", pca.components_)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Given the dataset [[1, 4, 7], [2, 5, 8], [3, 6, 9]], perform PCA and check how many components explain 95% of the variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,4,7],[2,5,8],[3,6,9]])\npca = PCA(n_components=0.95)\npca.fit(X)\nprint(\"Number of Components:\", pca.n_components_)"
    },
    {
        "input": "Given the dataset [[4, 4], [4, 4], [4, 4]], perform PCA and explain the output components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4,4],[4,4],[4,4]])\npca = PCA()\npca.fit(X)\nprint(\"Components:\\n\", pca.components_)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Given the dataset [[2, 3], [5, 6], [8, 9]], apply PCA and print the explained variance ratio and singular values.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2,3],[5,6],[8,9]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)\nprint(\"Singular Values:\", pca.singular_values_)"
    },
    {
        "input": "Given the dataset [[3, 6], [6, 3], [4, 4]], perform PCA and visualize the reduced 1D data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3, 6], [6, 3], [4, 4]])\npca = PCA(n_components=1)\nX_reduced = pca.fit_transform(X)\nprint(\"PCA Reduced 1D Data:\\n\", X_reduced)"
    },
    {
        "input": "Given the dataset [[1, 2], [2, 4], [3, 6]], perform PCA and print the direction vector of the principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,2],[2,4],[3,6]])\npca = PCA()\npca.fit(X)\nprint(\"Principal Component Vector:\", pca.components_[0])"
    },
    {
        "input": "Apply PCA on dataset [[1, 2], [3, 4], [5, 6], [7, 8]] and print the explained variance ratio.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,2],[3,4],[5,6],[7,8]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Use PCA to reduce dataset [[10, 1], [20, 2], [30, 3]] to 1D and show the projected values.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[10,1],[20,2],[30,3]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nprint(\"1D Projection:\\n\", X_pca)"
    },
    {
        "input": "Perform PCA on [[3, 5], [5, 3], [6, 6], [2, 8]] and print the principal axes.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3,5],[5,3],[6,6],[2,8]])\npca = PCA()\npca.fit(X)\nprint(\"Principal Axes:\\n\", pca.components_)"
    },
    {
        "input": "Perform PCA on [[5, 5], [6, 6], [7, 7]] and print the transformed data and inverse transformed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[5,5],[6,6],[7,7]])\npca = PCA(n_components=1)\nX_transformed = pca.fit_transform(X)\nX_inverse = pca.inverse_transform(X_transformed)\nprint(\"Transformed:\\n\", X_transformed)\nprint(\"Reconstructed:\\n\", X_inverse)"
    },
    {
        "input": "Given dataset [[2, 0], [0, 2], [-2, 0], [0, -2]], apply PCA and plot the principal axes on top of the original points.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2, 0], [0, 2], [-2, 0], [0, -2]])\npca = PCA()\npca.fit(X)\nprint(\"Principal components:\\n\", pca.components_)\nprint(\"Explained variance:\\n\", pca.explained_variance_)\nprint(\"Mean of the data:\\n\", pca.mean_)"
    },
    {
        "input": "Apply PCA to [[9, 10], [4, 7], [2, 5], [3, 1]] and display the explained variance for each component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[9,10],[4,7],[2,5],[3,1]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Perform PCA on [[5, 7], [7, 5], [9, 9]] and reduce it to 1D. Print the reduced and original shape.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[5,7],[7,5],[9,9]])\npca = PCA(n_components=1)\nX_new = pca.fit_transform(X)\nprint(\"Reduced Shape:\", X_new.shape)\nprint(\"Original Shape:\", X.shape)"
    },
    {
        "input": "Given [[1, 2, 3], [4, 5, 6], [7, 8, 9]], use PCA to find the minimum number of components that explain at least 95% variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,2,3],[4,5,6],[7,8,9]])\npca = PCA(n_components=0.95)\npca.fit(X)\nprint(\"Number of Components:\", pca.n_components_)"
    },
    {
        "input": "Perform PCA on [[10, 20], [20, 30], [30, 40]] and print the mean and singular values.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[10,20],[20,30],[30,40]])\npca = PCA()\npca.fit(X)\nprint(\"Mean:\", pca.mean_)\nprint(\"Singular Values:\", pca.singular_values_)"
    },
    {
        "input": "Use PCA to reduce [[3, 3], [6, 6], [9, 9], [12, 12]] to 1D and inverse transform it. Print all.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3,3],[6,6],[9,9],[12,12]])\npca = PCA(n_components=1)\nX_reduced = pca.fit_transform(X)\nX_reconstructed = pca.inverse_transform(X_reduced)\nprint(\"Reduced:\\n\", X_reduced)\nprint(\"Reconstructed:\\n\", X_reconstructed)"
    },
    {
        "input": "Given [[5, 0], [0, 5]], perform PCA and verify that the components are orthogonal.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[5,0],[0,5]])\npca = PCA()\npca.fit(X)\nprint(\"Components (Orthogonal):\\n\", pca.components_)\nprint(\"Dot Product:\", np.dot(pca.components_[0], pca.components_[1]))"
    },
    {
        "input": "Apply PCA on [[6, 3], [8, 6], [9, 9], [10, 12]] and print the explained variance ratio and the principal axes.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[6,3],[8,6],[9,9],[10,12]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)\nprint(\"Principal Axes:\\n\", pca.components_)"
    },
    {
        "input": "Perform PCA on [[1, 0], [0, 1], [-1, 0], [0, -1]] and verify if the data lies on a circle or line.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,0],[0,1],[-1,0],[0,-1]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Use PCA on [[3, 3, 3], [6, 6, 6], [9, 9, 9]] and show that only one component is needed.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3,3,3],[6,6,6],[9,9,9]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Apply PCA on dataset [[2, 4], [4, 2], [6, 6]] and print the covariance matrix of the transformed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2,4],[4,2],[6,6]])\npca = PCA()\nX_pca = pca.fit_transform(X)\nprint(\"Covariance Matrix:\\n\", np.cov(X_pca.T))"
    },
    {
        "input": "Perform PCA on [[4, 8], [8, 4], [12, 12]] and visualize the original and reduced dimensions.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4, 8], [8, 4], [12, 12]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nX_inv = pca.inverse_transform(X_pca)\nprint(\"Reduced data (1D):\\n\", X_pca)\nprint(\"Reconstructed data (approximation in 2D):\\n\", X_inv)"
    },
    {
        "input": "Given [[3, 2], [2, 3], [3, 3]], use PCA to reduce to 1D and explain retained variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3,2],[2,3],[3,3]])\npca = PCA(n_components=1)\npca.fit(X)\nprint(\"Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Apply PCA to reduce [[1, 3], [2, 4], [3, 5]] to 1D and print the transformed output.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,3],[2,4],[3,5]])\npca = PCA(n_components=1)\nX_new = pca.fit_transform(X)\nprint(\"Transformed:\", X_new)"
    },
    {
        "input": "Find explained variance and components using PCA on [[4, 6], [6, 8], [8, 10]]",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4,6],[6,8],[8,10]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)\nprint(\"Components:\", pca.components_)"
    },
    {
        "input": "Use PCA to reduce [[1, 2], [3, 6], [5, 10]] and check the shape before and after transformation.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,2],[3,6],[5,10]])\npca = PCA(n_components=1)\nX_new = pca.fit_transform(X)\nprint(\"Original Shape:\", X.shape)\nprint(\"Reduced Shape:\", X_new.shape)"
    },
    {
        "input": "Fit PCA on [[3, 4], [6, 8], [9, 12]] and print the mean used for centering the data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3,4],[6,8],[9,12]])\npca = PCA()\npca.fit(X)\nprint(\"Mean:\", pca.mean_)"
    },
    {
        "input": "Perform PCA on [[1, 2], [2, 3], [3, 4]] and print singular values.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,2],[2,3],[3,4]])\npca = PCA()\npca.fit(X)\nprint(\"Singular Values:\", pca.singular_values_)"
    },
    {
        "input": "Use PCA with n_components=2 on [[2, 4], [4, 6], [6, 8]] and print the transformed result.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2,4],[4,6],[6,8]])\npca = PCA(n_components=2)\nX_new = pca.fit_transform(X)\nprint(\"Transformed:\", X_new)"
    },
    {
        "input": "Apply PCA to [[7, 14], [8, 16], [9, 18]] and print the ratio of variance explained.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[7,14],[8,16],[9,18]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Check how many components are needed to retain 100% variance in [[10, 20], [15, 30], [20, 40]]",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[10, 20], [15, 30], [20, 40]])\npca = PCA(n_components=None)\npca.fit(X)\nexplained_variance_ratio = np.cumsum(pca.explained_variance_ratio_)\nnum_components = np.argmax(explained_variance_ratio >= 1.0) + 1\nprint(\"Number of Components to retain 100% variance:\", num_components)"
    },
    {
        "input": "Perform PCA on [[3, 5], [4, 6], [5, 7]] and print components and transformed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[3,5],[4,6],[5,7]])\npca = PCA()\nX_transformed = pca.fit_transform(X)\nprint(\"Components:\", pca.components_)\nprint(\"Transformed:\", X_transformed)"
    },
    {
        "input": "Reduce dimensions of [[11, 22], [13, 26], [15, 30]] to 1D using PCA and reconstruct the data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[11,22],[13,26],[15,30]])\npca = PCA(n_components=1)\nX_reduced = pca.fit_transform(X)\nX_reconstructed = pca.inverse_transform(X_reduced)\nprint(\"Reconstructed:\\n\", X_reconstructed)"
    },
    {
        "input": "Perform PCA on [[2, 1], [4, 2], [6, 3]] and verify if only one component explains all variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2,1],[4,2],[6,3]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Use PCA to transform [[2, 2], [3, 3], [4, 4]] and show the result of inverse_transform.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2,2],[3,3],[4,4]])\npca = PCA(n_components=1)\nX_new = pca.fit_transform(X)\nX_inv = pca.inverse_transform(X_new)\nprint(\"Inverse Transformed:\", X_inv)"
    },
    {
        "input": "Use PCA to transform and inverse [[10, 5], [20, 10], [30, 15]] and show loss if any.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[10,5],[20,10],[30,15]])\npca = PCA(n_components=1)\nX_transformed = pca.fit_transform(X)\nX_inv = pca.inverse_transform(X_transformed)\nprint(\"Loss:\", np.abs(X - X_inv))"
    },
    {
        "input": "Fit PCA on [[1, 5], [2, 10], [3, 15]] and print number of components when variance threshold is 0.9.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,5],[2,10],[3,15]])\npca = PCA(n_components=0.9)\npca.fit(X)\nprint(\"Components Needed:\", pca.n_components_)"
    },
    {
        "input": "Use PCA to reduce [[5, 10], [10, 20], [15, 30]] and check if any component has near zero variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[5,10],[10,20],[15,30]])\npca = PCA()\npca.fit(X)\nprint(\"Variance of Each Component:\", pca.explained_variance_)"
    },
    {
        "input": "Apply PCA on [[0, 1], [0, 2], [0, 3]] and print the transformed values and components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[0,1],[0,2],[0,3]])\npca = PCA()\nX_new = pca.fit_transform(X)\nprint(\"Components:\", pca.components_)\nprint(\"Transformed:\", X_new)"
    },
    {
        "input": "Perform PCA on [[10, 10], [10, 10], [10, 10]] and observe explained variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[10,10],[10,10],[10,10]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Use PCA on [[5, 0], [10, 0], [15, 0]] and confirm if PCA finds variance only along x-axis.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[5,0],[10,0],[15,0]])\npca = PCA()\npca.fit(X)\nprint(\"Components:\", pca.components_)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Use PCA with n_components=1 on [[1, 1], [2, 2], [3, 3]] and print all results.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,1],[2,2],[3,3]])\npca = PCA(n_components=1)\nX_new = pca.fit_transform(X)\nprint(\"Components:\", pca.components_)\nprint(\"Transformed:\", X_new)"
    },
    {
        "input": "Fit PCA on [[4, 4], [4, 4], [4, 4]] and check the shape of components and explained variance.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[4,4],[4,4],[4,4]])\npca = PCA()\npca.fit(X)\nprint(\"Components Shape:\", pca.components_.shape)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Check how PCA handles identical rows: [[1, 2], [1, 2], [1, 2]]",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,2],[1,2],[1,2]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Transform and inverse [[9, 3], [18, 6], [27, 9]] using PCA and confirm if reconstruction is lossless.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[9,3],[18,6],[27,9]])\npca = PCA(n_components=1)\nX_pca = pca.fit_transform(X)\nX_inv = pca.inverse_transform(X_pca)\nprint(\"Difference:\\n\", X - X_inv)"
    },
    {
        "input": "Perform PCA on [[1, 0], [0, 1]] and print dot product of components to confirm orthogonality.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,0],[0,1]])\npca = PCA()\npca.fit(X)\nprint(\"Dot Product:\", np.dot(pca.components_[0], pca.components_[1]))"
    },
    {
        "input": "Apply PCA on [[8, 0], [0, 8]] and print explained variance and components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[8,0],[0,8]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)\nprint(\"Components:\", pca.components_)"
    },
    {
        "input": "Apply PCA to a dataset [[1, 2], [2, 3], [3, 4]] and print cumulative explained variance ratio.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,2],[2,3],[3,4]])\npca = PCA()\npca.fit(X)\ncumsum = np.cumsum(pca.explained_variance_ratio_)\nprint(\"Cumulative Explained Variance Ratio:\", cumsum)"
    },
    {
        "input": "Transform and inverse a dataset using PCA and calculate reconstruction error for [[1, 1], [2, 2], [3, 3]]",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,1],[2,2],[3,3]])\npca = PCA(n_components=1)\nX_transformed = pca.fit_transform(X)\nX_inv = pca.inverse_transform(X_transformed)\nerror = np.mean((X - X_inv)**2)\nprint(\"Reconstruction Error:\", error)"
    },
    {
        "input": "Find the number of PCA components that retain at least 95% variance for [[1, 2], [2, 4], [3, 6], [4, 8]]",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,2],[2,4],[3,6],[4,8]])\npca = PCA(n_components=0.95)\npca.fit(X)\nprint(\"Components to retain 95%:\", pca.n_components_)"
    },
    {
        "input": "Fit PCA to [[1, 0], [0, 1], [1, 1]] and verify the direction of the principal components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,0],[0,1],[1,1]])\npca = PCA()\npca.fit(X)\nprint(\"Principal Components:\", pca.components_)"
    },
    {
        "input": "Verify if PCA on [[1, 2], [2, 4], [3, 6]] results in one dominant component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,2],[2,4],[3,6]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Run PCA on [[0, 0], [1, 1], [2, 2], [3, 3]] and print all explained variances and components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[0,0],[1,1],[2,2],[3,3]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)\nprint(\"Components:\", pca.components_)"
    },
    {
        "input": "Use PCA on [[1, 10], [2, 20], [3, 30], [4, 40]] and check if there's only one informative direction.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,10],[2,20],[3,30],[4,40]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Transform data [[2, 0], [4, 0], [6, 0]] using PCA and compare transformed and inverse values.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2,0],[4,0],[6,0]])\npca = PCA(n_components=1)\nX_trans = pca.fit_transform(X)\nX_inv = pca.inverse_transform(X_trans)\nprint(\"Inverse Transformed:\", X_inv)"
    },
    {
        "input": "Fit PCA with 2D input [[0, 1], [1, 0], [1, 1]] and show mean and singular values.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[0,1],[1,0],[1,1]])\npca = PCA()\npca.fit(X)\nprint(\"Mean:\", pca.mean_)\nprint(\"Singular Values:\", pca.singular_values_)"
    },
    {
        "input": "Fit PCA to [[1, 2], [2, 1], [3, 3]] and get the projection onto principal component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,2],[2,1],[3,3]])\npca = PCA(n_components=1)\nX_proj = pca.fit_transform(X)\nprint(\"Projected Data:\", X_proj)"
    },
    {
        "input": "Check if PCA detects direction in data [[1, 0], [2, 1], [3, 2]] and print first component.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,0],[2,1],[3,2]])\npca = PCA()\npca.fit(X)\nprint(\"First Component:\", pca.components_[0])"
    },
    {
        "input": "Use PCA on [[1, 3], [2, 6], [3, 9]] and print all PCA attributes.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,3],[2,6],[3,9]])\npca = PCA()\npca.fit(X)\nprint(\"Mean:\", pca.mean_)\nprint(\"Components:\", pca.components_)\nprint(\"Explained Variance:\", pca.explained_variance_)\nprint(\"Explained Variance Ratio:\", pca.explained_variance_ratio_)"
    },
    {
        "input": "Verify PCA behavior on a dataset with same values [[1, 1], [1, 1], [1, 1]]",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,1],[1,1],[1,1]])\npca = PCA()\npca.fit(X)\nprint(\"Explained Variance:\", pca.explained_variance_)"
    },
    {
        "input": "Run PCA on [[5, 10], [6, 12], [7, 14]] and print the shape of reduced and reconstructed data.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[5,10],[6,12],[7,14]])\npca = PCA(n_components=1)\nX_red = pca.fit_transform(X)\nX_rec = pca.inverse_transform(X_red)\nprint(\"Reduced Shape:\", X_red.shape)\nprint(\"Reconstructed Shape:\", X_rec.shape)"
    },
    {
        "input": "Perform PCA on [[10, 1], [20, 2], [30, 3]] and print all singular values and means.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[10,1],[20,2],[30,3]])\npca = PCA()\npca.fit(X)\nprint(\"Singular Values:\", pca.singular_values_)\nprint(\"Means:\", pca.mean_)"
    },
    {
        "input": "Check principal directions using PCA on [[2, 2], [4, 0], [0, 4]]",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[2,2],[4,0],[0,4]])\npca = PCA()\npca.fit(X)\nprint(\"Principal Components:\", pca.components_)"
    },
    {
        "input": "Use PCA with n_components=0.99 on [[1, 1], [2, 2], [3, 3], [4, 4]] and get required components.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nX = np.array([[1,1],[2,2],[3,3],[4,4]])\npca = PCA(n_components=0.99)\npca.fit(X)\nprint(\"Required Components:\", pca.n_components_)"
    },
    {
        "input": "Compute the inner product of vectors (1, 2, -1) and (2, 1, 4) in R^3, and determine their angle.",
        "output": "import numpy as np\nv1 = np.array([1, 2, -1])\nv2 = np.array([2, 1, 4])\ninner_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\nangle = np.arccos(inner_product / (norm_v1 * norm_v2))\nprint(\"Inner Product:\", inner_product)\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Find the norm of vector (3, -4) in R^2 using the Euclidean norm.",
        "output": "import numpy as np\nv = np.array([3, -4])\nnorm = np.linalg.norm(v)\nprint(\"Norm:\", norm)"
    },
    {
        "input": "Compute the projection of vector (4, 2) onto vector (1, 1) in R^2.",
        "output": "import numpy as np\nv = np.array([4, 2])\nu = np.array([1, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(\"Projection:\", projection)"
    },
    {
        "input": "Determine the orthonormal basis for the span of vectors (1, 1) and (1, -1) in R^2 using Gram-Schmidt process.",
        "output": "import numpy as np\nv1 = np.array([1, 1])\nv2 = np.array([1, -1])\nu1 = v1 / np.linalg.norm(v1)\nproj_v2_u1 = (np.dot(v2, u1)) * u1\nu2 = v2 - proj_v2_u1\nu2 = u2 / np.linalg.norm(u2)\nprint(\"Orthonormal Basis:\", u1, u2)"
    },
    {
        "input": "Calculate the distance between vectors (1, 2) and (3, 4) in R^2.",
        "output": "import numpy as np\nv1 = np.array([1, 2])\nv2 = np.array([3, 4])\ndistance = np.linalg.norm(v1 - v2)\nprint(\"Distance:\", distance)"
    },
    {
        "input": "Find the norm of the function f(x) = x on the interval [0, 1] using the L2 norm.",
        "output": "from scipy.integrate import quad\nimport numpy as np\nf = lambda x: x**2\nnorm = np.sqrt(quad(f, 0, 1)[0])\nprint(\"Norm:\", norm)"
    },
    {
        "input": "Compute the inner product of functions f(x) = x and g(x) = x^2 on [0, 1] using the L2 inner product.",
        "output": "from scipy.integrate import quad\nf = lambda x: x\ng = lambda x: x**2\ninner_product = quad(lambda x: f(x) * g(x), 0, 1)[0]\nprint(\"Inner Product:\", inner_product)"
    },
    {
        "input": "Find the angle between vectors (1, 2, 3) and (4, 5, 6) in R^3.",
        "output": "import numpy as np\nv1 = np.array([1, 2, 3])\nv2 = np.array([4, 5, 6])\ninner_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\nangle = np.arccos(inner_product / (norm_v1 * norm_v2))\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Compute the L1 norm of vector (3, -4, 5) in R^3.",
        "output": "import numpy as np\nv = np.array([3, -4, 5])\nl1_norm = np.sum(np.abs(v))\nprint(\"L1 Norm:\", l1_norm)"
    },
    {
        "input": "Compute the norm of the vector (1, -2, 3) in R^3 using the Euclidean norm.",
        "output": "import numpy as np\nv = np.array([1, -2, 3])\nnorm = np.linalg.norm(v)\nprint(\"Norm:\", norm)"
    },
    {
        "input": "Find the inner product of vectors (1, 2) and (3, 4) in R^2.",
        "output": "import numpy as np\nv1 = np.array([1, 2])\nv2 = np.array([3, 4])\ninner_product = np.dot(v1, v2)\nprint(\"Inner Product:\", inner_product)"
    },
    {
        "input": "Compute the projection of vector (3, 4) onto vector (1, 2) in R^2.",
        "output": "import numpy as np\nv = np.array([3, 4])\nu = np.array([1, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(\"Projection:\", projection)"
    },
    {
        "input": "Calculate the distance between vectors (1, 2, 3) and (4, 5, 6) in R^3.",
        "output": "import numpy as np\nv1 = np.array([1, 2, 3])\nv2 = np.array([4, 5, 6])\ndistance = np.linalg.norm(v1 - v2)\nprint(\"Distance:\", distance)"
    },
    {
        "input": "Calculate the Euclidean norm of the vector (3, -4, 12) in R^3.",
        "output": "import numpy as np\nv = np.array([3, -4, 12])\nnorm = np.linalg.norm(v)\nprint(\"Euclidean Norm:\", norm)"
    },
    {
        "input": "Find the inner product of vectors (1, 2, 3) and (4, -5, 6) in R^3.",
        "output": "import numpy as np\nv1 = np.array([1, 2, 3])\nv2 = np.array([4, -5, 6])\ninner_product = np.dot(v1, v2)\nprint(\"Inner Product:\", inner_product)"
    },
    {
        "input": "Compute the projection of vector (2, 3) onto vector (1, 1) in R^2.",
        "output": "import numpy as np\nv = np.array([2, 3])\nu = np.array([1, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(\"Projection:\", projection)"
    },
    {
        "input": "Calculate the angle between vectors (1, 0) and (0, 1) in R^2.",
        "output": "import numpy as np\nv1 = np.array([1, 0])\nv2 = np.array([0, 1])\ninner_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\ncos_theta = inner_product / (norm_v1 * norm_v2)\nangle = np.arccos(cos_theta)\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Find the L-infinity norm (maximum norm) of vector (-1, 4, -3) in R^3.",
        "output": "import numpy as np\nv = np.array([-1, 4, -3])\nl_inf_norm = np.max(np.abs(v))\nprint(\"L-infinity Norm:\", l_inf_norm)"
    },
    {
        "input": "Compute the norm of the function f(x) = x^2 on the interval [0, 1] using the L2 norm.",
        "output": "from scipy.integrate import quad\nimport numpy as np\nf = lambda x: x**4\nnorm = np.sqrt(quad(f, 0, 1)[0])\nprint(\"L2 Norm:\", norm)"
    },
    {
        "input": "Find the angle between vectors (1, 2, 3) and (-1, -2, -3) in R^3.",
        "output": "import numpy as np\nv1 = np.array([1, 2, 3])\nv2 = np.array([-1, -2, -3])\ninner_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\ncos_theta = inner_product / (norm_v1 * norm_v2)\nangle = np.arccos(cos_theta)\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Compute the inner product of functions f(x) = sin(x) and g(x) = cos(x) on [0, π] using the L2 inner product.",
        "output": "from scipy.integrate import quad\nimport numpy as np\nf = lambda x: np.sin(x)\ng = lambda x: np.cos(x)\ninner_product = quad(lambda x: f(x) * g(x), 0, np.pi)[0]\nprint(\"Inner Product:\", inner_product)"
    },
    {
        "input": "Compute the Euclidean norm of the vector (5, -12) in R^2.",
        "output": "import numpy as np\nv = np.array([5, -12])\nnorm = np.linalg.norm(v)\nprint(\"Euclidean Norm:\", norm)"
    },
    {
        "input": "Find the inner product of vectors (1, 0, -1) and (0, 1, 1) in R^3.",
        "output": "import numpy as np\nv1 = np.array([1, 0, -1])\nv2 = np.array([0, 1, 1])\ninner_product = np.dot(v1, v2)\nprint(\"Inner Product:\", inner_product)"
    },
    {
        "input": "Compute the projection of vector (3, 4, 0) onto vector (1, 0, 0) in R^3.",
        "output": "import numpy as np\nv = np.array([3, 4, 0])\nu = np.array([1, 0, 0])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(\"Projection:\", projection)"
    },
    {
        "input": "Calculate the angle between vectors (1, 2) and (2, -1) in R^2.",
        "output": "import numpy as np\nv1 = np.array([1, 2])\nv2 = np.array([2, -1])\ninner_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\ncos_theta = inner_product / (norm_v1 * norm_v2)\nangle = np.arccos(cos_theta)\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Compute the L1 norm of vector (-3, 4, -5) in R^3.",
        "output": "import numpy as np\nv = np.array([-3, 4, -5])\nl1_norm = np.sum(np.abs(v))\nprint(\"L1 Norm:\", l1_norm)"
    },
    {
        "input": "Find the L-infinity norm (maximum norm) of vector (7, -2, 3) in R^3.",
        "output": "import numpy as np\nv = np.array([7, -2, 3])\nl_inf_norm = np.max(np.abs(v))\nprint(\"L-infinity Norm:\", l_inf_norm)"
    },
    {
        "input": "Compute the norm of the function f(x) = x^3 on the interval [0, 1] using the L2 norm.",
        "output": "from scipy.integrate import quad\nimport numpy as np\nf = lambda x: x**6\nnorm = np.sqrt(quad(f, 0, 1)[0])\nprint(\"L2 Norm:\", norm)"
    },
    {
        "input": "Find the angle between vectors (2, 3, 4) and (-2, -3, -4) in R^3.",
        "output": "import numpy as np\nv1 = np.array([2, 3, 4])\nv2 = np.array([-2, -3, -4])\ninner_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\ncos_theta = inner_product / (norm_v1 * norm_v2)\nangle = np.arccos(cos_theta)\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Compute the inner product of functions f(x) = e^x and g(x) = e^{-x} on [-1, 1] using the L2 inner product.",
        "output": "from scipy.integrate import quad\nimport numpy as np\nf = lambda x: np.exp(x)\ng = lambda x: np.exp(-x)\ninner_product = quad(lambda x: f(x) * g(x), -1, 1)[0]\nprint(\"Inner Product:\", inner_product)"
    },
    {
        "input": "Compute the inner product of vectors (2, -1, 3) and (-4, 0, 5) in R^3.",
        "output": "import numpy as np\nv1 = np.array([2, -1, 3])\nv2 = np.array([-4, 0, 5])\ninner_product = np.dot(v1, v2)\nprint(\"Inner Product:\", inner_product)"
    },
    {
        "input": "Calculate the norm of the vector (1, -2, 2) in R^3.",
        "output": "import numpy as np\nv = np.array([1, -2, 2])\nnorm = np.linalg.norm(v)\nprint(\"Norm:\", norm)"
    },
    {
        "input": "Find an orthonormal basis for the subspace of R^3 spanned by {(1, 0, 0), (1, 1, 0)} using the Gram-Schmidt process.",
        "output": "import numpy as np\nv1 = np.array([1, 0, 0])\nv2 = np.array([1, 1, 0])\nu1 = v1\nu2 = v2 - np.dot(v2, u1) / np.dot(u1, u1) * u1\nu1 = u1 / np.linalg.norm(u1)\nu2 = u2 / np.linalg.norm(u2)\nprint(\"Orthonormal Basis:\", u1, u2)"
    },
    {
        "input": "Compute the projection of vector (4, 2, 3) onto vector (1, 0, -1) in R^3.",
        "output": "import numpy as np\nv = np.array([4, 2, 3])\nu = np.array([1, 0, -1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(\"Projection:\", projection)"
    },
    {
        "input": "Find the angle between vectors (1, 2) and (2, -1) in R^2.",
        "output": "import numpy as np\nv1 = np.array([1, 2])\nv2 = np.array([2, -1])\ninner_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\ncos_theta = inner_product / (norm_v1 * norm_v2)\nangle = np.arccos(cos_theta)\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Compute the L2 norm of the function f(x) = e^x on the interval [0, 1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nf = lambda x: np.exp(x)**2\nnorm = np.sqrt(quad(f, 0, 1)[0])\nprint(\"L2 Norm:\", norm)"
    },
    {
        "input": "Compute the 1-norm (Manhattan norm) of the vector (3, -4, 5) in R^3.",
        "output": "import numpy as np\nv = np.array([3, -4, 5])\nnorm_1 = np.linalg.norm(v, 1)\nprint(\"1-Norm:\", norm_1)"
    },
    {
        "input": "Calculate the infinity norm (maximum norm) of the vector (-7, 2, 9) in R^3.",
        "output": "import numpy as np\nv = np.array([-7, 2, 9])\nnorm_inf = np.linalg.norm(v, np.inf)\nprint(\"Infinity Norm:\", norm_inf)"
    },
    {
        "input": "Find the inner product of vectors (1, -1, 2) and (2, 0, -3) in R^3.",
        "output": "import numpy as np\nv1 = np.array([1, -1, 2])\nv2 = np.array([2, 0, -3])\ninner_product = np.dot(v1, v2)\nprint(\"Inner Product:\", inner_product)"
    },
    {
        "input": "Compute the projection of vector (4, -2, 1) onto vector (1, 2, 2) in R^3.",
        "output": "import numpy as np\nv = np.array([4, -2, 1])\nu = np.array([1, 2, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(\"Projection:\", projection)"
    },
    {
        "input": "Compute the angle between vectors (2, 3) and (-3, 2) in R^2.",
        "output": "import numpy as np\nv1 = np.array([2, 3])\nv2 = np.array([-3, 2])\ninner_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\ncos_theta = inner_product / (norm_v1 * norm_v2)\nangle = np.arccos(cos_theta)\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Compute the Fourier series coefficients for f(x) = x^2 on the interval [-π, π] up to the second harmonic.",
        "output": "import numpy as np\nfrom scipy.integrate import quad\nL = np.pi\na0 = (1/L) * quad(lambda x: x**2, -L, L)[0]\nan = lambda n: (1/L) * quad(lambda x: x**2 * np.cos(n * np.pi * x / L), -L, L)[0]\nbn = lambda n: (1/L) * quad(lambda x: x**2 * np.sin(n * np.pi * x / L), -L, L)[0]\nprint(\"a0:\", a0, \"a1:\", an(1), \"b1:\", bn(1), \"a2:\", an(2), \"b2:\", bn(2))"
    },
    {
        "input": "Compute the Frobenius norm of the matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nfrobenius_norm = np.linalg.norm(A, 'fro')\nprint(\"Frobenius Norm:\", frobenius_norm)"
    },
    {
        "input": "Find the inner product of polynomials f(x) = 1 + x and g(x) = x + x^2 over the interval [0, 1] with the inner product defined as ⟨f, g⟩ = ∫[0,1] f(x)g(x) dx.",
        "output": "import numpy as np\nfrom scipy.integrate import quad\nf = lambda x: 1 + x\ng = lambda x: x + x**2\ninner_product, _ = quad(lambda x: f(x) * g(x), 0, 1)\nprint(\"Inner Product:\", inner_product)"
    },
    {
        "input": "Compute the norm induced by the inner product ⟨f, g⟩ = ∫[0,1] f(x)g(x) dx for f(x) = x.",
        "output": "import numpy as np\nfrom scipy.integrate import quad\nf = lambda x: x\ninner_product, _ = quad(lambda x: f(x) * f(x), 0, 1)\nnorm = np.sqrt(inner_product)\nprint(\"Norm:\", norm)"
    },
    {
        "input": "Find the projection of the vector (3, 4, 0) onto the subspace spanned by the vectors (1, 0, 0) and (0, 1, 0) in R^3.",
        "output": "import numpy as np\nv = np.array([3, 4, 0])\nbasis = np.array([[1, 0, 0], [0, 1, 0]])\nprojection = np.zeros(3)\nfor b in basis:\n    projection += (np.dot(v, b) / np.dot(b, b)) * b\nprint(\"Projection:\", projection)"
    },
    {
        "input": "Compute the angle between the vectors (1, 0, 0) and (0, 1, 1) in R^3.",
        "output": "import numpy as np\nv1 = np.array([1, 0, 0])\nv2 = np.array([0, 1, 1])\ninner_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\ncos_theta = inner_product / (norm_v1 * norm_v2)\nangle = np.arccos(cos_theta)\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Apply the Gram-Schmidt process to orthogonalize the set of vectors {(1, 1, 1), (1, 0, -1), (0, 1, 1)} in R^3.",
        "output": "import numpy as np\nv1 = np.array([1, 1, 1])\nv2 = np.array([1, 0, -1])\nv3 = np.array([0, 1, 1])\nu1 = v1\nu2 = v2 - (np.dot(v2, u1) / np.dot(u1, u1)) * u1\nu3 = v3 - (np.dot(v3, u1) / np.dot(u1, u1)) * u1 - (np.dot(v3, u2) / np.dot(u2, u2)) * u2\nu1 = u1 / np.linalg.norm(u1)\nu2 = u2 / np.linalg.norm(u2)\nu3 = u3 / np.linalg.norm(u3)\nprint(\"Orthonormal Set:\", u1, u2, u3)"
    },
    {
        "input": "Compute the Fourier series coefficients for f(x) = sin(x) on the interval [-π, π] up to the first harmonic.",
        "output": "import numpy as np\nfrom scipy.integrate import quad\nL = np.pi\nf = lambda x: np.sin(x)\na0 = (1 / L) * quad(f, -L, L)[0]\nan = lambda n: (1 / L) * quad(lambda x: f(x) * np.cos(n * np.pi * x / L), -L, L)[0]\nbn = lambda n: (1 / L) * quad(lambda x: f(x) * np.sin(n * np.pi * x / L), -L, L)[0]\na1 = an(1)\nb1 = bn(1)\nprint(\"a0 =\", a0)\nprint(\"a1 =\", a1)\nprint(\"b1 =\", b1)"
    },
    {
        "input": "Compute the Euclidean norm (2-norm) of the vector (7, -24) in R^2.",
        "output": "import numpy as np\nv = np.array([7, -24])\nnorm_2 = np.linalg.norm(v, 2)\nprint(\"2-Norm:\", norm_2)"
    },
    {
        "input": "Find the projection of the vector (5, 5) onto the vector (1, 2) in R^2.",
        "output": "import numpy as np\nv = np.array([5, 5])\nu = np.array([1, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(\"Projection:\", projection)"
    },
    {
        "input": "Compute the angle between vectors (3, 4) and (4, -3) in R^2.",
        "output": "import numpy as np\nv1 = np.array([3, 4])\nv2 = np.array([4, -3])\ninner_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\ncos_theta = inner_product / (norm_v1 * norm_v2)\nangle = np.arccos(cos_theta)\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Apply the Gram-Schmidt process to orthogonalize the set of vectors {(1, 2), (2, 3)} in R^2.",
        "output": "import numpy as np\nv1 = np.array([1, 2])\nv2 = np.array([2, 3])\nu1 = v1\nu2 = v2 - (np.dot(v2, u1) / np.dot(u1, u1)) * u1\nu1 = u1 / np.linalg.norm(u1)\nu2 = u2 / np.linalg.norm(u2)\nprint(\"Orthonormal Set:\", u1, u2)"
    },
    {
        "input": "Compute the Fourier series coefficients for f(x) = x on the interval [-π, π] up to the first harmonic.",
        "output": "import numpy as np\nfrom scipy.integrate import quad\nL = np.pi\na0 = (1/L) * quad(lambda x: x, -L, L)[0]\nan = lambda n: (1/L) * quad(lambda x: x * np.cos(n * np.pi * x / L), -L, L)[0]\nbn = lambda n: (1/L) * quad(lambda x: x * np.sin(n * np.pi * x / L), -L, L)[0]\nprint(\"a0:\", a0, \"a1:\", an(1), \"b1:\", bn(1))"
    },
    {
        "input": "Compute the norm of the polynomial f(x) = 1 + x in the inner product space of polynomials with inner product ⟨f, g⟩ = ∫[0,1] f(x)g(x) dx.",
        "output": "import numpy as np\nfrom scipy.integrate import quad\nf = lambda x: 1 + x\ninner_product = quad(lambda x: f(x) * f(x), 0, 1)[0]\nnorm = np.sqrt(inner_product)\nprint(\"Norm:\", norm)"
    },
    {
        "input": "Find the projection of the vector (4, 2, 3) onto the vector (1, 1, 1) in R^3.",
        "output": "import numpy as np\nv = np.array([4, 2, 3])\nu = np.array([1, 1, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(\"Projection:\", projection)"
    },
    {
        "input": "Compute the angle between vectors (1, 2, 3) and (4, 5, 6) in R^3.",
        "output": "import numpy as np\nv1 = np.array([1, 2, 3])\nv2 = np.array([4, 5, 6])\ninner_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\ncos_theta = inner_product / (norm_v1 * norm_v2)\nangle = np.arccos(cos_theta)\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Compute the Fourier series coefficients for f(x) = x^2 on the interval [-π, π] up to the first harmonic.",
        "output": "import numpy as np\nfrom scipy.integrate import quad\nL = np.pi\na0 = (1/L) * quad(lambda x: x**2, -L, L)[0]\nan = lambda n: (1/L) * quad(lambda x: x**2 * np.cos(n * np.pi * x / L), -L, L)[0]\nbn = lambda n: (1/L) * quad(lambda x: x**2 * np.sin(n * np.pi * x / L), -L, L)[0]\nprint(\"a0:\", a0, \"a1:\", an(1), \"b1:\", bn(1))"
    },
    {
        "input": "Compute the norm of the polynomial f(x) = x^2 + x + 1 in the inner product space of polynomials with inner product ⟨f, g⟩ = ∫[0,1] f(x)g(x) dx.",
        "output": "from scipy.integrate import quad\nimport numpy as np\nf = lambda x: x**2 + x + 1\ninner_product = quad(lambda x: f(x)**2, 0, 1)[0]\nnorm = np.sqrt(inner_product)\nprint(\"Norm of f(x):\", norm)"
    },
    {
        "input": "Compute the infinity norm (maximum norm) of the vector (2, -3, 7) in R^3.",
        "output": "import numpy as np\nv = np.array([2, -3, 7])\nnorm_inf = np.linalg.norm(v, np.inf)\nprint(\"Infinity Norm:\", norm_inf)"
    },
    {
        "input": "Find the projection of the vector (3, 4, 5) onto the vector (1, 0, -1) in R^3.",
        "output": "import numpy as np\nv = np.array([3, 4, 5])\nu = np.array([1, 0, -1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(\"Projection:\", projection)"
    },
    {
        "input": "Compute the angle between vectors (0, 1, 1) and (1, 0, -1) in R^3.",
        "output": "import numpy as np\nv1 = np.array([0, 1, 1])\nv2 = np.array([1, 0, -1])\ninner_product = np.dot(v1, v2)\nnorm_v1 = np.linalg.norm(v1)\nnorm_v2 = np.linalg.norm(v2)\ncos_theta = inner_product / (norm_v1 * norm_v2)\nangle = np.arccos(cos_theta)\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Apply the Gram-Schmidt process to orthogonalize the set of vectors {(1, 2, 3), (4, 5, 6), (7, 8, 9)} in R^3.",
        "output": "import numpy as np\nv1 = np.array([1, 2, 3])\nv2 = np.array([4, 5, 6])\nv3 = np.array([7, 8, 9])\nu1 = v1\nu2 = v2 - (np.dot(v2, u1) / np.dot(u1, u1)) * u1\nu3 = v3 - (np.dot(v3, u1) / np.dot(u1, u1)) * u1 - (np.dot(v3, u2) / np.dot(u2, u2)) * u2\nu1 = u1 / np.linalg.norm(u1)\nu2 = u2 / np.linalg.norm(u2)\nu3 = u3 / np.linalg.norm(u3)\nprint(\"Orthonormal Set:\", u1, u2, u3)"
    },
    {
        "input": "Compute the Fourier series coefficients for f(x) = sin(x) on the interval [0, 2π] up to the first harmonic.",
        "output": "import numpy as np\nfrom scipy.integrate import quad\nL = 2 * np.pi\na0 = (1/L) * quad(lambda x: np.sin(x), 0, L)[0]\nan = lambda n: (1/L) * quad(lambda x: np.sin(x) * np.cos(n * np.pi * x / L), 0, L)[0]\nbn = lambda n: (1/L) * quad(lambda x: np.sin(x) * np.sin(n * np.pi * x / L), 0, L)[0]\nprint(\"a0:\", a0, \"a1:\", an(1), \"b1:\", bn(1))"
    },
    {
        "input": "Let V be the vector space of real polynomials of degree at most 2, with inner product defined by ⟨f, g⟩ = ∫[0,1] f(x)g(x) dx. Find the norm of f(x) = x^2 + x + 1.",
        "output": "import numpy as np\nfrom scipy.integrate import quad\nf = lambda x: x**2 + x + 1\nnorm_f = np.sqrt(quad(lambda x: f(x)**2, 0, 1)[0])\nprint(\"Norm of f:\", norm_f)"
    },
    {
        "input": "In R^3, let W be the subspace spanned by the vectors (1, 1, 2) and (1, 1, -1). Find the point in W closest to the vector (4, 5, -2).",
        "output": "import numpy as np\nv1 = np.array([1, 1, 2])\nv2 = np.array([1, 1, -1])\nv = np.array([4, 5, -2])\nA = np.array([v1, v2]).T\nproj = A @ np.linalg.inv(A.T @ A) @ A.T @ v\nprint(\"Closest point in W:\", proj)"
    },
    {
        "input": "Let V be the vector space of 2x2 real matrices with inner product ⟨A, B⟩ = tr(A^T B). Find the norm of A = [[1, 2], [3, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nnorm_A = np.sqrt(np.trace(A.T @ A))\nprint(\"Norm of A:\", norm_A)"
    },
    {
        "input": "Let V be the vector space of continuous real-valued functions on [0, 1] with inner product ⟨f, g⟩ = ∫[0,1] f(x)g(x) dx. Find the norm of f(x) = e^x.",
        "output": "import numpy as np\nfrom scipy.integrate import quad\nf = lambda x: np.exp(x)\nnorm_f = np.sqrt(quad(lambda x: f(x)**2, 0, 1)[0])\nprint(\"Norm of f:\", norm_f)"
    },
    {
        "input": "Let x = (1, 2, 2) in R³. Compute the L2 norm of x.",
        "output": "import numpy as np\nx = np.array([1, 2, 2])\nnorm = np.linalg.norm(x)\nprint(\"L2 norm:\", norm)"
    },
    {
        "input": "Let u = (1, 2), v = (3, 4). Compute the inner product ⟨u, v⟩ in R².",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([3, 4])\ninner_product = np.dot(u, v)\nprint(\"Inner product:\", inner_product)"
    },
    {
        "input": "Given x = (2, -1, 2), find the unit vector in the same direction.",
        "output": "import numpy as np\nx = np.array([2, -1, 2])\nunit_vector = x / np.linalg.norm(x)\nprint(\"Unit vector:\", unit_vector)"
    },
    {
        "input": "In R² with inner product ⟨x, y⟩ = 2x1y1 + 3x2y2, compute the inner product of x = (1, 2) and y = (3, 4).",
        "output": "x = [1, 2]\ny = [3, 4]\ninner_product = 2*x[0]*y[0] + 3*x[1]*y[1]\nprint(\"Inner product:\", inner_product)"
    },
    {
        "input": "Find the projection of v = (3, 1) onto u = (1, 2).",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([3, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Given vectors u = (1, 1, 0), v = (-1, 1, 0), compute their orthonormal basis using Gram-Schmidt.",
        "output": "import numpy as np\nu = np.array([1, 1, 0])\nv = np.array([-1, 1, 0])\ne1 = u / np.linalg.norm(u)\nproj = np.dot(v, e1) * e1\ne2 = v - proj\ne2 = e2 / np.linalg.norm(e2)\nprint(\"Orthonormal basis:\", e1, e2)"
    },
    {
        "input": "Let x = (1, 2, 3), compute its L∞ norm.",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\nprint(\"L-infinity norm:\", np.max(np.abs(x)))"
    },
    {
        "input": "Given vectors a = (2, 3, 4) and b = (1, 0, -1), compute the distance between them using Euclidean norm.",
        "output": "import numpy as np\na = np.array([2, 3, 4])\nb = np.array([1, 0, -1])\ndistance = np.linalg.norm(a - b)\nprint(\"Distance:\", distance)"
    },
    {
        "input": "Let A be a 2x2 matrix [[1, 2], [3, 4]]. Find the Frobenius norm of A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nnorm = np.linalg.norm(A, 'fro')\nprint(\"Frobenius norm:\", norm)"
    },
    {
        "input": "Given u = (1, 1, 1), v = (1, 2, 3), find scalar projection of v onto u.",
        "output": "import numpy as np\nu = np.array([1, 1, 1])\nv = np.array([1, 2, 3])\nscalar_proj = np.dot(v, u) / np.linalg.norm(u)\nprint(\"Scalar projection:\", scalar_proj)"
    },
    {
        "input": "Find the length of the vector f(x) = sin(x) in inner product space on [0, π] with ⟨f, g⟩ = ∫ f(x)g(x) dx.",
        "output": "from scipy.integrate import quad\nfrom numpy import sin, sqrt\nlength = sqrt(quad(lambda x: sin(x)**2, 0, np.pi)[0])\nprint(\"Length:\", length)"
    },
    {
        "input": "In R³, compute the Euclidean norm (L2 norm) of the vector v = (3, -4, 12).",
        "output": "import numpy as np\nv = np.array([3, -4, 12])\nnorm_v = np.linalg.norm(v)\nprint(\"L2 norm of v:\", norm_v)"
    },
    {
        "input": "Given vectors u = (1, 0, 0) and v = (0, 1, 1) in R³, calculate their inner product.",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([0, 1, 1])\ninner_product = np.dot(u, v)\nprint(\"Inner product of u and v:\", inner_product)"
    },
    {
        "input": "Find the projection of vector v = (4, 2) onto vector u = (1, 1) in R².",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([4, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(\"Projection of v onto u:\", projection)"
    },
    {
        "input": "Compute the L1 norm (Manhattan norm) of the vector v = (-3, 4, -5) in R³.",
        "output": "import numpy as np\nv = np.array([-3, 4, -5])\nl1_norm = np.sum(np.abs(v))\nprint(\"L1 norm of v:\", l1_norm)"
    },
    {
        "input": "In R³, compute the cosine of the angle between vectors u = (1, 2, 3) and v = (4, 5, 6).",
        "output": "import numpy as np\nu = np.array([1, 2, 3])\nv = np.array([4, 5, 6])\ncos_theta = np.dot(u, v) / (np.linalg.norm(u) * np.linalg.norm(v))\nprint(\"Cosine of the angle between u and v:\", cos_theta)"
    },
    {
        "input": "Find the unit vector in the direction of v = (7, -24) in R².",
        "output": "import numpy as np\nv = np.array([7, -24])\nunit_vector = v / np.linalg.norm(v)\nprint(\"Unit vector in the direction of v:\", unit_vector)"
    },
    {
        "input": "Given vectors u = (1, 2, 3) and v = (4, 5, 6) in R³, compute their cross product.",
        "output": "import numpy as np\nu = np.array([1, 2, 3])\nv = np.array([4, 5, 6])\ncross_product = np.cross(u, v)\nprint(\"Cross product of u and v:\", cross_product)"
    },
    {
        "input": "Determine the orthogonal projection of v = (3, 4, 5) onto the plane defined by normal vector n = (0, 0, 1) in R³.",
        "output": "import numpy as np\nv = np.array([3, 4, 5])\nn = np.array([0, 0, 1])\nprojection = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(\"Projection of v onto the plane:\", projection)"
    },
    {
        "input": "Compute the Frobenius norm of matrix A = [[1, 2], [3, 4]] in R²x².",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nfrobenius_norm = np.sqrt(np.sum(A**2))\nprint(\"Frobenius norm of A:\", frobenius_norm)"
    },
    {
        "input": "Given vectors u = (1, 2) and v = (2, -1) in R², find the area of the parallelogram they span.",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([2, -1])\narea = np.abs(np.cross(u, v))\nprint(\"Area of the parallelogram spanned by u and v:\", area)"
    },
    {
        "input": "Compute the Euclidean norm (L2 norm) of the vector v = (6, -8, 0) in R³.",
        "output": "import numpy as np\nv = np.array([6, -8, 0])\nnorm_v = np.linalg.norm(v)\nprint(\"L2 norm of v:\", norm_v)"
    },
    {
        "input": "Given vectors u = (2, -1, 3) and v = (-1, 4, -2) in R³, calculate their inner product.",
        "output": "import numpy as np\nu = np.array([2, -1, 3])\nv = np.array([-1, 4, -2])\ninner_product = np.dot(u, v)\nprint(\"Inner product of u and v:\", inner_product)"
    },
    {
        "input": "Find the projection of vector v = (5, 0) onto vector u = (1, 1) in R².",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([5, 0])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(\"Projection of v onto u:\", projection)"
    },
    {
        "input": "Compute the L1 norm (Manhattan norm) of the vector v = (7, -2, 3) in R³.",
        "output": "import numpy as np\nv = np.array([7, -2, 3])\nl1_norm = np.sum(np.abs(v))\nprint(\"L1 norm of v:\", l1_norm)"
    },
    {
        "input": "In R³, compute the cosine of the angle between vectors u = (1, 0, 0) and v = (0, 1, 0).",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([0, 1, 0])\ncos_theta = np.dot(u, v) / (np.linalg.norm(u) * np.linalg.norm(v))\nprint(\"Cosine of the angle between u and v:\", cos_theta)"
    },
    {
        "input": "Find the unit vector in the direction of v = (-3, 4) in R².",
        "output": "import numpy as np\nv = np.array([-3, 4])\nunit_vector = v / np.linalg.norm(v)\nprint(\"Unit vector in the direction of v:\", unit_vector)"
    },
    {
        "input": "Given vectors u = (0, 1, 2) and v = (2, 0, -1) in R³, compute their cross product.",
        "output": "import numpy as np\nu = np.array([0, 1, 2])\nv = np.array([2, 0, -1])\ncross_product = np.cross(u, v)\nprint(\"Cross product of u and v:\", cross_product)"
    },
    {
        "input": "In R², find the angle between vectors u = (1, 2) and v = (2, 3) in degrees.",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([2, 3])\ncos_theta = np.dot(u, v) / (np.linalg.norm(u) * np.linalg.norm(v))\nangle_rad = np.arccos(cos_theta)\nangle_deg = np.degrees(angle_rad)\nprint(\"Angle between u and v in degrees:\", angle_deg)"
    },
    {
        "input": "Determine the orthogonal projection of v = (1, 2, 3) onto the plane defined by normal vector n = (0, 0, 1) in R³.",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nn = np.array([0, 0, 1])\nprojection = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(\"Projection of v onto the plane:\", projection)"
    },
    {
        "input": "Compute the Frobenius norm of matrix A = [[2, -1], [-1, 2]] in R²x².",
        "output": "import numpy as np\nA = np.array([[2, -1], [-1, 2]])\nfrobenius_norm = np.sqrt(np.sum(A**2))\nprint(\"Frobenius norm of A:\", frobenius_norm)"
    },
    {
        "input": "Given vectors u = (3, 0) and v = (0, 4) in R², find the area of the parallelogram they span.",
        "output": "import numpy as np\nu = np.array([3, 0])\nv = np.array([0, 4])\narea = np.abs(np.cross(u, v))\nprint(\"Area of the parallelogram spanned by u and v:\", area)"
    },
    {
        "input": "Given the vector x = [4, -3, 12], compute its L2 norm.",
        "output": "import numpy as np\nx = np.array([4, -3, 12])\nnorm = np.linalg.norm(x)\nprint(\"L2 norm:\", norm)"
    },
    {
        "input": "Compute the L1 norm of the vector v = [-5, 3, -2, 7].",
        "output": "import numpy as np\nv = np.array([-5, 3, -2, 7])\nnorm = np.linalg.norm(v, ord=1)\nprint(\"L1 norm:\", norm)"
    },
    {
        "input": "Find the maximum norm (L-infinity norm) of the vector a = [2, -7, 6, 0].",
        "output": "import numpy as np\na = np.array([2, -7, 6, 0])\nnorm = np.linalg.norm(a, ord=np.inf)\nprint(\"L-infinity norm:\", norm)"
    },
    {
        "input": "Normalize the vector u = [3, 4].",
        "output": "import numpy as np\nu = np.array([3, 4])\nunit_vector = u / np.linalg.norm(u)\nprint(\"Normalized vector:\", unit_vector)"
    },
    {
        "input": "Compute the inner product of vectors x = [1, 2, 3] and y = [4, -1, 2].",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([4, -1, 2])\ninner_product = np.dot(x, y)\nprint(\"Inner product:\", inner_product)"
    },
    {
        "input": "Given a vector v = [0, 2, -2], compute its squared norm using dot product.",
        "output": "import numpy as np\nv = np.array([0, 2, -2])\nsquared_norm = np.dot(v, v)\nprint(\"Squared norm:\", squared_norm)"
    },
    {
        "input": "Given u = [1, 2] and v = [3, 4], compute the cosine of the angle between them.",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([3, 4])\ncos_theta = np.dot(u, v) / (np.linalg.norm(u) * np.linalg.norm(v))\nprint(\"Cosine of angle:\", cos_theta)"
    },
    {
        "input": "Find the projection of vector u = [2, 3] on vector v = [1, 0].",
        "output": "import numpy as np\nu = np.array([2, 3])\nv = np.array([1, 0])\nproj = (np.dot(u, v) / np.dot(v, v)) * v\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute its Frobenius norm.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nnorm = np.linalg.norm(A, 'fro')\nprint(\"Frobenius norm:\", norm)"
    },
    {
        "input": "Compute the inner product of u = [5, -3, 0] and v = [2, 1, 4].",
        "output": "import numpy as np\nu = np.array([5, -3, 0])\nv = np.array([2, 1, 4])\nresult = np.dot(u, v)\nprint(\"Inner product:\", result)"
    },
    {
        "input": "Normalize the vector x = [-1, 2, -2].",
        "output": "import numpy as np\nx = np.array([-1, 2, -2])\nnormalized = x / np.linalg.norm(x)\nprint(\"Normalized vector:\", normalized)"
    },
    {
        "input": "For a = [3, 1, 4] and b = [2, 2, 2], calculate the inner product and determine the angle between them.",
        "output": "import numpy as np\na = np.array([3, 1, 4])\nb = np.array([2, 2, 2])\ndot = np.dot(a, b)\nnorm_a = np.linalg.norm(a)\nnorm_b = np.linalg.norm(b)\nangle = np.arccos(dot / (norm_a * norm_b))\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Find the L2 norm of the difference between u = [4, 5] and v = [1, 1].",
        "output": "import numpy as np\nu = np.array([4, 5])\nv = np.array([1, 1])\ndiff = u - v\nprint(\"Norm of difference:\", np.linalg.norm(diff))"
    },
    {
        "input": "Compute the L2 distance between vectors u = [5, 6, 7] and v = [2, 4, 6].",
        "output": "import numpy as np\nu = np.array([5, 6, 7])\nv = np.array([2, 4, 6])\ndistance = np.linalg.norm(u - v)\nprint(\"L2 distance:\", distance)"
    },
    {
        "input": "Given matrix A = [[1, -1], [1, 1]], compute its column norms.",
        "output": "import numpy as np\nA = np.array([[1, -1], [1, 1]])\ncolumn_norms = np.linalg.norm(A, axis=0)\nprint(\"Column norms:\", column_norms)"
    },
    {
        "input": "Find the L2 norm of the matrix A = [[2, 2], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[2, 2], [1, 1]])\nnorm = np.linalg.norm(A)\nprint(\"L2 norm of matrix:\", norm)"
    },
    {
        "input": "Find the angle between the vectors a = [1, 1] and b = [1, -1] using inner product.",
        "output": "import numpy as np\na = np.array([1, 1])\nb = np.array([1, -1])\nangle = np.arccos(np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b)))\nprint(\"Angle in radians:\", angle)"
    },
    {
        "input": "Given u = [3, 4] and v = [4, 3], compute the normalized dot product.",
        "output": "import numpy as np\nu = np.array([3, 4])\nv = np.array([4, 3])\ndot_normalized = np.dot(u, v) / (np.linalg.norm(u) * np.linalg.norm(v))\nprint(\"Normalized dot product:\", dot_normalized)"
    },
    {
        "input": "Use the Polarization Identity to compute the inner product of u = [2, -1] and v = [1, 3] in R².",
        "output": "import numpy as np\nu = np.array([2, -1])\nv = np.array([1, 3])\ninner_product = 0.25 * (np.linalg.norm(u + v)**2 - np.linalg.norm(u - v)**2)\nprint(\"Inner product:\", inner_product)"
    },
    {
        "input": "Find the orthogonal complement of the subspace spanned by [1, 1, 0] in R³.",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 1, 0]])\northogonal_complement = null_space(A)\nprint(\"Orthogonal complement:\", orthogonal_complement)"
    },
    {
        "input": "Given a linear functional f(x) = 3x₁ - 4x₂ on R², find the vector associated with f via the Riesz Representation Theorem.",
        "output": "import numpy as np\nf = np.array([3, -4])\nprint(\"Associated vector:\", f)"
    },
    {
        "input": "Compute the norm of the linear functional f(x) = 2x₁ - x₂ + 3x₃ on R³.",
        "output": "import numpy as np\nf = np.array([2, -1, 3])\nnorm_f = np.linalg.norm(f)\nprint(\"Norm of f:\", norm_f)"
    },
    {
        "input": "Use the Polarization Identity to compute the inner product of u = [4, 0] and v = [0, 3] in R².",
        "output": "import numpy as np\nu = np.array([4, 0])\nv = np.array([0, 3])\ninner_product = 0.25 * (np.linalg.norm(u + v)**2 - np.linalg.norm(u - v)**2)\nprint(\"Inner product:\", inner_product)"
    },
    {
        "input": "Find the projection of [2, 3, 4] onto the subspace orthogonal to [1, 1, 1] in R³.",
        "output": "import numpy as np\nv = np.array([2, 3, 4])\na = np.array([1, 1, 1])\nprojection = v - (np.dot(v, a) / np.dot(a, a)) * a\nprint(\"Projection:\", projection)"
    },
    {
        "input": "Compute the inner product of u = [1, 2, 3] and v = [4, 5, 6] using the Polarization Identity in R³.",
        "output": "import numpy as np\nu = np.array([1, 2, 3])\nv = np.array([4, 5, 6])\ninner_product = 0.25 * (np.linalg.norm(u + v)**2 - np.linalg.norm(u - v)**2)\nprint(\"Inner product:\", inner_product)"
    },
    {
        "input": "Find the orthogonal complement of the subspace spanned by [2, -1, 3] in R³.",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[2, -1, 3]])\northogonal_complement = null_space(A)\nprint(\"Orthogonal complement:\", orthogonal_complement)"
    },
    {
        "input": "Given a linear functional f(x) = x₁ + 2x₂ - x₃ on R³, find the vector associated with f via the Riesz Representation Theorem.",
        "output": "import numpy as np\nf = np.array([1, 2, -1])\nprint(\"Associated vector:\", f)"
    },
    {
        "input": "Compute the orthogonal projection of [3, 4, 5] onto the subspace spanned by [1, 0, 0] in R³.",
        "output": "import numpy as np\nv = np.array([3, 4, 5])\na = np.array([1, 0, 0])\nprojection = (np.dot(v, a) / np.dot(a, a)) * a\nprint(\"Orthogonal projection:\", projection)"
    },
    {
        "input": "Apply the Gram-Schmidt process to orthogonalize the set {[1, 1, 0], [0, 1, 1]} in R³.",
        "output": "import numpy as np\nv1 = np.array([1, 1, 0])\nv2 = np.array([0, 1, 1])\nu1 = v1\nu2 = v2 - (np.dot(v2, u1) / np.dot(u1, u1)) * u1\nprint(\"Orthonormal basis:\", u1 / np.linalg.norm(u1), u2 / np.linalg.norm(u2))"
    },
    {
        "input": "Calculate the norm of the vector [1, -2, 3, -4] in R⁴ using the Euclidean norm.",
        "output": "import numpy as np\nv = np.array([1, -2, 3, -4])\nnorm_v = np.linalg.norm(v, ord=2)\nprint(\"Euclidean norm:\", norm_v)"
    },
    {
        "input": "Use the Polarization Identity to compute the inner product of u = [2, 3] and v = [-1, 4] in R².",
        "output": "import numpy as np\nu = np.array([2, 3])\nv = np.array([-1, 4])\ninner_product = 0.25 * (np.linalg.norm(u + v, ord=2)**2 - np.linalg.norm(u - v, ord=2)**2)\nprint(\"Inner product:\", inner_product)"
    },
    {
        "input": "Find the projection of [1, 2, 3] onto the line spanned by [4, 5, 6] in R³.",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\na = np.array([4, 5, 6])\nprojection = (np.dot(v, a) / np.dot(a, a)) * a\nprint(\"Projection:\", projection)"
    },
    {
        "input": "Compute the inner product of u = [3, 4, 5] and v = [-2, 1, 3] using the Polarization Identity in R³.",
        "output": "import numpy as np\nu = np.array([3, 4, 5])\nv = np.array([-2, 1, 3])\ninner_product = 0.25 * (np.linalg.norm(u + v, ord=2)**2 - np.linalg.norm(u - v, ord=2)**2)\nprint(\"Inner product:\", inner_product)"
    },
    {
        "input": "Find the orthogonal complement of the subspace spanned by [1, 2, 3] in R³.",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 2, 3]])\northogonal_complement = null_space(A)\nprint(\"Orthogonal complement:\", orthogonal_complement)"
    },
    {
        "input": "Compute the norm of vector v = [3, -4, 1].",
        "output": "import numpy as np\nv = np.array([3, -4, 1])\nnorm = np.linalg.norm(v)\nprint(\"Norm:\", norm)"
    },
    {
        "input": "Use Polarization Identity to compute ⟨u, v⟩ where u = [1, 0], v = [0, 1].",
        "output": "import numpy as np\nu = np.array([1, 0])\nv = np.array([0, 1])\ninner = 0.25 * (np.linalg.norm(u + v)**2 - np.linalg.norm(u - v)**2)\nprint(\"Inner product:\", inner)"
    },
    {
        "input": "Find the projection of u = [1, 2, 3] onto v = [4, -1, 2].",
        "output": "import numpy as np\nu = np.array([1, 2, 3])\nv = np.array([4, -1, 2])\nproj = (np.dot(u, v) / np.dot(v, v)) * v\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Find the angle θ between u = [1, 0] and v = [1, 1].",
        "output": "import numpy as np\nu = np.array([1, 0])\nv = np.array([1, 1])\ncos_theta = np.dot(u, v) / (np.linalg.norm(u) * np.linalg.norm(v))\nangle = np.arccos(cos_theta)\nprint(\"Angle in degrees:\", np.degrees(angle))"
    },
    {
        "input": "Find norm induced by inner product ⟨u,v⟩ = u₁v₁ + 3u₂v₂ on vector [2, 1].",
        "output": "import numpy as np\nu = np.array([2, 1])\nnorm = np.sqrt(u[0]**2 + 3 * u[1]**2)\nprint(\"Induced norm:\", norm)"
    },
    {
        "input": "Given vectors u = [2, 3], v = [1, 1], compute projection of u on v.",
        "output": "import numpy as np\nu = np.array([2, 3])\nv = np.array([1, 1])\nproj = (np.dot(u, v) / np.dot(v, v)) * v\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Compute the norm of f(x) = x₁ - 2x₂ + 3x₃ in R³ using Riesz Representation.",
        "output": "import numpy as np\nf = np.array([1, -2, 3])\nprint(\"Norm of functional:\", np.linalg.norm(f))"
    },
    {
        "input": "Find the unit vector in the direction of u = [-2, 2, 1].",
        "output": "import numpy as np\nu = np.array([-2, 2, 1])\nunit = u / np.linalg.norm(u)\nprint(\"Unit vector:\", unit)"
    },
    {
        "input": "Compute ⟨u,v⟩ where u = [3, 1, 0] and v = [1, 0, -1].",
        "output": "import numpy as np\nu = np.array([3, 1, 0])\nv = np.array([1, 0, -1])\nprint(\"Inner product:\", np.dot(u, v))"
    },
    {
        "input": "Given inner product ⟨u,v⟩ = u₁v₁ + u₂v₂ + 4u₃v₃, find induced norm for u = [0, 2, 1].",
        "output": "import numpy as np\nu = np.array([0, 2, 1])\nnorm = np.sqrt(u[0]**2 + u[1]**2 + 4 * u[2]**2)\nprint(\"Induced norm:\", norm)"
    },
    {
        "input": "Find angle between vectors [2, 2] and [1, -1].",
        "output": "import numpy as np\nu = np.array([2, 2])\nv = np.array([1, -1])\nangle = np.arccos(np.dot(u, v) / (np.linalg.norm(u) * np.linalg.norm(v)))\nprint(\"Angle (deg):\", np.degrees(angle))"
    },
    {
        "input": "Use Riesz Representation Theorem to write functional f(x) = 4x₁ + x₂ in vector form.",
        "output": "import numpy as np\nf = np.array([4, 1])\nprint(\"Vector representation:\", f)"
    },
    {
        "input": "Compute the L¹-norm of vector v = [3, -4, 5].",
        "output": "import numpy as np\nv = np.array([3, -4, 5])\nnorm = np.sum(np.abs(v))\nprint(\"L1 norm:\", norm)"
    },
    {
        "input": "Compute the L∞-norm of vector v = [-1, 7, -3].",
        "output": "import numpy as np\nv = np.array([-1, 7, -3])\nnorm = np.max(np.abs(v))\nprint(\"L-infinity norm:\", norm)"
    },
    {
        "input": "Find the Euclidean norm of vector u = [0, -3, 4].",
        "output": "import numpy as np\nu = np.array([0, -3, 4])\nnorm = np.linalg.norm(u)\nprint(\"Euclidean norm:\", norm)"
    },
    {
        "input": "Find inner product ⟨u, v⟩ where u = [2, 2], v = [3, -3].",
        "output": "import numpy as np\nu = np.array([2, 2])\nv = np.array([3, -3])\ninner = np.dot(u, v)\nprint(\"Inner product:\", inner)"
    },
    {
        "input": "Given u = [1, 1], compute its projection on v = [2, 0].",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([2, 0])\nproj = (np.dot(u, v) / np.dot(v, v)) * v\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Using Gram-Schmidt, orthogonalize vectors u1 = [1, 1], u2 = [1, 0].",
        "output": "import numpy as np\nu1 = np.array([1, 1])\nu2 = np.array([1, 0])\nv1 = u1\nproj = (np.dot(u2, v1) / np.dot(v1, v1)) * v1\nv2 = u2 - proj\nprint(\"Orthogonal vector v2:\", v2)"
    },
    {
        "input": "Find distance between u = [1, 1] and v = [4, 5] using norm.",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([4, 5])\ndistance = np.linalg.norm(u - v)\nprint(\"Distance:\", distance)"
    },
    {
        "input": "Find cosine of angle between u = [1, 2], v = [2, 3].",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([2, 3])\ncos_theta = np.dot(u, v) / (np.linalg.norm(u) * np.linalg.norm(v))\nprint(\"Cosine:\", cos_theta)"
    },
    {
        "input": "Given ⟨u,v⟩ = u₁v₁ + 2u₂v₂, find norm of u = [3, 1].",
        "output": "import numpy as np\nu = np.array([3, 1])\nnorm = np.sqrt(u[0]**2 + 2*u[1]**2)\nprint(\"Induced norm:\", norm)"
    },
    {
        "input": "Given u = [2, 3], v = [1, 4], compute ||u - v||².",
        "output": "import numpy as np\nu = np.array([2, 3])\nv = np.array([1, 4])\ndiff = u - v\nprint(\"Squared distance:\", np.dot(diff, diff))"
    },
    {
        "input": "Calculate inner product in function space: ⟨f,g⟩ = ∫₀¹ f(x)g(x) dx for f(x)=x, g(x)=x².",
        "output": "from scipy.integrate import quad\nf = lambda x: x\ng = lambda x: x**2\nresult, _ = quad(lambda x: f(x)*g(x), 0, 1)\nprint(\"Inner product:\", result)"
    },
    {
        "input": "Normalize vector u = [5, 12].",
        "output": "import numpy as np\nu = np.array([5, 12])\nunit = u / np.linalg.norm(u)\nprint(\"Unit vector:\", unit)"
    },
    {
        "input": "Find component of u = [2, 3] along v = [1, 0].",
        "output": "import numpy as np\nu = np.array([2, 3])\nv = np.array([1, 0])\ncomponent = np.dot(u, v) / np.linalg.norm(v)\nprint(\"Component:\", component)"
    },
    {
        "input": "Compute norm of linear transformation T(x) = 2x in R¹.",
        "output": "import numpy as np\nx = 1\nT = lambda x: 2 * x\nnorm = abs(T(x)) / abs(x)\nprint(\"Operator norm:\", norm)"
    },
    {
        "input": "Apply Gram-Schmidt on vectors [1, 1, 0] and [1, 0, 1].",
        "output": "import numpy as np\nv1 = np.array([1, 1, 0])\nv2 = np.array([1, 0, 1])\nu1 = v1\nu2 = v2 - (np.dot(v2, u1)/np.dot(u1, u1))*u1\nprint(\"Ortho vector:\", u2)"
    },
    {
        "input": "Find angle between u = [1, 0], v = [1, 1] in degrees.",
        "output": "import numpy as np\nu = np.array([1, 0])\nv = np.array([1, 1])\ncos_theta = np.dot(u, v) / (np.linalg.norm(u) * np.linalg.norm(v))\nangle = np.degrees(np.arccos(cos_theta))\nprint(\"Angle (degrees):\", angle)"
    },
    {
        "input": "Compute norm induced by ⟨u,v⟩ = 2u₁v₁ + 3u₂v₂ for u = [2, -1].",
        "output": "import numpy as np\nu = np.array([2, -1])\nnorm = np.sqrt(2*u[0]**2 + 3*u[1]**2)\nprint(\"Induced norm:\", norm)"
    },
    {
        "input": "Normalize the vector [7, 24].",
        "output": "import numpy as np\nv = np.array([7, 24])\nunit = v / np.linalg.norm(v)\nprint(\"Normalized vector:\", unit)"
    },
    {
        "input": "Compute L1 norm of vector [-2, 0, 4, -3].",
        "output": "import numpy as np\nv = np.array([-2, 0, 4, -3])\nnorm = np.sum(np.abs(v))\nprint(\"L1 norm:\", norm)"
    },
    {
        "input": "Compute Euclidean norm of vector [1, -2, 2, -1].",
        "output": "import numpy as np\nv = np.array([1, -2, 2, -1])\nnorm = np.linalg.norm(v)\nprint(\"Euclidean norm:\", norm)"
    },
    {
        "input": "Use Gram-Schmidt to orthogonalize u1 = [1, 0, 1], u2 = [1, 1, 1].",
        "output": "import numpy as np\nu1 = np.array([1, 0, 1])\nu2 = np.array([1, 1, 1])\nv1 = u1\nproj = (np.dot(u2, v1) / np.dot(v1, v1)) * v1\nv2 = u2 - proj\nprint(\"v2:\", v2)"
    },
    {
        "input": "Find squared norm of u = [2, 3] using ⟨u,u⟩.",
        "output": "import numpy as np\nu = np.array([2, 3])\nsquared_norm = np.dot(u, u)\nprint(\"Squared norm:\", squared_norm)"
    },
    {
        "input": "Compute inner product ⟨f, g⟩ where f(x)=sin(x), g(x)=cos(x) on [0, π/2].",
        "output": "from scipy.integrate import quad\nfrom numpy import sin, cos\nresult, _ = quad(lambda x: sin(x)*cos(x), 0, np.pi/2)\nprint(\"Inner product:\", result)"
    },
    {
        "input": "Find projection of u = [2, 2] onto v = [1, 1].",
        "output": "import numpy as np\nu = np.array([2, 2])\nv = np.array([1, 1])\nproj = (np.dot(u, v) / np.dot(v, v)) * v\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Compute ||x|| where x = [1, -1, 2, -2] under max norm.",
        "output": "import numpy as np\nx = np.array([1, -1, 2, -2])\nnorm = np.max(np.abs(x))\nprint(\"Max norm:\", norm)"
    },
    {
        "input": "Find unit vector in direction of u = [-5, 12].",
        "output": "import numpy as np\nu = np.array([-5, 12])\nunit = u / np.linalg.norm(u)\nprint(\"Unit vector:\", unit)"
    },
    {
        "input": "Given vectors a = [1, 2], b = [2, 1], compute ⟨a, b⟩ in inner product space with weight matrix W = [[2, 0], [0, 3]].",
        "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([2, 1])\nW = np.array([[2, 0], [0, 3]])\ninner = np.dot(a.T, np.dot(W, b))\nprint(\"Weighted inner product:\", inner)"
    },
    {
        "input": "Calculate distance between vectors a = [1, 2] and b = [4, 6] using 2-norm.",
        "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([4, 6])\nd = np.linalg.norm(a - b)\nprint(\"Distance:\", d)"
    },
    {
        "input": "Find norm of u = [2, -3, 6] under L2 norm.",
        "output": "import numpy as np\nu = np.array([2, -3, 6])\nnorm = np.linalg.norm(u)\nprint(\"L2 norm:\", norm)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize vectors u1 = [1, 1, 0], u2 = [1, 0, 1].",
        "output": "import numpy as np\nu1 = np.array([1, 1, 0])\nu2 = np.array([1, 0, 1])\nv1 = u1 / np.linalg.norm(u1)\nproj = np.dot(u2, v1) * v1\nv2 = u2 - proj\nv2 = v2 / np.linalg.norm(v2)\nprint(\"Orthonormal vectors:\", v1, v2)"
    },
    {
        "input": "Find norm induced by inner product ⟨x, y⟩ = 4x₁y₁ + 2x₂y₂ for x = [2,3].",
        "output": "import numpy as np\nx = np.array([2,3])\nnorm = np.sqrt(4*x[0]**2 + 2*x[1]**2)\nprint(\"Induced norm:\", norm)"
    },
    {
        "input": "Compute inner product of polynomials f(x)=x and g(x)=x^3 on [0,1].",
        "output": "from scipy.integrate import quad\ninner, _ = quad(lambda x: x*x**3, 0, 1)\nprint(\"Inner product:\", inner)"
    },
    {
        "input": "Calculate projection of a = [2, 4] on b = [1, 1].",
        "output": "import numpy as np\na = np.array([2, 4])\nb = np.array([1, 1])\nproj = (np.dot(a,b)/np.dot(b,b)) * b\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Compute ||x||∞ for x = [-1, 5, 2, -4].",
        "output": "import numpy as np\nx = np.array([-1, 5, 2, -4])\nprint(\"Infinity norm:\", np.max(np.abs(x)))"
    },
    {
        "input": "Given a = [3,4], b = [4,3], find angle between them in degrees.",
        "output": "import numpy as np\na = np.array([3,4])\nb = np.array([4,3])\ncos_theta = np.dot(a,b)/(np.linalg.norm(a)*np.linalg.norm(b))\nangle = np.degrees(np.arccos(cos_theta))\nprint(\"Angle:\", angle)"
    },
    {
        "input": "Calculate norm of f(x)=x^2 on [0,1] under L2 norm.",
        "output": "from scipy.integrate import quad\nfrom numpy import sqrt\nf = lambda x: x**2\nsquared_norm, _ = quad(lambda x: f(x)**2, 0, 1)\nprint(\"L2 norm:\", sqrt(squared_norm))"
    },
    {
        "input": "Find L1 norm of vector [1, -2, 3, -4].",
        "output": "import numpy as np\nx = np.array([1, -2, 3, -4])\nprint(\"L1 norm:\", np.sum(np.abs(x)))"
    },
    {
        "input": "Normalize vector [6, 8].",
        "output": "import numpy as np\nx = np.array([6, 8])\nunit = x / np.linalg.norm(x)\nprint(\"Normalized:\", unit)"
    },
    {
        "input": "Find induced norm using ⟨x,y⟩ = x₁y₁ + 4x₂y₂ for x = [1, 2].",
        "output": "import numpy as np\nx = np.array([1, 2])\nnorm = np.sqrt(np.dot(x, [1, 8]))\nprint(\"Induced norm:\", norm)"
    },
    {
        "input": "Compute angle between vectors u = [5, 0] and v = [0, 12].",
        "output": "import numpy as np\nu = np.array([5, 0])\nv = np.array([0, 12])\ncos_theta = np.dot(u, v)/(np.linalg.norm(u)*np.linalg.norm(v))\nangle = np.degrees(np.arccos(cos_theta))\nprint(\"Angle:\", angle)"
    },
    {
        "input": "For f(x)=x^2, compute norm over [−1,1] in L2 space.",
        "output": "from scipy.integrate import quad\nfrom numpy import sqrt\nf = lambda x: x**2\nsquared_norm, _ = quad(lambda x: f(x)**2, -1, 1)\nprint(\"L2 norm:\", sqrt(squared_norm))"
    },
    {
        "input": "Find projection of f(x)=x^2 on g(x)=x on [0,1].",
        "output": "from scipy.integrate import quad\nnum, _ = quad(lambda x: x**3, 0, 1)\nden, _ = quad(lambda x: x**2, 0, 1)\nprint(\"Projection scalar:\", num/den)"
    },
    {
        "input": "Find L2 norm of vector [1, 3, 5].",
        "output": "import numpy as np\nv = np.array([1, 3, 5])\nprint(\"L2 norm:\", np.linalg.norm(v))"
    },
    {
        "input": "Compute ||x||₁ and ||x||∞ for x = [4, -3, 2, -7].",
        "output": "import numpy as np\nx = np.array([4, -3, 2, -7])\nprint(\"L1 norm:\", np.sum(np.abs(x)))\nprint(\"Infinity norm:\", np.max(np.abs(x)))"
    },
    {
        "input": "Compute inner product ⟨x, y⟩ for x = [2, 0, -1], y = [-1, 4, 3].",
        "output": "import numpy as np\nx = np.array([2, 0, -1])\ny = np.array([-1, 4, 3])\nprint(\"Inner product:\", np.dot(x, y))"
    },
    {
        "input": "Find unit vector in direction of v = [3, -4].",
        "output": "import numpy as np\nv = np.array([3, -4])\nunit_v = v / np.linalg.norm(v)\nprint(\"Unit vector:\", unit_v)"
    },
    {
        "input": "Apply Gram-Schmidt to vectors [1, 2], [3, 4].",
        "output": "import numpy as np\nv1 = np.array([1, 2])\nv2 = np.array([3, 4])\ne1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, e1) * e1\ne2 = v2 - proj\ne2 = e2 / np.linalg.norm(e2)\nprint(\"Orthonormal basis:\", e1, e2)"
    },
    {
        "input": "Find projection of x = [1, 2, 3] on y = [1, 0, -1].",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([1, 0, -1])\nproj = (np.dot(x, y) / np.dot(y, y)) * y\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Find induced norm from inner product ⟨x,y⟩ = x₁y₁ + 9x₂y₂ for x = [2, 1].",
        "output": "import numpy as np\nx = np.array([2, 1])\nnorm = np.sqrt(np.dot(x, [2, 9]))\nprint(\"Induced norm:\", norm)"
    },
    {
        "input": "Evaluate ⟨f,g⟩ = ∫(0 to 1) f(x)g(x) dx for f(x)=sin(x), g(x)=cos(x).",
        "output": "from scipy.integrate import quad\nimport numpy as np\ninner, _ = quad(lambda x: np.sin(x)*np.cos(x), 0, 1)\nprint(\"Inner product:\", inner)"
    },
    {
        "input": "Compute cosine similarity between a = [2, 3], b = [3, 2].",
        "output": "import numpy as np\na = np.array([2, 3])\nb = np.array([3, 2])\ncos_sim = np.dot(a, b)/(np.linalg.norm(a)*np.linalg.norm(b))\nprint(\"Cosine similarity:\", cos_sim)"
    },
    {
        "input": "Calculate ||x||₂ for x = [7, 24].",
        "output": "import numpy as np\nx = np.array([7, 24])\nprint(\"Euclidean norm:\", np.linalg.norm(x))"
    },
    {
        "input": "Compute L2 norm of f(x)=e^x on [0,1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nf = lambda x: np.exp(x)\nsq_norm, _ = quad(lambda x: f(x)**2, 0, 1)\nprint(\"L2 norm:\", np.sqrt(sq_norm))"
    },
    {
        "input": "Use Gram-Schmidt on vectors u1=[1,1,1], u2=[1,0,1], u3=[0,0,1].",
        "output": "import numpy as np\nu1 = np.array([1,1,1])\nu2 = np.array([1,0,1])\nu3 = np.array([0,0,1])\ne1 = u1/np.linalg.norm(u1)\nproj2 = np.dot(u2, e1)*e1\ne2 = u2 - proj2\ne2 /= np.linalg.norm(e2)\nproj3 = np.dot(u3, e1)*e1 + np.dot(u3, e2)*e2\ne3 = u3 - proj3\ne3 /= np.linalg.norm(e3)\nprint(\"Orthonormal basis:\", e1, e2, e3)"
    },
    {
        "input": "Compute angle between a = [1, 2], b = [2, 3] in radians.",
        "output": "import numpy as np\na = np.array([1,2])\nb = np.array([2,3])\nangle = np.arccos(np.dot(a, b)/(np.linalg.norm(a)*np.linalg.norm(b)))\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Find distance between vectors x=[1,2], y=[3,4].",
        "output": "import numpy as np\nx = np.array([1, 2])\ny = np.array([3, 4])\nprint(\"Distance:\", np.linalg.norm(x - y))"
    },
    {
        "input": "For inner product ⟨x,y⟩ = 2x₁y₁ + 3x₂y₂, compute ||x|| for x=[3,4].",
        "output": "import numpy as np\nx = np.array([3,4])\nnorm = np.sqrt(2*x[0]**2 + 3*x[1]**2)\nprint(\"Induced norm:\", norm)"
    },
    {
        "input": "Find the L1 norm of function f(x) = |x| over interval [−1, 1].",
        "output": "from scipy.integrate import quad\nf = lambda x: abs(x)\narea, _ = quad(f, -1, 1)\nprint(\"L1 norm:\", area)"
    },
    {
        "input": "Compute the projection of a = [2, 3] on b = [1, 1].",
        "output": "import numpy as np\na = np.array([2, 3])\nb = np.array([1, 1])\nproj = (np.dot(a, b)/np.dot(b, b)) * b\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Find the orthogonal component of [2, 2] with respect to [1, 0].",
        "output": "import numpy as np\nv = np.array([2, 2])\nu = np.array([1, 0])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\northogonal_component = v - proj\nprint(\"Orthogonal component:\", orthogonal_component)"
    },
    {
        "input": "Use Gram-Schmidt on [1, 0], [1, 1], [1, 2].",
        "output": "import numpy as np\nu1 = np.array([1, 0])\nu2 = np.array([1, 1])\nu3 = np.array([1, 2])\ne1 = u1 / np.linalg.norm(u1)\nproj2 = np.dot(u2, e1) * e1\ne2 = u2 - proj2\ne2 = e2 / np.linalg.norm(e2)\nproj3 = np.dot(u3, e1)*e1 + np.dot(u3, e2)*e2\ne3 = u3 - proj3\ne3 = e3 / np.linalg.norm(e3)\nprint(\"Orthonormal basis:\", e1, e2, e3)"
    },
    {
        "input": "Calculate the L1 norm of x = [-3, 4, -5, 6].",
        "output": "import numpy as np\nx = np.array([-3, 4, -5, 6])\nprint(\"L1 norm:\", np.sum(np.abs(x)))"
    },
    {
        "input": "Compute ||x||_∞ for x = [1, -9, 3, 4].",
        "output": "import numpy as np\nx = np.array([1, -9, 3, 4])\nprint(\"Infinity norm:\", np.max(np.abs(x)))"
    },
    {
        "input": "Compute induced norm from ⟨x,y⟩ = 5x₁y₁ + 2x₂y₂ for x = [2, 3].",
        "output": "import numpy as np\nx = np.array([2, 3])\nnorm = np.sqrt(5 * x[0]**2 + 2 * x[1]**2)\nprint(\"Induced norm:\", norm)"
    },
    {
        "input": "Evaluate inner product of polynomials x² and 1 on [0, 1].",
        "output": "from scipy.integrate import quad\ninner, _ = quad(lambda x: x**2 * 1, 0, 1)\nprint(\"Inner product:\", inner)"
    },
    {
        "input": "Find cosine of angle between a = [1, 1, 1] and b = [1, -1, 0].",
        "output": "import numpy as np\na = np.array([1, 1, 1])\nb = np.array([1, -1, 0])\ncos_theta = np.dot(a, b)/(np.linalg.norm(a)*np.linalg.norm(b))\nprint(\"Cosine:\", cos_theta)"
    },
    {
        "input": "Normalize the vector [4, -3].",
        "output": "import numpy as np\nv = np.array([4, -3])\nunit_v = v / np.linalg.norm(v)\nprint(\"Normalized vector:\", unit_v)"
    },
    {
        "input": "Find inner product ⟨f,g⟩ where f(x)=x, g(x)=x² on [0,1].",
        "output": "from scipy.integrate import quad\ninner, _ = quad(lambda x: x * x**2, 0, 1)\nprint(\"Inner product:\", inner)"
    },
    {
        "input": "Determine norm ||f||₂ for f(x) = sin(pi*x) on [0,1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm_sq, _ = quad(lambda x: np.sin(np.pi*x)**2, 0, 1)\nprint(\"L2 norm:\", np.sqrt(norm_sq))"
    },
    {
        "input": "Compute norm from inner product ⟨x,y⟩ = xᵀAy, A=diag(2,3), x=[1,2].",
        "output": "import numpy as np\nx = np.array([1,2])\nA = np.diag([2,3])\nnorm = np.sqrt(np.dot(x, A.dot(x)))\nprint(\"Induced norm:\", norm)"
    },
    {
        "input": "Compute ⟨x,y⟩ where x = [1, -1], y = [2, 2] under dot product.",
        "output": "import numpy as np\nx = np.array([1, -1])\ny = np.array([2, 2])\nprint(\"Inner product:\", np.dot(x, y))"
    },
    {
        "input": "Find distance between vectors [0,0,1] and [1,1,0].",
        "output": "import numpy as np\nx = np.array([0, 0, 1])\ny = np.array([1, 1, 0])\nprint(\"Distance:\", np.linalg.norm(x - y))"
    },
    {
        "input": "Evaluate ||x+y||² for x=[1,2], y=[2,1] and compare with ||x||²+||y||².",
        "output": "import numpy as np\nx = np.array([1,2])\ny = np.array([2,1])\nprint(\"LHS:\", np.linalg.norm(x+y)**2)\nprint(\"RHS:\", np.linalg.norm(x)**2 + np.linalg.norm(y)**2)"
    },
    {
        "input": "Find projection of x=[2,1] onto unit vector y=[1/sqrt(2), 1/sqrt(2)].",
        "output": "import numpy as np\nx = np.array([2,1])\ny = np.array([1/np.sqrt(2), 1/np.sqrt(2)])\nproj = np.dot(x, y) * y\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Evaluate ||x+y||² for x=[1,2], y=[3,4].",
        "output": "import numpy as np\nx = np.array([1,2])\ny = np.array([3,4])\nresult = np.linalg.norm(x+y)**2\nprint(\"||x+y||²:\", result)"
    },
    {
        "input": "Find the L2 norm of vector x = [0.6, 0.8].",
        "output": "import numpy as np\nx = np.array([0.6, 0.8])\nprint(\"L2 norm:\", np.linalg.norm(x))"
    },
    {
        "input": "Normalize function f(x)=x on interval [0,1] using L2 norm.",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm_sq, _ = quad(lambda x: x**2, 0, 1)\nnorm = np.sqrt(norm_sq)\nprint(\"Normalized function: f(x)/norm with norm =\", norm)"
    },
    {
        "input": "Compute norm induced by inner product ⟨x,y⟩=4x₁y₁ + x₂y₂, x=[2,1].",
        "output": "import numpy as np\nx = np.array([2,1])\nnorm = np.sqrt(4*x[0]**2 + x[1]**2)\nprint(\"Induced norm:\", norm)"
    },
    {
        "input": "Find projection of v=[1,2,3] on u=[1,0,0].",
        "output": "import numpy as np\nv = np.array([1,2,3])\nu = np.array([1,0,0])\nproj = (np.dot(v,u)/np.dot(u,u)) * u\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Determine angle between vectors a=[0,1] and b=[1,0].",
        "output": "import numpy as np\na = np.array([0,1])\nb = np.array([1,0])\nangle = np.arccos(np.dot(a,b)/(np.linalg.norm(a)*np.linalg.norm(b)))\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Find inner product of vectors [2, -1] and [-1, 2].",
        "output": "import numpy as np\nx = np.array([2, -1])\ny = np.array([-1, 2])\nprint(\"Inner product:\", np.dot(x, y))"
    },
    {
        "input": "Compute L1 norm of x = [5, -7, 2].",
        "output": "import numpy as np\nx = np.array([5, -7, 2])\nprint(\"L1 norm:\", np.sum(np.abs(x)))"
    },
    {
        "input": "Compute ∞-norm of x = [-1, 4, -3].",
        "output": "import numpy as np\nx = np.array([-1, 4, -3])\nprint(\"Infinity norm:\", np.max(np.abs(x)))"
    },
    {
        "input": "Compute inner product of sin(x) and cos(x) on [0,π].",
        "output": "from scipy.integrate import quad\nimport numpy as np\ninner, _ = quad(lambda x: np.sin(x)*np.cos(x), 0, np.pi)\nprint(\"Inner product:\", inner)"
    },
    {
        "input": "Find projection of [4,2] on [1,1].",
        "output": "import numpy as np\nv = np.array([4,2])\nu = np.array([1,1])\nproj = (np.dot(v, u)/np.dot(u,u)) * u\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Use Gram-Schmidt on [1,1,0], [1,0,1].",
        "output": "import numpy as np\na = np.array([1,1,0])\nb = np.array([1,0,1])\ne1 = a / np.linalg.norm(a)\nproj = np.dot(b, e1)*e1\ne2 = b - proj\ne2 = e2 / np.linalg.norm(e2)\nprint(\"Orthonormal basis:\", e1, e2)"
    },
    {
        "input": "Find cosine similarity between x=[1,2], y=[3,4].",
        "output": "import numpy as np\nx = np.array([1,2])\ny = np.array([3,4])\ncos_sim = np.dot(x,y)/(np.linalg.norm(x)*np.linalg.norm(y))\nprint(\"Cosine similarity:\", cos_sim)"
    },
    {
        "input": "Evaluate ⟨x,x⟩ for x = [1,2,3].",
        "output": "import numpy as np\nx = np.array([1,2,3])\nprint(\"<x,x>:\", np.dot(x,x))"
    },
    {
        "input": "Compute induced norm from ⟨x,y⟩ = x₁y₁ + 4x₂y₂ for x = [1,2].",
        "output": "import numpy as np\nx = np.array([1,2])\nnorm = np.sqrt(x[0]**2 + 4*x[1]**2)\nprint(\"Induced norm:\", norm)"
    },
    {
        "input": "Evaluate inner product of x² and x³ on [0,1].",
        "output": "from scipy.integrate import quad\ninner, _ = quad(lambda x: x**5, 0, 1)\nprint(\"Inner product:\", inner)"
    },
    {
        "input": "Normalize vector [2, 2, 1].",
        "output": "import numpy as np\nx = np.array([2,2,1])\nunit = x / np.linalg.norm(x)\nprint(\"Normalized vector:\", unit)"
    },
    {
        "input": "Find norm of vector [0,3,4] using Euclidean norm.",
        "output": "import numpy as np\nx = np.array([0,3,4])\nprint(\"Norm:\", np.linalg.norm(x))"
    },
    {
        "input": "Compute L2 norm of function f(x) = x² on [0,1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nintegral, _ = quad(lambda x: x**4, 0, 1)\nnorm = np.sqrt(integral)\nprint(\"L2 norm:\", norm)"
    },
    {
        "input": "Find inner product of polynomials f(x)=x and g(x)=x² on [0,1].",
        "output": "from scipy.integrate import quad\ninner, _ = quad(lambda x: x**3, 0, 1)\nprint(\"Inner product:\", inner)"
    },
    {
        "input": "Compute cosine of angle between a=[1,0,0] and b=[1,1,0].",
        "output": "import numpy as np\na = np.array([1,0,0])\nb = np.array([1,1,0])\ncos_theta = np.dot(a,b)/(np.linalg.norm(a)*np.linalg.norm(b))\nprint(\"Cosine:\", cos_theta)"
    },
    {
        "input": "Find norm induced by inner product ⟨x,y⟩=2x₁y₁+3x₂y₂, x=[1,2].",
        "output": "import numpy as np\nx = np.array([1,2])\nnorm = np.sqrt(2*x[0]**2 + 3*x[1]**2)\nprint(\"Induced norm:\", norm)"
    },
    {
        "input": "Compute projection of [2,3] on [1,1].",
        "output": "import numpy as np\nv = np.array([2,3])\nu = np.array([1,1])\nproj = (np.dot(v,u)/np.dot(u,u)) * u\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Evaluate ⟨x,y⟩ where x = [0,1], y = [1,1].",
        "output": "import numpy as np\nx = np.array([0,1])\ny = np.array([1,1])\nprint(\"Inner product:\", np.dot(x, y))"
    },
    {
        "input": "Calculate L1 norm of vector [1, -2, 3].",
        "output": "import numpy as np\nx = np.array([1, -2, 3])\nprint(\"L1 norm:\", np.sum(np.abs(x)))"
    },
    {
        "input": "Compute norm of vector [6,8] using L2 norm.",
        "output": "import numpy as np\nx = np.array([6,8])\nprint(\"L2 norm:\", np.linalg.norm(x))"
    },
    {
        "input": "Find unit vector in direction of [4,0,3].",
        "output": "import numpy as np\nx = np.array([4,0,3])\nunit = x / np.linalg.norm(x)\nprint(\"Unit vector:\", unit)"
    },
    {
        "input": "Compute norm of function f(x) = 1 on [0,1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm = np.sqrt(quad(lambda x: 1, 0, 1)[0])\nprint(\"Norm:\", norm)"
    },
    {
        "input": "Evaluate inner product of x=[2,1] and y=[-1,2].",
        "output": "import numpy as np\nx = np.array([2,1])\ny = np.array([-1,2])\nprint(\"Inner product:\", np.dot(x,y))"
    },
    {
        "input": "Calculate ∞-norm of [-2, 5, -3, 4].",
        "output": "import numpy as np\nx = np.array([-2, 5, -3, 4])\nprint(\"Infinity norm:\", np.max(np.abs(x)))"
    },
    {
        "input": "Find cosine similarity between [2,3] and [4,5].",
        "output": "import numpy as np\nx = np.array([2,3])\ny = np.array([4,5])\ncos_sim = np.dot(x,y)/(np.linalg.norm(x)*np.linalg.norm(y))\nprint(\"Cosine similarity:\", cos_sim)"
    },
    {
        "input": "Normalize function f(x)=x² on [0,1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm = np.sqrt(quad(lambda x: x**4, 0, 1)[0])\nprint(\"Normalized f(x): f(x)/norm with norm =\", norm)"
    },
    {
        "input": "Find projection of [1,1,1] on [0,1,0].",
        "output": "import numpy as np\nv = np.array([1,1,1])\nu = np.array([0,1,0])\nproj = (np.dot(v,u)/np.dot(u,u)) * u\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Evaluate inner product on [0,π] of sin²(x).",
        "output": "from scipy.integrate import quad\nimport numpy as np\nval, _ = quad(lambda x: np.sin(x)**2, 0, np.pi)\nprint(\"Inner product:\", val)"
    },
    {
        "input": "Compute L2 norm of x = [1,1,1,1].",
        "output": "import numpy as np\nx = np.ones(4)\nprint(\"L2 norm:\", np.linalg.norm(x))"
    },
    {
        "input": "Compute norm of vector [1,2,2] with inner product ⟨x,y⟩=x₁y₁+x₂y₂+2x₃y₃.",
        "output": "import numpy as np\nx = np.array([1,2,2])\nnorm = np.sqrt(x[0]**2 + x[1]**2 + 2*x[2]**2)\nprint(\"Custom norm:\", norm)"
    },
    {
        "input": "Find the angle (in degrees) between [1,2,2] and [2,0,1].",
        "output": "import numpy as np\nx = np.array([1,2,2])\ny = np.array([2,0,1])\ncos_theta = np.dot(x,y)/(np.linalg.norm(x)*np.linalg.norm(y))\nangle = np.degrees(np.arccos(cos_theta))\nprint(\"Angle:\", angle)"
    },
    {
        "input": "Given ||x||=3, ||y||=4 and ⟨x,y⟩=6, compute ||x - y||².",
        "output": "norm_sq = 3**2 + 4**2 - 2*6\nprint(\"||x - y||²:\", norm_sq)"
    },
    {
        "input": "Find distance from point (1,2) to line through origin in direction (3,4).",
        "output": "import numpy as np\np = np.array([1,2])\nd = np.array([3,4])\nproj = (np.dot(p,d)/np.dot(d,d)) * d\ndist = np.linalg.norm(p - proj)\nprint(\"Distance:\", dist)"
    },
    {
        "input": "Compute Gram-Schmidt orthonormal basis for vectors [1,1] and [1,0].",
        "output": "import numpy as np\nx = np.array([1,1], dtype=float)\ny = np.array([1,0], dtype=float)\ne1 = x/np.linalg.norm(x)\nproj = np.dot(y,e1)*e1\ne2 = (y - proj)/np.linalg.norm(y - proj)\nprint(\"Basis:\", e1, e2)"
    },
    {
        "input": "Find L2 norm of f(x)=sin(x) on [0,π].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nval, _ = quad(lambda x: np.sin(x)**2, 0, np.pi)\nnorm = np.sqrt(val)\nprint(\"L2 norm:\", norm)"
    },
    {
        "input": "Compute orthogonal projection of f(x)=x on subspace spanned by g(x)=1 over [0,1].",
        "output": "from scipy.integrate import quad\nnum, _ = quad(lambda x: x*1, 0, 1)\nden, _ = quad(lambda x: 1, 0, 1)\nc = num/den\nprint(\"Projection function is f̂(x) =\", c)"
    },
    {
        "input": "Given vectors x=[3,4], find scalar λ such that x and x−λ[1,1] are orthogonal.",
        "output": "import numpy as np\nx = np.array([3,4])\na = np.array([1,1])\nlam = np.dot(x,x)/np.dot(x,a)\nprint(\"Lambda:\", lam)"
    },
    {
        "input": "Find value of a such that vectors [1,a] and [a,1] are orthogonal.",
        "output": "import sympy as sp\na = sp.Symbol('a')\ndot = 1*a + a*1\nsolution = sp.solve(dot, a)\nprint(\"Value of a:\", solution)"
    },
    {
        "input": "Find inner product ⟨f,g⟩ with f(x)=x², g(x)=x³ over [−1,1].",
        "output": "from scipy.integrate import quad\ninner, _ = quad(lambda x: x**5, -1, 1)\nprint(\"Inner product:\", inner)"
    },
    {
        "input": "Find orthogonal component of [3,2] w.r.t subspace spanned by [1,1].",
        "output": "import numpy as np\nv = np.array([3,2])\nu = np.array([1,1])\nproj = (np.dot(v,u)/np.dot(u,u)) * u\north = v - proj\nprint(\"Orthogonal component:\", orth)"
    },
    {
        "input": "Given ⟨x,y⟩ = xᵀAy with A=[[2,0],[0,3]], compute induced norm of x=[1,1].",
        "output": "import numpy as np\nx = np.array([1,1])\nA = np.array([[2,0],[0,3]])\nnorm = np.sqrt(np.dot(x, A @ x))\nprint(\"Induced norm:\", norm)"
    },
    {
        "input": "For f(x)=x, find closest constant function to f(x) in L²[0,1].",
        "output": "from scipy.integrate import quad\nc = quad(lambda x: x, 0, 1)[0]\nprint(\"Best constant approximation:\", c)"
    },
    {
        "input": "Compute L2 norm of f(x) = x³ on interval [-1, 1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nval, _ = quad(lambda x: x**6, -1, 1)\nnorm = np.sqrt(val)\nprint(\"L2 norm:\", norm)"
    },
    {
        "input": "Find inner product of functions f(x)=1, g(x)=cos(πx) on [0,1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nval, _ = quad(lambda x: np.cos(np.pi*x), 0, 1)\nprint(\"Inner product:\", val)"
    },
    {
        "input": "Determine best approximation of f(x)=x² by ax on [0,1].",
        "output": "from scipy.integrate import quad\na = quad(lambda x: x**3, 0, 1)[0]/quad(lambda x: x**2, 0, 1)[0]\nprint(\"Best a:\", a)"
    },
    {
        "input": "Find the norm induced by inner product ⟨x,y⟩ = xᵀAy where A = [[4,0],[0,9]] and x = [2,1].",
        "output": "import numpy as np\nx = np.array([2,1])\nA = np.array([[4,0],[0,9]])\nnorm = np.sqrt(x @ A @ x)\nprint(\"Induced norm:\", norm)"
    },
    {
        "input": "Compute angle between [3,-1,2] and [1,4,-2] in radians.",
        "output": "import numpy as np\na = np.array([3,-1,2])\nb = np.array([1,4,-2])\nangle = np.arccos(np.dot(a,b)/(np.linalg.norm(a)*np.linalg.norm(b)))\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Find projection of [2,3] onto [1,2].",
        "output": "import numpy as np\na = np.array([2,3])\nb = np.array([1,2])\nproj = (np.dot(a,b)/np.dot(b,b)) * b\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Compute norm of matrix A = [[1,2],[3,4]] under Frobenius norm.",
        "output": "import numpy as np\nA = np.array([[1,2],[3,4]])\nnorm = np.linalg.norm(A, 'fro')\nprint(\"Frobenius norm:\", norm)"
    },
    {
        "input": "Find unit vector in direction of v = [5,12].",
        "output": "import numpy as np\nv = np.array([5,12])\nunit = v / np.linalg.norm(v)\nprint(\"Unit vector:\", unit)"
    },
    {
        "input": "Find L1 norm of vector [1,−2,3].",
        "output": "import numpy as np\nv = np.array([1,-2,3])\nnorm = np.linalg.norm(v, 1)\nprint(\"L1 norm:\", norm)"
    },
    {
        "input": "Find L∞ norm of vector [−4,2,7,−1].",
        "output": "import numpy as np\nv = np.array([-4,2,7,-1])\nnorm = np.linalg.norm(v, np.inf)\nprint(\"L∞ norm:\", norm)"
    },
    {
        "input": "Compute ⟨x,y⟩ with x=[1,2], y=[2,5] in R².",
        "output": "import numpy as np\nx = np.array([1,2])\ny = np.array([2,5])\nprint(\"Inner product:\", np.dot(x,y))"
    },
    {
        "input": "Given u=[1,2], v=[3,4], compute Gram-Schmidt orthogonal basis.",
        "output": "import numpy as np\nu = np.array([1,2])\nv = np.array([3,4])\ne1 = u / np.linalg.norm(u)\nproj = np.dot(v, e1) * e1\ne2 = (v - proj) / np.linalg.norm(v - proj)\nprint(\"Orthonormal basis:\", e1, e2)"
    },
    {
        "input": "If ⟨x,y⟩=xᵀy and ||x||=2, ||y||=3, ⟨x,y⟩=6, find angle between x and y.",
        "output": "import numpy as np\ncos_theta = 6/(2*3)\nangle = np.arccos(cos_theta)\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Compute cosine similarity between vectors [1,2,3] and [4,5,6].",
        "output": "import numpy as np\na = np.array([1,2,3])\nb = np.array([4,5,6])\nsim = np.dot(a,b)/(np.linalg.norm(a)*np.linalg.norm(b))\nprint(\"Cosine similarity:\", sim)"
    },
    {
        "input": "Find vector orthogonal to both [1,0,1] and [0,1,1].",
        "output": "import numpy as np\na = np.array([1, 0, 1])\nb = np.array([0, 1, 1])\north = np.cross(a, b)\nprint(\"Orthogonal vector:\", orth)"
    },
    {
        "input": "Find distance between points a=[3,4] and b=[0,0] using norm.",
        "output": "import numpy as np\na = np.array([3,4])\ndist = np.linalg.norm(a - [0,0])\nprint(\"Distance:\", dist)"
    },
    {
        "input": "Given vectors x=[1,2,3], y=[2,1,1], compute projection of x onto y.",
        "output": "import numpy as np\nx = np.array([1,2,3])\ny = np.array([2,1,1])\nproj = (np.dot(x,y)/np.dot(y,y)) * y\nprint(\"Projection:\", proj)"
    },
    {
        "input": "If ⟨f,g⟩ = 0 and ||f||=2, ||g||=1, compute ||f + 2g||.",
        "output": "import numpy as np\nnorm = np.sqrt(2**2 + (2*1)**2)\nprint(\"Norm:\", norm)"
    },
    {
        "input": "Find the L2 norm of the vector x=[1, 2, 2].",
        "output": "import numpy as np\nx = np.array([1,2,2])\nnorm = np.linalg.norm(x)\nprint(\"L2 norm:\", norm)"
    },
    {
        "input": "For vector v=[3,−4], compute normalized vector using L2 norm.",
        "output": "import numpy as np\nv = np.array([3,-4])\nunit = v / np.linalg.norm(v)\nprint(\"Normalized vector:\", unit)"
    },
    {
        "input": "Let x=[1,2], y=[3,4]. Compute inner product and norm of x+y.",
        "output": "import numpy as np\nx = np.array([1,2])\ny = np.array([3,4])\ninner = np.dot(x,y)\nsum_norm = np.linalg.norm(x + y)\nprint(\"Inner product:\", inner, \"Norm of x+y:\", sum_norm)"
    },
    {
        "input": "Given A = [[1, 2], [2, 5]], x = [1, 0], compute ||x||_A.",
        "output": "import numpy as np\nA = np.array([[1,2],[2,5]])\nx = np.array([1,0])\nnorm = np.sqrt(x @ A @ x)\nprint(\"Norm induced by A:\", norm)"
    },
    {
        "input": "Compute projection of u=[1,2,2] onto v=[2,0,1].",
        "output": "import numpy as np\nu = np.array([1,2,2])\nv = np.array([2,0,1])\nproj = (np.dot(u,v)/np.dot(v,v))*v\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Let f(x)=x, g(x)=1 on [0,2]. Compute ⟨f,g⟩ and ||f||.",
        "output": "from scipy.integrate import quad\nimport numpy as np\nip = quad(lambda x: x*1, 0, 2)[0]\nnorm = np.sqrt(quad(lambda x: x**2, 0, 2)[0])\nprint(\"Inner product:\", ip, \"Norm of f:\", norm)"
    },
    {
        "input": "Given x=[1,1], y=[1,−1], compute their angle in degrees.",
        "output": "import numpy as np\nx = np.array([1,1])\ny = np.array([1,-1])\nangle = np.arccos(np.dot(x,y)/(np.linalg.norm(x)*np.linalg.norm(y)))\nprint(\"Angle (degrees):\", np.degrees(angle))"
    },
    {
        "input": "Find orthogonal projection of f(x)=x² onto g(x)=x on [0,1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\ndef f(x): return x**2\ndef g(x): return x\nnum = quad(lambda x: f(x)*g(x), 0, 1)[0]\nden = quad(lambda x: g(x)*g(x), 0, 1)[0]\ncoeff = num/den\nprint(\"Projection coefficient:\", coeff)"
    },
    {
        "input": "Given x=[1,2,3], compute projection onto subspace spanned by u=[1,1,1].",
        "output": "import numpy as np\nx = np.array([1,2,3])\nu = np.array([1,1,1])\nproj = (np.dot(x,u)/np.dot(u,u))*u\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Given x=[1,2], compute projection onto unit vector u=[1/√5,2/√5].",
        "output": "import numpy as np\nx = np.array([1,2])\nu = np.array([1/np.sqrt(5),2/np.sqrt(5)])\nproj = np.dot(x,u)*u\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Compute L2 norm of polynomial f(x)=3x²−2x on [0,1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm = np.sqrt(quad(lambda x: (3*x**2 - 2*x)**2, 0, 1)[0])\nprint(\"L2 norm:\", norm)"
    },
    {
        "input": "If f(x)=sin(x), g(x)=cos(x), find ⟨f,g⟩ on [0,π].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nip = quad(lambda x: np.sin(x)*np.cos(x), 0, np.pi)[0]\nprint(\"Inner product:\", ip)"
    },
    {
        "input": "Let x=[3,4], find projection onto y=[4,−3].",
        "output": "import numpy as np\nx = np.array([3,4])\ny = np.array([4,-3])\nproj = (np.dot(x,y)/np.dot(y,y))*y\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Compute unit vector of [7,24] and confirm L2 norm = 1.",
        "output": "import numpy as np\nv = np.array([7,24])\nu = v/np.linalg.norm(v)\nprint(\"Unit vector:\", u, \"Norm:\", np.linalg.norm(u))"
    },
    {
        "input": "Find orthonormal basis of span{[1,1,0], [1,0,1]} using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([1,1,0])\nv2 = np.array([1,0,1])\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2,u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(\"Orthonormal basis:\", u1, u2)"
    },
    {
        "input": "Let x=[1,−1], y=[2,2]. Find angle between them in radians.",
        "output": "import numpy as np\nx = np.array([1,-1])\ny = np.array([2,2])\ncos_theta = np.dot(x,y)/(np.linalg.norm(x)*np.linalg.norm(y))\nangle = np.arccos(cos_theta)\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Given functions f(x)=x², g(x)=x³, compute ⟨f,g⟩ on [0,1].",
        "output": "from scipy.integrate import quad\nip = quad(lambda x: x**2 * x**3, 0, 1)[0]\nprint(\"Inner product:\", ip)"
    },
    {
        "input": "Compute ||f|| where f(x)=e^x on [0,1] using L2 norm.",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm = np.sqrt(quad(lambda x: np.exp(x)**2, 0, 1)[0])\nprint(\"L2 norm:\", norm)"
    },
    {
        "input": "Let x=[1,2,3], find its component orthogonal to u=[1,1,1].",
        "output": "import numpy as np\nx = np.array([1,2,3])\nu = np.array([1,1,1])\nproj = (np.dot(x,u)/np.dot(u,u))*u\north = x - proj\nprint(\"Orthogonal component:\", orth)"
    },
    {
        "input": "Use Gram-Schmidt on vectors [1,0,0], [1,1,0], [1,1,1].",
        "output": "import numpy as np\nv1 = np.array([1,0,0])\nv2 = np.array([1,1,0])\nv3 = np.array([1,1,1])\nu1 = v1 / np.linalg.norm(v1)\nv2_proj = v2 - np.dot(v2,u1)*u1\nu2 = v2_proj / np.linalg.norm(v2_proj)\nv3_proj = v3 - np.dot(v3,u1)*u1 - np.dot(v3,u2)*u2\nu3 = v3_proj / np.linalg.norm(v3_proj)\nprint(\"Orthonormal basis:\", u1, u2, u3)"
    },
    {
        "input": "Calculate the L1 norm of vector [−3, 4, −2].",
        "output": "import numpy as np\nx = np.array([-3,4,-2])\nnorm = np.linalg.norm(x, 1)\nprint(\"L1 norm:\", norm)"
    },
    {
        "input": "Given u=[1,2], v=[2,1], find ⟨u,v⟩ and angle between them.",
        "output": "import numpy as np\nu = np.array([1,2])\nv = np.array([2,1])\ndot = np.dot(u,v)\nangle = np.arccos(dot/(np.linalg.norm(u)*np.linalg.norm(v)))\nprint(\"Inner product:\", dot, \"Angle (deg):\", np.degrees(angle))"
    },
    {
        "input": "Let x=[2,−1,1], find L∞ norm.",
        "output": "import numpy as np\nx = np.array([2,-1,1])\nnorm = np.linalg.norm(x, np.inf)\nprint(\"L∞ norm:\", norm)"
    },
    {
        "input": "Given vectors u=[3,0], v=[4,0], compute norm of u−v.",
        "output": "import numpy as np\nu = np.array([3,0])\nv = np.array([4,0])\nnorm = np.linalg.norm(u - v)\nprint(\"Norm of u-v:\", norm)"
    },
    {
        "input": "Given f(x)=x and g(x)=1−x on [0,1], compute ⟨f,g⟩.",
        "output": "from scipy.integrate import quad\nip = quad(lambda x: x*(1-x), 0, 1)[0]\nprint(\"Inner product:\", ip)"
    },
    {
        "input": "Let x=[1,1,1], project it onto u=[1,0,0].",
        "output": "import numpy as np\nx = np.array([1,1,1])\nu = np.array([1,0,0])\nproj = (np.dot(x,u)/np.dot(u,u))*u\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Compute the cosine similarity between x=[1,2] and y=[2,1].",
        "output": "import numpy as np\nx = np.array([1,2])\ny = np.array([2,1])\ncos_sim = np.dot(x,y)/(np.linalg.norm(x)*np.linalg.norm(y))\nprint(\"Cosine similarity:\", cos_sim)"
    },
    {
        "input": "If x=[1,2,2], find unit vector in same direction.",
        "output": "import numpy as np\nx = np.array([1,2,2])\nunit = x / np.linalg.norm(x)\nprint(\"Unit vector:\", unit)"
    },
    {
        "input": "Find L2 norm of function f(x)=x² on [0,2].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm = np.sqrt(quad(lambda x: x**4, 0, 2)[0])\nprint(\"L2 norm:\", norm)"
    },
    {
        "input": "Find angle between x=[1,2,2] and y=[2,1,1].",
        "output": "import numpy as np\nx = np.array([1,2,2])\ny = np.array([2,1,1])\ncos_theta = np.dot(x,y)/(np.linalg.norm(x)*np.linalg.norm(y))\nangle = np.arccos(cos_theta)\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Normalize function f(x)=sin(x) on [0,π].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm = np.sqrt(quad(lambda x: np.sin(x)**2, 0, np.pi)[0])\nprint(\"Normalized f(x): sin(x)/\", norm)"
    },
    {
        "input": "Given u=[1,1], find projection of x=[2,0] onto u.",
        "output": "import numpy as np\nu = np.array([1,1])\nx = np.array([2,0])\nproj = (np.dot(x,u)/np.dot(u,u))*u\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Find L2 norm of constant function f(x)=3 on [0,1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm = np.sqrt(quad(lambda x: 9, 0, 1)[0])\nprint(\"L2 norm:\", norm)"
    },
    {
        "input": "Find projection of [1,2,3] on [1,0,1].",
        "output": "import numpy as np\nx = np.array([1,2,3])\ny = np.array([1,0,1])\nproj = (np.dot(x,y)/np.dot(y,y))*y\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Find norm of vector from origin to point (3,4,12).",
        "output": "import numpy as np\nx = np.array([3,4,12])\nprint(\"Norm:\", np.linalg.norm(x))"
    },
    {
        "input": "Compute the inner product of x = [2, -1, 3] and y = [1, 4, -2].",
        "output": "import numpy as np\nx = np.array([2,-1,3])\ny = np.array([1,4,-2])\nprint(\"Inner product:\", np.dot(x, y))"
    },
    {
        "input": "Find the norm of x = [5, 12].",
        "output": "import numpy as np\nx = np.array([5,12])\nprint(\"Norm:\", np.linalg.norm(x))"
    },
    {
        "input": "Normalize x = [1,2,2].",
        "output": "import numpy as np\nx = np.array([1,2,2])\nprint(\"Normalized vector:\", x / np.linalg.norm(x))"
    },
    {
        "input": "Compute projection of [1,2] onto [3,4].",
        "output": "import numpy as np\nx = np.array([1,2])\ny = np.array([3,4])\nproj = (np.dot(x,y)/np.dot(y,y)) * y\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Find L2 norm of f(x)=x^3 over [0,1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm = np.sqrt(quad(lambda x: x**6, 0, 1)[0])\nprint(\"L2 norm:\", norm)"
    },
    {
        "input": "Find unit vector in direction of [4,4,7].",
        "output": "import numpy as np\nx = np.array([4,4,7])\nprint(\"Unit vector:\", x / np.linalg.norm(x))"
    },
    {
        "input": "Find angle between [1,0] and [1,1].",
        "output": "import numpy as np\nx = np.array([1,0])\ny = np.array([1,1])\ncos_theta = np.dot(x,y)/(np.linalg.norm(x)*np.linalg.norm(y))\nangle = np.arccos(cos_theta)\nprint(\"Angle in radians:\", angle)"
    },
    {
        "input": "Find the projection of x=[4,1] onto y=[1,2].",
        "output": "import numpy as np\nx = np.array([4,1])\ny = np.array([1,2])\nproj = (np.dot(x,y)/np.dot(y,y))*y\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Compute ∫₀^π sin(x)·cos(x) dx.",
        "output": "from scipy.integrate import quad\nip = quad(lambda x: np.sin(x)*np.cos(x), 0, np.pi)[0]\nprint(\"Inner product:\", ip)"
    },
    {
        "input": "Find L2 norm of f(x)=e^x over [0,1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm = np.sqrt(quad(lambda x: np.exp(2*x), 0, 1)[0])\nprint(\"L2 norm:\", norm)"
    },
    {
        "input": "Find norm of vector [7,24].",
        "output": "import numpy as np\nx = np.array([7,24])\nprint(\"Norm:\", np.linalg.norm(x))"
    },
    {
        "input": "Let x=[2,1], y=[−1,2]. Find ⟨x+y,x−y⟩.",
        "output": "import numpy as np\nx = np.array([2,1])\ny = np.array([-1,2])\nprint(\"Inner product:\", np.dot(x+y,x-y))"
    },
    {
        "input": "Find the inner product of x=[3,4,5] and y=[1,0,1].",
        "output": "import numpy as np\nx = np.array([3,4,5])\ny = np.array([1,0,1])\nprint(\"Inner product:\", np.dot(x,y))"
    },
    {
        "input": "Find unit vector of [6,2,3].",
        "output": "import numpy as np\nx = np.array([6,2,3])\nprint(\"Unit vector:\", x / np.linalg.norm(x))"
    },
    {
        "input": "Let f(x)=x, g(x)=1 over [0,1]. Compute ⟨f,g⟩.",
        "output": "from scipy.integrate import quad\ninner = quad(lambda x: x * 1, 0, 1)[0]\nprint(\"Inner product:\", inner)"
    },
    {
        "input": "Find the cosine of angle between [1,2,2] and [2,1,2].",
        "output": "import numpy as np\nx = np.array([1,2,2])\ny = np.array([2,1,2])\ncos_theta = np.dot(x,y)/(np.linalg.norm(x)*np.linalg.norm(y))\nprint(\"Cosine of angle:\", cos_theta)"
    },
    {
        "input": "Compute ||f||² where f(x) = sin(x) on [0,π].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm_sq = quad(lambda x: np.sin(x)**2, 0, np.pi)[0]\nprint(\"Norm squared:\", norm_sq)"
    },
    {
        "input": "Find L2 norm of x^2 on [−1,1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm = np.sqrt(quad(lambda x: x**4, -1, 1)[0])\nprint(\"L2 norm:\", norm)"
    },
    {
        "input": "Compute ⟨f,g⟩ where f(x)=x, g(x)=x² on [0,1].",
        "output": "from scipy.integrate import quad\ninner = quad(lambda x: x*x**2, 0, 1)[0]\nprint(\"Inner product:\", inner)"
    },
    {
        "input": "Find distance between x=[1,1] and y=[4,5].",
        "output": "import numpy as np\nx = np.array([1,1])\ny = np.array([4,5])\nprint(\"Distance:\", np.linalg.norm(x - y))"
    },
    {
        "input": "Let f(x)=x on [0,1]. Find unit function g(x) = af(x).",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm = np.sqrt(quad(lambda x: x**2, 0, 1)[0])\nprint(\"a:\", 1/norm)"
    },
    {
        "input": "Find the projection of x=[2,1] on y=[1,0].",
        "output": "import numpy as np\nx = np.array([2,1])\ny = np.array([1,0])\nproj = (np.dot(x,y)/np.dot(y,y)) * y\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Find norm of f(x) = e^x over [0,1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm = np.sqrt(quad(lambda x: np.exp(x)**2, 0, 1)[0])\nprint(\"Norm:\", norm)"
    },
    {
        "input": "Compute angle between vectors [2,0] and [1,1].",
        "output": "import numpy as np\nx = np.array([2,0])\ny = np.array([1,1])\ncos_theta = np.dot(x,y)/(np.linalg.norm(x)*np.linalg.norm(y))\nangle = np.arccos(cos_theta)\nprint(\"Angle (radians):\", angle)"
    },
    {
        "input": "Compute inner product in ℝ⁴ for x=[1,2,0,3], y=[4,0,1,1].",
        "output": "import numpy as np\nx = np.array([1,2,0,3])\ny = np.array([4,0,1,1])\nprint(\"Inner product:\", np.dot(x,y))"
    },
    {
        "input": "Find the L2 norm of sin(x) + cos(x) over [0,π].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm = np.sqrt(quad(lambda x: (np.sin(x) + np.cos(x))**2, 0, np.pi)[0])\nprint(\"Norm:\", norm)"
    },
    {
        "input": "Find value of a so that ⟨[1,a],[a,1]⟩ = 0.",
        "output": "from sympy import symbols, solve\nx = symbols('x')\nsol = solve(1*x + x*1, x)\nprint(\"a:\", sol)"
    },
    {
        "input": "Let f(x)=x²−1, g(x)=x on [−1,1]. Compute ⟨f,g⟩.",
        "output": "from scipy.integrate import quad\ninner = quad(lambda x: (x**2 - 1)*x, -1, 1)[0]\nprint(\"Inner product:\", inner)"
    },
    {
        "input": "If f(x)=x², compute norm over [0,2].",
        "output": "from scipy.integrate import quad\nnorm = quad(lambda x: x**4, 0, 2)[0]**0.5\nprint(\"Norm:\", norm)"
    },
    {
        "input": "Find scalar c minimizing ||x − cy||² for x=[1,2], y=[3,4].",
        "output": "import numpy as np\nx = np.array([1,2])\ny = np.array([3,4])\nc = np.dot(x,y)/np.dot(y,y)\nprint(\"Optimal c:\", c)"
    },
    {
        "input": "Find norm of vector [3,−4,1] in ℝ³.",
        "output": "import numpy as np\nx = np.array([3,-4,1])\nprint(\"Norm:\", np.linalg.norm(x))"
    },
    {
        "input": "Find inner product of [1,2,3] and [4,5,6].",
        "output": "import numpy as np\nx = np.array([1,2,3])\ny = np.array([4,5,6])\nprint(\"Inner product:\", np.dot(x,y))"
    },
    {
        "input": "Find the projection of x=[3,4] onto y=[1,1].",
        "output": "import numpy as np\nx = np.array([3,4])\ny = np.array([1,1])\nproj = (np.dot(x,y)/np.dot(y,y))*y\nprint(\"Projection:\", proj)"
    },
    {
        "input": "Find angle between [1,0] and [0,1] in degrees.",
        "output": "import numpy as np\nx = np.array([1,0])\ny = np.array([0,1])\nangle = np.degrees(np.arccos(np.dot(x,y)/(np.linalg.norm(x)*np.linalg.norm(y))))\nprint(\"Angle:\", angle)"
    },
    {
        "input": "Find norm of f(x)=x on [0,2] with inner product ∫f(x)² dx.",
        "output": "from scipy.integrate import quad\nnorm = quad(lambda x: x**2, 0, 2)[0]**0.5\nprint(\"Norm:\", norm)"
    },
    {
        "input": "Given x=[2,1], y=[3,4], find scalar c minimizing ||x−cy||².",
        "output": "import numpy as np\nx = np.array([2,1])\ny = np.array([3,4])\nc = np.dot(x,y)/np.dot(y,y)\nprint(\"c:\", c)"
    },
    {
        "input": "Find ||x+y||² − ||x||² − ||y||² for x=[1,2], y=[3,4].",
        "output": "import numpy as np\nx = np.array([1,2])\ny = np.array([3,4])\ndiff = np.linalg.norm(x+y)**2 - np.linalg.norm(x)**2 - np.linalg.norm(y)**2\nprint(\"Value:\", diff)"
    },
    {
        "input": "Find ||f|| where f(x)=1−2x on [0,1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm = np.sqrt(quad(lambda x: (1-2*x)**2, 0, 1)[0])\nprint(\"Norm:\", norm)"
    },
    {
        "input": "Find the L² norm of f(x)=cos(πx) on [0,1].",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm = np.sqrt(quad(lambda x: np.cos(np.pi*x)**2, 0, 1)[0])\nprint(\"Norm:\", norm)"
    },
    {
        "input": "Find the orthogonal complement of span{[1,2]} in ℝ².",
        "output": "import numpy as np\nv = np.array([1,2])\northogonal = np.array([-v[1], v[0]])\nprint(\"Orthogonal complement basis:\", orthogonal)"
    },
    {
        "input": "Find the norm of f(x)=x² over [0,1] in L² norm.",
        "output": "from scipy.integrate import quad\nimport numpy as np\nnorm = np.sqrt(quad(lambda x: x**4, 0, 1)[0])\nprint(\"Norm:\", norm)"
    },
    {
        "input": "Find an orthonormal basis from vectors [1,1,0] and [1,0,1].",
        "output": "from numpy.linalg import norm\nimport numpy as np\nv1 = np.array([1,1,0])\ne1 = v1 / norm(v1)\nv2 = np.array([1,0,1]) - np.dot(np.array([1,0,1]), e1) * e1\ne2 = v2 / norm(v2)\nprint(\"Orthonormal basis:\", e1, e2)"
    },
    {
        "input": "Given f(x)=x and g(x)=x², find ⟨f,g⟩ over [0,1].",
        "output": "from scipy.integrate import quad\nprint(\"Inner product:\", quad(lambda x: x*x**2, 0, 1)[0])"
    },
    {
        "input": "Find norm of x=[1,2,2] using dot product.",
        "output": "import numpy as np\nx = np.array([1,2,2])\nprint(\"Norm:\", np.sqrt(np.dot(x,x)))"
    },
    {
        "input": "Find ⟨x,y⟩ if x=[2,−1,0], y=[1,1,3].",
        "output": "import numpy as np\nx = np.array([2,-1,0])\ny = np.array([1,1,3])\nprint(\"Inner product:\", np.dot(x,y))"
    },
    {
        "input": "Solve the system using SVD:\n2x + 3y = 8\n5x - y = 2",
        "output": "import numpy as np\nA = np.array([[2, 3], [5, -1]])\nb = np.array([8, 2])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD to solve the system:\nx + y + z = 6\n2x + 3y + z = 14\n3x + 4y + 2z = 20",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [2, 3, 1], [3, 4, 2]])\nb = np.array([6, 14, 20])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((3, 3)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((3, 3))\ndiag_len = min(3, 3)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Find the least-squares solution using SVD:\nx + 2y = 4\n2x + 4y = 9",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4]])\nb = np.array([4, 9])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Given a system: 3x - y + 2z = 7, 2x + 4y - z = 1, x - y + z = 4. Solve using SVD.",
        "output": "import numpy as np\nA = np.array([[3, -1, 2], [2, 4, -1], [1, -1, 1]])\nb = np.array([7, 1, 4])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((3, 3)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((3, 3))\ndiag_len = min(3, 3)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve using SVD:\n4x + 2y = 10\n6x + 3y = 15",
        "output": "import numpy as np\nA = np.array([[4, 2], [6, 3]])\nb = np.array([10, 15])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD to solve:\nx - y + z = 2\n2x + y - z = 1\n3x + 2y + z = 5",
        "output": "import numpy as np\nA = np.array([[1, -1, 1], [2, 1, -1], [3, 2, 1]])\nb = np.array([2, 1, 5])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((3, 3)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((3, 3))\ndiag_len = min(3, 3)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve using SVD:\n2x + y = 5\n4x + 2y = 11",
        "output": "import numpy as np\nA = np.array([[2, 1], [4, 2]])\nb = np.array([5, 11])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "System of equations:\n3x + y + z = 10\nx + 2y + 3z = 14\n2x + 3y + z = 13\nSolve using SVD.",
        "output": "import numpy as np\nA = np.array([[3, 1, 1], [1, 2, 3], [2, 3, 1]])\nb = np.array([10, 14, 13])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((3, 3)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((3, 3))\ndiag_len = min(3, 3)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n5x + 4y = 13\n10x + 8y = 26.5",
        "output": "import numpy as np\nA = np.array([[5, 4], [10, 8]])\nb = np.array([13, 26.5])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve:\nx + 2y + 3z = 6\n4x + 5y + 6z = 15\n7x + 8y + 9z = 24\nUsing SVD.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nb = np.array([6, 15, 24])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((3, 3)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((3, 3))\ndiag_len = min(3, 3)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD to solve:\n2x + y + z = 5\nx - y + z = 3\n3x + 2y + 4z = 10",
        "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, -1, 1], [3, 2, 4]])\nb = np.array([5, 3, 10])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((3, 3)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((3, 3))\ndiag_len = min(3, 3)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Find the SVD solution for:\n4x - y + z = 9\n-2x + 2y - 3z = -4\n3x + y + 2z = 10",
        "output": "import numpy as np\nA = np.array([[4, -1, 1], [-2, 2, -3], [3, 1, 2]])\nb = np.array([9, -4, 10])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((3, 3)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((3, 3))\ndiag_len = min(3, 3)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve this system using SVD:\n2x + 3y + z = 7\nx + y + z = 4\nx - y + z = 2",
        "output": "import numpy as np\nA = np.array([[2, 3, 1], [1, 1, 1], [1, -1, 1]])\nb = np.array([7, 4, 2])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((3, 3)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((3, 3))\ndiag_len = min(3, 3)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD to find the solution:\n3x + 2y = 11\nx + 4y = 10",
        "output": "import numpy as np\nA = np.array([[3, 2], [1, 4]])\nb = np.array([11, 10])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve using SVD:\n5x + 3y + z = 12\n2x + 2y + 2z = 12\n3x + 4y + 5z = 26",
        "output": "import numpy as np\nA = np.array([[5, 3, 1], [2, 2, 2], [3, 4, 5]])\nb = np.array([12, 12, 26])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((3, 3)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((3, 3))\ndiag_len = min(3, 3)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "System:\n2x + 3y + 5z = 18\n4x + y + z = 11\n6x + 2y + 3z = 20\nSolve using SVD.",
        "output": "import numpy as np\nA = np.array([[2, 3, 5], [4, 1, 1], [6, 2, 3]])\nb = np.array([18, 11, 20])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((3, 3)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((3, 3))\ndiag_len = min(3, 3)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD to solve this inconsistent system:\n3x + 2y = 8\n6x + 4y = 17",
        "output": "import numpy as np\nA = np.array([[3, 2], [6, 4]])\nb = np.array([8, 17])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve using SVD:\n3x + y + z = 8\nx + 3y + z = 10\nx + y + 3z = 12",
        "output": "import numpy as np\nA = np.array([[3, 1, 1], [1, 3, 1], [1, 1, 3]])\nb = np.array([8, 10, 12])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((3, 3)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((3, 3))\ndiag_len = min(3, 3)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD for:\n4x + y + z = 9\n2x + 3y + 5z = 18\nx + y + z = 6",
        "output": "import numpy as np\nA = np.array([[4, 1, 1], [2, 3, 5], [1, 1, 1]])\nb = np.array([9, 18, 6])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Solve using SVD:\n3x - y = 5\n6x - 2y = 9",
        "output": "import numpy as np\nA = np.array([[3, -1], [6, -2]])\nb = np.array([5, 9])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "System:\n2x + 5y = 13\n3x + 4y = 12\nSolve it using SVD.",
        "output": "import numpy as np\nA = np.array([[2, 5], [3, 4]])\nb = np.array([13, 12])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve:\n5x + y = 6\n2x + 3y = 7\nx + 4y = 8\nUsing SVD.",
        "output": "import numpy as np\nA = np.array([[5, 1], [2, 3], [1, 4]])\nb = np.array([6, 7, 8])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((3, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 3))\ndiag_len = min(2, 3)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD to solve:\n2x + y - z = 3\nx + 3y + 2z = 7\n3x + 2y + 4z = 13",
        "output": "import numpy as np\nA = np.array([[2, 1, -1], [1, 3, 2], [3, 2, 4]])\nb = np.array([3, 7, 13])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((3, 3)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((3, 3))\ndiag_len = min(3, 3)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve using SVD:\n2x + 2y + z = 9\nx + 3y + 3z = 13\n3x + y + 4z = 17",
        "output": "import numpy as np\nA = np.array([[2, 2, 1], [1, 3, 3], [3, 1, 4]])\nb = np.array([9, 13, 17])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((3, 3)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((3, 3))\ndiag_len = min(3, 3)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD to solve:\n4x + 2y = 10\n3x + 5y = 13\nx + y = 4",
        "output": "import numpy as np\nA = np.array([[4, 2], [3, 5], [1, 1]])\nb = np.array([10, 13, 4])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((3, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 3))\ndiag_len = min(2, 3)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve using SVD:\nx + y = 4\nx - y = 2",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, -1]])\nb = np.array([4, 2])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD to solve:\n2x + y = 5\nx + y = 3",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 1]])\nb = np.array([5, 3])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system:\nx + 2y = 6\nx - y = 1\nusing SVD",
        "output": "import numpy as np\nA = np.array([[1, 2], [1, -1]])\nb = np.array([6, 1])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD:\n2x + 3y = 8\nx + y = 3",
        "output": "import numpy as np\nA = np.array([[2, 3], [1, 1]])\nb = np.array([8, 3])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Solve using SVD:\n3x + y = 7\nx + y = 4",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 1]])\nb = np.array([7, 4])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD:\n3x + 2y = 11\nx - y = 1",
        "output": "import numpy as np\nA = np.array([[3, 2], [1, -1]])\nb = np.array([11, 1])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Solve using SVD:\nx + y = 5\nx + 2y = 7",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, 2]])\nb = np.array([5, 7])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD to solve:\n2x + 3y = 6\n3x + 4y = 9",
        "output": "import numpy as np\nA = np.array([[2, 3], [3, 4]])\nb = np.array([6, 9])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve this system:\n2x + y = 4\nx + 3y = 7\nusing SVD",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 3]])\nb = np.array([4, 7])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "SVD solution:\n3x + 3y = 12\nx + 2y = 6",
        "output": "import numpy as np\nA = np.array([[3, 3], [1, 2]])\nb = np.array([12, 6])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve using SVD:\n2x + 2y = 6\nx + y = 3",
        "output": "import numpy as np\nA = np.array([[2, 2], [1, 1]])\nb = np.array([6, 3])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD:\n4x + y = 9\nx + y = 5",
        "output": "import numpy as np\nA = np.array([[4, 1], [1, 1]])\nb = np.array([9, 5])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Use SVD to solve:\n3x + y = 7\nx + 2y = 6",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 2]])\nb = np.array([7, 6])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve:\nx + 2y = 4\n2x + 3y = 7\nusing SVD",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 3]])\nb = np.array([4, 7])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "SVD solution:\n4x + y = 10\n2x + 2y = 8",
        "output": "import numpy as np\nA = np.array([[4, 1], [2, 2]])\nb = np.array([10, 8])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD:\nx + y = 3\n2x + 2y = 6",
        "output": "import numpy as np\nA = np.array([[1, 1], [2, 2]])\nb = np.array([3, 6])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2, 2))\nS_inv[:len(S), :len(S)] = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Solve using SVD:\nx + 2y = 6\n3x + y = 7",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 1]])\nb = np.array([6, 7])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "SVD solution:\n2x + 3y = 7\n4x + y = 9",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 1]])\nb = np.array([7, 9])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve:\n3x + 2y = 10\nx + y = 4\nusing SVD",
        "output": "import numpy as np\nA = np.array([[3, 2], [1, 1]])\nb = np.array([10, 4])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD to solve:\nx + y = 5\n2x + 3y = 11",
        "output": "import numpy as np\nA = np.array([[1, 1], [2, 3]])\nb = np.array([5, 11])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve using SVD:\n4x + 3y = 15\nx + 2y = 7",
        "output": "import numpy as np\nA = np.array([[4, 3], [1, 2]])\nb = np.array([15, 7])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "SVD method:\n2x + 4y = 12\nx + y = 4",
        "output": "import numpy as np\nA = np.array([[2, 4], [1, 1]])\nb = np.array([12, 4])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Determine the solution of this linear system using Singular Value Decomposition:\n2x + 3y = 13\nx + y = 5",
        "output": "import numpy as np\nA = np.array([[2, 3], [1, 1]])\nb = np.array([13, 5])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Apply SVD to solve:\n3x + 4y = 18\nx + 2y = 8",
        "output": "import numpy as np\nA = np.array([[3, 4], [1, 2]])\nb = np.array([18, 8])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Using singular value decomposition, find the solution:\n2x + y = 7\nx + 3y = 10",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 3]])\nb = np.array([7, 10])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "What is the solution of the system below using SVD?\n4x + 2y = 14\nx + y = 5",
        "output": "import numpy as np\nA = np.array([[4, 2], [1, 1]])\nb = np.array([14, 5])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use singular value decomposition to find the values of x and y:\n3x + y = 11\n2x + y = 9",
        "output": "import numpy as np\nA = np.array([[3, 1], [2, 1]])\nb = np.array([11, 9])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Find x and y using SVD:\n2x + 3y = 12\nx + 4y = 10",
        "output": "import numpy as np\nA = np.array([[2, 3], [1, 4]])\nb = np.array([12, 10])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Use SVD to determine the solution of the linear system:\n4x + y = 13\nx + 2y = 7",
        "output": "import numpy as np\nA = np.array([[4, 1], [1, 2]])\nb = np.array([13, 7])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the following equations using singular value decomposition:\n2x + 2y = 10\nx + 3y = 9",
        "output": "import numpy as np\nA = np.array([[2, 2], [1, 3]])\nb = np.array([10, 9])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Determine the least squares solution using SVD:\n3x + y = 8\nx + 2y = 6",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 2]])\nb = np.array([8, 6])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Find the solution via SVD:\n2x + y = 7\nx + 2y = 8",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\nb = np.array([7, 8])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD to solve this system of equations:\n4x + 3y = 16\nx + y = 6",
        "output": "import numpy as np\nA = np.array([[4, 3], [1, 1]])\nb = np.array([16, 6])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the following linear system using the SVD approach:\n2x + 5y = 19\nx + y = 6",
        "output": "import numpy as np\nA = np.array([[2, 5], [1, 1]])\nb = np.array([19, 6])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the equations below using the singular value decomposition method:\n2x + y = 5\nx + 2y = 6",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\nb = np.array([5, 6])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Using SVD, solve the following:\n3x + 2y = 11\n2x + 2y = 10",
        "output": "import numpy as np\nA = np.array([[3, 2], [2, 2]])\nb = np.array([11, 10])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use singular value decomposition to compute the solution:\nx + 4y = 10\n2x + 3y = 12",
        "output": "import numpy as np\nA = np.array([[1, 4], [2, 3]])\nb = np.array([10, 12])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Solve via SVD:\n2x + y = 6\nx + 3y = 9",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 3]])\nb = np.array([6, 9])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Determine the values of x and y using the SVD technique:\n3x + y = 9\nx + 2y = 7",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 2]])\nb = np.array([9, 7])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Find the SVD solution to:\n2x + 2y = 8\n3x + y = 9",
        "output": "import numpy as np\nA = np.array([[2, 2], [3, 1]])\nb = np.array([8, 9])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve with SVD:\n3x + 3y = 15\n2x + y = 8",
        "output": "import numpy as np\nA = np.array([[3, 3], [2, 1]])\nb = np.array([15, 8])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Find the solution to this system using SVD:\n4x + 3y = 17\nx + y = 6",
        "output": "import numpy as np\nA = np.array([[4, 3], [1, 1]])\nb = np.array([17, 6])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use the singular value decomposition method to solve:\n2x + y = 5\nx + 2y = 7",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\nb = np.array([5, 7])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Solve the following using singular value decomposition:\nA = [[2, 1], [3, 2]], b = [7, 13]",
        "output": "import numpy as np\nA = np.array([[2, 1], [3, 2]])\nb = np.array([7, 13])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Given the matrix system Ax = b with\nA = [[4, 2], [1, 3]] and b = [14, 10], find x using SVD.",
        "output": "import numpy as np\nA = np.array([[4, 2], [1, 3]])\nb = np.array([14, 10])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Use SVD to solve the system:\n5x + 2y = 21\n3x + 4y = 24",
        "output": "import numpy as np\nA = np.array([[5, 2], [3, 4]])\nb = np.array([21, 24])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve using SVD:\n6x + y = 20\nx + 5y = 19",
        "output": "import numpy as np\nA = np.array([[6, 1], [1, 5]])\nb = np.array([20, 19])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Find the solution using singular value decomposition for the matrix equation:\nA = [[3, 5], [1, 6]]\nb = [19, 17]",
        "output": "import numpy as np\nA = np.array([[3, 5], [1, 6]])\nb = np.array([19, 17])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Use SVD to solve:\n2x + 6y = 26\nx + 2y = 10",
        "output": "import numpy as np\nA = np.array([[2, 6], [1, 2]])\nb = np.array([26, 10])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Given:\nA = [[2, 4], [3, 1]],\nb = [16, 11]\nFind x such that Ax = b using SVD.",
        "output": "import numpy as np\nA = np.array([[2, 4], [3, 1]])\nb = np.array([16, 11])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Use singular value decomposition to solve this system:\n7x + y = 30\n2x + 3y = 18",
        "output": "import numpy as np\nA = np.array([[7, 1], [2, 3]])\nb = np.array([30, 18])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Apply SVD to this matrix equation:\nA = [[5, 2], [4, 6]]\nb = [23, 40]",
        "output": "import numpy as np\nA = np.array([[5, 2], [4, 6]])\nb = np.array([23, 40])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Solve using singular value decomposition:\n3x + 7y = 34\n5x + 2y = 29",
        "output": "import numpy as np\nA = np.array([[3, 7], [5, 2]])\nb = np.array([34, 29])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Solve the system below using SVD:\n2x + 5y = 21\n4x + 3y = 26",
        "output": "import numpy as np\nA = np.array([[2, 5], [4, 3]])\nb = np.array([21, 26])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD to determine the solution of the system:\nA = [[6, 4], [3, 2]], b = [28, 14]",
        "output": "import numpy as np\nA = np.array([[6, 4], [3, 2]])\nb = np.array([28, 14])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Determine the solution using SVD:\n4x + 7y = 43\n6x + y = 28",
        "output": "import numpy as np\nA = np.array([[4, 7], [6, 1]])\nb = np.array([43, 28])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve this matrix equation using singular value decomposition:\nA = [[1, 8], [5, 3]], b = [33, 28]",
        "output": "import numpy as np\nA = np.array([[1, 8], [5, 3]])\nb = np.array([33, 28])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Apply SVD to solve:\nx + 5y = 19\n6x + 3y = 33",
        "output": "import numpy as np\nA = np.array([[1, 5], [6, 3]])\nb = np.array([19, 33])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use singular value decomposition to compute x in the matrix system:\nA = [[4, 6], [2, 3]], b = [36, 18]",
        "output": "import numpy as np\nA = np.array([[4, 6], [2, 3]])\nb = np.array([36, 18])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Solve using SVD:\n5x + 4y = 31\nx + 6y = 29",
        "output": "import numpy as np\nA = np.array([[5, 4], [1, 6]])\nb = np.array([31, 29])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Given the matrix A and vector b:\nA = [[7, 2], [5, 4]], b = [33, 37]\nSolve Ax = b using SVD.",
        "output": "import numpy as np\nA = np.array([[7, 2], [5, 4]])\nb = np.array([33, 37])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system below using the singular value decomposition method:\nA = [[6, 2], [4, 5]], b = [30, 34]",
        "output": "import numpy as np\nA = np.array([[6, 2], [4, 5]])\nb = np.array([30, 34])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
    },
    {
        "input": "Use SVD to solve this linear system:\n3x + 8y = 46\n5x + 2y = 34",
        "output": "import numpy as np\nA = np.array([[3, 8], [5, 2]])\nb = np.array([46, 34])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Compute the SVD of the matrix A = [[3, 2], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 2], [2, 3]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('Singular values:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Given matrix A = [[4, 0], [3, -5]], find its singular values.",
        "output": "import numpy as np\nA = np.array([[4, 0], [3, -5]])\n_, S, _ = np.linalg.svd(A)\nprint('Singular values:', S)"
    },
    {
        "input": "For A = [[1, 2, 3], [4, 5, 6]], determine the matrices U, S, and Vt from its SVD.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Find the rank of matrix A = [[7, 8], [9, 10]] using its singular values.",
        "output": "import numpy as np\nA = np.array([[7, 8], [9, 10]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Rank:', rank)"
    },
    {
        "input": "Compute the condition number of A = [[1, 2], [3, 4]] using its singular values.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\n_, S, _ = np.linalg.svd(A)\ncondition_number = S.max() / S.min()\nprint('Condition number:', condition_number)"
    },
    {
        "input": "Given A = [[1, 0, 0], [0, 2, 0], [0, 0, 3]], find its SVD and interpret the results.",
        "output": "import numpy as np\nA = np.array([[1, 0, 0], [0, 2, 0], [0, 0, 3]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Determine the null space of A = [[2, 4], [1, 2]] using SVD.",
        "output": "import numpy as np\nA = np.array([[2, 4], [1, 2]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nprint('Null space:', null_space)"
    },
    {
        "input": "Compute the pseudoinverse of A = [[1, 2], [3, 4], [5, 6]] using SVD.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros_like(A.T, dtype=float)\nS_inv[:len(S), :len(S)] = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nprint('Pseudoinverse of A:', A_pinv)"
    },
    {
        "input": "Find the best rank-1 approximation of A = [[1, 2], [3, 4]] using SVD.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nprint('Rank-1 approximation:', A_rank1)"
    },
    {
        "input": "Find the SVD of A = [[1, 0], [0, 0], [0, 0]] and interpret the geometry of the transformation.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 0], [0, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "A matrix A = [[1, 1], [1, 1]] has repeated rows. Use SVD to confirm its rank and interpret it.",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, 1]])\n_, S, _ = np.linalg.svd(A)\nprint('Singular values:', S)\nprint('Rank:', np.sum(S > 1e-10))"
    },
    {
        "input": "Let A = [[1, 2], [2, 4]]. Find the null space using its SVD components.",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nprint('Null space:', null_space)"
    },
    {
        "input": "Given A = [[3, 1], [0, 2]], compute the compact SVD and reconstruct the matrix.",
        "output": "import numpy as np\nA = np.array([[3, 1], [0, 2]])\nU, S, Vt = np.linalg.svd(A)\nA_reconstructed = U @ np.diag(S) @ Vt\nprint('Reconstructed A:', A_reconstructed)"
    },
    {
        "input": "Use SVD to find a basis for the column space of A = [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\ncolumn_space_basis = U[:, :rank]\nprint('Basis for column space:', column_space_basis)"
    },
    {
        "input": "Given a rectangular matrix A = [[1, 2, 3], [4, 5, 6]], use SVD to estimate the rank.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Estimated rank:', rank)"
    },
    {
        "input": "For A = [[2, 0, 0], [0, 0, 0]], find its SVD and describe what the singular values represent.",
        "output": "import numpy as np\nA = np.array([[2, 0, 0], [0, 0, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('Singular values:', S)"
    },
    {
        "input": "Decompose the matrix A = [[2, -1], [-1, 2]] using Singular Value Decomposition.",
        "output": "import numpy as np\nA = np.array([[2, -1], [-1, 2]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Using SVD, analyze the transformation behavior of matrix A = [[0, 4], [3, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 4], [3, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Compute the singular values of matrix A = [[1, 1], [1, -1]].",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, -1]])\n_, S, _ = np.linalg.svd(A)\nprint('Singular values:', S)"
    },
    {
        "input": "Let A be [[3, 4], [0, 0], [0, 0]]. Perform SVD and interpret the rank.",
        "output": "import numpy as np\nA = np.array([[3, 4], [0, 0], [0, 0]])\n_, S, _ = np.linalg.svd(A)\nprint('Rank:', np.sum(S > 1e-10))"
    },
    {
        "input": "Determine U, Î£, and Váµ— for matrix A = [[1, 0, 0], [0, 1, 0]].",
        "output": "import numpy as np\nA = np.array([[1, 0, 0], [0, 1, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Use SVD to compute the pseudoinverse of A = [[0, 1], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [1, 1]])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nprint('Pseudoinverse:', A_pinv)"
    },
    {
        "input": "Given matrix A = [[1, 3], [2, 6]], determine if it is rank deficient using SVD.",
        "output": "import numpy as np\nA = np.array([[1, 3], [2, 6]])\n_, S, _ = np.linalg.svd(A)\nprint('Rank:', np.sum(S > 1e-10))"
    },
    {
        "input": "Let A = [[5, 1, 0], [0, 0, 0]]. Use SVD to analyze its rank and basis vectors.",
        "output": "import numpy as np\nA = np.array([[5, 1, 0], [0, 0, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Compute the best rank-1 approximation for A = [[4, 0], [3, 0]].",
        "output": "import numpy as np\nA = np.array([[4, 0], [3, 0]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nprint('Rank-1 approximation:', A_rank1)"
    },
    {
        "input": "Given A = [[1, 2], [2, 1]], use SVD to check if its transformation preserves volume.",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\n_, S, _ = np.linalg.svd(A)\ndet = S[0] * S[1]\nprint('Determinant of AᵀA (volume squared):', det)"
    },
    {
        "input": "Matrix A = [[0, 1], [-1, 0]]. Analyze its rotation behavior using SVD.",
        "output": "import numpy as np\nA = np.array([[0, 1], [-1, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Given A = [[2, 3], [2, 3]], find SVD and explain the geometry of compression.",
        "output": "import numpy as np\nA = np.array([[2, 3], [2, 3]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Let A = [[0, 2], [0, 0], [0, 0]]. Use SVD to determine its image space.",
        "output": "import numpy as np\nA = np.array([[0, 2], [0, 0], [0, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('Image space basis:', U[:, :np.sum(S > 1e-10)])"
    },
    {
        "input": "Given matrix A = [[1, 0, 0], [0, 0, 0]], perform SVD and interpret the null space.",
        "output": "import numpy as np\nA = np.array([[1, 0, 0], [0, 0, 0]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nprint('Null space:', null_space)"
    },
    {
        "input": "Use SVD to extract the null space of matrix A = [[1, 2], [2, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4]])\nU, S, Vt = np.linalg.svd(A)\nnull_mask = (S <= 1e-10)\nnull_space = Vt.T[:, null_mask]\nprint('Null space:', null_space)"
    },
    {
        "input": "For A = [[0, 1], [1, 0]], compute its SVD and examine rotation/reflection.",
        "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Given A = [[1, 0], [0, 2], [0, 0]], use SVD to find orthonormal basis for range(A).",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 2], [0, 0]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nrange_basis = U[:, :rank]\nprint('Range basis:', range_basis)"
    },
    {
        "input": "Given A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], perform an SVD and compute the optimal rank-2 approximation.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Optimal rank-2 approximation:', A_rank2)"
    },
    {
        "input": "Let A = [[1, 2], [2, 3], [3, 4]]. Perform an SVD and determine the total energy captured by the first two singular values.",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 3], [3, 4]])\n_, S, _ = np.linalg.svd(A)\nenergy = np.sum(S[:2]**2) / np.sum(S**2)\nprint('Energy captured by the first two singular values:', energy)"
    },
    {
        "input": "Perform SVD on matrix A = [[1, 1, 0], [0, 1, 1]] and describe the geometric transformation represented by A.",
        "output": "import numpy as np\nA = np.array([[1, 1, 0], [0, 1, 1]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Given A = [[1, 0], [0, 1], [0, 0]], perform SVD and compute the energy captured by the first singular value.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1], [0, 0]])\n_, S, _ = np.linalg.svd(A)\nenergy = (S[0]**2) / np.sum(S**2)\nprint('Energy captured by the first singular value:', energy)"
    },
    {
        "input": "Let A = [[5, 5, 5], [10, 10, 10]]. Perform SVD and determine the rank of the matrix.",
        "output": "import numpy as np\nA = np.array([[5, 5, 5], [10, 10, 10]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Rank of A:', rank)"
    },
    {
        "input": "Given A = [[1, 2], [3, 4], [5, 6]], find the best rank-1 approximation using SVD and explain the error.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nreconstruction_error = np.linalg.norm(A - A_rank1)\nprint('Rank-1 approximation error:', reconstruction_error)"
    },
    {
        "input": "Given A = [[1, 0, 0], [0, 2, 0], [0, 0, 3]], use SVD to compute the condition number of A.",
        "output": "import numpy as np\nA = np.array([[1, 0, 0], [0, 2, 0], [0, 0, 3]])\n_, S, _ = np.linalg.svd(A)\ncondition_number = S[0] / S[-1]\nprint('Condition number of A:', condition_number)"
    },
    {
        "input": "Use SVD to compute the error in approximating matrix A = [[2, 0], [0, 3], [4, 0]] with its rank-1 approximation.",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 3], [4, 0]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nerror = np.linalg.norm(A - A_rank1)\nprint('Error in rank-1 approximation:', error)"
    },
    {
        "input": "Perform SVD on matrix A = [[1, 0, 0], [0, 0, 0], [0, 0, 1]] and analyze the null space.",
        "output": "import numpy as np\nA = np.array([[1, 0, 0], [0, 0, 0], [0, 0, 1]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nprint('Null space:', null_space)"
    },
    {
        "input": "Given A = [[1, 2], [3, 4]], compute its SVD and determine the distance between A and its rank-1 approximation.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\ndistance = np.linalg.norm(A - A_rank1)\nprint('Distance between A and its rank-1 approximation:', distance)"
    },
    {
        "input": "Given matrix A = [[2, 3, 4], [5, 6, 7], [8, 9, 10]], compute its SVD and determine the rank and nullity.",
        "output": "import numpy as np\nA = np.array([[2, 3, 4], [5, 6, 7], [8, 9, 10]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nnullity = A.shape[1] - rank\nprint('Rank:', rank)\nprint('Nullity:', nullity)"
    },
    {
        "input": "Use SVD to compute the best rank-2 approximation of A = [[1, 1, 1], [2, 2, 2], [3, 3, 3]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [2, 2, 2], [3, 3, 3]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Best rank-2 approximation:', A_rank2)"
    },
    {
        "input": "Let A be a 5x5 matrix with singular values 1, 2, 3, 4, 5. Calculate the condition number of A.",
        "output": "import numpy as np\nS = np.array([1, 2, 3, 4, 5])\ncondition_number = S[0] / S[-1]\nprint('Condition number of A:', condition_number)"
    },
    {
        "input": "Given A = [[1, 1], [0, 1], [0, 0]], perform SVD and calculate the best rank-1 approximation.",
        "output": "import numpy as np\nA = np.array([[1, 1], [0, 1], [0, 0]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nprint('Best rank-1 approximation:', A_rank1)"
    },
    {
        "input": "Use SVD to compute the pseudoinverse of a 3x3 matrix A = [[1, 2, 3], [0, 4, 5], [6, 7, 8]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [0, 4, 5], [6, 7, 8]])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nprint('Pseudoinverse of A:', A_pinv)"
    },
    {
        "input": "Given matrix A = [[1, 0], [0, 1], [0, 0]], use SVD to find the null space and rank of A.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1], [0, 0]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nrank = np.sum(S > 1e-10)\nprint('Null space:', null_space)\nprint('Rank:', rank)"
    },
    {
        "input": "Matrix A = [[4, 4], [1, 2], [3, 5]] has 3 rows and 2 columns. Perform SVD and compute the rank and condition number of A.",
        "output": "import numpy as np\nA = np.array([[4, 4], [1, 2], [3, 5]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\ncondition_number = S[0] / S[-1]\nprint('Rank:', rank)\nprint('Condition number:', condition_number)"
    },
    {
        "input": "Given matrix A = [[3, 1], [4, 2], [5, 3]], perform SVD and compute the best rank-2 approximation.",
        "output": "import numpy as np\nA = np.array([[3, 1], [4, 2], [5, 3]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Best rank-2 approximation:', A_rank2)"
    },
    {
        "input": "Use SVD to find the optimal rank-3 approximation of A = [[1, 0, 1], [2, 3, 4], [5, 6, 7]].",
        "output": "import numpy as np\nA = np.array([[1, 0, 1], [2, 3, 4], [5, 6, 7]])\nU, S, Vt = np.linalg.svd(A)\nA_rank3 = U[:, :3] @ np.diag(S[:3]) @ Vt[:3, :]\nprint('Optimal rank-3 approximation:', A_rank3)"
    },
    {
        "input": "Given A = [[1, 2], [3, 4], [5, 6]], compute the singular values and their contribution to the matrix energy.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\n_, S, _ = np.linalg.svd(A)\nenergy = np.sum(S**2)\nprint('Matrix energy:', energy)"
    },
    {
        "input": "Matrix A = [[1, 2], [3, 4], [5, 6]] is decomposed using SVD. Determine the best rank-2 approximation and the error between the original and approximation.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nerror = np.linalg.norm(A - A_rank2)\nprint('Rank-2 approximation error:', error)"
    },
    {
        "input": "Given A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], perform SVD and compute the optimal rank-1 approximation.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nprint('Optimal rank-1 approximation:', A_rank1)"
    },
    {
        "input": "Perform SVD on matrix A = [[1, 0, 1], [0, 1, 1], [1, 0, 0]] and find the rank of the matrix.",
        "output": "import numpy as np\nA = np.array([[1, 0, 1], [0, 1, 1], [1, 0, 0]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Rank of A:', rank)"
    },
    {
        "input": "Given matrix A = [[1, 1, 1], [2, 2, 2], [3, 3, 3]], compute its SVD and explain the implications for matrix approximation.",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [2, 2, 2], [3, 3, 3]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Use SVD to compute the rank-2 approximation of matrix A = [[1, 1], [2, 2], [3, 3]] and explain the dimensionality reduction process.",
        "output": "import numpy as np\nA = np.array([[1, 1], [2, 2], [3, 3]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Rank-2 approximation:', A_rank2)"
    },
    {
        "input": "Given matrix A = [[2, 3], [4, 5], [6, 7]], compute the SVD and explain its role in dimensionality reduction.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5], [6, 7]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Use SVD to compute the best rank-3 approximation of matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nU, S, Vt = np.linalg.svd(A)\nA_rank3 = U[:, :3] @ np.diag(S[:3]) @ Vt[:3, :]\nprint('Best rank-3 approximation:', A_rank3)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4], [5, 6]], compute its SVD and determine its rank.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Rank of A:', rank)"
    },
    {
        "input": "Matrix A = [[1, 2], [3, 4], [5, 6]] has orthogonal columns. Compute A^T A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nAtA = A.T @ A\nprint('A^T A:', AtA)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4], [5, 6]], compute its SVD and explain its role in dimensionality reduction.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Use SVD to compute the Moore-Penrose pseudoinverse of A = [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2, 3))\nnp.fill_diagonal(S_inv, 1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nprint('Pseudoinverse of A:', A_pinv)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4], [5, 6]], compute its SVD and determine the null space.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nprint('Null space of A:', null_space)"
    },
    {
        "input": "Matrix A = [[1, 2], [3, 4], [5, 6]] is decomposed using SVD. Compute the best rank-1 approximation.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nprint('Best rank-1 approximation:', A_rank1)"
    },
    {
        "input": "Use SVD to compute the rank-2 approximation of A = [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Rank-2 approximation:', A_rank2)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4], [5, 6]], compute its SVD and explain its application in image compression.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Matrix A = [[1, 2], [3, 4], [5, 6]] is decomposed using SVD. Compute the condition number of A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\ncondition_number = S[0] / S[-1]\nprint('Condition number of A:', condition_number)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4], [5, 6]], compute its SVD and determine the rank and nullity.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nnullity = A.shape[1] - rank\nprint('Rank of A:', rank)\nprint('Nullity of A:', nullity)"
    },
    {
        "input": "Use SVD to compute the best rank-1 approximation of A = [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nrank = 1\nA_rank1 = U[:, :rank] @ np.diag(S[:rank]) @ Vt[:rank, :]\nprint('Rank-1 approximation:', A_rank1)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4], [5, 6]], compute its SVD and explain its role in principal component analysis.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Matrix A = [[1, 2], [3, 4], [5, 6]] is decomposed using SVD. Compute the rank and condition number of A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\ncondition_number = S[0] / S[-1]\nprint('Rank of A:', rank)\nprint('Condition number of A:', condition_number)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4], [5, 6]], compute the rank-2 approximation using SVD.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Rank-2 approximation:', A_rank2)"
    },
    {
        "input": "Use SVD to compute the pseudoinverse of matrix A = [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2, 3))\nnp.fill_diagonal(S_inv, 1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nprint('Pseudoinverse of A:', A_pinv)"
    },
    {
        "input": "Given matrix A = [[2, 3], [5, 7], [8, 9]], use SVD to compute the rank and null space.",
        "output": "import numpy as np\nA = np.array([[2, 3], [5, 7], [8, 9]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nrank = np.sum(S > 1e-10)\nprint('Null space:', null_space)\nprint('Rank:', rank)"
    },
    {
        "input": "Matrix A = [[2, 3], [4, 5], [6, 7]] has orthogonal columns. Compute the condition number of A.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5], [6, 7]])\nU, S, Vt = np.linalg.svd(A)\ncondition_number = S[0] / S[-1]\nprint('Condition number of A:', condition_number)"
    },
    {
        "input": "Given matrix A = [[1, 1, 1], [1, 2, 3], [2, 3, 4]], compute the SVD and determine the optimal rank-2 approximation.",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, 2, 3], [2, 3, 4]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Rank-2 approximation:', A_rank2)"
    },
    {
        "input": "Matrix A = [[3, 1], [1, 2], [4, 5]] is decomposed using SVD. Compute its rank and explain the significance of the singular values.",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 2], [4, 5]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Rank of A:', rank)\nprint('Singular values:', S)"
    },
    {
        "input": "Given matrix A = [[4, 2, 1], [1, 2, 3], [2, 3, 4]], compute its SVD and explain how to use it in dimensionality reduction.",
        "output": "import numpy as np\nA = np.array([[4, 2, 1], [1, 2, 3], [2, 3, 4]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Use SVD to compute the best rank-2 approximation of matrix A = [[4, 2], [1, 3], [2, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 2], [1, 3], [2, 4]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Rank-2 approximation:', A_rank2)"
    },
    {
        "input": "Given A = [[1, 1], [1, 2], [2, 3]], perform SVD and compute its null space.",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, 2], [2, 3]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nprint('Null space of A:', null_space)"
    },
    {
        "input": "Matrix A = [[1, 2], [3, 4], [5, 6]] is decomposed using SVD. Compute the rank and explain how the singular values are related to the rank of A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Rank of A:', rank)\nprint('Singular values:', S)"
    },
    {
        "input": "Use SVD to compute the rank-1 approximation of matrix A = [[4, 5], [7, 8], [10, 11]].",
        "output": "import numpy as np\nA = np.array([[4, 5], [7, 8], [10, 11]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nprint('Rank-1 approximation:', A_rank1)"
    },
    {
        "input": "Matrix A = [[2, 4], [6, 8], [10, 12]] is decomposed using SVD. Compute the rank-2 approximation.",
        "output": "import numpy as np\nA = np.array([[2, 4], [6, 8], [10, 12]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Rank-2 approximation:', A_rank2)"
    },
    {
        "input": "Given A = [[1, 2], [3, 4], [5, 6]], compute the best rank-1 approximation using SVD.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nprint('Best rank-1 approximation:', A_rank1)"
    },
    {
        "input": "Use SVD to compute the optimal rank-2 approximation of matrix A = [[3, 3], [2, 2], [4, 5]].",
        "output": "import numpy as np\nA = np.array([[3, 3], [2, 2], [4, 5]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Rank-2 approximation:', A_rank2)"
    },
    {
        "input": "Use SVD to analyze a dataset of hotel reviews and identify the key aspects of hotel quality that customers value most.",
        "output": "import numpy as np\nA = np.array([[5, 4], [3, 2], [4, 5]])\nU, S, Vt = np.linalg.svd(A)\nquality_factors = Vt[:2, :]\nprint('Key aspects of hotel quality:', quality_factors)"
    },
    {
        "input": "Given a large set of images, use SVD to reduce dimensionality and speed up facial recognition.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1], [1, 1]])\nU, S, Vt = np.linalg.svd(A)\nreduced_images = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Reduced image data for facial recognition:', reduced_images)"
    },
    {
        "input": "You are given A = [[10, 0], [0, 1]]. Perform SVD and print all outputs.",
        "output": "import numpy as np\nA = np.array([[10, 0], [0, 1]])\nU, S, Vt = np.linalg.svd(A)\nprint(\"U:\\n\", U)\nprint(\"S:\\n\", S)\nprint(\"Vt:\\n\", Vt)"
    },
    {
        "input": "Construct a rank-1 approximation of matrix A = [[1, 2], [3, 4], [5, 6]] using SVD.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nrank_1 = U[:, :1] @ np.diag(S[:1]) @ Vt[:1, :]\nprint(\"Rank-1 approximation:\\n\", rank_1)"
    },
    {
        "input": "Given a data matrix A = [[2, 3], [4, 6], [6, 9]], detect rank deficiency using SVD.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 6], [6, 9]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint(\"Rank:\", rank)"
    },
    {
        "input": "You are solving Ax = b where A = [[1, 2], [3, 4], [5, 6]] and b = [1, 2, 3]. Use SVD-based pseudoinverse to find x.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nb = np.array([1, 2, 3])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((Vt.shape[0], U.shape[0]))\nfor i in range(len(S)):\n    S_inv[i, i] = 1 / S[i]\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(\"x =\", x)"
    },
    {
        "input": "From matrix A = [[2, 0], [0, 1]], extract U only using SVD.",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 1]])\nU, _, _ = np.linalg.svd(A)\nprint(\"U =\", U)"
    },
    {
        "input": "Find how many singular values of A = [[4, 4], [4, 4]] are non-zero.",
        "output": "import numpy as np\nA = np.array([[4, 4], [4, 4]])\n_, S, _ = np.linalg.svd(A)\nprint(\"Non-zero count:\", np.sum(S > 1e-10))"
    },
    {
        "input": "Use SVD to orthonormalize the columns of A = [[1, 1], [1, -1]].",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, -1]])\nU, _, _ = np.linalg.svd(A)\nprint(\"Orthonormal basis (columns of U):\\n\", U)"
    },
    {
        "input": "A researcher stores image data as a matrix A = [[255, 0], [0, 255]]. Use SVD to perform a low-rank approximation and display the result.",
        "output": "import numpy as np\nA = np.array([[255, 0], [0, 255]])\nU, S, Vt = np.linalg.svd(A)\nS[1] = 0\nA_low_rank = U @ np.diag(S) @ Vt\nprint(\"Low-rank approximation:\\n\", A_low_rank)"
    },
    {
        "input": "Compute the SVD of matrix A = [[7, 2], [3, 4]] and print U only.",
        "output": "import numpy as np\nA = np.array([[7, 2], [3, 4]])\nU, _, _ = np.linalg.svd(A)\nprint(\"U =\", U)"
    },
    {
        "input": "Given matrix A = [[5, 6], [7, 8]], find the values of V^T using SVD.",
        "output": "import numpy as np\nA = np.array([[5, 6], [7, 8]])\n_, _, Vt = np.linalg.svd(A)\nprint(\"V^T =\", Vt)"
    },
    {
        "input": "Let A be a 4x3 matrix with linearly dependent columns. Check its rank using SVD. Use A = [[1, 2, 3], [2, 4, 6], [3, 6, 9], [4, 8, 12]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 4, 6], [3, 6, 9], [4, 8, 12]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint(\"Rank:\", rank)"
    },
    {
        "input": "Matrix A = [[10, 5], [7, 3]]. Find its SVD and reconstruct the matrix using all components.",
        "output": "import numpy as np\nA = np.array([[10, 5], [7, 3]])\nU, S, Vt = np.linalg.svd(A)\nS_full = np.zeros_like(A, dtype=float)\nnp.fill_diagonal(S_full, S)\nA_reconstructed = U @ S_full @ Vt\nprint(\"Reconstructed A:\\n\", A_reconstructed)"
    },
    {
        "input": "Your data matrix A = [[3, 1], [1, 3]]. Use SVD to compute its eigenvalues approximately.",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\nU, S, Vt = np.linalg.svd(A)\neigenvalues = S**2\nprint(\"Approximate eigenvalues:\", eigenvalues)"
    },
    {
        "input": "Using matrix A = [[1, 0], [0, 100]], demonstrate why the condition number is high.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 100]])\n_, S, _ = np.linalg.svd(A)\ncondition = S[0] / S[-1]\nprint(\"Condition number:\", condition)"
    },
    {
        "input": "Create a matrix with one very small singular value by modifying [[1, 2], [2, 4.0001]] and print all singular values.",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4.0001]])\n_, S, _ = np.linalg.svd(A)\nprint(\"Singular values:\", S)"
    },
    {
        "input": "In a physics simulation, the matrix A = [[0, -1], [1, 0]] represents rotation. Find its SVD and print V^T.",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\n_, _, Vt = np.linalg.svd(A)\nprint(\"V^T =\", Vt)"
    },
    {
        "input": "Given A = [[8, 6], [9, 7], [2, 1]], find the number of non-zero singular values.",
        "output": "import numpy as np\nA = np.array([[8, 6], [9, 7], [2, 1]])\n_, S, _ = np.linalg.svd(A)\ncount = np.sum(S > 1e-10)\nprint(\"Non-zero singular values:\", count)"
    },
    {
        "input": "Estimate the numerical rank of A = [[1, 2], [2, 4.00001]] using singular values.",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4.00001]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint(\"Estimated rank:\", rank)"
    },
    {
        "input": "Let A = [[1, 1, 1], [1, 1, 1]]. Perform SVD and check how many non-zero singular values exist.",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, 1, 1]])\n_, S, _ = np.linalg.svd(A)\nprint(\"Non-zero singular values:\", np.sum(S > 1e-10))"
    },
    {
        "input": "Use SVD to find a basis for the column space of A = [[1, 0], [1, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [1, 1], [1, 2]])\nU, S, _ = np.linalg.svd(A)\nbasis = U[:, :np.sum(S > 1e-10)]\nprint(\"Column space basis:\\n\", basis)"
    },
    {
        "input": "Let A = [[1, 0], [0, -1]]. Show that the singular values of A differ from its eigenvalues and explain why.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, -1]])\neigvals = np.linalg.eigvals(A)\n_, S, _ = np.linalg.svd(A)\nprint(\"Eigenvalues:\", eigvals)\nprint(\"Singular values:\", S)"
    },
    {
        "input": "Matrix A = [[2, 2], [2, 2]] has rank 1. Use SVD to confirm and find its dominant direction.",
        "output": "import numpy as np\nA = np.array([[2, 2], [2, 2]])\nU, S, Vt = np.linalg.svd(A)\ndominant_direction = Vt[0]\nprint(\"Rank:\", np.sum(S > 1e-10))\nprint(\"Dominant direction:\", dominant_direction)"
    },
    {
        "input": "Use SVD to compute the pseudoinverse of a rank-deficient matrix A = [[1, 2], [2, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4]])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2,2))\nfor i in range(len(S)):\n    if S[i] > 1e-10:\n        S_inv[i, i] = 1/S[i]\nA_pinv = Vt.T @ S_inv @ U.T\nprint(\"Pseudoinverse:\\n\", A_pinv)"
    },
    {
        "input": "Consider matrix A = [[1, 0, 0], [0, 2, 0], [0, 0, 0.0001]]. Show the sensitivity of its SVD by adding noise.",
        "output": "import numpy as np\nA = np.diag([1, 2, 0.0001])\nA_noisy = A + np.random.normal(0, 1e-4, A.shape)\n_, S, _ = np.linalg.svd(A_noisy)\nprint(\"Singular values of noisy A:\", S)"
    },
    {
        "input": "Matrix A = [[1, 2, 3], [4, 5, 6]]. Compute SVD and determine which singular values to retain for 90% energy.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6]])\n_, S, _ = np.linalg.svd(A)\nenergy = np.cumsum(S**2) / np.sum(S**2)\nn = np.searchsorted(energy, 0.9) + 1\nprint(\"Number of singular values to retain:\", n)"
    },
    {
        "input": "Perform SVD on a skew-symmetric matrix A = [[0, -2], [2, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -2], [2, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint(\"SVD of skew-symmetric A:\\nU=\", U, \"\\nS=\", S, \"\\nV^T=\", Vt)"
    },
    {
        "input": "Use SVD to project a 3D point onto the best-fit 2D subspace using A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nU, S, Vt = np.linalg.svd(A)\nproj = A @ Vt[:2, :].T @ Vt[:2, :]\nprint(\"Projected points:\\n\", proj)"
    },
    {
        "input": "Use SVD to solve the underdetermined system A = [[1, 2, 3]], b = [1].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3]])\nb = np.array([1])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((1, 3)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((3, 1))\ndiag_len = min(3, 1)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Use SVD to find a rank-1 approximation of matrix A = [[1, 2], [3, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nU, S, Vt = np.linalg.svd(A)\nA_approx = U[:, 0:1] @ np.diag(S[:1]) @ Vt[:1, :]\nprint(\"Rank-1 approximation:\\n\", A_approx)"
    },
    {
        "input": "Solve the system using SVD:\n3x + 4y = 10\n2x - y = 1",
        "output": "import numpy as np\nA = np.array([[3, 4], [2, -1]])\nb = np.array([10, 1])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n4x - y = 3\nx + 2y = 7",
        "output": "import numpy as np\nA = np.array([[4, -1], [1, 2]])\nb = np.array([3, 7])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n6x + 2y = 14\n3x + y = 7",
        "output": "import numpy as np\nA = np.array([[6, 2], [3, 1]])\nb = np.array([14, 7])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n7x - 5y = 0\n2x + 3y = 11",
        "output": "import numpy as np\nA = np.array([[7, -5], [2, 3]])\nb = np.array([0, 11])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n-3x + 6y = 9\nx + y = 4",
        "output": "import numpy as np\nA = np.array([[-3, 6], [1, 1]])\nb = np.array([9, 4])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max((2, 2)) * S[0] if len(S) > 0 else np.finfo(S.dtype).eps\nS_pinv_diag = np.zeros(S.shape[0])\nnon_zero_indices = S > tol\nS_pinv_diag[non_zero_indices] = 1 / S[non_zero_indices]\nS_pinv = np.zeros((2, 2))\ndiag_len = min(2, 2)\nS_pinv[:diag_len, :diag_len] = np.diag(S_pinv_diag[:diag_len])\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n1x + 2y = 5\n3x + 4y = 6",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nb = np.array([5, 6])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max(A.shape) * S[0]\nS_pinv = np.zeros((A.shape[1], A.shape[0]))\nfor i in range(len(S)):\n    if S[i] > tol:\n        S_pinv[i, i] = 1 / S[i]\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n2x + -1y = 1\n4x + 3y = 7",
        "output": "import numpy as np\nA = np.array([[2, -1], [4, 3]])\nb = np.array([1, 7])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max(A.shape) * S[0]\nS_pinv = np.zeros((A.shape[1], A.shape[0]))\nfor i in range(len(S)):\n    if S[i] > tol:\n        S_pinv[i, i] = 1 / S[i]\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n5x + 0y = 10\n0x + 2y = 4",
        "output": "import numpy as np\nA = np.array([[5, 0], [0, 2]])\nb = np.array([10, 4])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max(A.shape) * S[0]\nS_pinv = np.zeros((A.shape[1], A.shape[0]))\nfor i in range(len(S)):\n    if S[i] > tol:\n        S_pinv[i, i] = 1 / S[i]\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n3x + 1y = 5\n1x + 2y = 3",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 2]])\nb = np.array([5, 3])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max(A.shape) * S[0]\nS_pinv = np.zeros((A.shape[1], A.shape[0]))\nfor i in range(len(S)):\n    if S[i] > tol:\n        S_pinv[i, i] = 1 / S[i]\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n6x + 2y = 8\n2x + 3y = 5",
        "output": "import numpy as np\nA = np.array([[6, 2], [2, 3]])\nb = np.array([8, 5])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max(A.shape) * S[0]\nS_pinv = np.zeros((A.shape[1], A.shape[0]))\nfor i in range(len(S)):\n    if S[i] > tol:\n        S_pinv[i, i] = 1 / S[i]\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n1x + 0y = 3\n0x + 1y = 5",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1]])\nb = np.array([3, 5])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max(A.shape) * S[0]\nS_pinv = np.zeros((A.shape[1], A.shape[0]))\nfor i in range(len(S)):\n    if S[i] > tol:\n        S_pinv[i, i] = 1 / S[i]\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n2x + 1y = 4\n1x + 2y = 6",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\nb = np.array([4, 6])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max(A.shape) * S[0]\nS_pinv = np.zeros((A.shape[1], A.shape[0]))\nfor i in range(len(S)):\n    if S[i] > tol:\n        S_pinv[i, i] = 1 / S[i]\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n4x + 2y = 9\n1x + 1y = 3",
        "output": "import numpy as np\nA = np.array([[4, 2], [1, 1]])\nb = np.array([9, 3])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max(A.shape) * S[0]\nS_pinv = np.zeros((A.shape[1], A.shape[0]))\nfor i in range(len(S)):\n    if S[i] > tol:\n        S_pinv[i, i] = 1 / S[i]\nA_pinv = Vt.T @ S_pinv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n4x - 2y = 10\n-3x + 5y = -1",
        "output": "import numpy as np\nA = np.array([[4, -2], [-3, 5]])\nb = np.array([10, -1])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max(A.shape) * S[0]\nS_inv = np.zeros((2, 2))\nfor i in range(len(S)):\n    if S[i] > tol:\n        S_inv[i, i] = 1 / S[i]\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n7x + 4y = 5\n6x - 3y = 9",
        "output": "import numpy as np\nA = np.array([[7, 4], [6, -3]])\nb = np.array([5, 9])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max(A.shape) * S[0]\nS_inv = np.zeros((2, 2))\nfor i in range(len(S)):\n    if S[i] > tol:\n        S_inv[i, i] = 1 / S[i]\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n5x + y = 13\n2x - 3y = -4",
        "output": "import numpy as np\nA = np.array([[5, 1], [2, -3]])\nb = np.array([13, -4])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max(A.shape) * S[0]\nS_inv = np.zeros((2, 2))\nfor i in range(len(S)):\n    if S[i] > tol:\n        S_inv[i, i] = 1 / S[i]\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n3x + 2y = 14\nx + 7y = 5",
        "output": "import numpy as np\nA = np.array([[3, 2], [1, 7]])\nb = np.array([14, 5])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max(A.shape) * S[0]\nS_inv = np.zeros((2, 2))\nfor i in range(len(S)):\n    if S[i] > tol:\n        S_inv[i, i] = 1 / S[i]\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Solve the system using SVD:\n-2x + y = 6\n4x + 3y = 2",
        "output": "import numpy as np\nA = np.array([[-2, 1], [4, 3]])\nb = np.array([6, 2])\nU, S, Vt = np.linalg.svd(A)\ntol = np.finfo(S.dtype).eps * max(A.shape) * S[0]\nS_inv = np.zeros((2, 2))\nfor i in range(len(S)):\n    if S[i] > tol:\n        S_inv[i, i] = 1 / S[i]\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(\"Solution x:\", x)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[2, 0], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the diagonal form D and the matrix P such that P^(-1) * C * P = D for C = [[5, 4], [1, 2]].",
        "output": "import numpy as np\nC = np.array([[5, 4], [1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(C)\nD = np.diag(eigenvalues)\nP = eigenvectors\nP_inv = np.linalg.inv(P)\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)\nprint('Verification (P_inv * C * P):\\n', np.dot(P_inv, np.dot(C, P)))"
    },
    {
        "input": "Find the spectral decomposition of the matrix D = [[3, 0], [0, -1]].",
        "output": "import numpy as np\nD = np.array([[3, 0], [0, -1]])\neigenvalues, eigenvectors = np.linalg.eigh(D)\nP = eigenvectors\nD_diag = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nprint('Spectral decomposition: P * D_diag * P_inv =\\n', np.dot(P, np.dot(D_diag, P_inv)))"
    },
    {
        "input": "For the matrix F = [[1, 2], [2, 1]], find an orthogonal matrix P that diagonalizes it.",
        "output": "import numpy as np\nF = np.array([[1, 2], [2, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(F)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nprint('Orthogonal matrix P:\\n', P)\nprint('Diagonal matrix D:\\n', D)\nprint('Verification (P_inv * F * P):\\n', np.dot(P_inv, np.dot(F, P)))"
    },
    {
        "input": "Determine the eigenvalues of the matrix G = [[0, -1], [1, 0]].",
        "output": "import numpy as np\nG = np.array([[0, -1], [1, 0]])\neigenvalues, _ = np.linalg.eig(G)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors corresponding to the eigenvalue 3 of the matrix H = [[3, 1], [0, 3]].",
        "output": "import numpy as np\nH = np.array([[3, 1], [0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(H)\neigenvalue = 3\nindices = np.where(np.isclose(eigenvalues, eigenvalue))[0]\ncorresponding_eigenvectors = eigenvectors[:, indices]\nprint('Eigenvectors corresponding to eigenvalue 3:\\n', corresponding_eigenvectors)"
    },
    {
        "input": "Compute the diagonalization of the matrix J = [[4, 0], [0, 1]].",
        "output": "import numpy as np\nJ = np.array([[4, 0], [0, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(J)\nD = np.diag(eigenvalues)\nP = eigenvectors\nP_inv = np.linalg.inv(P)\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)\nprint('Verification (P_inv * J * P):\\n', np.dot(P_inv, np.dot(J, P)))"
    },
    {
        "input": "Find the eigenvalues of the 2x2 matrix [[1, 0], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of the matrix [[3, 0], [0, 5]].",
        "output": "import numpy as np\nA = np.array([[3, 0], [0, 5]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of the identity matrix I = [[1, 0], [0, 1]].",
        "output": "import numpy as np\nI = np.eye(2)\neigenvalues = np.linalg.eigvals(I)\nprint('Eigenvalues of identity matrix:', eigenvalues)"
    },
    {
        "input": "Diagonalize the matrix [[7, 0], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[7, 0], [0, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nP_inv = np.linalg.inv(P)\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[0, 2], [2, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 2], [2, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 zero matrix.",
        "output": "import numpy as np\nZ = np.zeros((2, 2))\neigenvalues = np.linalg.eigvals(Z)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "For matrix [[9, 0], [0, 4]], find P and D such that A = P D P^(-1).",
        "output": "import numpy as np\nA = np.array([[9, 0], [0, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nprint('Matrix P:\\n', P)\nprint('Diagonal matrix D:\\n', D)"
    },
    {
        "input": "Find the trace and determinant of the matrix [[2, 0], [0, 3]] and verify with sum and product of eigenvalues.",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 3]])\neigenvalues = np.linalg.eigvals(A)\ntrace = np.trace(A)\ndet = np.linalg.det(A)\nprint('Trace:', trace, 'Sum of eigenvalues:', sum(eigenvalues))\nprint('Determinant:', det, 'Product of eigenvalues:', np.prod(eigenvalues))"
    },
    {
        "input": "Find eigenvalues and eigenvectors of matrix [[0, 1], [-1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [-1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the orthonormal eigenvectors of matrix [[2, 0], [0, 3]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[2, 0], [0, 3]])\n_, eigenvectors = np.linalg.eigh(A)\northonormal_vectors = [v / norm(v) for v in eigenvectors.T]\nprint('Orthonormal eigenvectors:\\n', np.array(orthonormal_vectors).T)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[4, 2], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[4, 2], [1, 3]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Diagonalize the matrix [[8, 0], [0, 5]].",
        "output": "import numpy as np\nA = np.array([[8, 0], [0, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)"
    },
    {
        "input": "Find the eigenvalues of matrix [[1, -1], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, -1], [1, 1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a diagonal matrix [[6, 0], [0, -3]].",
        "output": "import numpy as np\nA = np.array([[6, 0], [0, -3]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of matrix [[0, 2], [2, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 2], [2, 0]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the diagonal matrix D and matrix P for A = [[10, 0], [0, -2]].",
        "output": "import numpy as np\nA = np.array([[10, 0], [0, -2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)"
    },
    {
        "input": "Find eigenvalues and eigenvectors of the matrix [[1, 1], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1], [0, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find eigenvalues of matrix [[0, 1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute diagonalization of A = [[2, 0], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('Matrix P:\\n', P)\nprint('Diagonal matrix D:\\n', D)"
    },
    {
        "input": "Find the orthonormal eigenvectors of the matrix [[4, 0], [0, 9]].",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[4, 0], [0, 9]])\n_, eigenvectors = np.linalg.eigh(A)\northonormal_vectors = [v / norm(v) for v in eigenvectors.T]\nprint('Orthonormal eigenvectors:\\n', np.array(orthonormal_vectors).T)"
    },
    {
        "input": "Verify eigen-decomposition A = P D P^(-1) for A = [[5, 0], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[5, 0], [0, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nprint('A from decomposition:\\n', P @ D @ P_inv)"
    },
    {
        "input": "Find the eigenvalues of matrix [[-1, 0], [0, -1]].",
        "output": "import numpy as np\nA = np.array([[-1, 0], [0, -1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[2, 1], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [0, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the trace and determinant of matrix [[3, 1], [1, 3]] and compare with sum and product of eigenvalues.",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\neigenvalues = np.linalg.eigvals(A)\ntrace = np.trace(A)\ndet = np.linalg.det(A)\nprint('Trace:', trace, 'Sum of eigenvalues:', sum(eigenvalues))\nprint('Determinant:', det, 'Product of eigenvalues:', np.prod(eigenvalues))"
    },
    {
        "input": "Find the eigenvalues of matrix [[0, -1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find eigenvalues and eigenvectors of matrix [[5, 0], [0, 0]].",
        "output": "import numpy as np\nA = np.array([[5, 0], [0, 0]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the diagonal form of matrix [[7, 0], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[7, 0], [0, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('Diagonal matrix D:\\n', D)"
    },
    {
        "input": "Verify eigen-decomposition A = P D P^(-1) for A = [[4, 0], [0, 9]].",
        "output": "import numpy as np\nA = np.array([[4, 0], [0, 9]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nprint('A from decomposition:\\n', P @ D @ P_inv)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix with both rows [2, 2].",
        "output": "import numpy as np\nA = np.array([[2, 2], [2, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find eigenvectors of matrix [[1, 2], [2, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[-3, 0], [0, 4]].",
        "output": "import numpy as np\nA = np.array([[-3, 0], [0, 4]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Diagonalize the matrix [[6, 0], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[6, 0], [0, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)"
    },
    {
        "input": "Find the eigenvalues of matrix [[2, -1], [-1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1], [-1, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[3, 0], [0, 7]].",
        "output": "import numpy as np\nA = np.array([[3, 0], [0, 7]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of the matrix [[0, -1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix [[5, 4], [4, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 4], [4, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('Matrix P:\\n', P)\nprint('Diagonal matrix D:\\n', D)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[1, 2], [2, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the diagonal form of the matrix [[3, -2], [-2, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -2], [-2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('Diagonal matrix D:\\n', D)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix [[0, 2], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[0, 2], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[7, 0], [0, -1]].",
        "output": "import numpy as np\nA = np.array([[7, 0], [0, -1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvectors of the matrix [[2, 0], [0, 5]].",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 5]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Verify the diagonalization of the matrix [[3, 1], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nA_reconstructed = P @ D @ P_inv\nprint('Reconstructed A:\\n', A_reconstructed)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[0, -2], [2, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -2], [2, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of the matrix [[4, 0], [0, 9]].",
        "output": "import numpy as np\nA = np.array([[4, 0], [0, 9]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of matrix [[8, 0], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[8, 0], [0, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find eigenvectors of the matrix [[6, 1], [1, 6]].",
        "output": "import numpy as np\nA = np.array([[6, 1], [1, 6]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize matrix [[4, 0], [0, -3]].",
        "output": "import numpy as np\nA = np.array([[4, 0], [0, -3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)"
    },
    {
        "input": "Find eigenvalues of matrix [[5, 5], [5, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 5], [5, 5]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find eigenvectors of matrix [[10, 0], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[10, 0], [0, 1]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of matrix [[1, -1], [-1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, -1], [-1, 1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of matrix [[9, 0], [0, -4]].",
        "output": "import numpy as np\nA = np.array([[9, 0], [0, -4]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the diagonal form of matrix [[3, 0], [0, 6]].",
        "output": "import numpy as np\nA = np.array([[3, 0], [0, 6]])\neigenvalues, _ = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('Diagonal matrix D:\\n', D)"
    },
    {
        "input": "Compute eigenvalues of matrix [[0, 1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find eigenvectors of matrix [[2, 3], [3, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 3], [3, 2]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix [[1, 0], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[2, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of the matrix [[2, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix [[7, 0], [0, 5]].",
        "output": "import numpy as np\nA = np.array([[7, 0], [0, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Verify A = P D P⁻¹ for A = [[2, 0], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nA_check = P @ D @ P_inv\nprint('A reconstructed:\\n', A_check)"
    },
    {
        "input": "Find the eigenvalues of matrix [[1, 0], [0, -1]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, -1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of matrix [[1, 0], [0, -1]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, -1]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix [[2, -1], [-1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1], [-1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Compute the eigenvalues of matrix [[0, 1], [-1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [-1, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of matrix [[0, 1], [-1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [-1, 0]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize matrix [[1, 1], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Find the eigenvalues of matrix [[-2, 0], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[-2, 0], [0, 3]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find eigenvectors of matrix [[-2, 0], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[-2, 0], [0, 3]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of matrix [[3, 0], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 0], [0, 3]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of matrix [[3, 0], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 0], [0, 3]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix [[4, 1], [1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1], [1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Compute eigenvalues of matrix [[0, -2], [-2, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -2], [-2, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find eigenvectors of matrix [[0, -2], [-2, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -2], [-2, 0]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Verify that A = P D P⁻¹ for matrix A = [[2, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nP_inv = np.linalg.inv(P)\nA_check = P @ D @ P_inv\nprint('A reconstructed:\\n', A_check)"
    },
    {
        "input": "Find the eigenvalues of matrix [[6, 0], [0, -2]].",
        "output": "import numpy as np\nA = np.array([[6, 0], [0, -2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of matrix [[6, 0], [0, -2]].",
        "output": "import numpy as np\nA = np.array([[6, 0], [0, -2]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the diagonal form of matrix [[9, 0], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[9, 0], [0, 1]])\neigenvalues, _ = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('Diagonal matrix D:\\n', D)"
    },
    {
        "input": "Diagonalize matrix [[5, 2], [2, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 2], [2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Find the eigenvectors of matrix [[2, -1], [-1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1], [-1, 2]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[1, 2], [2, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of the matrix [[1, 2], [2, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Verify A = P D P⁻¹ for A = [[3, 0], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 0], [0, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nA_check = P @ D @ P_inv\nprint('A reconstructed:\\n', A_check)"
    },
    {
        "input": "Find the eigenvalues of matrix [[0, 2], [2, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 2], [2, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Diagonalize the matrix [[3, -1], [-1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -1], [-1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Compute the eigenvalues of matrix [[0, -3], [-3, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -3], [-3, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of matrix [[0, -3], [-3, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -3], [-3, 0]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize matrix [[2, 2], [2, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 2], [2, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Find the eigenvalues of matrix [[-3, 0], [0, 4]].",
        "output": "import numpy as np\nA = np.array([[-3, 0], [0, 4]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find eigenvectors of matrix [[-3, 0], [0, 4]].",
        "output": "import numpy as np\nA = np.array([[-3, 0], [0, 4]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix [[3, 2], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 2], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Verify A = P D P⁻¹ for A = [[5, 0], [0, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 0], [0, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nA_check = P @ D @ P_inv\nprint('A reconstructed:\\n', A_check)"
    },
    {
        "input": "Find the eigenvalues of matrix [[1, 3], [3, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 3], [3, 1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of matrix [[1, 3], [3, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 3], [3, 1]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix [[4, -1], [-1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, -1], [-1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Compute the eigenvalues of matrix [[0, 4], [4, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 4], [4, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of matrix [[0, 4], [4, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 4], [4, 0]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize matrix [[3, 3], [3, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 3], [3, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[3, 1], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of the matrix [[3, 1], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix [[4, 2], [2, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 2], [2, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Verify A = P D P⁻¹ for A = [[6, 0], [0, 6]].",
        "output": "import numpy as np\nA = np.array([[6, 0], [0, 6]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nA_check = P @ D @ P_inv\nprint('A reconstructed:\\n', A_check)"
    },
    {
        "input": "Find the eigenvalues of matrix [[2, 4], [4, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 4], [4, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of matrix [[2, 4], [4, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 4], [4, 2]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix [[5, -1], [-1, 5]].",
        "output": "import numpy as np\nA = np.array([[5, -1], [-1, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Compute the eigenvalues of matrix [[0, 5], [5, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 5], [5, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of matrix [[0, 5], [5, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 5], [5, 0]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[6, 2], [2, 6]].",
        "output": "import numpy as np\nA = np.array([[6, 2], [2, 6]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of the matrix [[6, 2], [2, 6]].",
        "output": "import numpy as np\nA = np.array([[6, 2], [2, 6]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix [[2, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Verify if A = PDP⁻¹ for A = [[7, 0], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[7, 0], [0, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nA_reconstructed = P @ D @ np.linalg.inv(P)\nprint('A reconstructed:\\n', A_reconstructed)"
    },
    {
        "input": "Find the eigenvalues of matrix [[1, 0], [0, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 9]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of matrix [[1, 0], [0, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 9]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 3x3 matrix [[2, 0, 0], [0, 3, 4], [0, 4, 9]].",
        "output": "import numpy as np\nA = np.array([[2, 0, 0], [0, 3, 4], [0, 4, 9]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix [[1, 2, 0], [2, 3, 0], [0, 0, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 0], [2, 3, 0], [0, 0, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Find eigenvalues of the symmetric matrix [[5, 2, 1], [2, 3, 0], [1, 0, 4]].",
        "output": "import numpy as np\nA = np.array([[5, 2, 1], [2, 3, 0], [1, 0, 4]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find a diagonal matrix similar to A = [[3, 1, 0], [1, 3, 0], [0, 0, 5]].",
        "output": "import numpy as np\nA = np.array([[3, 1, 0], [1, 3, 0], [0, 0, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('Diagonal matrix D:\\n', D)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the symmetric matrix [[1, -1, 0], [-1, 2, -1], [0, -1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, -1, 0], [-1, 2, -1], [0, -1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix [[7, 2, 0], [2, 5, 0], [0, 0, 3]].",
        "output": "import numpy as np\nA = np.array([[7, 2, 0], [2, 5, 0], [0, 0, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Verify that A = P D P⁻¹ for A = [[6, 1, 0], [1, 6, 0], [0, 0, 2]].",
        "output": "import numpy as np\nA = np.array([[6, 1, 0], [1, 6, 0], [0, 0, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nA_check = P @ D @ P_inv\nprint('A reconstructed:\\n', A_check)"
    },
    {
        "input": "Find the eigenvalues of matrix [[2, 1, 1], [1, 2, 1], [1, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of matrix [[2, 1, 1], [1, 2, 1], [1, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the symmetric matrix [[10, 2, 3], [2, 6, 4], [3, 4, 8]].",
        "output": "import numpy as np\nA = np.array([[10, 2, 3], [2, 6, 4], [3, 4, 8]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Compute the eigenvalues of matrix [[2, 0, 0], [0, 3, 0], [0, 0, 5]].",
        "output": "import numpy as np\nA = np.array([[2, 0, 0], [0, 3, 0], [0, 0, 5]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[4, 1, -1], [1, 4, -1], [-1, -1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1, -1], [1, 4, -1], [-1, -1, 4]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of the matrix [[4, 1, -1], [1, 4, -1], [-1, -1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1, -1], [1, 4, -1], [-1, -1, 4]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix [[1, 2, 3], [2, 1, 2], [3, 2, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 1, 2], [3, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)\nprint('P:\\n', eigenvectors)"
    },
    {
        "input": "Find eigenvalues of the matrix [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find a diagonal matrix similar to [[1, 1, 0], [1, 1, 1], [0, 1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 0], [1, 1, 1], [0, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('Diagonal matrix:\\n', D)"
    },
    {
        "input": "Diagonalize the matrix [[5, 0, 2], [0, 3, 0], [2, 0, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 0, 2], [0, 3, 0], [2, 0, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)\nprint('P:\\n', eigenvectors)"
    },
    {
        "input": "Find eigenvalues of the matrix [[6, 2, 0], [2, 3, 0], [0, 0, 1]].",
        "output": "import numpy as np\nA = np.array([[6, 2, 0], [2, 3, 0], [0, 0, 1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find eigenvectors of the matrix [[6, 2, 0], [2, 3, 0], [0, 0, 1]].",
        "output": "import numpy as np\nA = np.array([[6, 2, 0], [2, 3, 0], [0, 0, 1]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[0, 1, 0], [1, 0, 1], [0, 1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of matrix [[0, 1, 0], [1, 0, 1], [0, 1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the diagonalization of [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[3, -2, 0], [-2, 3, 0], [0, 0, 1]].",
        "output": "import numpy as np\nA = np.array([[3, -2, 0], [-2, 3, 0], [0, 0, 1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Diagonalize the symmetric matrix [[4, -1, 0], [-1, 4, -1], [0, -1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, -1, 0], [-1, 4, -1], [0, -1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)\nprint('P:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvectors of matrix [[2, 1, -1], [1, 2, 1], [-1, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, -1], [1, 2, 1], [-1, 1, 2]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of matrix [[7, 0, 0], [0, 3, 0], [0, 0, 5]].",
        "output": "import numpy as np\nA = np.array([[7, 0, 0], [0, 3, 0], [0, 0, 5]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of matrix [[1, 1, 1], [1, 1, 1], [1, 1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, 1, 1], [1, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the diagonalization of matrix [[6, 2, 1], [2, 3, 1], [1, 1, 1]].",
        "output": "import numpy as np\nA = np.array([[6, 2, 1], [2, 3, 1], [1, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Find the eigenvalues of matrix [[5, 2, 1], [2, 4, 2], [1, 2, 3]].",
        "output": "import numpy as np\nA = np.array([[5, 2, 1], [2, 4, 2], [1, 2, 3]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the diagonal matrix similar to A = [[1, 1, 0], [1, 2, 1], [0, 1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 0], [1, 2, 1], [0, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)"
    },
    {
        "input": "Diagonalize matrix [[1, 2, 0], [2, 1, 0], [0, 0, 3]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 0], [2, 1, 0], [0, 0, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)\nprint('P:\\n', eigenvectors)"
    },
    {
        "input": "Find eigenvectors of the matrix [[1, 0, 2], [0, 3, 0], [2, 0, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 0, 2], [0, 3, 0], [2, 0, 1]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[2, 1, 1], [1, 2, 1], [1, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[4, -2, 1], [-2, 4, -2], [1, -2, 4]].",
        "output": "import numpy as np\nA = np.array([[4, -2, 1], [-2, 4, -2], [1, -2, 4]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of the matrix [[3, 1, 1], [1, 3, 1], [1, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1, 1], [1, 3, 1], [1, 1, 3]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix [[5, 4, 2], [4, 5, 4], [2, 4, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 4, 2], [4, 5, 4], [2, 4, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the diagonalization of the matrix [[4, 1, 1], [1, 4, 1], [1, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 1], [1, 4, 1], [1, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[2, 0, 1], [0, 3, 0], [1, 0, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 0, 1], [0, 3, 0], [1, 0, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvectors of the matrix [[2, 0, 1], [0, 3, 0], [1, 0, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 0, 1], [0, 3, 0], [1, 0, 2]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix [[1, 1, 0], [1, 2, 1], [0, 1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 0], [1, 2, 1], [0, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix [[3, 2, 2], [2, 3, 2], [2, 2, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 2, 2], [2, 3, 2], [2, 2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[6, 1, 0], [1, 6, 1], [0, 1, 6]].",
        "output": "import numpy as np\nA = np.array([[6, 1, 0], [1, 6, 1], [0, 1, 6]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Diagonalize the symmetric matrix [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)\nprint('P:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvectors of the matrix [[0, 1, 0], [1, 0, 1], [0, 1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[4, 1, 2], [1, 4, 1], [2, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 2], [1, 4, 1], [2, 1, 4]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[7, 2, 1], [2, 7, 2], [1, 2, 7]].",
        "output": "import numpy as np\nA = np.array([[7, 2, 1], [2, 7, 2], [1, 2, 7]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the diagonal matrix similar to the matrix [[3, 1, 2], [1, 3, 1], [2, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1, 2], [1, 3, 1], [2, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of matrix [[3, 0, 0], [0, 5, 0], [0, 0, 7]].",
        "output": "import numpy as np\nA = np.array([[3, 0, 0], [0, 5, 0], [0, 0, 7]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[4, 0, 0], [0, 2, 0], [0, 0, 6]].",
        "output": "import numpy as np\nA = np.array([[4, 0, 0], [0, 2, 0], [0, 0, 6]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the diagonal matrix similar to the matrix [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)"
    },
    {
        "input": "Find the eigenvectors of the matrix [[1, 2, 0], [2, 1, 2], [0, 2, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 0], [2, 1, 2], [0, 2, 1]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix [[1, 0, 1], [0, 1, 0], [1, 0, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 0, 1], [0, 1, 0], [1, 0, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of matrix [[0, 1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the diagonal matrix similar to the matrix [[3, 1], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[5, 4], [4, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 4], [4, 5]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the diagonalization of the matrix [[3, -1], [-1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -1], [-1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[2, 3, 1], [3, 2, 3], [1, 3, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 3, 1], [3, 2, 3], [1, 3, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[4, 2, 2], [2, 4, 2], [2, 2, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 2, 2], [2, 4, 2], [2, 2, 4]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the diagonal matrix similar to the matrix [[2, 1, 1], [1, 2, 1], [1, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)"
    },
    {
        "input": "Find the eigenvectors of the matrix [[3, 0, 0], [0, 3, 0], [0, 0, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 0, 0], [0, 3, 0], [0, 0, 3]])\n_, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix [[4, 1, 2], [1, 4, 1], [2, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 2], [1, 4, 1], [2, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of matrix [[2, 0, 1], [0, 2, 0], [1, 0, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 0, 1], [0, 2, 0], [1, 0, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[3, 1, 2], [1, 3, 1], [2, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1, 2], [1, 3, 1], [2, 1, 3]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the diagonal matrix similar to the matrix [[2, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)"
    },
    {
        "input": "Diagonalize the matrix [[4, 0, 1], [0, 4, 0], [1, 0, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 0, 1], [0, 4, 0], [1, 0, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[0, 1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the diagonal matrix similar to the matrix [[3, -1], [-1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -1], [-1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)"
    },
    {
        "input": "Given the matrix A = [[4, 1], [6, -1]], find its eigenvalues and eigenvectors.",
        "output": "import numpy as np\nA = np.array([[4, 1], [6, -1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "For the matrix A = [[2, 0, 0], [1, 3, 1], [0, 0, 3]], find the diagonal matrix D and the matrix P such that A = P D P^{-1}.",
        "output": "import numpy as np\nA = np.array([[2, 0, 0], [1, 3, 1], [0, 0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nP_inv = np.linalg.inv(P)\nA_reconstructed = P @ D @ P_inv\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)\nprint('P inverse:\\n', P_inv)\nprint('Reconstructed A:\\n', A_reconstructed)"
    },
    {
        "input": "Given the matrix A = [[1, 2], [4, 3]], diagonalize A and use it to compute A^{-1}, if it exists.",
        "output": "import numpy as np\nA = np.array([[1, 2], [4, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nP_inv = np.linalg.inv(P)\nD_inv = np.diag(1 / eigenvalues)\nA_inv = P @ D_inv @ P_inv\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)\nprint('P inverse:\\n', P_inv)\nprint('A inverse:\\n', A_inv)"
    },
    {
        "input": "For the matrix A = [[7, -4, 4], [-4, 8, -4], [4, -4, 7]], find the eigenvalues and eigenvectors. Determine P and D for diagonalization.",
        "output": "import numpy as np\nA = np.array([[7, -4, 4], [-4, 8, -4], [4, -4, 7]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)"
    },
    {
        "input": "Given the matrix A = [[1, 0, -1], [1, 2, 1], [2, 2, 3]], find the diagonal matrix D using diagonalization.",
        "output": "import numpy as np\nA = np.array([[1, 0, -1], [1, 2, 1], [2, 2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('Diagonal matrix D:\\n', D)"
    },
    {
        "input": "Compute the characteristic polynomial of the matrix A = [[3, -2], [1, 0]], and find its eigenvalues.",
        "output": "import numpy as np\nA = np.array([[3, -2], [1, 0]])\nchar_poly = np.poly(A)\neigenvalues = np.roots(char_poly)\nprint('Characteristic polynomial coefficients:', char_poly)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Given the matrix A = [[2, 1], [1, 2]], find the orthonormal eigenvectors and diagonalize A using the spectral theorem.",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nA_reconstructed = P @ D @ P.T\nprint('Eigenvalues:', eigenvalues)\nprint('Orthonormal eigenvectors (P):\\n', P)\nprint('Diagonal matrix D:\\n', D)\nprint('Reconstructed A:\\n', A_reconstructed)"
    },
    {
        "input": "Find the spectral decomposition of A = [[1, -1], [-1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, -1], [-1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(\n    eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i])\n    for i in range(len(eigenvalues))\n)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)\nprint('Spectral decomposition result:\\n', spectral)"
    },
    {
        "input": "Let A = [[1, 2], [2, 1]]. Diagonalize it using the spectral theorem if possible.",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('Eigenvalues:', eigenvalues)\nprint('Orthonormal eigenvectors (P):\\n', P)\nprint('Diagonal matrix D:\\n', D)"
    },
    {
        "input": "Given the matrix A = [[4, 2], [2, 4]], determine whether A is diagonalizable and find the diagonal matrix D if it is.",
        "output": "import numpy as np\nA = np.array([[4, 2], [2, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Determine the eigenvalues and diagonal form of A = [[6, 2], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[6, 2], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Compute the eigenvalues of the symmetric matrix A = [[2, -1], [-1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1], [-1, 2]])\neigenvalues = np.linalg.eigvalsh(A)\nprint(\"Eigenvalues:\", eigenvalues)"
    },
    {
        "input": "Diagonalize A = [[5, 0], [0, -1]].",
        "output": "import numpy as np\nA = np.array([[5, 0], [0, -1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
    },
    {
        "input": "Find the spectral decomposition of A = [[2, 0], [0, 5]].",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspec_decomp = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(len(eigenvalues)))\nprint(\"Spectral decomposition:\\n\", spec_decomp)"
    },
    {
        "input": "Diagonalize the matrix A = [[0, -1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of A = [[4, 1, 0], [1, 4, 1], [0, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 0], [1, 4, 1], [0, 1, 4]])\neigenvalues = np.linalg.eigvalsh(A)\nprint(\"Eigenvalues:\", eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and diagonal matrix D of A = [[6, 0, 0], [0, 3, 0], [0, 0, 2]].",
        "output": "import numpy as np\nA = np.array([[6, 0, 0], [0, 3, 0], [0, 0, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Given the matrix A = [[3, -2], [-2, 3]], determine if A is diagonalizable and find the diagonal matrix D if it is.",
        "output": "import numpy as np\nA = np.array([[3, -2], [-2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Determine the eigenvalues and diagonal form of A = [[7, 0], [0, -3]].",
        "output": "import numpy as np\nA = np.array([[7, 0], [0, -3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Compute the eigenvalues of the symmetric matrix A = [[5, 1], [1, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 1], [1, 5]])\neigenvalues = np.linalg.eigvalsh(A)\nprint(\"Eigenvalues:\", eigenvalues)"
    },
    {
        "input": "Diagonalize A = [[2, -1], [-1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1], [-1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
    },
    {
        "input": "Find the spectral decomposition of A = [[1, 0], [0, -1]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, -1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspec_decomp = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(len(eigenvalues)))\nprint(\"Spectral decomposition:\\n\", spec_decomp)"
    },
    {
        "input": "Diagonalize the matrix A = [[0, 1], [-1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [-1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of A = [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues = np.linalg.eigvalsh(A)\nprint(\"Eigenvalues:\", eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and diagonal matrix D of A = [[1, 1, 1], [1, 1, 1], [1, 1, 1]].",
        "output": "import numpy as np\nA = np.ones((3, 3))\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the diagonal matrix A = [[7, 0, 0], [0, -2, 0], [0, 0, 5]].",
        "output": "import numpy as np\nA = np.diag([7, -2, 5])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix A = [[2, -2], [-2, 5]].",
        "output": "import numpy as np\nA = np.array([[2, -2], [-2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of A = [[0, 1, 0], [1, 0, 1], [0, 1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix A = [[5, 4], [4, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 4], [4, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Find the eigenvalues of the matrix A = [[1, 2, 1], [6, -1, 0], [-1, -2, -1]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 1], [6, -1, 0], [-1, -2, -1]])\neigenvalues = np.linalg.eigvals(A)\nprint(\"Eigenvalues:\", eigenvalues)"
    },
    {
        "input": "Find the spectral decomposition of A = [[3, 0], [0, 7]].",
        "output": "import numpy as np\nA = np.array([[3, 0], [0, 7]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\ndecomp = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(2))\nprint(\"Spectral decomposition:\\n\", decomp)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of A = [[0, 2], [2, 0]] and confirm diagonalization.",
        "output": "import numpy as np\nA = np.array([[0, 2], [2, 0]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Matrix P:\\n\", P)"
    },
    {
        "input": "Diagonalize A = [[6, -2], [-2, 3]].",
        "output": "import numpy as np\nA = np.array([[6, -2], [-2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Eigenvectors (P):\\n\", eigenvectors)"
    },
    {
        "input": "Find the diagonal form of matrix A = [[2, 2, 1], [2, 3, 1], [1, 1, 1]].",
        "output": "import numpy as np\nA = np.array([[2, 2, 1], [2, 3, 1], [1, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Find the spectral decomposition of A = [[5, 0], [0, -2]].",
        "output": "import numpy as np\nA = np.array([[5, 0], [0, -2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(2))\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of A = [[1, 4], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[1, 4], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
    },
    {
        "input": "Find the diagonal matrix D and P for matrix A = [[3, 1], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Matrix P:\\n\", P)"
    },
    {
        "input": "Compute the eigenvalues of matrix A = [[0, 1, 0], [1, 0, 1], [0, 1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint(\"Eigenvalues:\", eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and diagonalize the matrix A = [[2, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of matrix A = [[0, -1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
    },
    {
        "input": "Diagonalize the matrix A = [[4, 1, 1], [1, 4, 1], [1, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 1], [1, 4, 1], [1, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Eigenvectors (P):\\n\", eigenvectors)"
    },
    {
        "input": "Find the spectral decomposition of the symmetric matrix A = [[6, 2], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[6, 2], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(2))\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Given A = [[0, 2, 2], [2, 0, 2], [2, 2, 0]], find the spectral decomposition of A.",
        "output": "import numpy as np\nA = np.array([[0, 2, 2], [2, 0, 2], [2, 2, 0]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral_decomp = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral_decomp)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of A = [[3, -1, 0], [-1, 3, -1], [0, -1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -1, 0], [-1, 3, -1], [0, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
    },
    {
        "input": "Let A = [[2, 1, 0], [1, 2, 1], [0, 1, 2]]. find the diagonal form of it.",
        "output": "import numpy as np\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of A = [[1, 2, 3], [2, 1, 2], [3, 2, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 1, 2], [3, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
    },
    {
        "input": "For matrix A = [[4, -2, 2], [-2, 4, -2], [2, -2, 4]], find the orthogonal matrix P that diagonalizes A.",
        "output": "import numpy as np\nA = np.array([[4, -2, 2], [-2, 4, -2], [2, -2, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nprint(\"Orthogonal matrix P:\\n\", P)"
    },
    {
        "input": "Compute the Jordan canonical form of A = [[5, 4, 2], [0, 5, 1], [0, 0, 5]] using symbolic computation.",
        "output": "import sympy as sp\nA = sp.Matrix([[5, 4, 2], [0, 5, 1], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan canonical form J:\\n\", J)\nprint(\"Transformation matrix P:\\n\", P)"
    },
    {
        "input": "Let A = [[1, 2, 0], [0, 1, 2], [2, 0, 1]].find the diagonal matrix of it.",
        "output": "import numpy as np\nA = np.array([[1, 2, 0], [0, 1, 2], [2, 0, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nif is_diag:\n    D = np.diag(eigenvalues)\n    print(\"Eigenvalues:\", eigenvalues)\n    print(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Diagonalize A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Eigenvectors P:\\n\", eigenvectors)"
    },
    {
        "input": "Let A be the symmetric matrix [[6, -2, 0], [-2, 3, -1], [0, -1, 1]]. Find its spectral decomposition.",
        "output": "import numpy as np\nA = np.array([[6, -2, 0], [-2, 3, -1], [0, -1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Find an orthonormal basis of eigenvectors for A = [[4, 1, 1], [1, 4, 1], [1, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 1], [1, 4, 1], [1, 1, 4]])\n_, eigenvectors = np.linalg.eigh(A)\nprint(\"Orthonormal basis (eigenvectors):\\n\", eigenvectors)"
    },
    {
        "input": "Compute the spectral decomposition of A = [[1, 0, 0], [0, 2, 1], [0, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[1, 0, 0], [0, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Find the eigenvalues of matrix A = [[2, 2, 1], [2, 3, 2], [1, 2, 2]] and check multiplicity.",
        "output": "import numpy as np\nfrom collections import Counter\nA = np.array([[2, 2, 1], [2, 3, 2], [1, 2, 2]])\neigenvalues = np.linalg.eigvals(A)\nmultiplicities = Counter(np.round(eigenvalues, 6))\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Algebraic multiplicities:\", multiplicities)"
    },
    {
        "input": "Find the diagonal matrix and matrix P such that A = PDP⁻¹, for A = [[6, 2, 0], [2, 3, 1], [0, 1, 1]].",
        "output": "import numpy as np\nA = np.array([[6, 2, 0], [2, 3, 1], [0, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Matrix P:\\n\", P)"
    },
    {
        "input": "Given A = [[0, 1, -1], [1, 0, 1], [-1, 1, 0]], find the spectral decomposition of A.",
        "output": "import numpy as np\nA = np.array([[0, 1, -1], [1, 0, 1], [-1, 1, 0]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral_decomp = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral_decomp)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of A = [[5, -2, 2], [-2, 5, -2], [2, -2, 5]].",
        "output": "import numpy as np\nA = np.array([[5, -2, 2], [-2, 5, -2], [2, -2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
    },
    {
        "input": "Let A = [[3, 1, 0], [1, 3, 1], [0, 1, 3]]. find the diagonal form of it.",
        "output": "import numpy as np\nA = np.array([[3, 1, 0], [1, 3, 1], [0, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of A = [[2, -2, 1], [-2, 2, -2], [1, -2, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -2, 1], [-2, 2, -2], [1, -2, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
    },
    {
        "input": "For matrix A = [[6, -3, 2], [-3, 6, -3], [2, -3, 6]], find the orthogonal matrix P that diagonalizes A.",
        "output": "import numpy as np\nA = np.array([[6, -3, 2], [-3, 6, -3], [2, -3, 6]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nprint(\"Orthogonal matrix P:\\n\", P)"
    },
    {
        "input": "Compute the Jordan canonical form of A = [[4, 3, 0], [0, 4, 1], [0, 0, 4]] using symbolic computation.",
        "output": "import sympy as sp\nA = sp.Matrix([[4, 3, 0], [0, 4, 1], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan canonical form J:\\n\", J)\nprint(\"Transformation matrix P:\\n\", P)"
    },
    {
        "input": "Let A = [[2, 0, 1], [1, 2, 0], [0, 1, 2]].find the diagonal matrix of it.",
        "output": "import numpy as np\nA = np.array([[2, 0, 1], [1, 2, 0], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Find the spectral decomposition of matrix A = [[1, -1, 0], [-1, 2, -1], [0, -1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, -1, 0], [-1, 2, -1], [0, -1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Let A = [[5, 4, 2], [4, 5, 2], [2, 2, 2]].find the diagonal matrix.",
        "output": "import numpy as np\nA = np.array([[5, 4, 2], [4, 5, 2], [2, 2, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Let A = [[4, -1, 1], [-1, 3, -2], [1, -2, 3]]. Find the eigenvalues and an orthogonal matrix P that diagonalizes A.",
        "output": "import numpy as np\nA = np.array([[4, -1, 1], [-1, 3, -2], [1, -2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Orthogonal matrix P:\\n\", P)"
    },
    {
        "input": "Given the matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]], find the diagonal matrix D.",
        "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\", eigenvalues)\nif np.allclose(A, eigenvectors @ D @ eigenvectors.T):\n    print(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Compute the spectral decomposition of A = [[3, 1, 0], [1, 3, 1], [0, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1, 0], [1, 3, 1], [0, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral_decomp = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral_decomp)"
    },
    {
        "input": "Let A = [[0, 1, 1], [1, 0, 1], [1, 1, 0]]. Find the eigenvalues and an orthogonal matrix P that diagonalizes A.",
        "output": "import numpy as np\nA = np.array([[0, 1, 1], [1, 0, 1], [1, 1, 0]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Orthogonal matrix P:\\n\", P)"
    },
    {
        "input": "Compute the spectral decomposition of A = [[5, -2, 2], [-2, 5, -2], [2, -2, 5]].",
        "output": "import numpy as np\nA = np.array([[5, -2, 2], [-2, 5, -2], [2, -2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral_decomp = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral_decomp)"
    },
    {
        "input": "Let A = [[3, -1, 1], [-1, 3, -1], [1, -1, 3]]. Find the eigenvalues and an orthogonal matrix P that diagonalizes A.",
        "output": "import numpy as np\nA = np.array([[3, -1, 1], [-1, 3, -1], [1, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Orthogonal matrix P:\\n\", P)"
    },
    {
        "input": "Let A = [[2, -2, 4], [-2, 5, -2], [4, -2, 2]]. Find the spectral decomposition.",
        "output": "import numpy as np\nA = np.array([[2, -2, 4], [-2, 5, -2], [4, -2, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Diagonalize A = [[5, -2, -1], [-2, 6, -2], [-1, -2, 5]] and print the diagonal matrix.",
        "output": "import numpy as np\nA = np.array([[5, -2, -1], [-2, 6, -2], [-1, -2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Given A = [[0, 2, 2], [2, 0, 2], [2, 2, 0]], find the orthogonal matrix P that diagonalizes A.",
        "output": "import numpy as np\nA = np.array([[0, 2, 2], [2, 0, 2], [2, 2, 0]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nprint(\"Orthogonal matrix P:\\n\", P)"
    },
    {
        "input": "Find the spectral decomposition of A = [[4, 1, 1], [1, 4, 1], [1, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 1], [1, 4, 1], [1, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Given matrix A = [[6, -2, 2], [-2, 3, -1], [2, -1, 3]], find its spectral decomposition.",
        "output": "import numpy as np\nA = np.array([[6, -2, 2], [-2, 3, -1], [2, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Given symmetric matrix A = [[4, 1, -1], [1, 4, 1], [-1, 1, 4]], find spectral decomposition.",
        "output": "import numpy as np\nA = np.array([[4, 1, -1], [1, 4, 1], [-1, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Compute the spectral decomposition of matrix A = [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Find an orthogonal matrix P that diagonalizes A = [[1, 0, 0], [0, 2, 1], [0, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[1, 0, 0], [0, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nprint(\"Orthogonal matrix P:\\n\", P)"
    },
    {
        "input": "Let A = [[2, 1, 1], [1, 2, 1], [1, 1, 2]]. Find the spectral decomposition of A.",
        "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Find eigenvalues and orthogonal diagonalization for A = [[5, 2, 2], [2, 5, 2], [2, 2, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 2, 2], [2, 5, 2], [2, 2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Orthogonal matrix P:\\n\", eigenvectors)\nprint(\"D =\\n\", D)"
    },
    {
        "input": "Diagonalize A = [[3, -2, 4], [-2, 6, 2], [4, 2, 3]] using eigen decomposition.",
        "output": "import numpy as np\nA = np.array([[3, -2, 4], [-2, 6, 2], [4, 2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Let A = [[4, 1, 2], [1, 2, 0], [2, 0, 3]]. Find the spectral decomposition.",
        "output": "import numpy as np\nA = np.array([[4, 1, 2], [1, 2, 0], [2, 0, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\ncomponents = [eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3)]\nspectral = sum(components)\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Given symmetric matrix A = [[4, -2, 0], [-2, 4, -2], [0, -2, 4]], diagonalize it using orthogonal matrices.",
        "output": "import numpy as np\nA = np.array([[4, -2, 0], [-2, 4, -2], [0, -2, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint(\"Orthogonal matrix P:\\n\", P)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Find eigenvalues and perform spectral decomposition of A = [[5, 3, 1], [3, 5, 3], [1, 3, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 3, 1], [3, 5, 3], [1, 3, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Compute spectral decomposition of symmetric matrix A = [[3, 1, 1], [1, 3, 1], [1, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1, 1], [1, 3, 1], [1, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Diagonalize the symmetric matrix A = [[7, 4, 1], [4, 6, 2], [1, 2, 5]] using orthogonal transformation.",
        "output": "import numpy as np\nA = np.array([[7, 4, 1], [4, 6, 2], [1, 2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Orthogonal matrix P:\\n\", eigenvectors)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Find the spectral decomposition of matrix A = [[1, 1, 1], [1, 1, 1], [1, 1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, 1, 1], [1, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\ncomponents = [eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3)]\nspectral = sum(components)\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Diagonalize symmetric matrix A = [[6, 2, 1], [2, 5, 2], [1, 2, 4]] using eigen decomposition.",
        "output": "import numpy as np\nA = np.array([[6, 2, 1], [2, 5, 2], [1, 2, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Perform spectral decomposition of A = [[9, 4, 2], [4, 9, 4], [2, 4, 9]].",
        "output": "import numpy as np\nA = np.array([[9, 4, 2], [4, 9, 4], [2, 4, 9]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Find the eigenvalues and diagonalize A = [[4, 1, -2], [1, 2, 1], [-2, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[4, 1, -2], [1, 2, 1], [-2, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Diagonalize the symmetric matrix A = [[7, -3, 1], [-3, 5, 2], [1, 2, 6]] using orthogonal matrix.",
        "output": "import numpy as np\nA = np.array([[7, -3, 1], [-3, 5, 2], [1, 2, 6]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Orthogonal matrix P:\\n\", eigenvectors)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Compute the spectral decomposition of A = [[8, 1, -1], [1, 6, 2], [-1, 2, 5]].",
        "output": "import numpy as np\nA = np.array([[8, 1, -1], [1, 6, 2], [-1, 2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
    },
    {
        "input": "Find eigenvalues and eigenvectors of symmetric matrix A = [[3, -1, -1], [-1, 3, -1], [-1, -1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -1, -1], [-1, 3, -1], [-1, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint(\"Eigenvalues:\\n\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and diagonalize A = [[5, -2, 2], [-2, 5, -2], [2, -2, 5]].",
        "output": "import numpy as np\nA = np.array([[5, -2, 2], [-2, 5, -2], [2, -2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Diagonalize the symmetric matrix A = [[6, 2, -2], [2, 3, 1], [-2, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[6, 2, -2], [2, 3, 1], [-2, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Orthogonal matrix P:\\n\", eigenvectors)"
    },
    {
        "input": "Compute eigenvalues and diagonalize A = [[5, 2, 0], [2, 3, 1], [0, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[5, 2, 0], [2, 3, 1], [0, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\\n\", eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Diagonalize the matrix A = [[2, 1, 1], [1, 2, 1], [1, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Diagonalize the matrix A = [[3, 0, 0], [0, 4, 1], [0, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[3, 0, 0], [0, 4, 1], [0, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Diagonalize symmetric matrix A = [[10, -3, 0], [-3, 10, -3], [0, -3, 10]].",
        "output": "import numpy as np\nA = np.array([[10, -3, 0], [-3, 10, -3], [0, -3, 10]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Diagonalize the symmetric matrix A = [[5, 2, 2], [2, 5, 2], [2, 2, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 2, 2], [2, 5, 2], [2, 2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Diagonalize A = [[2, 0, 1], [0, 3, 0], [1, 0, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 0, 1], [0, 3, 0], [1, 0, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\\n\", eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Given matrix A = [[2, 2], [0, 2]], find a basis of generalized eigenvectors.",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 2], [0, 2]])\ngevecs = A.jordan_form(calc_transform=True)[1]\nprint(\"Generalized eigenvectors basis (columns of P):\\n\", gevecs)"
    },
    {
        "input": "Find the matrix exponential of a diagonalizable matrix A = [[2, 0], [0, 3]] using its diagonal form.",
        "output": "import numpy as np\nfrom scipy.linalg import expm\nA = np.array([[2, 0], [0, 3]])\nexpA = expm(A)\nprint(\"Matrix exponential of A:\\n\", expA)"
    },
    {
        "input": "Find a matrix whose minimal polynomial has higher degree than its characteristic polynomial.",
        "output": "import sympy as sp\nA = sp.Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nchar_poly = A.charpoly().as_expr()\nk = 1\npower = A\nwhile not power.equals(sp.zeros(*A.shape)):\n    k += 1\n    power = A**k\nprint(\"Characteristic polynomial:\", char_poly)\nprint(f\"Minimal polynomial: x^{k}\")"
    },
    {
        "input": "Create a matrix with complex eigenvalues and demonstrate diagonalization over ℂ using sympy.",
        "output": "import sympy as sp\nA = sp.ImmutableMatrix([[0, -1], [1, 0]])\neigenvals = A.eigenvals()\nD, P = A.diagonalize()\nprint(\"Eigenvalues:\", eigenvals)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Transformation matrix P:\\n\", P)"
    },
    {
        "input": "Create a defective matrix and show that its geometric multiplicity is less than algebraic multiplicity.",
        "output": "import sympy as sp\nA = sp.Matrix([[3, 1], [0, 3]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Eigenvectors:\\n\", A.eigenvects())"
    },
    {
        "input": "Construct a real matrix with complex eigenvalues but with a real minimal polynomial.",
        "output": "import sympy as sp\nA = sp.Matrix([[0, -1], [1, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())\nA2 = A**2\nif A2 == -sp.eye(2):\n    print(\"Minimal polynomial: x^2 + 1\")\nelse:\n    print(\"Minimal polynomial is of higher degree\")"
    },
    {
        "input": "Given A = [[2, 1], [0, 2]], compute its exponential using Jordan form.",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 1], [0, 2]])\nJ, P = A.jordan_form()\nexpJ = (J * sp.Symbol('t')).exp()\nexpA = P * expJ * P.inv()\nprint(\"Matrix exponential e^(At):\\n\", expA)"
    },
    {
        "input": "Create a 2x2 matrix with real entries that has complex eigenvalues, and diagonalize it over ℂ.",
        "output": "import sympy as sp\nA = sp.ImmutableMatrix([[0, -2], [2, 0]])\neigenvals = A.eigenvals()\nD, P = A.diagonalize()\nprint(\"Eigenvalues:\", eigenvals)\nprint(\"Diagonal form over ℂ:\\n\", D)\nprint(\"Transformation matrix:\\n\", P)"
    },
    {
        "input": "Let A be a matrix such that A^2 = I but A ≠ I. Construct such a matrix and verify its eigenvalues.",
        "output": "import sympy as sp\nA = sp.Matrix([[0, 1], [1, 0]])\nprint(\"A^2:\", A**2)\nprint(\"Eigenvalues:\", A.eigenvals())"
    },
    {
        "input": "Construct a non-symmetric matrix with real eigenvalues and diagonalize it.",
        "output": "import sympy as sp\nA = sp.Matrix([[3, 2], [0, 1]])\nD, P = A.diagonalize()\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Transformation matrix P:\\n\", P)"
    },
    {
        "input": "Let A = [[0, 2], [-2, 0]]. Show that the eigenvalues are purely imaginary and it’s diagonalizable over ℂ.",
        "output": "import sympy as sp\nA = sp.ImmutableMatrix([[0, 2], [-2, 0]])\neigenvals = A.eigenvals()\nD, P = A.diagonalize()\nprint(\"Eigenvalues:\", eigenvals)\nprint(\"Diagonal matrix D:\\n\", D)"
    },
    {
        "input": "Given A = [[4, 1], [0, 4]], verify that it's not diagonalizable and compute its exponential using Jordan form.",
        "output": "import sympy as sp\nt = sp.Symbol('t')\nA = sp.Matrix([[4, 1], [0, 4]])\nJ, P = A.jordan_form()\nexpJ = (J * t).exp()\nexpA = P * expJ * P.inv()\nprint(\"e^(At):\\n\", expA)"
    },
    {
        "input": "Let A = [[1, 2], [-2, 1]]. Show it's a rotation matrix and verify complex eigenvalues.",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 2], [-2, 1]])\nprint(\"Determinant:\", A.det())\nprint(\"Eigenvalues:\", A.eigenvals())"
    },
    {
        "input": "Let A be a real matrix with complex eigenvalues. Compute its real Jordan form.",
        "output": "import sympy as sp\nA = sp.Matrix([[0, -1], [1, 0]])\nJ, P = A.jordan_form()\nprint(\"Real Jordan form:\\n\", J)"
    },
    {
        "input": "Construct a 3x3 real matrix with a complex conjugate pair of eigenvalues and one real eigenvalue.",
        "output": "import sympy as sp\nA = sp.Matrix([[1, -1, 0], [1, 1, 0], [0, 0, 2]])\nprint(\"Eigenvalues:\", A.eigenvals())"
    },
    {
        "input": "Construct a matrix with minimal polynomial (x-2)^2 and characteristic polynomial (x-2)^3.",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 1, 0], [0, 2, 1], [0, 0, 2]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\nI = sp.eye(3)\nB = A - 2 * I\nprint(\"(A - 2I)^1 =\\n\", B)\nprint(\"(A - 2I)^2 =\\n\", B**2)\nprint(\"(A - 2I)^3 =\\n\", B**3)\nprint(\"Minimal polynomial: (x - 2)^3\")"
    },
    {
        "input": "Create a 2x2 orthogonal matrix with determinant -1 and find its eigenvalues.",
        "output": "import sympy as sp\nA = sp.Matrix([[0, 1], [1, 0]])\nprint(\"Determinant:\", A.det())\nprint(\"Eigenvalues:\", A.eigenvals())"
    },
    {
        "input": "Find a matrix whose minimal polynomial equals its characteristic polynomial and diagonalize it.",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 0], [0, 2]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\nprint(\"Minimal polynomial:\", char_poly)\nP, D = A.diagonalize()\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Transformation matrix P:\\n\", P)"
    },
    {
        "input": "Let A = [[3, 2], [2, 3]]. Find orthonormal eigenvectors.",
        "output": "import sympy as sp\nA = sp.Matrix([[3, 2], [2, 3]])\nQ, D = A.diagonalize()\nprint(\"Eigenvectors matrix Q:\\n\", Q)"
    },
    {
        "input": "Construct a matrix A such that A^2 = I but A is not equal to I, and diagonalize it.",
        "output": "import sympy as sp\nA = sp.Matrix([[0, 1], [1, 0]])\nD, P = A.diagonalize()\nprint(\"Diagonal form:\\n\", D)"
    },
    {
        "input": "Let A = [[1, 1], [0, 1]]. Find its minimal polynomial and show that it is not diagonalizable.",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 1], [0, 1]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\nI = sp.eye(2)\nM = A - I\nprint(\"(A - I)^2:\\n\", (M @ M))\nprint(\"Minimal polynomial is (x - 1)^2\")"
    },
    {
        "input": "Construct a symmetric matrix and find its eigenvectors forming an orthonormal basis.",
        "output": "import sympy as sp\nA = sp.Matrix([[2, -1], [-1, 2]])\nQ, D = A.diagonalize()\nprint(\"Eigenvectors matrix Q:\\n\", Q)"
    },
    {
        "input": "Construct a non-zero nilpotent matrix and find its minimal polynomial.",
        "output": "import sympy as sp\nA = sp.Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nprint(\"Minimal polynomial is x^3\")"
    },
    {
        "input": "Create a 3x3 matrix with a 2-dimensional eigenspace for a repeated eigenvalue.",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 0, 0], [0, 2, 0], [0, 0, 3]])\nprint(\"Eigenvectors:\", A.eigenvects())"
    },
    {
        "input": "Construct a symmetric matrix with distinct eigenvalues and orthogonally diagonalize it.",
        "output": "import sympy as sp\nA = sp.Matrix([[3, 1], [1, 2]])\nQ, D = A.diagonalize()\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Eigenvector matrix Q:\\n\", Q)"
    },
    {
        "input": "Let A = [[1, 2], [0, 1]]. Find the minimal polynomial and Jordan form.",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 2], [0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)\nprint(\"Minimal polynomial is (x - 1)^2\")"
    },
    {
        "input": "Construct a matrix with all zero eigenvalues but not the zero matrix.",
        "output": "import sympy as sp\nA = sp.Matrix([[0, 1], [0, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())"
    },
    {
        "input": "Diagonalize a 3x3 matrix with distinct eigenvalues.",
        "output": "import sympy as sp\nA = sp.Matrix([[4, 0, 0], [0, 5, 0], [0, 0, 6]])\nP, D = A.diagonalize()\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Transformation matrix P:\\n\", P)"
    },
    {
        "input": "Let A = [[2, 1, 0], [0, 2, 0], [0, 0, 3]]. Find its eigenvalues and Jordan form.",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 1, 0], [0, 2, 0], [0, 0, 3]])\nprint(\"Eigenvalues:\", A.eigenvals())\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)"
    },
    {
        "input": "Construct a 3x3 matrix with two Jordan blocks for the same eigenvalue.",
        "output": "import sympy as sp\nA = sp.Matrix([[5, 1, 0], [0, 5, 0], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)"
    },
    {
        "input": "Find the minimal polynomial of a matrix A = [[2, 1, 0], [0, 2, 1], [0, 0, 2]].",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 1, 0], [0, 2, 1], [0, 0, 2]])\nx = sp.symbols('x')\nchar_poly = A.charpoly(x)\nprint(\"Characteristic polynomial:\", char_poly.as_expr())\nprint(\"Minimal polynomial is (x - 2)^3\")"
    },
    {
        "input": "Diagonalize the matrix A = [[1, 1], [0, 2]].",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 1], [0, 2]])\nP, D = A.diagonalize()\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Transformation matrix P:\\n\", P)"
    },
    {
        "input": "Let A = [[1, 1, 0], [0, 1, 0], [0, 0, 2]]. Find its eigenvalues and Jordan form.",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 1, 0], [0, 1, 0], [0, 0, 2]])\nprint(\"Eigenvalues:\", A.eigenvals())\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)"
    },
    {
        "input": "Construct a matrix with real entries and complex eigenvalues.",
        "output": "import sympy as sp\nA = sp.Matrix([[0, -3], [3, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())"
    },
    {
        "input": "Let A = [[0, 1], [-1, 0]]. Find its eigenvalues and show it is unitary.",
        "output": "import sympy as sp\nA = sp.Matrix([[0, 1], [-1, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())"
    },
    {
        "input": "Construct a nilpotent matrix of order 3 and find its minimal polynomial.",
        "output": "import sympy as sp\nA = sp.Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nprint(\"Minimal polynomial is x^3\")"
    },
    {
        "input": "Diagonalize a 3x3 matrix with repeated eigenvalues and independent eigenvectors.",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 0, 0], [0, 2, 0], [0, 0, 3]])\nP, D = A.diagonalize()\nprint(\"D:\\n\", D)"
    },
    {
        "input": "Find a 2x2 matrix with minimal polynomial different from its characteristic polynomial.",
        "output": "import sympy as sp\nA = sp.Matrix([[4, 1], [0, 4]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\nprint(\"Minimal polynomial is (x - 4)^2\")"
    },
    {
        "input": "Find a matrix with eigenvalues 1, 1, 1 but only one linearly independent eigenvector.",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 1, 0], [0, 1, 1], [0, 0, 1]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Eigenvectors:\", A.eigenvects())"
    },
    {
        "input": "Let A = [[1, 2], [2, 1]]. Compute eigenvalues.",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 2], [2, 1]])\nprint(\"Eigenvalues:\", A.eigenvals())"
    },
    {
        "input": "Find the Jordan form of A = [[6, 1, 0], [0, 6, 1], [0, 0, 6]].",
        "output": "import sympy as sp\nA = sp.ImmutableMatrix([[6, 1, 0], [0, 6, 1], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)\nprint(\"Transformation matrix P:\\n\", P)"
    },
    {
        "input": "Create a 3x3 matrix with one eigenvalue and three linearly independent eigenvectors.",
        "output": "import sympy as sp\nA = sp.eye(3) * 4\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Eigenvectors:\", A.eigenvects())"
    },
    {
        "input": "Construct a matrix whose characteristic and minimal polynomials are equal.",
        "output": "import sympy as sp\nA = sp.Matrix([[3, 0], [0, 4]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\nprint(\"Minimal polynomial:\", char_poly)"
    },
    {
        "input": "Let A = [[1, 1], [0, 1]]. Show its minimal polynomial is different from characteristic.",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 1], [0, 1]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\nmin_poly = (sp.Symbol('x') - 1)**2\nprint(\"Minimal polynomial:\", min_poly)"
    },
    {
        "input": "Let A = [[2, 1, 0], [0, 2, 0], [0, 0, 3]]. Compute the Jordan canonical form.",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 1, 0], [0, 2, 0], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)"
    },
    {
        "input": "Find a matrix with algebraic multiplicity 3 and geometric multiplicity 1 for its eigenvalue.",
        "output": "import sympy as sp\nA = sp.Matrix([[5, 1, 0], [0, 5, 1], [0, 0, 5]])\nprint(\"Eigenvectors:\", A.eigenvects())"
    },
    {
        "input": "Let A = [[2, 1], [0, 2]]. Find the characteristic and minimal polynomials.",
        "output": "import sympy as sp\nA = sp.Matrix([[2, 1], [0, 2]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\nx = sp.Symbol('x')\nmin_poly = (x - 2)**2\nprint(\"Minimal polynomial:\", min_poly)"
    },
    {
        "input": "Let A = [[3, 0], [0, 5]]. Show that minimal polynomial equals characteristic polynomial.",
        "output": "import sympy as sp\nA = sp.Matrix([[3, 0], [0, 5]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\nx = sp.Symbol('x')\nmin_poly = (x - 3)*(x - 5)\nprint(\"Minimal polynomial:\", min_poly)"
    },
    {
        "input": "Let A = [[0, 1], [-1, 0]]. Find the characteristic and minimal polynomials.",
        "output": "import sympy as sp\nA = sp.Matrix([[0, 1], [-1, 0]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\nx = sp.Symbol('x')\nmin_poly = x**2 + 1\nprint(\"Minimal polynomial:\", min_poly)"
    },
    {
        "input": "Let A = [[0, 1, 0], [0, 0, 1], [0, 0, 0]]. Find its minimal polynomial.",
        "output": "import sympy as sp\nA = sp.Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nx = sp.Symbol('x')\nmin_poly = x**3\nprint(\"Minimal polynomial:\", min_poly)"
    },
    {
        "input": "Let A = [[5, 0], [0, 5]]. Find characteristic and minimal polynomials.",
        "output": "import sympy as sp\nA = sp.Matrix([[5, 0], [0, 5]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\nx = sp.Symbol('x')\nmin_poly = (x - 5)\nprint(\"Minimal polynomial:\", min_poly)"
    },
    {
        "input": "Find the eigenvalues, eigenvectors, and the Jordan canonical form of A = [[5, 4, 2], [0, 5, 2], [0, 0, 5]].",
        "output": "import sympy as sp\nA = sp.Matrix([[5, 4, 2], [0, 5, 2], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)\nprint(\"Transformation matrix:\\n\", P)"
    },
    {
        "input": "Construct a 3x3 real matrix with repeated eigenvalues but not diagonalizable. Find its Jordan form.",
        "output": "import sympy as sp\nA = sp.Matrix([[4, 1, 0], [0, 4, 1], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Matrix A:\\n\", A)\nprint(\"Jordan form:\\n\", J)\nprint(\"P (Jordan basis):\\n\", P)"
    },
    {
        "input": "Given vectors u = [3, 4] and v = [1, 2], compute the orthogonal projection of v onto u.",
        "output": "import numpy as np\nu = np.array([3, 4])\nv = np.array([1, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the orthogonal projection of vector v = [2, -1, 3] onto vector u = [1, 0, 0].",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([2, -1, 3])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the orthogonal projection of vector v = [4, 1] onto vector u = [0, 2].",
        "output": "import numpy as np\nu = np.array([0, 2])\nv = np.array([4, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the orthogonal projection of vector v = [1, 2, 2] onto vector u = [2, 1, 1].",
        "output": "import numpy as np\nu = np.array([2, 1, 1])\nv = np.array([1, 2, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the orthogonal projection of vector v = [0, 3, 4] onto vector u = [1, 0, 0].",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([0, 3, 4])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the orthogonal projection of vector v = [2, 2, 2] onto vector u = [1, 1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1, 1])\nv = np.array([2, 2, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the orthogonal projection of vector v = [5, 0, 0] onto vector u = [0, 5, 0].",
        "output": "import numpy as np\nu = np.array([0, 5, 0])\nv = np.array([5, 0, 0])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of vector v = [6, 2] onto vector u = [1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([6, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [1, 0] onto u = [0, 1].",
        "output": "import numpy as np\nu = np.array([0, 1])\nv = np.array([1, 0])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [2, 2, 1] onto u = [1, 0, 0].",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([2, 2, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Calculate the projection of v = [4, 4, 4] onto u = [0, 1, 0].",
        "output": "import numpy as np\nu = np.array([0, 1, 0])\nv = np.array([4, 4, 4])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "What is the projection of v = [1, -1] onto u = [1, 1]?",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([1, -1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [0, 1, 1] onto u = [0, 1, 0].",
        "output": "import numpy as np\nu = np.array([0, 1, 0])\nv = np.array([0, 1, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [5, 5] onto u = [1, 0].",
        "output": "import numpy as np\nu = np.array([1, 0])\nv = np.array([5, 5])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [2, 3] onto u = [2, 0].",
        "output": "import numpy as np\nu = np.array([2, 0])\nv = np.array([2, 3])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project vector v = [1, 1, 0] onto vector u = [1, 0, 0].",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([1, 1, 0])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [0, 0, 1] onto u = [0, 1, 1].",
        "output": "import numpy as np\nu = np.array([0, 1, 1])\nv = np.array([0, 0, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "What is the projection of v = [1, 2, 1] onto u = [1, 1, 1]?",
        "output": "import numpy as np\nu = np.array([1, 1, 1])\nv = np.array([1, 2, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [0, 1, 0] onto u = [0, 0, 1].",
        "output": "import numpy as np\nu = np.array([0, 0, 1])\nv = np.array([0, 1, 0])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [1, 3] onto u = [3, 1].",
        "output": "import numpy as np\nu = np.array([3, 1])\nv = np.array([1, 3])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [1, 2, 3] onto u = [0, 1, 0].",
        "output": "import numpy as np\nu = np.array([0, 1, 0])\nv = np.array([1, 2, 3])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of vector v = [7, 1] onto vector u = [1, 2].",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([7, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [0, -3] onto u = [2, 0].",
        "output": "import numpy as np\nu = np.array([2, 0])\nv = np.array([0, -3])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [3, 3, 0] onto u = [1, -1, 0].",
        "output": "import numpy as np\nu = np.array([1, -1, 0])\nv = np.array([3, 3, 0])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [5, 1] onto u = [1, -2].",
        "output": "import numpy as np\nu = np.array([1, -2])\nv = np.array([5, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [-1, 2] onto u = [1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([-1, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "What is the projection of vector v = [4, 0, 3] onto u = [0, 0, 1]?",
        "output": "import numpy as np\nu = np.array([0, 0, 1])\nv = np.array([4, 0, 3])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [1, 2, 3] onto u = [2, 2, 2].",
        "output": "import numpy as np\nu = np.array([2, 2, 2])\nv = np.array([1, 2, 3])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [2, 0, 2] onto u = [0, 1, 0].",
        "output": "import numpy as np\nu = np.array([0, 1, 0])\nv = np.array([2, 0, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [-2, 4] onto u = [2, 1].",
        "output": "import numpy as np\nu = np.array([2, 1])\nv = np.array([-2, 4])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project vector v = [3, 3, 3] onto vector u = [0, 1, -1].",
        "output": "import numpy as np\nu = np.array([0, 1, -1])\nv = np.array([3, 3, 3])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [1, 2] onto u = [2, 2].",
        "output": "import numpy as np\nu = np.array([2, 2])\nv = np.array([1, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [6, -1] onto u = [1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([6, -1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of vector v = [2, 1] onto u = [1, 0].",
        "output": "import numpy as np\nu = np.array([1, 0])\nv = np.array([2, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of vector v = [0, 2] onto vector u = [1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([0, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [3, 0, 4] onto u = [0, 0, 1].",
        "output": "import numpy as np\nu = np.array([0, 0, 1])\nv = np.array([3, 0, 4])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [5, 5, 0] onto u = [1, -1, 0].",
        "output": "import numpy as np\nu = np.array([1, -1, 0])\nv = np.array([5, 5, 0])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [1, 1] onto u = [2, 2].",
        "output": "import numpy as np\nu = np.array([2, 2])\nv = np.array([1, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [0, 1, 1] onto u = [1, 0, 0].",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([0, 1, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [1, -1] onto u = [2, 1].",
        "output": "import numpy as np\nu = np.array([2, 1])\nv = np.array([1, -1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of vector v = [3, 2, 1] onto vector u = [1, 0, 0].",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([3, 2, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [0, 1, -1] onto u = [0, 1, 1].",
        "output": "import numpy as np\nu = np.array([0, 1, 1])\nv = np.array([0, 1, -1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [2, 2] onto u = [1, -1].",
        "output": "import numpy as np\nu = np.array([1, -1])\nv = np.array([2, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [1, 3] onto u = [0, 1].",
        "output": "import numpy as np\nu = np.array([0, 1])\nv = np.array([1, 3])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [5, -2] onto u = [1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([5, -2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [2, 1, 0] onto u = [1, 2, 0].",
        "output": "import numpy as np\nu = np.array([1, 2, 0])\nv = np.array([2, 1, 0])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [6, 2] onto u = [3, 1].",
        "output": "import numpy as np\nu = np.array([3, 1])\nv = np.array([6, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of vector v = [1, 1, 1] onto u = [1, 0, 0].",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([1, 1, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project vector v = [4, -2] onto u = [2, 1].",
        "output": "import numpy as np\nu = np.array([2, 1])\nv = np.array([4, -2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [0, 4] onto u = [1, 2].",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([0, 4])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of vector v = [5, 0, -5] onto u = [0, 0, 1].",
        "output": "import numpy as np\nu = np.array([0, 0, 1])\nv = np.array([5, 0, -5])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [1, 3] onto u = [1, 0].",
        "output": "import numpy as np\nu = np.array([1, 0])\nv = np.array([1, 3])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [3, 3] onto u = [1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([3, 3])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [7, 1, 2] onto u = [1, 0, 0].",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([7, 1, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [-2, 5] onto u = [1, 2].",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([-2, 5])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [0, 0, 6] onto u = [0, 0, 2].",
        "output": "import numpy as np\nu = np.array([0, 0, 2])\nv = np.array([0, 0, 6])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [3, 6] onto u = [3, 0].",
        "output": "import numpy as np\nu = np.array([3, 0])\nv = np.array([3, 6])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [1, 0, 2] onto u = [0, 1, 0].",
        "output": "import numpy as np\nu = np.array([0, 1, 0])\nv = np.array([1, 0, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [5, -1] onto u = [2, 2].",
        "output": "import numpy as np\nu = np.array([2, 2])\nv = np.array([5, -1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project vector v = [4, 4, 4] onto vector u = [1, 0, -1].",
        "output": "import numpy as np\nu = np.array([1, 0, -1])\nv = np.array([4, 4, 4])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [2, -2] onto u = [1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([2, -2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project vector v = [3, 1, 0] onto u = [1, 2, 2].",
        "output": "import numpy as np\nu = np.array([1, 2, 2])\nv = np.array([3, 1, 0])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [0, 5] onto u = [2, 0].",
        "output": "import numpy as np\nu = np.array([2, 0])\nv = np.array([0, 5])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of vector v = [7, 4] onto u = [1, -1].",
        "output": "import numpy as np\nu = np.array([1, -1])\nv = np.array([7, 4])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [1, 2, 3] onto u = [3, 2, 1].",
        "output": "import numpy as np\nu = np.array([3, 2, 1])\nv = np.array([1, 2, 3])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [1, 4] onto u = [2, 1].",
        "output": "import numpy as np\nu = np.array([2, 1])\nv = np.array([1, 4])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project vector v = [0, 2, 2] onto u = [0, 1, -1].",
        "output": "import numpy as np\nu = np.array([0, 1, -1])\nv = np.array([0, 2, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [5, 0, 0] onto u = [1, 1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1, 1])\nv = np.array([5, 0, 0])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [-1, -1] onto u = [1, -1].",
        "output": "import numpy as np\nu = np.array([1, -1])\nv = np.array([-1, -1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [2, 1] onto u = [0, 1].",
        "output": "import numpy as np\nu = np.array([0, 1])\nv = np.array([2, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [3, 6, 9] onto u = [1, 1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1, 1])\nv = np.array([3, 6, 9])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [0, 0, 5] onto u = [1, 1, 0].",
        "output": "import numpy as np\nu = np.array([1, 1, 0])\nv = np.array([0, 0, 5])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [1, 2] onto u = [2, 0].",
        "output": "import numpy as np\nu = np.array([2, 0])\nv = np.array([1, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [4, 5, 6] onto u = [1, 0, 1].",
        "output": "import numpy as np\nu = np.array([1, 0, 1])\nv = np.array([4, 5, 6])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [6, -3] onto u = [1, 2].",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([6, -3])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [8, 4] onto u = [2, 1].",
        "output": "import numpy as np\nu = np.array([2, 1])\nv = np.array([8, 4])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project vector v = [3, 5] onto u = [1, 0].",
        "output": "import numpy as np\nu = np.array([1, 0])\nv = np.array([3, 5])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [0, 1] onto u = [1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([0, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [1, 2, 3] onto u = [1, 1, 0].",
        "output": "import numpy as np\nu = np.array([1, 1, 0])\nv = np.array([1, 2, 3])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [-1, -2] onto u = [0, 1].",
        "output": "import numpy as np\nu = np.array([0, 1])\nv = np.array([-1, -2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [3, 3] onto u = [2, 0].",
        "output": "import numpy as np\nu = np.array([2, 0])\nv = np.array([3, 3])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [6, 2, 0] onto u = [0, 1, 1].",
        "output": "import numpy as np\nu = np.array([0, 1, 1])\nv = np.array([6, 2, 0])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [1, 1, 0] onto u = [1, -1, 0].",
        "output": "import numpy as np\nu = np.array([1, -1, 0])\nv = np.array([1, 1, 0])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [5, 2] onto u = [1, -1].",
        "output": "import numpy as np\nu = np.array([1, -1])\nv = np.array([5, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [2, 0, 2] onto u = [1, 1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1, 1])\nv = np.array([2, 0, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [3, 0, 0] onto u = [0, 1, 0].",
        "output": "import numpy as np\nu = np.array([0, 1, 0])\nv = np.array([3, 0, 0])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [7, 8] onto u = [1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([7, 8])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the projection of v = [1, 2, 3] onto u = [0, 0, 1].",
        "output": "import numpy as np\nu = np.array([0, 0, 1])\nv = np.array([1, 2, 3])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Project v = [1, 2] onto u = [1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([1, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [4, -4] onto u = [1, 2].",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([4, -4])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the projection of v = [2, 3] onto u = [1, 0].",
        "output": "import numpy as np\nu = np.array([1, 0])\nv = np.array([2, 3])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find a vector orthogonal to [1, 2] in R².",
        "output": "import numpy as np\nv = np.array([1, 2])\northogonal = np.array([-2, 1])\nprint(orthogonal)"
    },
    {
        "input": "Compute the component of v = [4, 5] orthogonal to u = [1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([4, 5])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\northogonal_component = v - proj\nprint(orthogonal_component)"
    },
    {
        "input": "Given matrix A = [[1, 0], [1, 1]], project b = [2, 3] onto the column space of A.",
        "output": "import numpy as np\nA = np.array([[1, 0], [1, 1]])\nb = np.array([2, 3])\nproj = A @ np.linalg.inv(A.T @ A) @ A.T @ b\nprint(proj)"
    },
    {
        "input": "Find a unit vector orthogonal to [2, 1] in R².",
        "output": "import numpy as np\nv = np.array([2, 1])\north = np.array([-1, 2])\nunit_orth = orth / np.linalg.norm(orth)\nprint(unit_orth)"
    },
    {
        "input": "Project [0, 3, 4] onto [0, 0, 1].",
        "output": "import numpy as np\nu = np.array([0, 0, 1])\nv = np.array([0, 3, 4])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the orthogonal component of v = [5, 6] relative to u = [1, 0].",
        "output": "import numpy as np\nu = np.array([1, 0])\nv = np.array([5, 6])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Find the projection of v = [5, 0] onto u = [1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([5, 0])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Project v = [2, 3, 0] onto u = [1, 0, 0].",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([2, 3, 0])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find a unit vector orthogonal to [3, 4] in R².",
        "output": "import numpy as np\nv = np.array([3, 4])\north = np.array([-4, 3])\nunit_orth = orth / np.linalg.norm(orth)\nprint(unit_orth)"
    },
    {
        "input": "Compute the orthogonal component of v = [6, 2] to u = [0, 1].",
        "output": "import numpy as np\nu = np.array([0, 1])\nv = np.array([6, 2])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Project [4, 5, 6] onto [1, 1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1, 1])\nv = np.array([4, 5, 6])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Compute the projection of v = [7, 2] onto u = [0, 1].",
        "output": "import numpy as np\nu = np.array([0, 1])\nv = np.array([7, 2])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Compute the projection of [1, 2, 2] onto the unit vector [0, 0, 1].",
        "output": "import numpy as np\nu = np.array([0, 0, 1])\nv = np.array([1, 2, 2])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Start Gram-Schmidt on vectors [1, 0] and [1, 1] — return first orthonormal vector.",
        "output": "import numpy as np\na = np.array([1, 0])\ne1 = a / np.linalg.norm(a)\nprint(e1)"
    },
    {
        "input": "Find a vector orthogonal to [1, 3] in R².",
        "output": "import numpy as np\nv = np.array([1, 3])\north = np.array([-3, 1])\nprint(orth)"
    },
    {
        "input": "Compute the projection of [0, 4] onto [1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([0, 4])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Project vector v = [4, 0] onto u = [1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([4, 0])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find a vector orthogonal to [5, 12] in R².",
        "output": "import numpy as np\nv = np.array([5, 12])\north = np.array([-12, 5])\nprint(orth)"
    },
    {
        "input": "Find the component of [6, 8] orthogonal to [1, 0].",
        "output": "import numpy as np\nu = np.array([1, 0])\nv = np.array([6, 8])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Project [7, 7] onto [1, -1].",
        "output": "import numpy as np\nu = np.array([1, -1])\nv = np.array([7, 7])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the orthogonal decomposition of v = [4, 3] relative to u = [1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1])\nv = np.array([4, 3])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint(\"Parallel:\", proj)\nprint(\"Orthogonal:\", orth)"
    },
    {
        "input": "Compute the projection of [1, 1, 1] onto the x-axis.",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([1, 1, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Compute the unit vector orthogonal to [4, 3].",
        "output": "import numpy as np\nv = np.array([4, 3])\north = np.array([-3, 4])\nunit = orth / np.linalg.norm(orth)\nprint(unit)"
    },
    {
        "input": "Project [0, 1] onto [1, 2].",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([0, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the projection of [3, 3, 0] onto [1, 1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1, 1])\nv = np.array([3, 3, 0])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Project [2, -2] onto [1, 0].",
        "output": "import numpy as np\nu = np.array([1, 0])\nv = np.array([2, -2])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find a unit vector orthogonal to [2, -1] in R².",
        "output": "import numpy as np\nv = np.array([2, -1])\north = np.array([1, 2])\nunit = orth / np.linalg.norm(orth)\nprint(unit)"
    },
    {
        "input": "Project [1, 4] onto [0, 1].",
        "output": "import numpy as np\nu = np.array([0, 1])\nv = np.array([1, 4])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Compute the projection of [5, 5, 0] onto [1, 1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1, 1])\nv = np.array([5, 5, 0])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find a vector in R² orthogonal to [7, -4].",
        "output": "import numpy as np\nv = np.array([7, -4])\north = np.array([4, 7])\nprint(orth)"
    },
    {
        "input": "Project [0, 0, 1] onto [1, 1, 1].",
        "output": "import numpy as np\nu = np.array([1, 1, 1])\nv = np.array([0, 0, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the unit projection of [3, 4] onto [0, 1].",
        "output": "import numpy as np\nu = np.array([0, 1])\nv = np.array([3, 4])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nunit_proj = proj / np.linalg.norm(proj)\nprint(unit_proj)"
    },
    {
        "input": "Project [1, 2, 3] onto the y-axis.",
        "output": "import numpy as np\nu = np.array([0, 1, 0])\nv = np.array([1, 2, 3])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Given vectors [1, 1, 0] and [1, 0, 1], apply the Gram-Schmidt process and return the orthonormal set.",
        "output": "import numpy as np\nv1 = np.array([1, 1, 0], dtype=float)\nv2 = np.array([1, 0, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Compute the projection matrix that projects onto the line spanned by u = [2, 3].",
        "output": "import numpy as np\nu = np.array([2, 3])\nP = np.outer(u, u) / np.dot(u, u)\nprint(P)"
    },
    {
        "input": "Decompose v = [3, 4] into parallel and orthogonal components relative to u = [1, 2].",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([3, 4])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint(\"Parallel:\", proj)\nprint(\"Orthogonal:\", orth)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize [1, 2, 2] and [2, 1, -1]. Return the final vectors.",
        "output": "import numpy as np\na = np.array([1, 2, 2], dtype=float)\nb = np.array([2, 1, -1], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Find the orthogonal projection of v = [1, 2, 3] onto the plane spanned by u1 = [1, 0, 0] and u2 = [0, 1, 0].",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nu1 = np.array([1, 0, 0])\nu2 = np.array([0, 1, 0])\nproj1 = np.dot(v, u1) / np.dot(u1, u1) * u1\nproj2 = np.dot(v, u2) / np.dot(u2, u2) * u2\nproj = proj1 + proj2\nprint(proj)"
    },
    {
        "input": "Given an orthonormal basis {[1, 0], [0, 1]}, project [4, 5] onto the space they span.",
        "output": "import numpy as np\nv = np.array([4, 5])\nbasis = [np.array([1, 0]), np.array([0, 1])]\nproj = sum(np.dot(v, b) * b for b in basis)\nprint(proj)"
    },
    {
        "input": "Find the projection matrix for projecting onto the column space of A = [[1, 1], [0, 1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[1, 1], [0, 1], [1, 0]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nprint(P)"
    },
    {
        "input": "Orthonormalize the set {[1, 1, 1], [1, 0, 1], [1, 1, 0]} using Gram-Schmidt.",
        "output": "import numpy as np\na1 = np.array([1, 1, 1], dtype=float)\na2 = np.array([1, 0, 1], dtype=float)\na3 = np.array([1, 1, 0], dtype=float)\nu1 = a1 / np.linalg.norm(a1)\nproj2 = np.dot(a2, u1) * u1\nu2 = a2 - proj2\nu2 = u2 / np.linalg.norm(u2)\nproj3 = np.dot(a3, u1) * u1 + np.dot(a3, u2) * u2\nu3 = a3 - proj3\nu3 = u3 / np.linalg.norm(u3)\nprint(u1, u2, u3)"
    },
    {
        "input": "Given v = [3, 1, 2] and orthonormal basis {[1, 0, 0], [0, 1, 0]}, compute the projection of v.",
        "output": "import numpy as np\nv = np.array([3, 1, 2])\nb1 = np.array([1, 0, 0])\nb2 = np.array([0, 1, 0])\nproj = np.dot(v, b1) * b1 + np.dot(v, b2) * b2\nprint(proj)"
    },
    {
        "input": "Given u = [1, 2, 2], construct the matrix that projects any vector onto u.",
        "output": "import numpy as np\nu = np.array([1, 2, 2])\nP = np.outer(u, u) / np.dot(u, u)\nprint(P)"
    },
    {
        "input": "Find the projection of [3, 0, 4] onto the line spanned by [0, 1, 0].",
        "output": "import numpy as np\nv = np.array([3, 0, 4])\nu = np.array([0, 1, 0])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Compute the projection of [4, 2, 1] onto the plane x + y + z = 0.",
        "output": "import numpy as np\nv = np.array([4, 2, 1])\nn = np.array([1, 1, 1])\nproj_onto_n = (np.dot(v, n) / np.dot(n, n)) * n\nproj = v - proj_onto_n\nprint(proj)"
    },
    {
        "input": "Perform one step of Gram-Schmidt on [2, 2, 1] and [1, 0, 1]. Return orthonormal vectors.",
        "output": "import numpy as np\na = np.array([2, 2, 1], dtype=float)\nb = np.array([1, 0, 1], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Given matrix A = [[1, 0], [0, 1], [1, 1]], compute the projection of b = [2, 3, 4] onto Col(A).",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1], [1, 1]])\nb = np.array([2, 3, 4])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ b\nprint(proj)"
    },
    {
        "input": "Find the projection of [1, 2] onto the line y = x.",
        "output": "import numpy as np\nv = np.array([1, 2])\nu = np.array([1, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Compute the orthogonal projection of [2, 3, 4] onto the vector [1, 0, -1].",
        "output": "import numpy as np\nv = np.array([2, 3, 4])\nu = np.array([1, 0, -1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Orthonormalize [1, 1, 1], [0, 1, -1], [1, 0, -1] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([1, 1, 1], dtype=float)\nv2 = np.array([0, 1, -1], dtype=float)\nv3 = np.array([1, 0, -1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj2 = np.dot(v2, u1) * u1\nu2 = v2 - proj2\nu2 = u2 / np.linalg.norm(u2)\nproj3 = np.dot(v3, u1) * u1 + np.dot(v3, u2) * u2\nu3 = v3 - proj3\nu3 = u3 / np.linalg.norm(u3)\nprint(u1, u2, u3)"
    },
    {
        "input": "Find the projection matrix that projects onto the line through [1, 2, 3].",
        "output": "import numpy as np\nu = np.array([1, 2, 3])\nP = np.outer(u, u) / np.dot(u, u)\nprint(P)"
    },
    {
        "input": "Given b = [3, 3, 3], find its projection onto the plane x + y + z = 0.",
        "output": "import numpy as np\nb = np.array([3, 3, 3])\nn = np.array([1, 1, 1])\nproj = b - (np.dot(b, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Decompose [2, 2] into components along and orthogonal to [3, 1].",
        "output": "import numpy as np\nv = np.array([2, 2])\nu = np.array([3, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint(\"Parallel:\", proj)\nprint(\"Orthogonal:\", orth)"
    },
    {
        "input": "Compute the projection of [5, 5, 5] onto the subspace spanned by [1, 0, 0] and [0, 1, 0].",
        "output": "import numpy as np\nv = np.array([5, 5, 5])\nb1 = np.array([1, 0, 0])\nb2 = np.array([0, 1, 0])\nproj = np.dot(v, b1) * b1 + np.dot(v, b2) * b2\nprint(proj)"
    },
    {
        "input": "Find the orthogonal component of [4, 5, 6] to [1, 0, 1].",
        "output": "import numpy as np\nv = np.array([4, 5, 6])\nu = np.array([1, 0, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Orthonormalize [2, 0], [1, 1] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([2, 0], dtype=float)\nv2 = np.array([1, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Compute projection of [3, -1, 2] onto the line through [2, 0, 1].",
        "output": "import numpy as np\nv = np.array([3, -1, 2])\nu = np.array([2, 0, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the projection matrix that projects any vector onto [0, 1, 1].",
        "output": "import numpy as np\nu = np.array([0, 1, 1])\nP = np.outer(u, u) / np.dot(u, u)\nprint(P)"
    },
    {
        "input": "Given v = [6, 2, 1], compute its orthogonal projection onto the xy-plane.",
        "output": "import numpy as np\nv = np.array([6, 2, 1])\nn = np.array([0, 0, 1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Project [4, 3, 0] onto the subspace spanned by [1, 0, 0] and [0, 1, 0].",
        "output": "import numpy as np\nv = np.array([4, 3, 0])\nb1 = np.array([1, 0, 0])\nb2 = np.array([0, 1, 0])\nproj = np.dot(v, b1) * b1 + np.dot(v, b2) * b2\nprint(proj)"
    },
    {
        "input": "Compute the projection of [2, 4, 6] onto the vector [1, 1, 1].",
        "output": "import numpy as np\nv = np.array([2, 4, 6])\nu = np.array([1, 1, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the projection of [1, 2] onto the vector [2, -1].",
        "output": "import numpy as np\nv = np.array([1, 2])\nu = np.array([2, -1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Orthonormalize the vectors [1, 2, 0], [0, 1, 1] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([1, 2, 0], dtype=float)\nb = np.array([0, 1, 1], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Find the projection of b = [2, 4, 6] onto the plane orthogonal to [0, 0, 1].",
        "output": "import numpy as np\nb = np.array([2, 4, 6])\nn = np.array([0, 0, 1])\nproj = b - (np.dot(b, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Construct a projection matrix for projecting onto the y-axis in R^2.",
        "output": "import numpy as np\nu = np.array([0, 1])\nP = np.outer(u, u) / np.dot(u, u)\nprint(P)"
    },
    {
        "input": "Orthonormalize [3, 1], [2, 2] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([3, 1], dtype=float)\nv2 = np.array([2, 2], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Find the orthogonal component of [5, 5, 5] to [1, -1, 0].",
        "output": "import numpy as np\nv = np.array([5, 5, 5])\nu = np.array([1, -1, 0])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Project [2, -3] onto the line through [1, 1].",
        "output": "import numpy as np\nv = np.array([2, -3])\nu = np.array([1, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the projection matrix for projecting onto the plane x + y + z = 0.",
        "output": "import numpy as np\nn = np.array([1, 1, 1])\nP = np.eye(3) - np.outer(n, n) / np.dot(n, n)\nprint(P)"
    },
    {
        "input": "Decompose [4, 3] into components along and orthogonal to [1, 1].",
        "output": "import numpy as np\nv = np.array([4, 3])\nu = np.array([1, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint(\"Parallel:\", proj)\nprint(\"Orthogonal:\", orth)"
    },
    {
        "input": "Orthonormalize [1, 2, 2], [2, 1, 2] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([1, 2, 2], dtype=float)\nb = np.array([2, 1, 2], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Compute projection of [3, 1] onto [1, -1].",
        "output": "import numpy as np\nv = np.array([3, 1])\nu = np.array([1, -1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the projection of [6, 2, 3] onto the vector [1, 2, 1].",
        "output": "import numpy as np\nv = np.array([6, 2, 3])\nu = np.array([1, 2, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Orthonormalize [1, 1, 0], [1, 0, 1] using Gram-Schmidt process.",
        "output": "import numpy as np\nv1 = np.array([1, 1, 0], dtype=float)\nv2 = np.array([1, 0, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Decompose [1, 0, -1] into components parallel and orthogonal to [1, 1, 1].",
        "output": "import numpy as np\nv = np.array([1, 0, -1])\nu = np.array([1, 1, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\north = v - proj\nprint(\"Parallel:\", proj)\nprint(\"Orthogonal:\", orth)"
    },
    {
        "input": "Compute the orthogonal projection of [2, -1, 0] onto the yz-plane.",
        "output": "import numpy as np\nv = np.array([2, -1, 0])\nn = np.array([1, 0, 0])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Project [3, 4] onto the line y = 2x.",
        "output": "import numpy as np\nv = np.array([3, 4])\nu = np.array([1, 2])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Orthonormalize the vectors [1, 2], [2, 3] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([1, 2], dtype=float)\nv2 = np.array([2, 3], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Compute the projection of [7, 2, -1] onto the x-axis.",
        "output": "import numpy as np\nv = np.array([7, 2, -1])\nu = np.array([1, 0, 0])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find projection of [0, 1, 2] onto the plane y - z = 0.",
        "output": "import numpy as np\nv = np.array([0, 1, 2])\nn = np.array([0, 1, -1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Orthonormalize [1, 2, 1], [2, 0, 1] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([1, 2, 1], dtype=float)\nb = np.array([2, 0, 1], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Compute the projection of [5, 1] onto the vector [4, 3].",
        "output": "import numpy as np\nv = np.array([5, 1])\nu = np.array([4, 3])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the projection of [2, 2, 2] onto the subspace spanned by [1, 1, 0] and [0, 1, 1].",
        "output": "import numpy as np\nv = np.array([2, 2, 2])\nb1 = np.array([1, 1, 0])\nb2 = np.array([0, 1, 1])\nproj = np.dot(v, b1) * b1 / np.dot(b1, b1) + np.dot(v, b2) * b2 / np.dot(b2, b2)\nprint(proj)"
    },
    {
        "input": "Compute the projection of [1, 1, 1] onto the plane x + y + z = 3.",
        "output": "import numpy as np\nv = np.array([1, 1, 1])\nn = np.array([1, 1, 1])\nproj = v - ((np.dot(v, n) - 3) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find the projection of [4, 5, 6] onto the line spanned by [1, 0, 1].",
        "output": "import numpy as np\nv = np.array([4, 5, 6])\nu = np.array([1, 0, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Compute the projection of [1, 3, 2] onto the vector [2, 1, 2].",
        "output": "import numpy as np\nv = np.array([1, 3, 2])\nu = np.array([2, 1, 2])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Orthonormalize [2, 2, 1] and [1, 0, 2] using the Gram-Schmidt process.",
        "output": "import numpy as np\na = np.array([2, 2, 1], dtype=float)\nb = np.array([1, 0, 2], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Project the vector [4, -2, 1] onto the plane with normal vector [1, -1, 1].",
        "output": "import numpy as np\nv = np.array([4, -2, 1])\nn = np.array([1, -1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find the projection matrix onto the vector [1, 2].",
        "output": "import numpy as np\nu = np.array([1, 2])\nP = np.outer(u, u) / np.dot(u, u)\nprint(P)"
    },
    {
        "input": "Project [5, 5, 5] onto the subspace orthogonal to [0, 1, 0].",
        "output": "import numpy as np\nv = np.array([5, 5, 5])\nn = np.array([0, 1, 0])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find the component of [2, -1, 4] orthogonal to [1, 2, 3].",
        "output": "import numpy as np\nv = np.array([2, -1, 4])\nu = np.array([1, 2, 3])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Orthonormalize the vectors [1, 3], [2, -1] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([1, 3], dtype=float)\nb = np.array([2, -1], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Project [3, 2, 1] onto the line spanned by [0, 1, 0].",
        "output": "import numpy as np\nv = np.array([3, 2, 1])\nu = np.array([0, 1, 0])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find projection of [1, 1] onto [1, 0].",
        "output": "import numpy as np\nv = np.array([1, 1])\nu = np.array([1, 0])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Compute the orthogonal projection of [0, 4] onto the y-axis.",
        "output": "import numpy as np\nv = np.array([0, 4])\nu = np.array([0, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Orthonormalize [2, 0, 0], [1, 1, 0], [0, 1, 1] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([2, 0, 0], dtype=float)\nv2 = np.array([1, 1, 0], dtype=float)\nv3 = np.array([0, 1, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj2 = np.dot(v2, u1) * u1\nu2 = v2 - proj2\nu2 = u2 / np.linalg.norm(u2)\nproj3 = np.dot(v3, u1) * u1 + np.dot(v3, u2) * u2\nu3 = v3 - proj3\nu3 = u3 / np.linalg.norm(u3)\nprint(u1, u2, u3)"
    },
    {
        "input": "Project [6, 0, 0] onto [1, 2, 2].",
        "output": "import numpy as np\nv = np.array([6, 0, 0])\nu = np.array([1, 2, 2])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find projection of [3, -3, 3] onto the plane x - y + z = 0.",
        "output": "import numpy as np\nv = np.array([3, -3, 3])\nn = np.array([1, -1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Compute the projection of [2, 1, 2] onto the vector [1, 0, -1].",
        "output": "import numpy as np\nv = np.array([2, 1, 2])\nu = np.array([1, 0, -1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Orthonormalize the vectors [3, 1], [1, 3] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([3, 1], dtype=float)\nb = np.array([1, 3], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Compute the projection of [0, 1, 1] onto the plane x + y + z = 0.",
        "output": "import numpy as np\nv = np.array([0, 1, 1])\nn = np.array([1, 1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Project [2, 2, 2] onto the subspace spanned by [1, 1, 1] and [1, -1, 0].",
        "output": "import numpy as np\nv = np.array([2, 2, 2])\nb1 = np.array([1, 1, 1])\nb2 = np.array([1, -1, 0])\nproj = np.dot(v, b1)*b1/np.dot(b1, b1) + np.dot(v, b2)*b2/np.dot(b2, b2)\nprint(proj)"
    },
    {
        "input": "Find orthogonal projection of [5, -1] onto the x-axis.",
        "output": "import numpy as np\nv = np.array([5, -1])\nu = np.array([1, 0])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Orthonormalize vectors [0, 1, 1], [1, 0, 1] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([0, 1, 1], dtype=float)\nb = np.array([1, 0, 1], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Find the projection matrix onto the line spanned by [2, 1].",
        "output": "import numpy as np\nu = np.array([2, 1])\nP = np.outer(u, u) / np.dot(u, u)\nprint(P)"
    },
    {
        "input": "Compute orthogonal component of [3, 4, 5] to [1, 2, 1].",
        "output": "import numpy as np\nv = np.array([3, 4, 5])\nu = np.array([1, 2, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Orthonormalize [1, 0, 1], [1, 1, 0], [0, 1, 1] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([1, 0, 1], dtype=float)\nv2 = np.array([1, 1, 0], dtype=float)\nv3 = np.array([0, 1, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj2 = np.dot(v2, u1) * u1\nu2 = v2 - proj2\nu2 = u2 / np.linalg.norm(u2)\nproj3 = np.dot(v3, u1) * u1 + np.dot(v3, u2) * u2\nu3 = v3 - proj3\nu3 = u3 / np.linalg.norm(u3)\nprint(u1, u2, u3)"
    },
    {
        "input": "Project [1, 2, 3] onto [0, 0, 1].",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nu = np.array([0, 0, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find projection of [4, 2] onto the vector [1, 1].",
        "output": "import numpy as np\nv = np.array([4, 2])\nu = np.array([1, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Compute projection of [1, 1, -1] onto the plane with normal [0, 1, 1].",
        "output": "import numpy as np\nv = np.array([1, 1, -1])\nn = np.array([0, 1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Compute the projection of [4, 0, 2] onto the vector [1, 1, 0].",
        "output": "import numpy as np\nv = np.array([4, 0, 2])\nu = np.array([1, 1, 0])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Orthonormalize vectors [1, 2, 2], [2, 0, -1] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([1, 2, 2], dtype=float)\nb = np.array([2, 0, -1], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Find the projection matrix onto the vector [3, 4].",
        "output": "import numpy as np\nu = np.array([3, 4])\nP = np.outer(u, u) / np.dot(u, u)\nprint(P)"
    },
    {
        "input": "Project the vector [5, 1, 3] onto the xz-plane.",
        "output": "import numpy as np\nv = np.array([5, 1, 3])\nn = np.array([0, 1, 0])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Orthonormalize [1, 2, 3] and [4, 5, 6] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([1, 2, 3], dtype=float)\nb = np.array([4, 5, 6], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Compute projection of [1, -1, 0] onto vector [1, 1, 0].",
        "output": "import numpy as np\nv = np.array([1, -1, 0])\nu = np.array([1, 1, 0])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Project [6, 3] onto the y-axis.",
        "output": "import numpy as np\nv = np.array([6, 3])\nu = np.array([0, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the orthogonal projection of [2, 3, 5] onto the plane y - z = 0.",
        "output": "import numpy as np\nv = np.array([2, 3, 5])\nn = np.array([0, 1, -1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Project [3, 4, 0] onto the yz-plane.",
        "output": "import numpy as np\nv = np.array([3, 4, 0])\nn = np.array([1, 0, 0])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Compute the orthogonal component of [3, 3, 1] to [1, 0, 1].",
        "output": "import numpy as np\nv = np.array([3, 3, 1])\nu = np.array([1, 0, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Orthonormalize [1, 0, 1], [0, 1, 0], [1, 1, 0] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([1, 0, 1], dtype=float)\nv2 = np.array([0, 1, 0], dtype=float)\nv3 = np.array([1, 1, 0], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nu2 = v2 / np.linalg.norm(v2)\nproj3 = np.dot(v3, u1) * u1 + np.dot(v3, u2) * u2\nu3 = v3 - proj3\nu3 = u3 / np.linalg.norm(u3)\nprint(u1, u2, u3)"
    },
    {
        "input": "Project [1, 0, 1] onto the plane with normal vector [0, 1, -1].",
        "output": "import numpy as np\nv = np.array([1, 0, 1])\nn = np.array([0, 1, -1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Compute projection of [3, 4] onto [4, -3].",
        "output": "import numpy as np\nv = np.array([3, 4])\nu = np.array([4, -3])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find projection of [1, 2, 2] onto the line spanned by [1, 1, 1].",
        "output": "import numpy as np\nv = np.array([1, 2, 2])\nu = np.array([1, 1, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Orthonormalize [2, 0, 1], [1, 1, 1] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([2, 0, 1], dtype=float)\nb = np.array([1, 1, 1], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Find orthogonal projection of [0, 3] onto the x-axis.",
        "output": "import numpy as np\nv = np.array([0, 3])\nu = np.array([1, 0])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Project [2, 2, 2] onto plane x + y + z = 3.",
        "output": "import numpy as np\nv = np.array([2, 2, 2])\nn = np.array([1, 1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Project [3, 1, 2] onto [0, 1, 1].",
        "output": "import numpy as np\nv = np.array([3, 1, 2])\nu = np.array([0, 1, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Orthonormalize [1, 1], [1, -1] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([1, 1], dtype=float)\nb = np.array([1, -1], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Compute projection of [5, 6, 0] onto the yz-plane.",
        "output": "import numpy as np\nv = np.array([5, 6, 0])\nn = np.array([1, 0, 0])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find the projection matrix onto the vector [1, 2, 2].",
        "output": "import numpy as np\nu = np.array([1, 2, 2])\nP = np.outer(u, u) / np.dot(u, u)\nprint(P)"
    },
    {
        "input": "Project [1, 0, 0] onto plane x + 2y + 2z = 0.",
        "output": "import numpy as np\nv = np.array([1, 0, 0])\nn = np.array([1, 2, 2])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Orthonormalize [1, 2, 2], [2, 4, 5] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([1, 2, 2], dtype=float)\nb = np.array([2, 4, 5], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Compute orthogonal component of [1, 1, 0] to [1, 1, 1].",
        "output": "import numpy as np\nv = np.array([1, 1, 0])\nu = np.array([1, 1, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Find projection of [0, 1, 0] onto the line spanned by [1, 2, 2].",
        "output": "import numpy as np\nv = np.array([0, 1, 0])\nu = np.array([1, 2, 2])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Project vector [4, 2, -2] onto vector [1, 0, -1].",
        "output": "import numpy as np\nv = np.array([4, 2, -2])\nu = np.array([1, 0, -1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the orthogonal component of [3, 1] to [1, 2].",
        "output": "import numpy as np\nv = np.array([3, 1])\nu = np.array([1, 2])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Orthonormalize the vectors [1, 0, 1], [1, 1, 0] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([1, 0, 1], dtype=float)\nb = np.array([1, 1, 0], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Project [0, 2, 4] onto the xy-plane.",
        "output": "import numpy as np\nv = np.array([0, 2, 4])\nn = np.array([0, 0, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find the projection matrix onto the line spanned by [2, -1, 2].",
        "output": "import numpy as np\nu = np.array([2, -1, 2])\nP = np.outer(u, u) / np.dot(u, u)\nprint(P)"
    },
    {
        "input": "Project [1, 1, 1] onto the plane x - y + z = 0.",
        "output": "import numpy as np\nv = np.array([1, 1, 1])\nn = np.array([1, -1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Project [2, 2, 1] onto [1, 2, 1].",
        "output": "import numpy as np\nv = np.array([2, 2, 1])\nu = np.array([1, 2, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Orthonormalize [0, 1, 2], [1, 0, 2] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([0, 1, 2], dtype=float)\nb = np.array([1, 0, 2], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Compute projection of [2, 1] onto vector [1, -1].",
        "output": "import numpy as np\nv = np.array([2, 1])\nu = np.array([1, -1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Project vector [5, 5, 1] onto vector [1, 1, 0].",
        "output": "import numpy as np\nv = np.array([5, 5, 1])\nu = np.array([1, 1, 0])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Compute the orthogonal component of [1, 2, 3] to [0, 1, 1].",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nu = np.array([0, 1, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Orthonormalize [1, 2], [2, 1] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([1, 2], dtype=float)\nb = np.array([2, 1], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Project [1, 1, 0] onto the plane x + y + z = 0.",
        "output": "import numpy as np\nv = np.array([1, 1, 0])\nn = np.array([1, 1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Project [3, 2, 1] onto [1, 0, -1].",
        "output": "import numpy as np\nv = np.array([3, 2, 1])\nu = np.array([1, 0, -1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Compute projection of [3, 2, 1] onto vector [1, 1, 0].",
        "output": "import numpy as np\nv = np.array([3, 2, 1])\nu = np.array([1, 1, 0])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find orthogonal component of [1, 2, 3] to vector [2, 2, 2].",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nu = np.array([2, 2, 2])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Orthonormalize [3, 0, 1], [0, 2, 2] using Gram-Schmidt process.",
        "output": "import numpy as np\na = np.array([3, 0, 1], dtype=float)\nb = np.array([0, 2, 2], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Project [4, 1, 1] onto line spanned by [0, 1, -1].",
        "output": "import numpy as np\nv = np.array([4, 1, 1])\nu = np.array([0, 1, -1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find projection of [0, 0, 5] onto plane x + y + z = 0.",
        "output": "import numpy as np\nv = np.array([0, 0, 5])\nn = np.array([1, 1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Project [1, -1, 0] onto vector [1, 0, 1].",
        "output": "import numpy as np\nv = np.array([1, -1, 0])\nu = np.array([1, 0, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the projection matrix onto the vector [1, -1, 1].",
        "output": "import numpy as np\nu = np.array([1, -1, 1])\nP = np.outer(u, u) / np.dot(u, u)\nprint(P)"
    },
    {
        "input": "Orthonormalize [1, 0, 0], [1, 1, 0], [1, 1, 1] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([1, 0, 0], dtype=float)\nb = np.array([1, 1, 0], dtype=float)\nc = np.array([1, 1, 1], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj_b = np.dot(b, u1) * u1\nu2 = b - proj_b\nu2 = u2 / np.linalg.norm(u2)\nproj_c = np.dot(c, u1) * u1 + np.dot(c, u2) * u2\nu3 = c - proj_c\nu3 = u3 / np.linalg.norm(u3)\nprint(u1, u2, u3)"
    },
    {
        "input": "Project [6, 0, 0] onto the yz-plane.",
        "output": "import numpy as np\nv = np.array([6, 0, 0])\nn = np.array([1, 0, 0])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find projection of [1, 2, 3] onto vector [3, 2, 1].",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nu = np.array([3, 2, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Project vector [2, 4] onto vector [1, 1].",
        "output": "import numpy as np\nv = np.array([2, 4])\nu = np.array([1, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Compute projection of [2, 0, 2] onto plane x + y + z = 1.",
        "output": "import numpy as np\nv = np.array([2, 0, 2])\nn = np.array([1, 1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Orthonormalize [2, 2], [1, -1] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([2, 2], dtype=float)\nb = np.array([1, -1], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Project [3, -3, 6] onto vector [1, -1, 2].",
        "output": "import numpy as np\nv = np.array([3, -3, 6])\nu = np.array([1, -1, 2])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Project [4, 3, 0] onto vector [0, 1, 1].",
        "output": "import numpy as np\nv = np.array([4, 3, 0])\nu = np.array([0, 1, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Orthonormalize [1, 2, 2], [2, 0, 1] using Gram-Schmidt.",
        "output": "import numpy as np\na = np.array([1, 2, 2], dtype=float)\nb = np.array([2, 0, 1], dtype=float)\nu1 = a / np.linalg.norm(a)\nproj = np.dot(b, u1) * u1\nu2 = b - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Compute orthogonal component of [2, 1, 3] to [0, 0, 1].",
        "output": "import numpy as np\nv = np.array([2, 1, 3])\nu = np.array([0, 0, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Find projection matrix onto [1, 2].",
        "output": "import numpy as np\nu = np.array([1, 2])\nP = np.outer(u, u) / np.dot(u, u)\nprint(P)"
    },
    {
        "input": "Project [5, 1, -2] onto vector [1, 1, 1].",
        "output": "import numpy as np\nv = np.array([5, 1, -2])\nu = np.array([1, 1, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Project [2, -2, 2] onto the plane x + y + z = 0.",
        "output": "import numpy as np\nv = np.array([2, -2, 2])\nn = np.array([1, 1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find the orthogonal projection of vector [3, 2, 1] onto the plane defined by 2x - y + z = 0.",
        "output": "import numpy as np\nv = np.array([3, 2, 1])\nn = np.array([2, -1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Orthonormalize the set of vectors [[1, 1, 0], [1, 0, 1], [0, 1, 1]] using Gram-Schmidt process.",
        "output": "import numpy as np\nv1 = np.array([1, 1, 0], dtype=float)\nv2 = np.array([1, 0, 1], dtype=float)\nv3 = np.array([0, 1, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj_v2 = np.dot(v2, u1) * u1\nu2 = v2 - proj_v2\nu2 = u2 / np.linalg.norm(u2)\nproj_v3 = np.dot(v3, u1) * u1 + np.dot(v3, u2) * u2\nu3 = v3 - proj_v3\nu3 = u3 / np.linalg.norm(u3)\nprint(u1, u2, u3)"
    },
    {
        "input": "Find the projection of vector [4, 4, 1] onto the plane with normal vector [1, -1, 1].",
        "output": "import numpy as np\nv = np.array([4, 4, 1])\nn = np.array([1, -1, 1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find projection matrix onto the subspace spanned by [[1, 0, 1], [0, 1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 0, 1], [0, 1, 1]]).T\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nprint(P)"
    },
    {
        "input": "Find orthogonal projection of [5, 2, -1] onto subspace spanned by [[1, 2, 1], [2, 1, -1]].",
        "output": "import numpy as np\nv = np.array([5, 2, -1])\nA = np.array([[1, 2, 1], [2, 1, -1]]).T\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Orthonormalize [[2, 1, 0], [1, 1, 1], [0, 1, 2]] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([2, 1, 0], dtype=float)\nv2 = np.array([1, 1, 1], dtype=float)\nv3 = np.array([0, 1, 2], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj_v2 = np.dot(v2, u1) * u1\nu2 = v2 - proj_v2\nu2 = u2 / np.linalg.norm(u2)\nproj_v3 = np.dot(v3, u1) * u1 + np.dot(v3, u2) * u2\nu3 = v3 - proj_v3\nu3 = u3 / np.linalg.norm(u3)\nprint(u1, u2, u3)"
    },
    {
        "input": "Project [6, -2, 1] onto the plane 3x + y - z = 0.",
        "output": "import numpy as np\nv = np.array([6, -2, 1])\nn = np.array([3, 1, -1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Project vector [2, 4, 6] onto the subspace orthogonal to [1, 1, 1].",
        "output": "import numpy as np\nv = np.array([2, 4, 6])\nn = np.array([1, 1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Project vector [2, 1, 3] onto the subspace spanned by [1, 1, 0] and [0, 1, 1].",
        "output": "import numpy as np\nv = np.array([2, 1, 3])\nA = np.array([[1, 1, 0], [0, 1, 1]]).T\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Orthonormalize vectors [[3, 1, 4], [1, 5, 9], [2, 6, 5]] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([3, 1, 4], dtype=float)\nv2 = np.array([1, 5, 9], dtype=float)\nv3 = np.array([2, 6, 5], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj2 = np.dot(v2, u1) * u1\nu2 = v2 - proj2\nu2 = u2 / np.linalg.norm(u2)\nproj3 = np.dot(v3, u1) * u1 + np.dot(v3, u2) * u2\nu3 = v3 - proj3\nu3 = u3 / np.linalg.norm(u3)\nprint(u1, u2, u3)"
    },
    {
        "input": "Find orthogonal projection of [4, 1, 2] onto the plane defined by x - 2y + z = 0.",
        "output": "import numpy as np\nv = np.array([4, 1, 2])\nn = np.array([1, -2, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Compute projection matrix onto the column space of A = [[1, 0], [1, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [1, 1], [1, 2]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nprint(P)"
    },
    {
        "input": "Project [1, 2, 3, 4] onto the subspace spanned by [1, 1, 0, 0], [0, 0, 1, 1].",
        "output": "import numpy as np\nv = np.array([1, 2, 3, 4])\nA = np.array([[1, 0], [1, 0], [0, 1], [0, 1]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Find the orthogonal projection of vector [1, 2, 2] onto the plane x + y + z = 0.",
        "output": "import numpy as np\nv = np.array([1, 2, 2])\nn = np.array([1, 1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Orthonormalize the set of vectors [[1, 2, 2], [2, 0, 1], [1, 1, 1]] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([1, 2, 2], dtype=float)\nv2 = np.array([2, 0, 1], dtype=float)\nv3 = np.array([1, 1, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj2 = np.dot(v2, u1) * u1\nu2 = v2 - proj2\nu2 = u2 / np.linalg.norm(u2)\nproj3 = np.dot(v3, u1) * u1 + np.dot(v3, u2) * u2\nu3 = v3 - proj3\nu3 = u3 / np.linalg.norm(u3)\nprint(u1, u2, u3)"
    },
    {
        "input": "Project [3, -1, 4] onto the plane defined by 2x + 3y + z = 0.",
        "output": "import numpy as np\nv = np.array([3, -1, 4])\nn = np.array([2, 3, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find the projection matrix onto the column space of A = [[1, 2], [0, 1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [0, 1], [1, 0]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nprint(P)"
    },
    {
        "input": "Orthonormalize the vectors [[1, 2, 1], [2, 3, 1], [1, 1, 2]].",
        "output": "import numpy as np\nv1 = np.array([1, 2, 1], dtype=float)\nv2 = np.array([2, 3, 1], dtype=float)\nv3 = np.array([1, 1, 2], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj2 = np.dot(v2, u1) * u1\nu2 = v2 - proj2\nu2 = u2 / np.linalg.norm(u2)\nproj3 = np.dot(v3, u1) * u1 + np.dot(v3, u2) * u2\nu3 = v3 - proj3\nu3 = u3 / np.linalg.norm(u3)\nprint(u1, u2, u3)"
    },
    {
        "input": "Project the vector [5, 5, 5] onto the orthogonal complement of [1, 2, 3].",
        "output": "import numpy as np\nv = np.array([5, 5, 5])\nn = np.array([1, 2, 3])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find the projection of [6, 2, -1] onto the subspace spanned by [[2, 1, 0], [0, 1, 2]].",
        "output": "import numpy as np\nv = np.array([6, 2, -1])\nA = np.array([[2, 1, 0], [0, 1, 2]]).T\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Project [3, 1, 2] onto the subspace orthogonal to the plane 2x + y + z = 0.",
        "output": "import numpy as np\nv = np.array([3, 1, 2])\nn = np.array([2, 1, 1])\north_comp = (np.dot(v, n) / np.dot(n, n)) * n\nprint(orth_comp)"
    },
    {
        "input": "Orthonormalize the set [[1, 0, 1], [0, 1, 1], [1, 1, 0]].",
        "output": "import numpy as np\nv1 = np.array([1, 0, 1], dtype=float)\nv2 = np.array([0, 1, 1], dtype=float)\nv3 = np.array([1, 1, 0], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj2 = np.dot(v2, u1) * u1\nu2 = v2 - proj2\nu2 = u2 / np.linalg.norm(u2)\nproj3 = np.dot(v3, u1) * u1 + np.dot(v3, u2) * u2\nu3 = v3 - proj3\nu3 = u3 / np.linalg.norm(u3)\nprint(u1, u2, u3)"
    },
    {
        "input": "Find the orthogonal projection of [7, -1, 3] onto the plane 4x - 2y + z = 0.",
        "output": "import numpy as np\nv = np.array([7, -1, 3])\nn = np.array([4, -2, 1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Project [2, 3, 4, 5] onto the subspace spanned by [1, 1, 0, 0], [0, 0, 1, 1].",
        "output": "import numpy as np\nv = np.array([2, 3, 4, 5])\nA = np.array([[1, 0], [1, 0], [0, 1], [0, 1]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Find projection matrix onto the column space of A = [[2, 0], [1, 1], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 0], [1, 1], [0, 2]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nprint(P)"
    },
    {
        "input": "Project [5, 5, 5] onto the plane x - y + z = 0.",
        "output": "import numpy as np\nv = np.array([5, 5, 5])\nn = np.array([1, -1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find the projection of vector [1, 2, 3] onto the subspace spanned by vectors [1, 0, 1] and [0, 1, 1].",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nA = np.array([[1, 0], [0, 1], [1, 1]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Orthonormalize the vectors [[1, 1, 1], [1, 0, -1], [1, -2, 1]].",
        "output": "import numpy as np\nv1 = np.array([1, 1, 1], dtype=float)\nv2 = np.array([1, 0, -1], dtype=float)\nv3 = np.array([1, -2, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj2 = np.dot(v2, u1) * u1\nu2 = v2 - proj2\nu2 = u2 / np.linalg.norm(u2)\nproj3 = np.dot(v3, u1) * u1 + np.dot(v3, u2) * u2\nu3 = v3 - proj3\nu3 = u3 / np.linalg.norm(u3)\nprint(u1, u2, u3)"
    },
    {
        "input": "Find the projection matrix onto the line spanned by [3, 4].",
        "output": "import numpy as np\nv = np.array([[3], [4]])\nP = v @ v.T / (v.T @ v)\nprint(P)"
    },
    {
        "input": "Find the projection of [2, 2, 2] onto the vector [1, 2, 3] and compute the error vector.",
        "output": "import numpy as np\nv = np.array([2, 2, 2])\nb = np.array([1, 2, 3])\nproj = (np.dot(v, b)/np.dot(b, b)) * b\nerror = v - proj\nprint(proj, error)"
    },
    {
        "input": "Compute the distance from the point [3, 4, 5] to the plane x + 2y + 2z = 10.",
        "output": "import numpy as np\npoint = np.array([3, 4, 5])\nn = np.array([1, 2, 2])\nd = abs(np.dot(point, n) - 10) / np.linalg.norm(n)\nprint(d)"
    },
    {
        "input": "Project vector [4, 4, 4] onto the null space of matrix A = [[1, 1, 1]].",
        "output": "import numpy as np\nv = np.array([4, 4, 4])\nA = np.array([[1, 1, 1]])\nP = np.eye(3) - A.T @ np.linalg.inv(A @ A.T) @ A\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Orthonormalize the columns of matrix A = [[2, 0], [1, 1], [0, 2]] using Gram-Schmidt.",
        "output": "import numpy as np\nA = np.array([[2, 0], [1, 1], [0, 2]], dtype=float)\nv1 = A[:,0]\nv2 = A[:,1]\nu1 = v1 / np.linalg.norm(v1)\nproj = np.dot(v2, u1) * u1\nu2 = v2 - proj\nu2 = u2 / np.linalg.norm(u2)\nprint(u1, u2)"
    },
    {
        "input": "Find the orthogonal complement of the subspace spanned by [1, 2, 3] in R^3.",
        "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq = sp.Eq(x + 2*y + 3*z, 0)\nsol = sp.solve(eq, (x, y, z))\nprint(sol)"
    },
    {
        "input": "Project vector [1, 2, 3, 4] onto the plane defined by x1 + x2 + x3 + x4 = 0.",
        "output": "import numpy as np\nv = np.array([1, 2, 3, 4])\nn = np.array([1, 1, 1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find a unit vector orthogonal to both [1, 0, -1] and [1, 2, 1].",
        "output": "import numpy as np\na = np.array([1, 0, -1])\nb = np.array([1, 2, 1])\nc = np.cross(a, b)\nc = c / np.linalg.norm(c)\nprint(c)"
    },
    {
        "input": "Find the orthogonal projection of vector [6, -1] onto the line y = 2x.",
        "output": "import numpy as np\nv = np.array([6, -1])\nd = np.array([1, 2])\nproj = (np.dot(v, d)/np.dot(d, d)) * d\nprint(proj)"
    },
    {
        "input": "Find the projection matrix onto the orthogonal complement of span{[1, 1, 1]} in R^3.",
        "output": "import numpy as np\nA = np.array([[1, 1, 1]])\nP = np.eye(3) - A.T @ np.linalg.inv(A @ A.T) @ A\nprint(P)"
    },
    {
        "input": "Compute the component of [3, -2, 1] along [1, 1, 1] and perpendicular to it.",
        "output": "import numpy as np\nv = np.array([3, -2, 1])\nu = np.array([1, 1, 1])\nu = u / np.linalg.norm(u)\ncomp_along = np.dot(v, u) * u\ncomp_perp = v - comp_along\nprint(comp_along, comp_perp)"
    },
    {
        "input": "Orthonormalize the set [[2, 2, 0], [-1, 1, 0], [0, 0, 1]] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([2, 2, 0], dtype=float)\nv2 = np.array([-1, 1, 0], dtype=float)\nv3 = np.array([0, 0, 1], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj2 = np.dot(v2, u1) * u1\nu2 = v2 - proj2\nu2 = u2 / np.linalg.norm(u2)\nproj3 = np.dot(v3, u1) * u1 + np.dot(v3, u2) * u2\nu3 = v3 - proj3\nu3 = u3 / np.linalg.norm(u3)\nprint(u1, u2, u3)"
    },
    {
        "input": "Find the projection of vector [4, -2, 3] onto the vector [2, 1, -1], and compute the orthogonal component.",
        "output": "import numpy as np\nv = np.array([4, -2, 3])\nu = np.array([2, 1, -1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint(proj, orth)"
    },
    {
        "input": "Project vector [1, 3, 5] onto the column space of A = [[1, 2], [0, 1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [0, 1], [1, 0]])\nv = np.array([1, 3, 5])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Find an orthonormal basis for the column space of matrix A = [[1, 0, 1], [0, 1, 1], [1, 1, 0]].",
        "output": "import numpy as np\nA = np.array([[1, 0, 1], [0, 1, 1], [1, 1, 0]], dtype=float)\nQ, _ = np.linalg.qr(A)\nprint(Q)"
    },
    {
        "input": "Find the projection matrix that projects vectors in R^3 onto the x-y plane.",
        "output": "import numpy as np\nP = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 0]])\nprint(P)"
    },
    {
        "input": "Orthonormalize the vectors [[3, 1, 1], [2, 2, 2], [1, 3, 3]] using Gram-Schmidt.",
        "output": "import numpy as np\nv1 = np.array([3, 1, 1], dtype=float)\nv2 = np.array([2, 2, 2], dtype=float)\nv3 = np.array([1, 3, 3], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nproj2 = np.dot(v2, u1) * u1\nu2 = v2 - proj2\nu2 = u2 / np.linalg.norm(u2)\nproj3 = np.dot(v3, u1) * u1 + np.dot(v3, u2) * u2\nu3 = v3 - proj3\nu3 = u3 / np.linalg.norm(u3)\nprint(u1, u2, u3)"
    },
    {
        "input": "Find the projection of [4, 1, 2] onto the line passing through the origin and parallel to [2, 2, 1].",
        "output": "import numpy as np\nv = np.array([4, 1, 2])\nd = np.array([2, 2, 1])\nproj = (np.dot(v, d) / np.dot(d, d)) * d\nprint(proj)"
    },
    {
        "input": "Compute the component of [1, 0, 1] orthogonal to the space spanned by [1, 1, 0] and [0, 1, 1].",
        "output": "import numpy as np\nv = np.array([1, 0, 1])\nA = np.array([[1, 0], [1, 1], [0, 1]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\north = v - P @ v\nprint(orth)"
    },
    {
        "input": "Compute the projection of [2, 2, 2, 2] onto the hyperplane x1 - x2 + x3 - x4 = 0.",
        "output": "import numpy as np\nv = np.array([2, 2, 2, 2])\nn = np.array([1, -1, 1, -1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Project [1, 2, 3, 4] onto the space orthogonal to [1, 1, 1, 1] and [1, -1, 1, -1].",
        "output": "import numpy as np\nv = np.array([1, 2, 3, 4])\nA = np.array([[1, 1, 1, 1], [1, -1, 1, -1]])\nP = np.eye(4) - A.T @ np.linalg.inv(A @ A.T) @ A\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Find the least squares projection of vector [4, 5] onto the column space of A = [[1], [2]].",
        "output": "import numpy as np\nv = np.array([4, 5])\nA = np.array([[1], [2]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Compute the distance from vector [1, 1, 1, 1] to the subspace spanned by [1, 0, 0, 0] and [0, 1, 0, 0].",
        "output": "import numpy as np\nv = np.array([1, 1, 1, 1])\nA = np.array([[1, 0], [0, 1], [0, 0], [0, 0]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ v\ndist = np.linalg.norm(v - proj)\nprint(dist)"
    },
    {
        "input": "Find the orthogonal projection of vector [3, -1, 2] onto the plane x - y + z = 0.",
        "output": "import numpy as np\nv = np.array([3, -1, 2])\nn = np.array([1, -1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find a unit vector orthogonal to the plane 2x - y + 3z = 0.",
        "output": "import numpy as np\nn = np.array([2, -1, 3])\nunit_n = n / np.linalg.norm(n)\nprint(unit_n)"
    },
    {
        "input": "Given vectors [2, 3, 1] and [4, 1, -2], compute the projection of the first onto the second.",
        "output": "import numpy as np\na = np.array([2, 3, 1])\nb = np.array([4, 1, -2])\nproj = (np.dot(a, b) / np.dot(b, b)) * b\nprint(proj)"
    },
    {
        "input": "Find the projection matrix onto the plane perpendicular to vector [1, 2, 2].",
        "output": "import numpy as np\nn = np.array([1, 2, 2])\nP = np.eye(3) - np.outer(n, n) / np.dot(n, n)\nprint(P)"
    },
    {
        "input": "Compute the projection of vector [5, 6, 7] onto the column space of A = [[1, 0], [0, 1], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1], [1, 1]])\nv = np.array([5, 6, 7])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Find an orthonormal basis for the space perpendicular to [1, 2, 3] in R^3.",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nn = np.array([[1, 2, 3]])\nN = null_space(n)\nprint(N)"
    },
    {
        "input": "Find the projection of [3, 2, 1, 0] onto the subspace defined by x + y + z + w = 0.",
        "output": "import numpy as np\nv = np.array([3, 2, 1, 0])\nn = np.array([1, 1, 1, 1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find the least-squares solution to Ax = b where A = [[1, 1], [1, -1], [1, 2]], b = [2, 0, 3].",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, -1], [1, 2]])\nb = np.array([2, 0, 3])\nx = np.linalg.inv(A.T @ A) @ A.T @ b\nprint(x)"
    },
    {
        "input": "Project the vector [1, 4, 7] onto the span of [[2, 2, 2], [1, 0, 1]].",
        "output": "import numpy as np\nv = np.array([1, 4, 7])\nA = np.array([[2, 1], [2, 0], [2, 1]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Find a vector in the null space of A = [[2, 3, 1], [1, 1, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[2, 3, 1], [1, 1, 1]])\nnull = null_space(A)\nprint(null[:, 0])"
    },
    {
        "input": "Find a basis for the orthogonal complement of span{[1, 2, 3], [3, 2, 1]} in R^3.",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 2, 3], [3, 2, 1]])\nN = null_space(A)\nprint(N)"
    },
    {
        "input": "Given A = [[1, 2], [2, 4], [3, 6]], find the orthogonal projection of b = [1, 2, 3] onto Col(A).",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4], [3, 6]])\nb = np.array([1, 2, 3])\nP = A @ np.linalg.pinv(A)\nproj = P @ b\nprint(proj)"
    },
    {
        "input": "Find the vector component of [1, 1, 1] that lies in the null space of A = [[1, 1, 1]].",
        "output": "import numpy as np\nv = np.array([1, 1, 1])\nA = np.array([[1, 1, 1]])\nP = np.eye(3) - A.T @ np.linalg.inv(A @ A.T) @ A\ncomponent = P @ v\nprint(component)"
    },
    {
        "input": "Find the unit vector in the direction of projection of [5, 5, 0] onto the plane z = 0.",
        "output": "import numpy as np\nv = np.array([5, 5, 0])\nunit = v / np.linalg.norm(v)\nprint(unit)"
    },
    {
        "input": "Find a vector orthogonal to both [2, -1, 0] and [1, 1, 1] using cross product.",
        "output": "import numpy as np\na = np.array([2, -1, 0])\nb = np.array([1, 1, 1])\nc = np.cross(a, b)\nprint(c / np.linalg.norm(c))"
    },
    {
        "input": "Find the orthogonal projection of [3, -2, 5] onto the subspace spanned by [1, 1, 0] and [0, 1, 1].",
        "output": "import numpy as np\nv = np.array([3, -2, 5])\nA = np.array([[1, 0], [1, 1], [0, 1]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Compute the distance from vector [2, 4, 6] to the subspace defined by the span of [1, 1, 1].",
        "output": "import numpy as np\nv = np.array([2, 4, 6])\nu = np.array([1, 1, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\ndist = np.linalg.norm(v - proj)\nprint(dist)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize the set [[2, 0, 0], [1, 2, 0], [1, 1, 2]].",
        "output": "import numpy as np\nV = np.array([[2, 0, 0], [1, 2, 0], [1, 1, 2]], dtype=float)\nU = []\nfor v in V:\n    for u in U:\n        v = v - np.dot(v, u) * u\n    U.append(v / np.linalg.norm(v))\nfor u in U:\n    print(u)"
    },
    {
        "input": "Find the least-squares solution to Ax = b where A = [[2, 1], [1, 2], [1, 1]], b = [1, 2, 3].",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2], [1, 1]])\nb = np.array([1, 2, 3])\nx = np.linalg.inv(A.T @ A) @ A.T @ b\nprint(x)"
    },
    {
        "input": "Find the projection of vector [2, -1, 1] onto the plane x + y + z = 1 through origin.",
        "output": "import numpy as np\nv = np.array([2, -1, 1])\nn = np.array([1, 1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find a unit vector orthogonal to the column space of matrix [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 2], [3, 4], [5, 6]])\nN = null_space(A.T)\nprint(N[:, 0] / np.linalg.norm(N[:, 0]))"
    },
    {
        "input": "Project vector [4, 0, 0, 1] onto the space orthogonal to [1, 1, 1, 1].",
        "output": "import numpy as np\nv = np.array([4, 0, 0, 1])\nn = np.array([1, 1, 1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Given the vectors [1, 1, 0] and [1, -1, 0], find an orthonormal basis for the plane they span.",
        "output": "import numpy as np\nv1 = np.array([1, 1, 0], dtype=float)\nv2 = np.array([1, -1, 0], dtype=float)\nu1 = v1 / np.linalg.norm(v1)\nv2 = v2 - np.dot(v2, u1) * u1\nu2 = v2 / np.linalg.norm(v2)\nprint(u1, u2)"
    },
    {
        "input": "Compute the projection matrix onto the space spanned by [2, -1, 1, 0].",
        "output": "import numpy as np\nu = np.array([2, -1, 1, 0])\nP = np.outer(u, u) / np.dot(u, u)\nprint(P)"
    },
    {
        "input": "Find the projection of vector [1, 2, 2, 1] onto the plane defined by x - y + z = 0 and y - z + w = 0.",
        "output": "import numpy as np\nv = np.array([1, 2, 2, 1])\nA = np.array([[1, -1, 1, 0], [0, 1, -1, 1]])\nP = np.eye(4) - A.T @ np.linalg.inv(A @ A.T) @ A\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Find the orthogonal projection of vector [0, 2, 1] onto the span of [1, 1, 1].",
        "output": "import numpy as np\nv = np.array([0, 2, 1])\nu = np.array([1, 1, 1])\nproj = (np.dot(v, u)/np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find an orthonormal basis for the space perpendicular to both [1, 0, 1, 0] and [0, 1, 0, 1].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 0, 1, 0], [0, 1, 0, 1]])\nN = null_space(A)\nprint(N)"
    },
    {
        "input": "Find the projection matrix for projecting vectors in R^2 onto the x-axis.",
        "output": "import numpy as np\nP = np.array([[1, 0], [0, 0]])\nprint(P)"
    },
    {
        "input": "Project [3, 3, 3] onto the orthogonal complement of span{[1, 0, -1], [0, 1, 1]}.",
        "output": "import numpy as np\nv = np.array([3, 3, 3])\nA = np.array([[1, 0], [0, 1], [-1, 1]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\north_proj = v - P @ v\nprint(orth_proj)"
    },
    {
        "input": "Find the projection of vector [1, 2, 3] onto the null space of matrix A = [[1, 1, 1]].",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nA = np.array([[1, 1, 1]])\nP = np.eye(3) - A.T @ np.linalg.inv(A @ A.T) @ A\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Find a vector orthogonal to both [1, 2, 2] and [2, -1, 2] using cross product.",
        "output": "import numpy as np\na = np.array([1, 2, 2])\nb = np.array([2, -1, 2])\nc = np.cross(a, b)\nprint(c / np.linalg.norm(c))"
    },
    {
        "input": "Compute the orthogonal projection of [5, 0, -3, 2] onto the subspace spanned by [1, 1, 1, 1].",
        "output": "import numpy as np\nv = np.array([5, 0, -3, 2])\nu = np.array([1, 1, 1, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Use Gram-Schmidt process on [[1, 2, 2], [2, 4, 5], [3, 6, 8]].",
        "output": "import numpy as np\nV = np.array([[1, 2, 2], [2, 4, 5], [3, 6, 8]], dtype=float)\nU = []\nfor v in V:\n    for u in U:\n        v = v - np.dot(v, u) * u\n    U.append(v / np.linalg.norm(v))\nfor u in U:\n    print(u)"
    },
    {
        "input": "Find the projection matrix onto the column space of A = [[1, 2], [2, 4], [3, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4], [3, 6]])\nP = A @ np.linalg.pinv(A.T @ A) @ A.T\nprint(P)"
    },
    {
        "input": "Project [3, 1, 4, 1] onto the space spanned by [1, 0, 0, 0] and [0, 1, 1, 0].",
        "output": "import numpy as np\nv = np.array([3, 1, 4, 1])\nA = np.array([[1, 0], [0, 1], [0, 1], [0, 0]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Find a unit vector perpendicular to the subspace spanned by [1, 2, 3] and [4, 5, 6].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 2, 3], [4, 5, 6]])\nN = null_space(A)\nprint(N[:, 0] / np.linalg.norm(N[:, 0]))"
    },
    {
        "input": "Find a basis for the space of all vectors orthogonal to both [1, 1, 0] and [0, 1, 1].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 1, 0], [0, 1, 1]])\nN = null_space(A)\nprint(N)"
    },
    {
        "input": "Find the orthogonal projection of [7, -2, 5] onto the plane 3x - y + z = 0.",
        "output": "import numpy as np\nv = np.array([7, -2, 5])\nn = np.array([3, -1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find the distance from vector [1, 2, 2, 1] to the plane x + y + z + w = 0.",
        "output": "import numpy as np\nv = np.array([1, 2, 2, 1])\nn = np.array([1, 1, 1, 1])\ndistance = abs(np.dot(v, n)) / np.linalg.norm(n)\nprint(distance)"
    },
    {
        "input": "Project vector [0, 2, -1] onto the orthogonal complement of [1, 1, 1].",
        "output": "import numpy as np\nv = np.array([0, 2, -1])\nn = np.array([1, 1, 1])\nproj = v - (np.dot(v, n)/np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find an orthonormal basis for the subspace of R^3 spanned by [1, 2, 2] and [2, 0, 1].",
        "output": "import numpy as np\nV = np.array([[1, 2, 2], [2, 0, 1]], dtype=float)\nU = []\nfor v in V:\n    for u in U:\n        v -= np.dot(v, u) * u\n    U.append(v / np.linalg.norm(v))\nfor u in U:\n    print(u)"
    },
    {
        "input": "Find the projection matrix that projects onto the orthogonal complement of [2, -2, 1].",
        "output": "import numpy as np\nn = np.array([2, -2, 1])\nP = np.eye(3) - np.outer(n, n) / np.dot(n, n)\nprint(P)"
    },
    {
        "input": "Compute the projection of [1, 3, 1, 0] onto the column space of A = [[1, 0], [2, 1], [1, 0], [0, 1]].",
        "output": "import numpy as np\nv = np.array([1, 3, 1, 0])\nA = np.array([[1, 0], [2, 1], [1, 0], [0, 1]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ v\nprint(proj)"
    },
    {
        "input": "Find the projection of [4, -2, 7] onto the plane defined by x + 2y - z = 0.",
        "output": "import numpy as np\nv = np.array([4, -2, 7])\nn = np.array([1, 2, -1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize [[3, 1, 4], [1, 5, 9], [2, 6, 5]].",
        "output": "import numpy as np\nV = np.array([[3, 1, 4], [1, 5, 9], [2, 6, 5]], dtype=float)\nU = []\nfor v in V:\n    for u in U:\n        v -= np.dot(v, u) * u\n    U.append(v / np.linalg.norm(v))\nfor u in U:\n    print(u)"
    },
    {
        "input": "Compute the projection matrix onto the null space of matrix A = [[1, 1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 1]])\nP_null = np.eye(3) - A.T @ np.linalg.inv(A @ A.T) @ A\nprint(P_null)"
    },
    {
        "input": "Find the least squares solution to Ax = b where A = [[1, 0], [1, 1], [1, 2]], b = [1, 2, 2].",
        "output": "import numpy as np\nA = np.array([[1, 0], [1, 1], [1, 2]])\nb = np.array([1, 2, 2])\nx = np.linalg.inv(A.T @ A) @ A.T @ b\nprint(x)"
    },
    {
        "input": "Find the component of [1, 2, 3] orthogonal to [1, 0, -1].",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nu = np.array([1, 0, -1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Find a unit vector in the null space of [[1, -2, 1], [3, -6, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, -2, 1], [3, -6, 3]])\nN = null_space(A)\nprint(N[:, 0] / np.linalg.norm(N[:, 0]))"
    },
    {
        "input": "Find the projection of vector [1, 2, 2, 1] onto the space spanned by [1, 1, 1, 1].",
        "output": "import numpy as np\nv = np.array([1, 2, 2, 1])\nu = np.array([1, 1, 1, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find an orthonormal basis for the subspace spanned by [1, 1, 0, 0], [0, 1, 1, 0], and [0, 0, 1, 1].",
        "output": "import numpy as np\nV = np.array([[1, 1, 0, 0], [0, 1, 1, 0], [0, 0, 1, 1]], dtype=float)\nU = []\nfor v in V:\n    for u in U:\n        v -= np.dot(v, u) * u\n    U.append(v / np.linalg.norm(v))\nfor u in U:\n    print(u)"
    },
    {
        "input": "Find the distance from [3, 0, -1] to the line spanned by [1, 2, 3].",
        "output": "import numpy as np\nv = np.array([3, 0, -1])\nu = np.array([1, 2, 3])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\ndist = np.linalg.norm(v - proj)\nprint(dist)"
    },
    {
        "input": "Project [4, 5] onto the subspace spanned by [1, 1].",
        "output": "import numpy as np\nv = np.array([4, 5])\nu = np.array([1, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the projection matrix that projects vectors in R^3 onto the yz-plane.",
        "output": "import numpy as np\nP = np.array([[0, 0, 0], [0, 1, 0], [0, 0, 1]])\nprint(P)"
    },
    {
        "input": "Compute the projection of [1, 0, 0] onto the orthogonal complement of [1, 1, 1].",
        "output": "import numpy as np\nv = np.array([1, 0, 0])\nu = np.array([1, 1, 1])\nproj = v - (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find an orthonormal basis for the null space of matrix [[1, 1, 1, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 1, 1, 1]])\nN = null_space(A)\nprint(N)"
    },
    {
        "input": "Project [1, 2, 3] onto the plane perpendicular to vector [2, -1, 2].",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nn = np.array([2, -1, 2])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Given A = [[1, 1], [1, -1], [1, 0]], b = [2, 0, 1], find the least squares solution to Ax = b.",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, -1], [1, 0]])\nb = np.array([2, 0, 1])\nx = np.linalg.inv(A.T @ A) @ A.T @ b\nprint(x)"
    },
    {
        "input": "Find the projection of vector [2, 1, 0] onto the space orthogonal to [1, 1, 1].",
        "output": "import numpy as np\nv = np.array([2, 1, 0])\nn = np.array([1, 1, 1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find the projection matrix that projects vectors onto the line spanned by [1, -1, 2].",
        "output": "import numpy as np\nv = np.array([1, -1, 2])\nP = np.outer(v, v) / np.dot(v, v)\nprint(P)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize the columns of [[1, 1], [1, 0], [0, 1]].",
        "output": "import numpy as np\nV = np.array([[1, 1], [1, 0], [0, 1]], dtype=float).T\nU = []\nfor v in V:\n    for u in U:\n        v -= np.dot(v, u) * u\n    U.append(v / np.linalg.norm(v))\nfor u in U:\n    print(u)"
    },
    {
        "input": "Find the orthogonal component of [5, 2, 1] with respect to [2, 2, 2].",
        "output": "import numpy as np\nv = np.array([5, 2, 1])\nu = np.array([2, 2, 2])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Compute the orthogonal projection of [3, 4] onto the x-axis.",
        "output": "import numpy as np\nv = np.array([3, 4])\nu = np.array([1, 0])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the least squares solution for Ax = b with A = [[2, 1], [1, 3], [1, 2]], b = [5, 6, 7].",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 3], [1, 2]])\nb = np.array([5, 6, 7])\nx = np.linalg.inv(A.T @ A) @ A.T @ b\nprint(x)"
    },
    {
        "input": "Compute the projection of vector [1, 0, 2, 3] onto the space spanned by [1, 1, 1, 1].",
        "output": "import numpy as np\nv = np.array([1, 0, 2, 3])\nu = np.array([1, 1, 1, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the orthonormal basis of the column space of A = [[1, 2], [2, 4], [3, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4], [3, 6]], dtype=float)\nQ, R = np.linalg.qr(A)\nprint(Q)"
    },
    {
        "input": "Find the projection matrix that projects onto the column space of [[1, 0], [1, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [1, 1], [1, 2]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nprint(P)"
    },
    {
        "input": "Find the orthogonal complement of the subspace spanned by [1, 1, 0, 0] and [0, 1, 1, 0].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 1, 0, 0], [0, 1, 1, 0]])\nN = null_space(A)\nprint(N)"
    },
    {
        "input": "Project vector [2, -1, 3] onto the plane 2x + y - z = 0.",
        "output": "import numpy as np\nv = np.array([2, -1, 3])\nn = np.array([2, 1, -1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find a unit vector in the orthogonal complement of [1, 1, 1, 1] in R^4.",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 1, 1, 1]])\nN = null_space(A)\nunit_vector = N[:, 0] / np.linalg.norm(N[:, 0])\nprint(unit_vector)"
    },
    {
        "input": "Find the projection of [2, 2, 1] onto the plane orthogonal to [1, -1, 1].",
        "output": "import numpy as np\nv = np.array([2, 2, 1])\nn = np.array([1, -1, 1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Compute the least squares solution to Ax = b where A = [[1, 2], [3, 4], [5, 6]], b = [7, 8, 9].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nb = np.array([7, 8, 9])\nx = np.linalg.inv(A.T @ A) @ A.T @ b\nprint(x)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize the rows of [[1, 0, 1], [1, 1, 0]].",
        "output": "import numpy as np\nV = np.array([[1, 0, 1], [1, 1, 0]], dtype=float)\nU = []\nfor v in V:\n    for u in U:\n        v -= np.dot(v, u) * u\n    U.append(v / np.linalg.norm(v))\nfor u in U:\n    print(u)"
    },
    {
        "input": "Find the orthogonal projection of [0, 1, 2] onto the column space of A = [[1, 2], [0, 1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [0, 1], [1, 0]])\nb = np.array([0, 1, 2])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ b\nprint(proj)"
    },
    {
        "input": "Compute the distance from [1, 2, 2] to the subspace spanned by [1, 0, 1] and [0, 1, 1].",
        "output": "import numpy as np\nv = np.array([1, 2, 2])\nA = np.array([[1, 0], [0, 1], [1, 1]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ v\ndist = np.linalg.norm(v - proj)\nprint(dist)"
    },
    {
        "input": "Find a unit vector orthogonal to both [1, 0, 1] and [0, 1, 1].",
        "output": "import numpy as np\na = np.array([1, 0, 1])\nb = np.array([0, 1, 1])\nc = np.cross(a, b)\nunit = c / np.linalg.norm(c)\nprint(unit)"
    },
    {
        "input": "Find a nonzero vector that is orthogonal to both [1, 2, 3] and [4, 5, 6] and lies in the plane x + y + z = 0.",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 2, 3], [4, 5, 6], [1, 1, 1]])\nN = null_space(A)\nv = N[:, 0] / np.linalg.norm(N[:, 0])\nprint(v)"
    },
    {
        "input": "Let u and v be orthogonal unit vectors. What is the norm of u + v?",
        "output": "import numpy as np\nu = np.array([1, 0])\nv = np.array([0, 1])\nsum_vector = u + v\nnorm = np.linalg.norm(sum_vector)\nprint(norm)"
    },
    {
        "input": "Find the projection matrix P such that P^2 = P and P is symmetric, for projecting onto the null space of A = [[1, 2], [3, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 2], [3, 6]])\nN = null_space(A)\nP = N @ np.linalg.inv(N.T @ N) @ N.T\nprint(P)"
    },
    {
        "input": "Given A = [[1, 2], [2, 4], [3, 6]], find the orthogonal projection of b = [1, 2, 3] onto the column space of A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4], [3, 6]])\nb = np.array([1, 2, 3])\nP = A @ np.linalg.pinv(A)\nproj = P @ b\nprint(proj)"
    },
    {
        "input": "Given orthonormal matrix Q and vector x, show that the projection of x onto the column space of Q is Q @ Q.T @ x.",
        "output": "import numpy as np\nQ = np.array([[1, 0], [0, 1], [0, 0]])\nx = np.array([1, 2, 3])\nproj = Q @ Q.T @ x\nprint(proj)"
    },
    {
        "input": "Find a unit vector in the null space of A = [[1, 1, 1], [2, 2, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 1, 1], [2, 2, 2]])\nN = null_space(A)\nv = N[:, 0] / np.linalg.norm(N[:, 0])\nprint(v)"
    },
    {
        "input": "Find the angle between the projection of [1, 2, 2] onto [1, 1, 0] and the vector itself.",
        "output": "import numpy as np\nv = np.array([1, 2, 2])\nu = np.array([1, 1, 0])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nangle = np.arccos(np.dot(proj, v) / (np.linalg.norm(proj) * np.linalg.norm(v)))\nprint(np.degrees(angle))"
    },
    {
        "input": "Let A be an m x n matrix with orthonormal columns. Prove that A.T @ A = I.",
        "output": "import numpy as np\nA = np.array([[1/np.sqrt(2), 1/np.sqrt(2)], [-1/np.sqrt(2), 1/np.sqrt(2)]])\nresult = A.T @ A\nprint(result)"
    },
    {
        "input": "Find the vector v in R^3 such that v is orthogonal to both [1, 1, 0] and [0, 1, 1], and ||v|| = 1.",
        "output": "import numpy as np\na = np.array([1, 1, 0])\nb = np.array([0, 1, 1])\nv = np.cross(a, b)\nv = v / np.linalg.norm(v)\nprint(v)"
    },
    {
        "input": "Let v be a unit vector orthogonal to both u1 = [1, 0, 1] and u2 = [0, 1, 1]. Compute v · (u1 + u2).",
        "output": "import numpy as np\nu1 = np.array([1, 0, 1])\nu2 = np.array([0, 1, 1])\nv = np.cross(u1, u2)\nv = v / np.linalg.norm(v)\ndot = np.dot(v, u1 + u2)\nprint(dot)"
    },
    {
        "input": "Find the projection of [1, 2, 3, 4] onto the orthogonal complement of the column space of A = [[1, 1], [2, 2], [3, 3], [4, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 1], [2, 2], [3, 3], [4, 4]])\nb = np.array([1, 2, 3, 4])\nP = A @ np.linalg.pinv(A)\nproj_orth = b - P @ b\nprint(proj_orth)"
    },
    {
        "input": "Find a vector orthogonal to the plane defined by the vectors [1, 0, 0] and [0, 1, 1], and normalize it.",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([0, 1, 1])\nnormal = np.cross(u, v)\nunit = normal / np.linalg.norm(normal)\nprint(unit)"
    },
    {
        "input": "Find a non-zero vector that is orthogonal to [1, 1, 1] and lies in the plane x - y + z = 0.",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 1, 1], [1, -1, 1]])\nv = null_space(A)[:, 0]\nv = v / np.linalg.norm(v)\nprint(v)"
    },
    {
        "input": "Find a vector in R^3 that is orthogonal to [1, 1, 1] and has length 3.",
        "output": "import numpy as np\nv = np.array([1, -1, 0])\nv = v / np.linalg.norm(v) * 3\nprint(v)"
    },
    {
        "input": "Find the unit vector that is orthogonal to both [1, 2, 2] and [2, 1, 2].",
        "output": "import numpy as np\na = np.array([1, 2, 2])\nb = np.array([2, 1, 2])\nc = np.cross(a, b)\nc = c / np.linalg.norm(c)\nprint(c)"
    },
    {
        "input": "Let A = [[1, 2, 3], [2, 4, 6]], find a basis for the orthogonal complement of the row space.",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 2, 3], [2, 4, 6]])\nB = null_space(A)\nprint(B)"
    },
    {
        "input": "Find the projection of the vector [4, 3, 0] onto the plane x + y + z = 0.",
        "output": "import numpy as np\nv = np.array([4, 3, 0])\nn = np.array([1, 1, 1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find the distance from point [2, 3, 1] to the line passing through origin in the direction [1, 2, 2].",
        "output": "import numpy as np\np = np.array([2, 3, 1])\nd = np.array([1, 2, 2])\nproj = (np.dot(p, d) / np.dot(d, d)) * d\ndist = np.linalg.norm(p - proj)\nprint(dist)"
    },
    {
        "input": "Let A = [[1, 0], [0, 1], [1, 1]]. Find the projection of [2, 2, 2] onto the column space of A.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1], [1, 1]])\nb = np.array([2, 2, 2])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nproj = P @ b\nprint(proj)"
    },
    {
        "input": "Find a vector in the subspace spanned by [1, 1, 0] and [0, 1, 1] that is orthogonal to [1, 0, 1].",
        "output": "import numpy as np\nfrom sympy import symbols, Eq, solve\nc1, c2 = symbols('c1 c2')\nv1 = np.array([1, 1, 0])\nv2 = np.array([0, 1, 1])\nw = np.array([1, 0, 1])\nv = c1 * v1 + c2 * v2\ncondition = Eq(np.dot(v, w), 0)\nsol = solve(condition.subs(c2, 1), c1)\nc1_val = float(sol[0])\nc2_val = 1\nv_final = c1_val * v1 + c2_val * v2\nprint(v_final)"
    },
    {
        "input": "Find the unit vector that lies in the plane x + 2y + 3z = 0 and is orthogonal to [1, -1, 0].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, -1, 0], [1, 2, 3]])\nv = null_space(A)[:, 0]\nv = v / np.linalg.norm(v)\nprint(v)"
    },
    {
        "input": "Given two orthogonal vectors u = [1, 0, 1] and v = [0, 1, -1], compute the norm of u + v.",
        "output": "import numpy as np\nu = np.array([1, 0, 1])\nv = np.array([0, 1, -1])\nsum_vector = u + v\nnorm = np.linalg.norm(sum_vector)\nprint(norm)"
    },
    {
        "input": "Find the projection of [1, 2, 3] onto the space spanned by the orthonormal vectors [1/√2, 1/√2, 0] and [0, 0, 1].",
        "output": "import numpy as np\nu1 = np.array([1/np.sqrt(2), 1/np.sqrt(2), 0])\nu2 = np.array([0, 0, 1])\nv = np.array([1, 2, 3])\nproj = np.dot(v, u1) * u1 + np.dot(v, u2) * u2\nprint(proj)"
    },
    {
        "input": "Find the distance from the point [3, 1, 2] to the plane x + y + z = 0.",
        "output": "import numpy as np\np = np.array([3, 1, 2])\nn = np.array([1, 1, 1])\ndist = abs(np.dot(p, n)) / np.linalg.norm(n)\nprint(dist)"
    },
    {
        "input": "Find a unit vector orthogonal to both [1, 2, 3] and [4, 5, 6].",
        "output": "import numpy as np\nu = np.array([1, 2, 3])\nv = np.array([4, 5, 6])\nw = np.cross(u, v)\nunit = w / np.linalg.norm(w)\nprint(unit)"
    },
    {
        "input": "Find the projection matrix onto the space spanned by [2, 1, 0].",
        "output": "import numpy as np\nv = np.array([2, 1, 0])\nv = v / np.linalg.norm(v)\nP = np.outer(v, v)\nprint(P)"
    },
    {
        "input": "Find the orthogonal complement of the row space of A = [[1, 2, 3], [2, 4, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 2, 3], [2, 4, 6]])\nB = null_space(A)\nprint(B)"
    },
    {
        "input": "Find a vector in R^3 of magnitude 5 that is orthogonal to [1, 1, 1].",
        "output": "import numpy as np\nv = np.array([1, -1, 0])\nv = v / np.linalg.norm(v) * 5\nprint(v)"
    },
    {
        "input": "Find the projection of [1, 0, 0] onto the space spanned by [1, 2, 2] and [2, 1, 2].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 1], [2, 2]])\nb = np.array([1, 0, 0])\nP = A @ np.linalg.pinv(A) @ b\nprint(P)"
    },
    {
        "input": "Find a unit vector in the column space of A = [[1, 0], [1, 1], [0, 1]] that is orthogonal to [1, 1, 1].",
        "output": "import numpy as np\nfrom scipy.linalg import orth\nA = np.array([[1, 0], [1, 1], [0, 1]])\nC = orth(A)\nv = C[:, 0] - (np.dot(C[:, 0], [1, 1, 1]) / 3) * np.array([1, 1, 1])\nv = v / np.linalg.norm(v)\nprint(v)"
    },
    {
        "input": "Find the projection of [3, 3, 3] onto the null space of A = [[1, 1, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 1, 1]])\nN = null_space(A)\nv = np.array([3, 3, 3])\nproj = N @ (N.T @ v)\nprint(proj)"
    },
    {
        "input": "Let u = [1, 2] and v = [2, -1]. Find the projection of u onto v and compute the orthogonal component.",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([2, -1])\nproj = (np.dot(u, v) / np.dot(v, v)) * v\north = u - proj\nprint({'projection': proj, 'orthogonal_component': orth})"
    },
    {
        "input": "Find the unit vector in the null space of A = [[1, 2, -1], [2, 4, -2]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 2, -1], [2, 4, -2]])\nN = null_space(A)\nv = N[:, 0] / np.linalg.norm(N[:, 0])\nprint(v)"
    },
    {
        "input": "Given v = [3, 4, 0] and u = [0, 0, 5], find the orthogonal projection of v onto u.",
        "output": "import numpy as np\nv = np.array([3, 4, 0])\nu = np.array([0, 0, 5])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the projection of [1, 0, 1, 0] onto the subspace spanned by [1, 1, 0, 0] and [0, 0, 1, 1].",
        "output": "import numpy as np\nA = np.array([[1, 0], [1, 0], [0, 1], [0, 1]])\nv = np.array([1, 0, 1, 0])\nP = A @ np.linalg.pinv(A) @ v\nprint(P)"
    },
    {
        "input": "Find the orthogonal projection of vector [1, 2, 3] onto the plane 2x + y - z = 0.",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nn = np.array([2, 1, -1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find a unit vector orthogonal to the vector [1, 2, 3] and lying in the x-y plane.",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nw = np.array([2, -1, 0])\nw = w - (np.dot(w, v) / np.dot(v, v)) * v\nunit = w / np.linalg.norm(w)\nprint(unit)"
    },
    {
        "input": "Find the component of [2, 3, 4] that is orthogonal to the space spanned by [1, 1, 0].",
        "output": "import numpy as np\nu = np.array([1, 1, 0])\nv = np.array([2, 3, 4])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Let u1 = [1, 1, 0], u2 = [1, -1, 0]. Apply Gram-Schmidt to orthogonalize them.",
        "output": "import numpy as np\nu1 = np.array([1, 1, 0])\nu2 = np.array([1, -1, 0])\nv1 = u1\nv2 = u2 - (np.dot(u2, v1) / np.dot(v1, v1)) * v1\nprint(v1, v2)"
    },
    {
        "input": "Let A be a matrix with columns [1, 1], [2, 2], [3, 3]. Find the rank of the projection matrix A @ A^+.",
        "output": "import numpy as np\nA = np.array([[1, 1], [2, 2], [3, 3]])\nP = A @ np.linalg.pinv(A)\nrank = np.linalg.matrix_rank(P)\nprint(rank)"
    },
    {
        "input": "Let v = [1, 2, 2]. Find its projection onto the space orthogonal to [1, 1, 1].",
        "output": "import numpy as np\nv = np.array([1, 2, 2])\nn = np.array([1, 1, 1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Let A = [[1, 0], [0, 1], [1, 1]]. Find an orthonormal basis for its column space using Gram-Schmidt.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 0], [0, 1], [1, 1]])\nQ, _ = qr(A, mode='economic')\nprint(Q)"
    },
    {
        "input": "Find a unit vector in the null space of A = [[1, -1, 2], [-2, 2, -4]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, -1, 2], [-2, 2, -4]])\nN = null_space(A)\nunit = N[:, 0] / np.linalg.norm(N[:, 0])\nprint(unit)"
    },
    {
        "input": "Let v = [3, 2, 1]. Compute its projection onto the column space of A = [[1, 0], [1, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [1, 1], [1, 2]])\nv = np.array([3, 2, 1])\nP = A @ np.linalg.pinv(A) @ v\nprint(P)"
    },
    {
        "input": "Compute the projection of [4, 1] onto the line y = 2x.",
        "output": "import numpy as np\nv = np.array([4, 1])\nu = np.array([1, 2])\nu = u / np.linalg.norm(u)\nproj = np.dot(v, u) * u\nprint(proj)"
    },
    {
        "input": "Let v = [1, 2, 3, 4] and A = [[1, 0], [0, 1], [1, 0], [0, 1]]. Compute projection of v onto Col(A).",
        "output": "import numpy as np\nv = np.array([1, 2, 3, 4])\nA = np.array([[1, 0], [0, 1], [1, 0], [0, 1]])\nP = A @ np.linalg.pinv(A) @ v\nprint(P)"
    },
    {
        "input": "Find a unit vector in the plane x - 2y + z = 0 that is orthogonal to [2, 1, -1].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, -2, 1], [2, 1, -1]])\nv = null_space(A)[:, 0]\nv = v / np.linalg.norm(v)\nprint(v)"
    },
    {
        "input": "Compute the projection matrix onto the plane spanned by vectors [1, 0, 0] and [0, 1, 1].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1], [0, 1]])\nP = A @ np.linalg.pinv(A)\nprint(P)"
    },
    {
        "input": "Given a vector [1, 2, 3], find its orthogonal component to the subspace spanned by [1, 1, 1].",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nu = np.array([1, 1, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Apply the Gram-Schmidt process to vectors [1, 0, 1], [1, 1, 0], and [0, 1, 1].",
        "output": "import numpy as np\ndef gram_schmidt(V):\n    U = []\n    for v in V:\n        v = v.astype(float)\n        for u in U:\n            v -= np.dot(v, u) * u\n        U.append(v / np.linalg.norm(v))\n    return np.array(U)\nV = [np.array([1, 0, 1], dtype=float), np.array([1, 1, 0], dtype=float), np.array([0, 1, 1], dtype=float)]\nQ = gram_schmidt(V)\nprint(Q)"
    },
    {
        "input": "Find a unit vector in the orthogonal complement of the column space of A = [[1, 2], [2, 4], [3, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 2], [2, 4], [3, 6]])\nN = null_space(A.T)\nunit = N[:, 0] / np.linalg.norm(N[:, 0])\nprint(unit)"
    },
    {
        "input": "Find the vector component of [4, 4, 2] parallel to [1, 1, 0] and its orthogonal component.",
        "output": "import numpy as np\nv = np.array([4, 4, 2])\nu = np.array([1, 1, 0])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint({'parallel': proj, 'orthogonal': orth})"
    },
    {
        "input": "Find a vector perpendicular to both [1, 1, 1] and [2, 2, -1] using the cross product.",
        "output": "import numpy as np\nu = np.array([1, 1, 1])\nv = np.array([2, 2, -1])\nw = np.cross(u, v)\nprint(w / np.linalg.norm(w))"
    },
    {
        "input": "Let Q = [[1/√2, -1/√2], [1/√2, 1/√2]]. Show Q is orthogonal and compute Q.T @ Q.",
        "output": "import numpy as np\nQ = np.array([[1/np.sqrt(2), -1/np.sqrt(2)], [1/np.sqrt(2), 1/np.sqrt(2)]])\nprint(Q.T @ Q)"
    },
    {
        "input": "Find a unit vector in the plane x + 2y - z = 0, perpendicular to the vector [2, -1, 1].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 2, -1], [2, -1, 1]])\nv = null_space(A)[:, 0]\nv = v / np.linalg.norm(v)\nprint(v)"
    },
    {
        "input": "Given the matrix A = [[1, 2], [3, 4], [5, 6]], find the orthogonal projection of [7, 8, 9] onto Col(A).",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nv = np.array([7, 8, 9])\nproj = A @ np.linalg.pinv(A) @ v\nprint(proj)"
    },
    {
        "input": "Let A = [[1, 0], [0, 0], [0, 1]]. Find the orthogonal projection matrix onto the column space of A.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 0], [0, 1]])\nP = A @ np.linalg.pinv(A)\nprint(P)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize vectors [1, 2, 0], [2, 3, 4], [1, 0, 1].",
        "output": "import numpy as np\ndef gram_schmidt(V):\n    U = []\n    for v in V:\n        v = v.astype(float)\n        for u in U:\n            v -= np.dot(v, u) * u\n        U.append(v / np.linalg.norm(v))\n    return np.array(U)\nV = [np.array([1, 2, 0], dtype=float), np.array([2, 3, 4], dtype=float), np.array([1, 0, 1], dtype=float)]\nQ = gram_schmidt(V)\nprint(Q)"
    },
    {
        "input": "Find the projection of [2, 1, -1] onto the subspace defined by x - y + z = 0.",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nn = np.array([1, -1, 1])\nv = np.array([2, 1, -1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find a unit vector in the space orthogonal to both [1, 2, 3] and [4, 5, 6].",
        "output": "import numpy as np\nu = np.array([1, 2, 3])\nv = np.array([4, 5, 6])\nw = np.cross(u, v)\nw = w / np.linalg.norm(w)\nprint(w)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 6], [5, 10]], compute the orthogonal projection matrix onto Col(A).",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 6], [5, 10]])\nP = A @ np.linalg.pinv(A)\nprint(P)"
    },
    {
        "input": "Compute the projection of v = [1, 1, 1] onto the null space of A = [[1, 2, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nv = np.array([1, 1, 1])\nA = np.array([[1, 2, 3]])\nN = null_space(A)\nproj = N @ np.linalg.pinv(N) @ v\nprint(proj)"
    },
    {
        "input": "Let v = [3, 4, 0], find its projection onto the plane x + y + z = 0.",
        "output": "import numpy as np\nn = np.array([1, 1, 1])\nv = np.array([3, 4, 0])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find the projection of [4, 5] onto the vector [1, 2], then find the orthogonal component.",
        "output": "import numpy as np\nv = np.array([4, 5])\nu = np.array([1, 2])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint({'projection': proj, 'orthogonal': orth})"
    },
    {
        "input": "Let A = [[1, 2], [3, 4], [5, 6]]. Compute Q from QR decomposition using Gram-Schmidt.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2], [3, 4], [5, 6]])\nQ, _ = qr(A, mode='economic')\nprint(Q)"
    },
    {
        "input": "Find an orthonormal basis for the null space of A = [[1, 2, 3], [4, 5, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nN = null_space(np.array([[1, 2, 3], [4, 5, 6]]))\nprint(N)"
    },
    {
        "input": "Compute the vector component of [1, 0, -1] that is parallel to [2, 1, 0].",
        "output": "import numpy as np\nv = np.array([1, 0, -1])\nu = np.array([2, 1, 0])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Apply Gram-Schmidt to orthogonalize vectors [1, 2], [2, 1].",
        "output": "import numpy as np\ndef gram_schmidt(V):\n    U = []\n    for v in V:\n        v = v.astype(float)\n        for u in U:\n            v -= np.dot(v, u) * u\n        U.append(v / np.linalg.norm(v))\n    return np.array(U)\nV = [np.array([1, 2], dtype=float), np.array([2, 1], dtype=float)]\nQ = gram_schmidt(V)\nprint(Q)"
    },
    {
        "input": "Given v = [1, 2, 2], compute its projection onto the column space of A = [[1, 0], [0, 1], [1, 1]].",
        "output": "import numpy as np\nv = np.array([1, 2, 2])\nA = np.array([[1, 0], [0, 1], [1, 1]])\nproj = A @ np.linalg.pinv(A) @ v\nprint(proj)"
    },
    {
        "input": "Find a unit vector in the plane 2x - y + z = 0, orthogonal to [1, 0, 1].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[2, -1, 1], [1, 0, 1]])\nv = null_space(A)[:, 0]\nv = v / np.linalg.norm(v)\nprint(v)"
    },
    {
        "input": "Project the vector [1, 1, 1, 1] onto the subspace spanned by [1, 1, 0, 0] and [0, 0, 1, 1].",
        "output": "import numpy as np\nA = np.array([[1, 0], [1, 0], [0, 1], [0, 1]])\nv = np.array([1, 1, 1, 1])\nproj = A @ np.linalg.pinv(A) @ v\nprint(proj)"
    },
    {
        "input": "Find the orthogonal projection of [3, 3, 3] onto the subspace spanned by [1, 1, 0] and [0, 0, 1].",
        "output": "import numpy as np\nA = np.array([[1, 0], [1, 0], [0, 1]])\nv = np.array([3, 3, 3])\nproj = A @ np.linalg.pinv(A) @ v\nprint(proj)"
    },
    {
        "input": "Apply Gram-Schmidt to orthonormalize [2, 1, 0], [1, 1, 0], [0, 0, 1].",
        "output": "import numpy as np\ndef gram_schmidt(V):\n    U = []\n    for v in V:\n        v = v.astype(float)\n        for u in U:\n            v -= np.dot(v, u) * u\n        U.append(v / np.linalg.norm(v))\n    return np.array(U)\nV = [np.array([2, 1, 0], dtype=float), np.array([1, 1, 0], dtype=float), np.array([0, 0, 1], dtype=float)]\nQ = gram_schmidt(V)\nprint(Q)"
    },
    {
        "input": "Find the projection of [4, -2] onto the vector [3, 1] and confirm the error vector is orthogonal.",
        "output": "import numpy as np\nv = np.array([4, -2])\nu = np.array([3, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nerror = v - proj\nprint(np.dot(error, u))"
    },
    {
        "input": "Given v = [1, 2, 3], find its orthogonal projection onto the plane x + 2y + 2z = 0.",
        "output": "import numpy as np\nn = np.array([1, 2, 2])\nv = np.array([1, 2, 3])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Given matrix A = [[1, 1], [1, -1], [1, 0]], compute the projection matrix onto Col(A).",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, -1], [1, 0]])\nP = A @ np.linalg.pinv(A)\nprint(P)"
    },
    {
        "input": "Given vector [1, 2, 3], find its projection onto the null space of A = [[1, 1, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 1, 1]])\nv = np.array([1, 2, 3])\nN = null_space(A)\nproj = N @ np.linalg.pinv(N) @ v\nprint(proj)"
    },
    {
        "input": "Let A = [[1, 0, 1], [0, 1, 1]]. Find the projection of [2, 3, 4] onto the row space of A.",
        "output": "import numpy as np\nA = np.array([[1, 0, 1], [0, 1, 1]])\nv = np.array([2, 3, 4])\nR = A.T @ np.linalg.pinv(A @ A.T) @ A\nproj = R @ v\nprint(proj)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize [1, 1, 1], [1, 0, -1], [1, -2, 1].",
        "output": "import numpy as np\ndef gram_schmidt(V):\n    U = []\n    for v in V:\n        v = v.astype(float)\n        for u in U:\n            v -= np.dot(v, u) * u\n        U.append(v / np.linalg.norm(v))\n    return np.array(U)\nV = [np.array([1, 1, 1], dtype=float), np.array([1, 0, -1], dtype=float), np.array([1, -2, 1], dtype=float)]\nQ = gram_schmidt(V)\nprint(Q)"
    },
    {
        "input": "Find a vector in the null space of A = [[1, 2, 3], [2, 4, 6], [3, 6, 9]] and make it unit length.",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nN = null_space(np.array([[1, 2, 3], [2, 4, 6], [3, 6, 9]]))\nunit = N[:, 0] / np.linalg.norm(N[:, 0])\nprint(unit)"
    },
    {
        "input": "Let A = [[1, 2], [2, 4], [3, 6]], compute projection of [1, 0, 1] onto the orthogonal complement of Col(A).",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4], [3, 6]])\nv = np.array([1, 0, 1])\nP = A @ np.linalg.pinv(A)\north_proj = v - P @ v\nprint(orth_proj)"
    },
    {
        "input": "Given two vectors u = [1, 2] and v = [2, -1], compute the projection of v onto u and then reflect v over u.",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([2, -1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nreflected = 2 * proj - v\nprint(reflected)"
    },
    {
        "input": "Find the projection of [2, 1, -1] onto the plane defined by the normal vector [1, 1, 1].",
        "output": "import numpy as np\nn = np.array([1, 1, 1])\nv = np.array([2, 1, -1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Compute the orthogonal projection of [3, 0, 1] onto the subspace spanned by [1, 1, 0] and [0, 1, 1].",
        "output": "import numpy as np\nA = np.array([[1, 0], [1, 1], [0, 1]])\nv = np.array([3, 0, 1])\nproj = A @ np.linalg.pinv(A) @ v\nprint(proj)"
    },
    {
        "input": "Find a unit vector in the null space of A = [[1, 2, 1], [2, 4, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nN = null_space(np.array([[1, 2, 1], [2, 4, 2]]))\nunit = N[:, 0] / np.linalg.norm(N[:, 0])\nprint(unit)"
    },
    {
        "input": "Orthogonally decompose [4, 2] into components parallel and orthogonal to [3, -1].",
        "output": "import numpy as np\nv = np.array([4, 2])\nu = np.array([3, -1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint({'parallel': proj, 'orthogonal': orth})"
    },
    {
        "input": "Apply Gram-Schmidt to orthonormalize the vectors [1, 2, 2], [2, 0, 1], [1, 1, 1].",
        "output": "import numpy as np\ndef gram_schmidt(V):\n    U = []\n    for v in V:\n        v = v.astype(float)\n        for u in U:\n            v -= np.dot(v, u) * u\n        U.append(v / np.linalg.norm(v))\n    return np.array(U)\nV = [np.array([1, 2, 2], dtype=float), np.array([2, 0, 1], dtype=float), np.array([1, 1, 1], dtype=float)]\nQ = gram_schmidt(V)\nprint(Q)"
    },
    {
        "input": "Find the orthogonal component of [1, 1, 1] relative to the vector [1, -1, 0].",
        "output": "import numpy as np\nv = np.array([1, 1, 1])\nu = np.array([1, -1, 0])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\north = v - proj\nprint(orth)"
    },
    {
        "input": "Find the projection matrix that projects any vector in R^3 onto the line spanned by [2, 2, 1].",
        "output": "import numpy as np\nu = np.array([2, 2, 1])\nu = u / np.linalg.norm(u)\nP = np.outer(u, u)\nprint(P)"
    },
    {
        "input": "Project the vector [5, -3, 2] onto the row space of A = [[1, 2, 3]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3]])\nv = np.array([5, -3, 2])\nR = A.T @ np.linalg.pinv(A @ A.T) @ A\nproj = R @ v\nprint(proj)"
    },
    {
        "input": "Find an orthonormal basis for the column space of A = [[1, 2], [2, 4], [3, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import orth\nA = np.array([[1, 2], [2, 4], [3, 6]])\nQ = orth(A)\nprint(Q)"
    },
    {
        "input": "Decompose [3, 3, 3] into parts parallel and orthogonal to the plane x + y + z = 0.",
        "output": "import numpy as np\nv = np.array([3, 3, 3])\nn = np.array([1, 1, 1])\nproj = (np.dot(v, n) / np.dot(n, n)) * n\north = v - proj\nprint({'parallel': proj, 'orthogonal': orth})"
    },
    {
        "input": "Use QR decomposition to find an orthonormal basis for Col(A) where A = [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2], [3, 4], [5, 6]])\nQ, R = qr(A, mode='economic')\nprint(Q)"
    },
    {
        "input": "Find a unit vector that lies in the plane 3x + y - z = 0 and is orthogonal to [1, 2, 3].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[3, 1, -1], [1, 2, 3]])\nv = null_space(A)[:, 0]\nv = v / np.linalg.norm(v)\nprint(v)"
    },
    {
        "input": "Given v = [2, -1, 0], find its projection onto the line orthogonal to the plane x - 2y + z = 0.",
        "output": "import numpy as np\nv = np.array([2, -1, 0])\nn = np.array([1, -2, 1])\nn = n / np.linalg.norm(n)\nproj = np.dot(v, n) * n\nprint(proj)"
    },
    {
        "input": "Find a unit vector perpendicular to both [2, 1, 0] and [1, -1, 1].",
        "output": "import numpy as np\na = np.array([2, 1, 0])\nb = np.array([1, -1, 1])\nv = np.cross(a, b)\nunit = v / np.linalg.norm(v)\nprint(unit)"
    },
    {
        "input": "Compute the projection of [4, 1, -2] onto the space orthogonal to the vector [1, 0, -1].",
        "output": "import numpy as np\nv = np.array([4, 1, -2])\nn = np.array([1, 0, -1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize [3, 1, 0], [1, 1, 1], [0, 1, 2].",
        "output": "import numpy as np\ndef gram_schmidt(V):\n    U = []\n    for v in V:\n        v = v.astype(float)\n        for u in U:\n            v -= np.dot(v, u) * u\n        U.append(v / np.linalg.norm(v))\n    return np.array(U)\nV = [np.array([3, 1, 0], dtype=float), np.array([1, 1, 1], dtype=float), np.array([0, 1, 2], dtype=float)]\nQ = gram_schmidt(V)\nprint(Q)"
    },
    {
        "input": "Given a vector [1, 2, 2], compute its projection onto the span of [[1, 0, 0], [0, 1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1], [0, 1]])\nv = np.array([1, 2, 2])\nproj = A @ np.linalg.pinv(A) @ v\nprint(proj)"
    },
    {
        "input": "Let A = [[2, -1], [1, 1], [0, 1]]. Find the orthogonal projection of [3, 2, 1] onto Col(A).",
        "output": "import numpy as np\nA = np.array([[2, -1], [1, 1], [0, 1]])\nv = np.array([3, 2, 1])\nproj = A @ np.linalg.pinv(A) @ v\nprint(proj)"
    },
    {
        "input": "Find the component of [4, 4, 4] along the subspace defined by x + y + z = 0.",
        "output": "import numpy as np\nv = np.array([4, 4, 4])\nn = np.array([1, 1, 1])\ncomp_orth = (np.dot(v, n) / np.dot(n, n)) * n\nresidual = v - comp_orth\nprint(residual)"
    },
    {
        "input": "Let A = [[1, 0], [1, 1], [0, 1]]. Compute the projection matrix P = A(A^T A)^-1 A^T.",
        "output": "import numpy as np\nA = np.array([[1, 0], [1, 1], [0, 1]])\nP = A @ np.linalg.inv(A.T @ A) @ A.T\nprint(P)"
    },
    {
        "input": "Find a unit vector in the null space of A = [[1, 1, 0], [0, 1, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 1, 0], [0, 1, 1]])\nv = null_space(A)[:, 0]\nv = v / np.linalg.norm(v)\nprint(v)"
    },
    {
        "input": "Find the component of [2, 2, 1] perpendicular to the plane x + y + z = 6.",
        "output": "import numpy as np\nv = np.array([2, 2, 1])\nn = np.array([1, 1, 1])\ncomp = (np.dot(v, n) / np.dot(n, n)) * n\nprint(comp)"
    },
    {
        "input": "Let v = [1, 2, 3], find its projection onto the subspace orthogonal to [3, 2, 1].",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nn = np.array([3, 2, 1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find a unit vector in the plane x - y + z = 0 that is orthogonal to [2, 1, 0].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, -1, 1], [2, 1, 0]])\nv = null_space(A)[:, 0]\nv = v / np.linalg.norm(v)\nprint(v)"
    },
    {
        "input": "Given vectors u = [1, 2, 3] and v = [4, 5, 6], find the orthogonal projection of u onto v.",
        "output": "import numpy as np\nu = np.array([1, 2, 3])\nv = np.array([4, 5, 6])\nproj = (np.dot(u, v) / np.dot(v, v)) * v\nprint(proj)"
    },
    {
        "input": "Find the orthogonal projection of [3, -1, 4] onto the plane defined by x + y + z = 0.",
        "output": "import numpy as np\nv = np.array([3, -1, 4])\nn = np.array([1, 1, 1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Given A = [[1, 2], [3, 4], [5, 6]], compute the projection matrix onto Col(A).",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nP = A @ np.linalg.pinv(A)\nprint(P)"
    },
    {
        "input": "Find a vector orthogonal to both [1, 0, 1] and [0, 1, 1] and normalize it.",
        "output": "import numpy as np\na = np.array([1, 0, 1])\nb = np.array([0, 1, 1])\nv = np.cross(a, b)\nunit = v / np.linalg.norm(v)\nprint(unit)"
    },
    {
        "input": "Compute the dot product of vectors [3, 4] and [4, -3].",
        "output": "import numpy as np\na = np.array([3, 4])\nb = np.array([4, -3])\nprint(np.dot(a, b))"
    },
    {
        "input": "Normalize the vector [0, 3, 4].",
        "output": "import numpy as np\nv = np.array([0, 3, 4])\nnorm_v = v / np.linalg.norm(v)\nprint(norm_v)"
    },
    {
        "input": "Find the projection of [2, 3] onto [1, 0].",
        "output": "import numpy as np\nv = np.array([2, 3])\nu = np.array([1, 0])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the projection of [1, 2] onto [0, 1].",
        "output": "import numpy as np\nv = np.array([1, 2])\nu = np.array([0, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Compute the norm of vector [6, 8].",
        "output": "import numpy as np\nv = np.array([6, 8])\nnorm = np.linalg.norm(v)\nprint(norm)"
    },
    {
        "input": "Find the unit vector in the direction of [5, 12].",
        "output": "import numpy as np\nv = np.array([5, 12])\nunit = v / np.linalg.norm(v)\nprint(unit)"
    },
    {
        "input": "Calculate the projection of [2, 2] onto [1, 1].",
        "output": "import numpy as np\nv = np.array([2, 2])\nu = np.array([1, 1])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Project [3, 4, 0] onto [1, 2, 0] and compute the residual vector.",
        "output": "import numpy as np\nv = np.array([3, 4, 0])\nu = np.array([1, 2, 0])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nresidual = v - proj\nprint(residual)"
    },
    {
        "input": "Use Gram-Schmidt to orthonormalize the vectors [1, 1, 0] and [1, 0, 1].",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    u = []\n    for v in vectors:\n        for b in u:\n            v = v - np.dot(v, b) * b\n        u.append(v / np.linalg.norm(v))\n    return u\nvectors = [np.array([1, 1, 0]), np.array([1, 0, 1])]\nresult = gram_schmidt(vectors)\nprint(result)"
    },
    {
        "input": "Given A = [[1, 0], [1, 1], [0, 1]] and b = [2, 3, 4], compute the projection of b onto Col(A).",
        "output": "import numpy as np\nA = np.array([[1, 0], [1, 1], [0, 1]])\nb = np.array([2, 3, 4])\nproj = A @ np.linalg.pinv(A) @ b\nprint(proj)"
    },
    {
        "input": "Find an orthogonal basis for the subspace spanned by [1, 1, 0] and [1, -1, 2].",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    basis = []\n    for v in vectors:\n        for b in basis:\n            v = v - np.dot(v, b) / np.dot(b, b) * b\n        basis.append(v)\n    return basis\nvectors = [np.array([1, 1, 0]), np.array([1, -1, 2])]\northogonal_basis = gram_schmidt(vectors)\nprint(orthogonal_basis)"
    },
    {
        "input": "Compute the projection of vector [2, 1, 3] onto the plane x + y + z = 0.",
        "output": "import numpy as np\nv = np.array([2, 1, 3])\nn = np.array([1, 1, 1])\nproj = v - (np.dot(v, n) / np.dot(n, n)) * n\nprint(proj)"
    },
    {
        "input": "Find the projection of [1, 0, 0] onto the subspace spanned by [1, 1, 0] and [0, 1, 1].",
        "output": "import numpy as np\nA = np.array([[1, 0], [1, 1], [0, 1]])\nv = np.array([1, 0, 0])\nproj = A @ np.linalg.pinv(A) @ v\nprint(proj)"
    },
    {
        "input": "Use Gram-Schmidt to produce an orthonormal set from [2, 0], [1, 1].",
        "output": "import numpy as np\ndef gram_schmidt(V):\n    U = []\n    for v in V:\n        v = v.astype(float)\n        for u in U:\n            v -= np.dot(v, u) * u\n        U.append(v / np.linalg.norm(v))\n    return U\nV = [np.array([2, 0], dtype=float), np.array([1, 1], dtype=float)]\nQ = gram_schmidt(V)\nprint(Q)"
    },
    {
        "input": "Find a unit vector in the null space of matrix A = [[1, 2, 3], [4, 5, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 2, 3], [4, 5, 6]])\nns = null_space(A)\nunit_vector = ns[:, 0] / np.linalg.norm(ns[:, 0])\nprint(unit_vector)"
    },
    {
        "input": "Find a nonzero vector in the plane x + y + z = 0 that is orthogonal to [2, -1, 1].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 1, 1], [2, -1, 1]])\nv = null_space(A)[:, 0]\nv = v / np.linalg.norm(v)\nprint(v)"
    },
    {
        "input": "Given vectors u = [3, 0, 4] and v = [1, 2, -1], find the vector component of u orthogonal to v.",
        "output": "import numpy as np\nu = np.array([3, 0, 4])\nv = np.array([1, 2, -1])\nproj = (np.dot(u, v) / np.dot(v, v)) * v\north = u - proj\nprint(orth)"
    },
    {
        "input": "Given matrix A = [[2, -1], [1, 2], [0, 1]], find the projection matrix onto Col(A).",
        "output": "import numpy as np\nA = np.array([[2, -1], [1, 2], [0, 1]])\nATA_inv = np.linalg.inv(A.T @ A)\nP = A @ ATA_inv @ A.T\nprint(P)"
    },
    {
        "input": "Use the Gram-Schmidt process to orthonormalize the vectors [1, 2, 3], [4, 5, 6], and [7, 8, 9].",
        "output": "import numpy as np\ndef gram_schmidt(V):\n    U = []\n    for v in V:\n        for u in U:\n            v = v - np.dot(v, u) * u\n        if np.linalg.norm(v) > 1e-10:\n            U.append(v / np.linalg.norm(v))\n    return U\nV = [np.array([1, 2, 3]), np.array([4, 5, 6]), np.array([7, 8, 9])]\nQ = gram_schmidt(V)\nprint(Q)"
    },
    {
        "input": "Let A = [[1, 1, 0], [0, 1, 1], [1, 0, 1]]. Find an orthonormal basis for Col(A).",
        "output": "import numpy as np\ndef gram_schmidt(V):\n    U = []\n    for v in V:\n        for u in U:\n            v = v - np.dot(v, u) * u\n        if np.linalg.norm(v) > 1e-10:\n            U.append(v / np.linalg.norm(v))\n    return U\nA = np.array([[1, 1, 0], [0, 1, 1], [1, 0, 1]])\nvectors = A.T\nbasis = gram_schmidt([v for v in vectors])\nprint(basis)"
    },
    {
        "input": "Find the projection of vector [3, 1, 4] onto the null space of matrix A = [[1, 2, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nv = np.array([3, 1, 4])\nA = np.array([[1, 2, 3]])\nN = null_space(A)\nP = N @ np.linalg.pinv(N) @ v\nprint(P)"
    },
    {
        "input": "Given matrix A = [[1, 2], [2, 4]], find the projection matrix onto the row space of A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4]])\nR = A.T @ np.linalg.pinv(A @ A.T) @ A\nprint(R)"
    },
    {
        "input": "Find the least squares solution to Ax = b where A = [[1, 2], [3, 4], [5, 6]] and b = [7, 8, 9].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nb = np.array([7, 8, 9])\nx = np.linalg.lstsq(A, b, rcond=None)[0]\nprint(x)"
    },
    {
        "input": "Let A = [[1, 1], [1, -1]]. Find the projection of [2, 0] onto the column space of A.",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, -1]])\nv = np.array([2, 0])\nproj = A @ np.linalg.pinv(A) @ v\nprint(proj)"
    },
    {
        "input": "Given matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] and vector b = [1, 0, 1], find the orthogonal projection of b onto the column space of A using the projection matrix.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nb = np.array([1, 0, 1])\nP = A @ np.linalg.pinv(A)\nproj = P @ b\nprint(proj)"
    },
    {
        "input": "Given a vector v = [3, 4] in the standard basis, and a new basis B = [[1, 0], [0, 1]], find the coordinates of v in basis B.",
        "output": "import numpy as np\nv = np.array([3, 4])\nB = np.array([[1, 0], [0, 1]])\nB_inv = np.linalg.inv(B)\nv_coords = B_inv @ v\nprint(\"Coordinates of v in basis B:\", v_coords)"
    },
    {
        "input": "Convert the vector v = [2, -1] to coordinates in the new basis B = [[1, 1], [1, -1]].",
        "output": "import numpy as np\nv = np.array([2, -1])\nB = np.array([[1, 1], [1, -1]])\nB_inv = np.linalg.inv(B)\nv_coords = B_inv @ v\nprint(\"Coordinates of v in basis B:\", v_coords)"
    },
    {
        "input": "Find the standard coordinates of a vector whose coordinates in basis B = [[2, 0], [0, 3]] are [1, 2].",
        "output": "import numpy as np\nB = np.array([[2, 0], [0, 3]])\nv_coords = np.array([1, 2])\nv_standard = B @ v_coords\nprint(\"Vector in standard coordinates:\", v_standard)"
    },
    {
        "input": "Given basis B = [[1, 2], [0, 1]], find the matrix that changes coordinates from B to standard basis.",
        "output": "import numpy as np\nB = np.array([[1, 2], [0, 1]])\nchange_matrix = B\nprint(\"Change of basis matrix (B to standard):\\n\", change_matrix)"
    },
    {
        "input": "Given basis B = [[1, 2], [0, 1]], find the matrix that changes coordinates from standard basis to B.",
        "output": "import numpy as np\nB = np.array([[1, 2], [0, 1]])\nchange_matrix = np.linalg.inv(B)\nprint(\"Change of basis matrix (standard to B):\\n\", change_matrix)"
    },
    {
        "input": "If v = [7, 3] and basis B = [[3, 0], [0, 1]], what are the coordinates of v in B?",
        "output": "import numpy as np\nv = np.array([7, 3])\nB = np.array([[3, 0], [0, 1]])\nB_inv = np.linalg.inv(B)\nv_coords = B_inv @ v\nprint(\"Coordinates of v in B:\", v_coords)"
    },
    {
        "input": "Change the coordinates of v = [1, 1] from standard basis to B = [[1, 1], [1, -1]].",
        "output": "import numpy as np\nv = np.array([1, 1])\nB = np.array([[1, 1], [1, -1]])\nB_inv = np.linalg.inv(B)\nv_B = B_inv @ v\nprint(\"Coordinates of v in basis B:\", v_B)"
    },
    {
        "input": "Given a vector in B-coordinates [2, 0], and B = [[4, 1], [0, 2]], find its coordinates in standard basis.",
        "output": "import numpy as np\nB = np.array([[4, 1], [0, 2]])\nv_B = np.array([2, 0])\nv_std = B @ v_B\nprint(\"Vector in standard coordinates:\", v_std)"
    },
    {
        "input": "Find the matrix to convert coordinates from basis A = [[1, 0], [1, 1]] to basis B = [[1, 1], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [1, 1]])\nB = np.array([[1, 1], [0, 1]])\nA_to_B = np.linalg.inv(B) @ A\nprint(\"Change of basis matrix from A to B:\\n\", A_to_B)"
    },
    {
        "input": "A vector has coordinates [3, 2] in basis B = [[2, 0], [1, 1]]. Convert it to standard basis.",
        "output": "import numpy as np\nB = np.array([[2, 0], [1, 1]])\nv_B = np.array([3, 2])\nv_std = B @ v_B\nprint(\"Vector in standard basis:\", v_std)"
    },
    {
        "input": "Find coordinates of v = [4, 4] in basis B = [[2, 2], [0, 1]].",
        "output": "import numpy as np\nv = np.array([4, 4])\nB = np.array([[2, 2], [0, 1]])\nB_inv = np.linalg.inv(B)\nv_B = B_inv @ v\nprint(\"Coordinates of v in basis B:\", v_B)"
    },
    {
        "input": "Change of basis matrix from standard basis to B = [[1, 2], [3, 4]]?",
        "output": "import numpy as np\nB = np.array([[1, 2], [3, 4]])\nchange_matrix = np.linalg.inv(B)\nprint(\"Change of basis matrix (standard to B):\\n\", change_matrix)"
    },
    {
        "input": "If v = [5, -3] in standard basis and B = [[1, -1], [1, 1]], find its coordinates in B.",
        "output": "import numpy as np\nv = np.array([5, -3])\nB = np.array([[1, -1], [1, 1]])\nB_inv = np.linalg.inv(B)\nv_B = B_inv @ v\nprint(\"Coordinates in basis B:\", v_B)"
    },
    {
        "input": "Given two bases A = [[1, 0], [0, 1]] and B = [[0, 1], [-1, 0]], find matrix to convert from A to B.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1]])\nB = np.array([[0, 1], [-1, 0]])\nchange_matrix = np.linalg.inv(B) @ A\nprint(\"Change of basis from A to B:\\n\", change_matrix)"
    },
    {
        "input": "Convert v = [1, 0] from standard basis to basis B = [[2, 1], [0, 1]].",
        "output": "import numpy as np\nv = np.array([1, 0])\nB = np.array([[2, 1], [0, 1]])\nB_inv = np.linalg.inv(B)\nv_B = B_inv @ v\nprint(\"Coordinates of v in B:\", v_B)"
    },
    {
        "input": "Find vector in basis B = [[1, 1], [1, -1]] that corresponds to standard vector [3, 1].",
        "output": "import numpy as np\nv = np.array([3, 1])\nB = np.array([[1, 1], [1, -1]])\nB_inv = np.linalg.inv(B)\nv_B = B_inv @ v\nprint(\"Coordinates in basis B:\", v_B)"
    },
    {
        "input": "Find change of basis matrix from basis B to basis A, where B = [[1, 2], [3, 4]], A = [[2, 0], [0, 2]].",
        "output": "import numpy as np\nB = np.array([[1, 2], [3, 4]])\nA = np.array([[2, 0], [0, 2]])\nB_to_A = np.linalg.inv(A) @ B\nprint(\"Change of basis matrix from B to A:\\n\", B_to_A)"
    },
    {
        "input": "What are the coordinates of [0, 2] in basis B = [[1, 0], [1, 1]]?",
        "output": "import numpy as np\nv = np.array([0, 2])\nB = np.array([[1, 0], [1, 1]])\nB_inv = np.linalg.inv(B)\nv_B = B_inv @ v\nprint(\"Coordinates in basis B:\", v_B)"
    },
    {
        "input": "Given v = [1, -1] in standard basis, and B = [[2, 2], [0, 1]], find v in B-coordinates.",
        "output": "import numpy as np\nv = np.array([1, -1])\nB = np.array([[2, 2], [0, 1]])\nB_inv = np.linalg.inv(B)\nv_B = B_inv @ v\nprint(\"Coordinates of v in B:\", v_B)"
    },
    {
        "input": "Convert the 3D vector v = [3, 2, 1] into coordinates with respect to the basis B = [[1, 0, 1], [0, 1, 1], [1, 1, 0]].",
        "output": "import numpy as np\nv = np.array([3, 2, 1])\nB = np.array([[1, 0, 1], [0, 1, 1], [1, 1, 0]])\nB_inv = np.linalg.inv(B)\nv_B = B_inv @ v\nprint(\"Coordinates of v in basis B:\", v_B)"
    },
    {
        "input": "A vector v has coordinates [1, 0, 2] in basis B = [[1, 1, 0], [0, 1, 1], [1, 0, 1]]. Find v in the standard basis.",
        "output": "import numpy as np\nB = np.array([[1, 1, 0], [0, 1, 1], [1, 0, 1]])\nv_B = np.array([1, 0, 2])\nv_std = B @ v_B\nprint(\"Vector in standard coordinates:\", v_std)"
    },
    {
        "input": "Find the change of basis matrix from basis A = [[1, 1], [0, 2]] to B = [[2, 0], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1], [0, 2]])\nB = np.array([[2, 0], [1, 1]])\nchange_matrix = np.linalg.inv(B) @ A\nprint(\"Change of basis matrix from A to B:\\n\", change_matrix)"
    },
    {
        "input": "Transform v = [1, 2, 3] from standard basis to basis B = [[1, 2, 3], [0, 1, 1], [0, 0, 1]].",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nB = np.array([[1, 2, 3], [0, 1, 1], [0, 0, 1]])\nB_inv = np.linalg.inv(B)\nv_B = B_inv @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "Let A and B be bases in R^2. A = [[1, 1], [0, 2]], B = [[2, 3], [1, 4]]. Find the matrix that converts from B to A.",
        "output": "import numpy as np\nA = np.array([[1, 1], [0, 2]])\nB = np.array([[2, 3], [1, 4]])\nB_to_A = np.linalg.inv(A) @ B\nprint(\"Change of basis matrix from B to A:\\n\", B_to_A)"
    },
    {
        "input": "Convert v = [2, 2] from basis A = [[1, 0], [0, 2]] to basis B = [[1, 1], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 2]])\nB = np.array([[1, 1], [0, 1]])\nv_A = np.array([2, 2])\nstandard = A @ v_A\nv_B = np.linalg.inv(B) @ standard\nprint(\"Coordinates in basis B:\", v_B)"
    },
    {
        "input": "Given v in B-coordinates as [1, 2, 3], and B = [[1, 0, 1], [0, 1, 1], [1, 1, 0]], find v in standard basis.",
        "output": "import numpy as np\nB = np.array([[1, 0, 1], [0, 1, 1], [1, 1, 0]])\nv_B = np.array([1, 2, 3])\nv_std = B @ v_B\nprint(\"Vector in standard coordinates:\", v_std)"
    },
    {
        "input": "Compute the transformation matrix T that changes coordinates from B = [[1, 1], [1, -1]] to standard basis.",
        "output": "import numpy as np\nB = np.array([[1, 1], [1, -1]])\nT = B\nprint(\"Transformation matrix T (B to standard):\\n\", T)"
    },
    {
        "input": "Find the inverse transformation matrix for B = [[3, 1], [2, 4]].",
        "output": "import numpy as np\nB = np.array([[3, 1], [2, 4]])\nB_inv = np.linalg.inv(B)\nprint(\"Inverse transformation matrix for B:\\n\", B_inv)"
    },
    {
        "input": "Convert coordinates [1, 2] in basis B = [[1, 2], [3, 4]] to standard basis, then to C = [[0, 1], [1, 0]].",
        "output": "import numpy as np\nB = np.array([[1, 2], [3, 4]])\nC = np.array([[0, 1], [1, 0]])\nv_B = np.array([1, 2])\nstandard = B @ v_B\nv_C = np.linalg.inv(C) @ standard\nprint(\"Coordinates in C:\", v_C)"
    },
    {
        "input": "Let A = [[2, 1], [1, 2]], and a vector has standard coordinates [5, 5]. Find coordinates in basis A.",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\nv = np.array([5, 5])\nv_A = np.linalg.inv(A) @ v\nprint(\"Coordinates in basis A:\", v_A)"
    },
    {
        "input": "Given 3D vector v = [4, 2, 0] and basis B = [[1, 1, 0], [0, 1, 1], [1, 0, 1]], express v in B-coordinates.",
        "output": "import numpy as np\nv = np.array([4, 2, 0])\nB = np.array([[1, 1, 0], [0, 1, 1], [1, 0, 1]])\nB_inv = np.linalg.inv(B)\nv_B = B_inv @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "What matrix transforms coordinates from B = [[1, 2], [0, 1]] to C = [[2, 0], [1, 1]]?",
        "output": "import numpy as np\nB = np.array([[1, 2], [0, 1]])\nC = np.array([[2, 0], [1, 1]])\nB_to_C = np.linalg.inv(C) @ B\nprint(\"Change of basis matrix from B to C:\\n\", B_to_C)"
    },
    {
        "input": "Vector has coordinates [1, 1] in B = [[1, 1], [1, -1]]. Convert to basis C = [[2, 0], [0, 2]].",
        "output": "import numpy as np\nB = np.array([[1, 1], [1, -1]])\nC = np.array([[2, 0], [0, 2]])\nv_B = np.array([1, 1])\nstandard = B @ v_B\nv_C = np.linalg.inv(C) @ standard\nprint(\"Coordinates in basis C:\", v_C)"
    },
    {
        "input": "Change of basis matrix from orthogonal basis B = [[1, 0], [0, 2]] to C = [[1, 1], [-1, 1]]?",
        "output": "import numpy as np\nB = np.array([[1, 0], [0, 2]])\nC = np.array([[1, 1], [-1, 1]])\nB_to_C = np.linalg.inv(C) @ B\nprint(\"Change of basis from B to C:\\n\", B_to_C)"
    },
    {
        "input": "Find matrix that maps coordinates from standard basis to orthogonal basis B = [[0, 1], [-1, 0]].",
        "output": "import numpy as np\nB = np.array([[0, 1], [-1, 0]])\nchange_matrix = np.linalg.inv(B)\nprint(\"Standard to B transformation matrix:\\n\", change_matrix)"
    },
    {
        "input": "Given B = [[1, 2], [3, 4]] and C = [[0, 1], [1, 1]], find the matrix to go from B to C.",
        "output": "import numpy as np\nB = np.array([[1, 2], [3, 4]])\nC = np.array([[0, 1], [1, 1]])\nB_to_C = np.linalg.inv(C) @ B\nprint(\"Change of basis from B to C:\\n\", B_to_C)"
    },
    {
        "input": "Convert vector [1, 0, -1] from basis A = [[1, 1, 0], [0, 1, 1], [1, 0, 1]] to standard basis.",
        "output": "import numpy as np\nA = np.array([[1, 1, 0], [0, 1, 1], [1, 0, 1]])\nv_A = np.array([1, 0, -1])\nv_std = A @ v_A\nprint(\"Vector in standard basis:\", v_std)"
    },
    {
        "input": "Find the basis matrix B such that standard vector [3, 3] has coordinates [1, 1] in B.",
        "output": "import numpy as np\nv = np.array([3, 3])\ncoords = np.array([1, 1])\nB = np.column_stack((v / coords[0], v / coords[1])) / 2\nprint(\"Basis B:\\n\", B)"
    },
    {
        "input": "Vector v = [2, 1] in standard basis. Find its coordinates in rotated basis B = [[cos(pi/4), -sin(pi/4)], [sin(pi/4), cos(pi/4)]].",
        "output": "import numpy as np\nfrom math import pi, cos, sin\nv = np.array([2, 1])\nB = np.array([[cos(pi/4), -sin(pi/4)], [sin(pi/4), cos(pi/4)]])\nB_inv = np.linalg.inv(B)\nv_B = B_inv @ v\nprint(\"Coordinates in rotated basis B:\", v_B)"
    },
    {
        "input": "Given a matrix A = [[2, 0], [0, 3]] and a basis B = [[1, 1], [1, -1]], find the matrix of A in basis B.",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 3]])\nB = np.array([[1, 1], [1, -1]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nprint(\"Matrix A in basis B:\\n\", A_B)"
    },
    {
        "input": "Find the change of basis matrix from basis B = [[1, 0], [2, 1]] to C = [[2, 1], [1, 1]], and then apply it to vector [3, 4].",
        "output": "import numpy as np\nB = np.array([[1, 0], [2, 1]])\nC = np.array([[2, 1], [1, 1]])\nv_B = np.array([3, 4])\nP = np.linalg.inv(C) @ B\nv_C = P @ v_B\nprint(\"Coordinates in basis C:\", v_C)"
    },
    {
        "input": "Find the matrix representation of reflection over the x-axis in the basis B = [[1, 1], [1, -1]].",
        "output": "import numpy as np\nT_std = np.array([[1, 0], [0, -1]])\nB = np.array([[1, 1], [1, -1]])\nP = B\nP_inv = np.linalg.inv(P)\nT_B = P_inv @ T_std @ P\nprint(\"Reflection matrix in basis B:\\n\", T_B)"
    },
    {
        "input": "Let A = [[4, 1], [2, 3]]. Find its representation in the eigenbasis.",
        "output": "import numpy as np\nA = np.array([[4, 1], [2, 3]])\nevals, evecs = np.linalg.eig(A)\nP = evecs\nP_inv = np.linalg.inv(P)\nA_diag = P_inv @ A @ P\nprint(\"Diagonal representation of A:\\n\", A_diag)"
    },
    {
        "input": "Convert the vector v = [1, 2, 3] from standard basis to orthonormal basis B = [[1/âˆš3, 1/âˆš3, 1/âˆš3], [1/âˆš2, -1/âˆš2, 0], [1/âˆš6, 1/âˆš6, -2/âˆš6]].",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nB = np.array([\n    [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)],\n    [1/np.sqrt(2), -1/np.sqrt(2), 0],\n    [1/np.sqrt(6), 1/np.sqrt(6), -2/np.sqrt(6)]\n])\nv_B = B @ v\nprint(\"Coordinates in orthonormal basis B:\", v_B)"
    },
    {
        "input": "Let T be a linear transformation that scales by 2 in x-direction and rotates 90 degrees. Find T in basis B = [[1, 0], [1, 1]].",
        "output": "import numpy as np\nS = np.array([[2, 0], [0, 1]])\nR = np.array([[0, -1], [1, 0]])\nT = R @ S\nB = np.array([[1, 0], [1, 1]])\nP = B\nP_inv = np.linalg.inv(P)\nT_B = P_inv @ T @ P\nprint(\"T in basis B:\\n\", T_B)"
    },
    {
        "input": "Let matrix A = [[0, -1], [1, 0]] represent 90-degree rotation. Find its representation in basis B = [[2, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\nB = np.array([[2, 1], [1, 2]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nprint(\"Matrix A in basis B:\\n\", A_B)"
    },
    {
        "input": "Find the coordinates of v = [5, -3] in the basis formed by the eigenvectors of A = [[2, 1], [1, 2]].",
        "output": "import numpy as np\nv = np.array([5, -3])\nA = np.array([[2, 1], [1, 2]])\n_, evecs = np.linalg.eig(A)\nv_new = np.linalg.inv(evecs) @ v\nprint(\"Coordinates of v in the eigenbasis:\", v_new)"
    },
    {
        "input": "Given a 3x3 rotation matrix R for 45 degrees around z-axis, express vector [1, 0, 0] in the rotated frame.",
        "output": "import numpy as np\nangle = np.pi / 4\nR = np.array([\n    [np.cos(angle), -np.sin(angle), 0],\n    [np.sin(angle), np.cos(angle), 0],\n    [0, 0, 1]\n])\nv = np.array([1, 0, 0])\nv_rot = np.linalg.inv(R) @ v\nprint(\"Vector in rotated frame:\", v_rot)"
    },
    {
        "input": "Compute the matrix representation of the derivative operator d/dx on the space spanned by {1, x, x^2} using finite difference.",
        "output": "import numpy as np\nX = np.array([[1, 0, 0], [1, 1, 1], [1, 2, 4]])\ndX = np.array([[0, 1, 0], [0, 1, 2], [0, 1, 4]])\nD = np.linalg.lstsq(X, dX, rcond=None)[0]\nprint(\"Derivative matrix in basis {1, x, x^2} (approx.):\\n\", D)"
    },
    {
        "input": "Find the transition matrix from standard basis to eigenbasis of A = [[5, 2], [2, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 2], [2, 5]])\n_, evecs = np.linalg.eig(A)\nP = evecs\nprint(\"Transition matrix to eigenbasis:\\n\", P)"
    },
    {
        "input": "Express v = [2, -1] in terms of the basis vectors [3, 1] and [1, -1].",
        "output": "import numpy as np\nB = np.array([[3, 1], [1, -1]])\nv = np.array([2, -1])\nv_B = np.linalg.inv(B) @ v\nprint(\"Coordinates in new basis:\", v_B)"
    },
    {
        "input": "Compute the inverse of a change of basis matrix from B = [[1, 2], [2, 3]] to standard basis.",
        "output": "import numpy as np\nB = np.array([[1, 2], [2, 3]])\nP = B\nP_inv = np.linalg.inv(P)\nprint(\"Inverse of change of basis matrix:\\n\", P_inv)"
    },
    {
        "input": "A linear operator T has matrix [[1, 2], [3, 4]] in basis B = [[1, 0], [1, 1]]. Find its matrix in standard basis.",
        "output": "import numpy as np\nT_B = np.array([[1, 2], [3, 4]])\nB = np.array([[1, 0], [1, 1]])\nP = B\nT_std = P @ T_B @ np.linalg.inv(P)\nprint(\"Matrix in standard basis:\\n\", T_std)"
    },
    {
        "input": "Given a symmetric matrix A = [[4, 2], [2, 3]], find the orthogonal matrix that diagonalizes it.",
        "output": "import numpy as np\nA = np.array([[4, 2], [2, 3]])\nevals, evecs = np.linalg.eigh(A)\nprint(\"Orthogonal matrix (eigenvectors):\\n\", evecs)"
    },
    {
        "input": "Let v = [1, 1, 0]. Find its coordinates in the basis B = [[1, 0, 1], [0, 1, 1], [1, 1, 0]].",
        "output": "import numpy as np\nv = np.array([1, 1, 0])\nB = np.array([[1, 0, 1], [0, 1, 1], [1, 1, 0]])\nB_inv = np.linalg.inv(B)\nv_B = B_inv @ v\nprint(\"Coordinates in basis B:\", v_B)"
    },
    {
        "input": "If a matrix T acts as a reflection about the line y = -x, express T in the eigenbasis of T.",
        "output": "import numpy as np\nT = np.array([[0, -1], [-1, 0]])\nevals, evecs = np.linalg.eig(T)\nT_diag = np.linalg.inv(evecs) @ T @ evecs\nprint(\"Matrix T in eigenbasis:\\n\", T_diag)"
    },
    {
        "input": "Given the basis B = [[1, 2], [2, 3]], express vector v = [4, 5] in coordinates relative to B.",
        "output": "import numpy as np\nB = np.array([[1, 2], [2, 3]])\nv = np.array([4, 5])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "Let A = [[1, 1], [0, 2]] and B = [[1, 0], [1, 1]]. Compute the matrix A in the basis B.",
        "output": "import numpy as np\nA = np.array([[1, 1], [0, 2]])\nB = np.array([[1, 0], [1, 1]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nprint(\"Matrix A in basis B:\\n\", A_B)"
    },
    {
        "input": "Express the function f(x) = x + 2x^2 in the basis {1, x, x^2}.",
        "output": "import numpy as np\nf_coeffs = np.array([0, 1, 2])\nprint(\"Coordinates of f(x) in standard polynomial basis:\", f_coeffs)"
    },
    {
        "input": "Let T be the derivative operator d/dx on the basis {1, x, x^2}. Find its matrix representation.",
        "output": "import numpy as np\nD = np.array([\n    [0, 1, 0],\n    [0, 0, 2],\n    [0, 0, 0]\n])\nprint(\"Matrix of d/dx in {1, x, x^2} basis:\\n\", D)"
    },
    {
        "input": "A 3x3 matrix A = [[1,2,0],[0,1,0],[0,0,3]] acts on ℝ³. Find its representation in basis B = [[1,0,0],[1,1,0],[0,0,1]].",
        "output": "import numpy as np\nA = np.array([[1,2,0],[0,1,0],[0,0,3]])\nB = np.array([[1,0,0],[1,1,0],[0,0,1]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nprint(\"A in basis B:\\n\", A_B)"
    },
    {
        "input": "Given A = [[3, 1], [0, 2]], find the basis that diagonalizes it and write A in that basis.",
        "output": "import numpy as np\nA = np.array([[3, 1], [0, 2]])\nevals, evecs = np.linalg.eig(A)\nA_diag = np.linalg.inv(evecs) @ A @ evecs\nprint(\"Diagonal form of A:\\n\", A_diag)"
    },
    {
        "input": "Given the vector v = [2, -2, 1], express it in the basis B = [[1, 0, 1], [0, 1, 0], [1, 0, -1]].",
        "output": "import numpy as np\nv = np.array([2, -2, 1])\nB = np.array([[1, 0, 1], [0, 1, 0], [1, 0, -1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "Let T rotate vectors by 180 degrees. Find the matrix representation in standard basis and in B = [[1, 1], [1, -1]].",
        "output": "import numpy as np\nT_std = -np.eye(2)\nB = np.array([[1, 1], [1, -1]])\nT_B = np.linalg.inv(B) @ T_std @ B\nprint(\"T in standard basis:\\n\", T_std)\nprint(\"T in basis B:\\n\", T_B)"
    },
    {
        "input": "Given A = [[1, 4], [2, 3]], find its matrix in the eigenbasis of A.",
        "output": "import numpy as np\nA = np.array([[1, 4], [2, 3]])\nevals, evecs = np.linalg.eig(A)\nA_diag = np.linalg.inv(evecs) @ A @ evecs\nprint(\"A in its eigenbasis:\\n\", A_diag)"
    },
    {
        "input": "Let B and C be two bases for ℝ²: B = [[2, 1], [1, 1]], C = [[1, 0], [0, 2]]. Find the transition matrix from B to C.",
        "output": "import numpy as np\nB = np.array([[2, 1], [1, 1]])\nC = np.array([[1, 0], [0, 2]])\nT = np.linalg.inv(C) @ B\nprint(\"Transition matrix from B to C:\\n\", T)"
    },
    {
        "input": "Given a transformation T: ℝ² → ℝ² defined by T(x, y) = (x + y, x - y), find its matrix in the standard basis.",
        "output": "import numpy as np\nT = np.array([[1, 1], [1, -1]])\nprint(\"Matrix of T in standard basis:\\n\", T)"
    },
    {
        "input": "Convert the coordinates [1, 0, -1] from basis B = [[1, 1, 0], [0, 1, 1], [1, 0, 1]] to standard basis.",
        "output": "import numpy as np\nB = np.array([[1, 1, 0], [0, 1, 1], [1, 0, 1]])\nv_B = np.array([1, 0, -1])\nv_std = B @ v_B\nprint(\"Vector in standard basis:\", v_std)"
    },
    {
        "input": "The matrix A = [[0, 1], [-1, 0]] represents rotation. Find a basis in which it becomes diagonal (if possible).",
        "output": "import numpy as np\nA = np.array([[0, 1], [-1, 0]])\nevals, evecs = np.linalg.eig(A)\nprint(\"Eigenvalues:\", evals)\nprint(\"Eigenvectors (possibly complex):\\n\", evecs)"
    },
    {
        "input": "Find the coordinates of vector [3, 3] in the orthonormal basis B = [[1/√2, 1/√2], [-1/√2, 1/√2]].",
        "output": "import numpy as np\nv = np.array([3, 3])\nB = np.array([[1/np.sqrt(2), 1/np.sqrt(2)], [-1/np.sqrt(2), 1/np.sqrt(2)]])\nv_B = B @ v\nprint(\"Coordinates in basis B:\", v_B)"
    },
    {
        "input": "Let v = [4, -1], and B = [[2, 3], [1, 4]]. Find v in coordinates of B and then reconstruct v from those coordinates.",
        "output": "import numpy as np\nB = np.array([[2, 3], [1, 4]])\nv = np.array([4, -1])\nv_B = np.linalg.inv(B) @ v\nv_reconstructed = B @ v_B\nprint(\"v in basis B:\", v_B)\nprint(\"Reconstructed v:\", v_reconstructed)"
    },
    {
        "input": "Find the matrix representation of projection onto x-axis in basis B = [[1, 0], [1, 1]].",
        "output": "import numpy as np\nP_std = np.array([[1, 0], [0, 0]])\nB = np.array([[1, 0], [1, 1]])\nP_B = np.linalg.inv(B) @ P_std @ B\nprint(\"Projection in basis B:\\n\", P_B)"
    },
    {
        "input": "Given a 3D transformation T represented by A = [[1,0,0],[0,2,0],[0,0,3]], find A in basis B = [[1,1,0],[0,1,1],[1,0,1]].",
        "output": "import numpy as np\nA = np.diag([1,2,3])\nB = np.array([[1,1,0],[0,1,1],[1,0,1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"A in basis B:\\n\", A_B)"
    },
    {
        "input": "Let T(x, y) = (2x + y, x - y). Find the matrix of T in basis B = [[1, 1], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, -1]])\nB = np.array([[1, 1], [0, 1]])\nT_B = np.linalg.inv(B) @ A @ B\nprint(\"T in basis B:\\n\", T_B)"
    },
    {
        "input": "Diagonalize the matrix A = [[6, 2], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[6, 2], [2, 3]])\nevals, evecs = np.linalg.eig(A)\nD = np.linalg.inv(evecs) @ A @ evecs\nprint(\"Diagonal matrix:\\n\", D)"
    },
    {
        "input": "Let vector v = [1, 2] be in coordinates of basis B = [[3, 1], [1, 2]]. Convert it to standard basis.",
        "output": "import numpy as np\nB = np.array([[3, 1], [1, 2]])\nv_B = np.array([1, 2])\nv_std = B @ v_B\nprint(\"v in standard basis:\", v_std)"
    },
    {
        "input": "Let T: ℝ² → ℝ² be reflection over y-axis. Express T in basis B = [[1, 0], [1, 1]].",
        "output": "import numpy as np\nT_std = np.array([[-1, 0], [0, 1]])\nB = np.array([[1, 0], [1, 1]])\nT_B = np.linalg.inv(B) @ T_std @ B\nprint(\"T in basis B:\\n\", T_B)"
    },
    {
        "input": "Let T: ℝ² → ℝ² be defined as T(x, y) = (3x - y, x + 4y). Diagonalize T, if possible. If not, compute its Jordan form.",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[3, -1], [1, 4]])\nP, J = A.jordan_form()\nprint(\"Jordan Form J:\")\nsp.pprint(J)\nprint(\"Transformation Matrix P:\")\nsp.pprint(P)"
    },
    {
        "input": "Let f(x) = 3 + 2x - x^2 in basis B = {1 - x, x, x^2}. Express f in coordinates of B.",
        "output": "import numpy as np\nB = np.array([[1, -1, 0], [0, 1, 0], [0, 0, 1]]).T\nf = np.array([3, 2, -1])\nf_B = np.linalg.inv(B) @ f\nprint(\"f(x) in basis B:\", f_B)"
    },
    {
        "input": "Let B be the basis {1, x, x^2} and T: f(x) ↦ f''(x). Find the matrix of T in basis B.",
        "output": "import numpy as np\nT = np.array([[0, 0, 2], [0, 0, 0], [0, 0, 0]])\nprint(\"Matrix of f'' in basis {1, x, x^2}:\", T)"
    },
    {
        "input": "Let M be the space of 2x2 symmetric matrices. Find a basis for M and represent A = [[1, 2], [2, 3]] in this basis.",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 3]])\ncoords = [A[0,0], A[0,1], A[1,1]]\nprint(\"Coordinates of A in symmetric matrix basis:\", coords)"
    },
    {
        "input": "Let T: ℝ³ → ℝ³ be defined by T(x, y, z) = (x + y, y + z, x + z). Find its matrix and diagonalize it if possible.",
        "output": "import numpy as np\nA = np.array([[1, 1, 0], [0, 1, 1], [1, 0, 1]])\nevals, evecs = np.linalg.eig(A)\nprint(\"Eigenvalues:\", evals)\nprint(\"Eigenvectors:\\n\", evecs)"
    },
    {
        "input": "Find the matrix of the Laplace operator (∂²/∂x²) on basis {1, x, x², x³}.",
        "output": "import numpy as np\nL = np.array([[0, 0, 2, 0], [0, 0, 0, 6], [0, 0, 0, 0], [0, 0, 0, 0]])\nprint(\"Laplace operator matrix on {1, x, x², x³}:\", L)"
    },
    {
        "input": "Let A = [[2, 0], [0, 3]], B = [[1, 2], [0, 1]]. Compute A in basis B and its inverse in that basis.",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 3]])\nB = np.array([[1, 2], [0, 1]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nA_inv_B = np.linalg.inv(A_B)\nprint(\"A in basis B:\\n\", A_B)\nprint(\"Inverse of A in basis B:\\n\", A_inv_B)"
    },
    {
        "input": "Let v = 3x + 4x². Express in B = {x - 1, x² + x}.",
        "output": "import numpy as np\nv_B = np.array([-1, 4])\nprint(\"Coordinates in basis B:\", v_B)"
    },
    {
        "input": "Let v = [1, 0, -1] in standard basis. Convert to basis B = [[1, 1, 0], [1, -1, 0], [0, 0, 1]].",
        "output": "import numpy as np\nv = np.array([1, 0, -1])\nB = np.array([[1, 1, 0], [1, -1, 0], [0, 0, 1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "Find the matrix representing T(f) = f' in the basis {1, x, x², x³}.",
        "output": "import numpy as np\nT = np.array([[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3], [0, 0, 0, 0]])\nprint(\"Matrix of derivative operator:\", T)"
    },
    {
        "input": "Let v = [3, -1] in basis B = [[2, 1], [1, 3]]. Find v in standard basis and then verify it satisfies the transformation matrix A = [[1,2],[3,4]] in that basis.",
        "output": "import numpy as np\nB = np.array([[2, 1], [1, 3]])\nv_B = np.array([3, -1])\nv_std = B @ v_B\nA = np.array([[1,2],[3,4]])\nAv = A @ v_std\nprint(\"v in standard basis:\", v_std)\nprint(\"A*v:\", Av)"
    },
    {
        "input": "Given T(x,y) = (x + 2y, 3x + 4y), find matrix of T in eigenbasis.",
        "output": "import numpy as np\nA = np.array([[1,2],[3,4]])\nevals, evecs = np.linalg.eig(A)\nT_diag = np.linalg.inv(evecs) @ A @ evecs\nprint(\"T in eigenbasis:\\n\", T_diag)"
    },
    {
        "input": "Let T be the integral operator: T(f) = ∫f from 0 to x. Represent T on {1, x, x²}.",
        "output": "import numpy as np\nT = np.array([[0, 0, 0], [1, 0, 0], [0, 0.5, 0]])\nprint(\"Integral operator matrix:\", T)"
    },
    {
        "input": "Let f(x) = 5 + 3x - x² + x³. Express it in basis {1+x, x² - 1, x³}.",
        "output": "import sympy as sp\nx = sp.Symbol('x')\na, b, c = sp.symbols('a b c')\nf = 5 + 3*x - x**2 + x**3\nb1 = 1 + x\nb2 = x**2 - 1\nb3 = x**3\nexpr = f - (a*b1 + b*b2 + c*b3)\ncoeffs = sp.linsolve([sp.expand(expr)], (a, b, c))\nprint(\"Coordinates in custom basis:\", list(coeffs)[0])"
    },
    {
        "input": "Let f(x) = x³ + 2x² - x + 5. Find its coordinate vector relative to B = {x³ + x, x² - 1, x - 2, 1}.",
        "output": "import sympy as sp\nx = sp.Symbol('x')\nf = x**3 + 2*x**2 - x + 5\nB = [x**3 + x, x**2 - 1, x - 2, 1]\na, b, c, d = sp.symbols('a b c d')\neq = sp.Eq(f, a*B[0] + b*B[1] + c*B[2] + d*B[3])\ncoeffs = sp.solve(eq, (a, b, c, d))\nprint(\"Coordinates in B:\", coeffs)"
    },
    {
        "input": "Let T be defined on ℝ⁴ by projecting any vector onto the subspace W spanned by [1,1,1,1]. Find the matrix of T.",
        "output": "import numpy as np\nw = np.array([[1], [1], [1], [1]])\nP = (w @ w.T) / (w.T @ w)\nprint(\"Projection matrix T onto W:\", P)"
    },
    {
        "input": "In inner product space V with basis B = {[1,0], [1,1]}, find the Gram matrix of B.",
        "output": "import numpy as np\nB = np.array([[1, 1], [0, 1]])\nG = B.T @ B\nprint(\"Gram matrix of B:\", G)"
    },
    {
        "input": "Given the space of polynomials P₄, define the differential operator D². Find the matrix of D² relative to the basis {1, x, x², x³, x⁴}.",
        "output": "import numpy as np\nD2 = np.zeros((5, 5))\nD2[0][2] = 2\nD2[1][3] = 6\nD2[2][4] = 12\nprint(\"Matrix of second derivative D²:\", D2)"
    },
    {
        "input": "Find the change-of-basis matrix from B = {1, x, x²} to B' = {x², x, 1}.",
        "output": "import numpy as np\nP = np.array([[0, 0, 1], [0, 1, 0], [1, 0, 0]])\nprint(\"Change of basis matrix B to B':\", P)"
    },
    {
        "input": "Let V = M₂×₂, the space of 2x2 matrices. Define B = {[1,0;0,0], [0,1;0,0], [0,0;1,0], [0,0;0,1]}. Find coordinates of A = [[2,3],[4,5]] in B.",
        "output": "import numpy as np\nA = np.array([[2,3],[4,5]])\ncoords = A.flatten()\nprint(\"Coordinates of A in standard matrix basis:\", coords)"
    },
    {
        "input": "Given a symmetric bilinear form B on ℝ² defined by B(x,y) = x₁y₁ + 2x₁y₂ + 2x₂y₁ + 4x₂y₂, find its matrix and diagonalize it.",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4]])\nevals, evecs = np.linalg.eigh(A)\nprint(\"Diagonal form (eigenvalues):\", evals)"
    },
    {
        "input": "Let f(x) = x³ + 1. Express f in basis B = {1 + x, x + x², x² + x³, x³}.",
        "output": "import sympy as sp\nx = sp.Symbol('x')\nf = x**3 + 1\nB = [1 + x, x + x**2, x**2 + x**3, x**3]\na,b,c,d = sp.symbols('a b c d')\neq = sp.Eq(f, a*B[0] + b*B[1] + c*B[2] + d*B[3])\ncoeffs = sp.solve(eq, (a,b,c,d))\nprint(\"Coordinates in B:\", coeffs)"
    },
    {
        "input": "Let V be ℝ³ with the inner product ⟨x,y⟩ = xᵀWy, where W = [[2,0,0],[0,3,0],[0,0,4]]. Find an orthonormal basis under this product.",
        "output": "import numpy as np\nfrom scipy.linalg import sqrtm\nW = np.diag([2,3,4])\nB = np.eye(3)\nS = np.linalg.inv(sqrtm(W))\northo = S @ B\nprint(\"Orthonormal basis under W:\", ortho)"
    },
    {
        "input": "Let f be a linear functional on P₂ defined by f(p) = p(1) + p'(2). Find its coordinate in dual basis to {1, x, x²}.",
        "output": "import sympy as sp\nx = sp.Symbol('x')\nbasis = [1, x, x**2]\nfunctionals = [sp.lambdify(x, b, 'numpy') for b in basis]\np = sp.Symbol('p')\ncoords = [1 + 0, 0 + 1, 0 + 4]\nprint(\"Coordinate in dual basis:\", coords)"
    },
    {
        "input": "Let A = [[0,1],[-2,-3]]. Find a basis of generalized eigenvectors and the Jordan form of A.",
        "output": "import numpy as np\nA = np.array([[0,1],[-2,-3]])\nevals, evecs = np.linalg.eig(A)\nprint(\"Eigenvalues:\", evals)"
    },
    {
        "input": "Let T: ℝ² → ℝ² be rotation by θ = π/4. Find the matrix in standard basis and find a basis in which T becomes a scalar multiple of identity.",
        "output": "import numpy as np\nθ = np.pi/4\nA = np.array([[np.cos(θ), -np.sin(θ)], [np.sin(θ), np.cos(θ)]])\nprint(\"Rotation matrix:\", A)"
    },
    {
        "input": "Find a basis B of ℝ² such that the linear transformation T(x, y) = (5x + y, x + 5y) has matrix [[6, 0], [0, 4]] in B.",
        "output": "import numpy as np\nA = np.array([[5,1],[1,5]])\nevals, evecs = np.linalg.eig(A)\nprint(\"Eigenvectors give the required basis B:\\n\", evecs)"
    },
    {
        "input": "Given v = x + 2x² and basis B = {x², x² + x, x + 1}, express v in B.",
        "output": "import sympy as sp\nx = sp.Symbol('x')\nv = x + 2*x**2\nB = [x**2, x**2 + x, x + 1]\na, b, c = sp.symbols('a b c')\neq = sp.Eq(v, a*B[0] + b*B[1] + c*B[2])\ncoeffs = sp.solve(eq, (a,b,c))\nprint(\"v in basis B:\", coeffs)"
    },
    {
        "input": "Let T: V → V be a linear transformation with known basis B. Given [T]_B = [[1,1],[0,1]], find generalized eigenvector of rank 2.",
        "output": "import numpy as np\nA = np.array([[1,1],[0,1]])\nv = np.array([1,0])\nprint(\"Generalized eigenvector:\", v)"
    },
    {
        "input": "In aerospace, convert velocity vector [300, 0] m/s from body frame to inertial frame with a yaw of 15 degrees.",
        "output": "import numpy as np\nv_body = np.array([300, 0])\nyaw = np.deg2rad(15)\nR = np.array([[np.cos(yaw), -np.sin(yaw)], [np.sin(yaw), np.cos(yaw)]])\nv_inertial = R @ v_body\nprint(\"Velocity in inertial frame:\", v_inertial)"
    },
    {
        "input": "In augmented reality, project a point in world coordinates to camera coordinates using given transformation matrix T.",
        "output": "import numpy as np\nT = np.array([[0.9, 0, 0, 1], [0, 0.9, 0, 2], [0, 0, 0.9, 3], [0, 0, 0, 1]])\np_world = np.array([2, 3, 4, 1])\np_camera = T @ p_world\nprint(\"Point in camera coordinates:\", p_camera[:3])"
    },
    {
        "input": "A particle moves in a rotated reference frame. Given position [3, 4] in new frame rotated 60 degrees, convert to original frame.",
        "output": "import numpy as np\nθ = np.deg2rad(60)\nR = np.array([[np.cos(θ), -np.sin(θ)], [np.sin(θ), np.cos(θ)]])\nv_new = np.array([3, 4])\nv_original = R @ v_new\nprint(\"Position in original frame:\", v_original)"
    },
    {
        "input": "In data science, reduce 3D vector to 2D using basis vectors e1 = [1,0,1], e2 = [0,1,1]. Express [2,3,5] in this basis.",
        "output": "import numpy as np\nB = np.array([[1,0],[0,1],[1,1]])\nv = np.array([2,3,5])\nv_B = np.linalg.lstsq(B, v, rcond=None)[0]\nprint(\"Coordinates in new basis:\", v_B)"
    },
    {
        "input": "In animation, convert a point from model space [1,2,1] to world space using rotation and translation.",
        "output": "import numpy as np\nR = np.eye(3)\nt = np.array([5, 5, 0])\np_model = np.array([1, 2, 1])\np_world = R @ p_model + t\nprint(\"World space coordinates:\", p_world)"
    },
    {
        "input": "A weather balloon sends data in local frame. Convert acceleration vector [0.5, 0.5, 0.1] using 30° pitch rotation.",
        "output": "import numpy as np\nθ = np.deg2rad(30)\nR_pitch = np.array([[1,0,0],[0,np.cos(θ),-np.sin(θ)],[0,np.sin(θ),np.cos(θ)]])\na_local = np.array([0.5, 0.5, 0.1])\na_global = R_pitch @ a_local\nprint(\"Acceleration in global frame:\", a_global)"
    },
    {
        "input": "In biomechanics, convert leg motion vector [3,0,0] from hip frame to world frame with 90° yaw.",
        "output": "import numpy as np\nθ = np.deg2rad(90)\nR = np.array([[np.cos(θ), -np.sin(θ), 0],[np.sin(θ), np.cos(θ), 0],[0, 0, 1]])\nv_hip = np.array([3, 0, 0])\nv_world = R @ v_hip\nprint(\"Leg motion in world frame:\", v_world)"
    },
    {
        "input": "In 2D design, convert a point [6, 2] from rotated grid (45°) to Cartesian frame.",
        "output": "import numpy as np\nθ = np.deg2rad(45)\nR = np.array([[np.cos(θ), -np.sin(θ)],[np.sin(θ), np.cos(θ)]])\np_rot = np.array([6, 2])\np_cartesian = R @ p_rot\nprint(\"Point in Cartesian frame:\", p_cartesian)"
    },
    {
        "input": "In 3D modeling, rotate point [1,2,3] by 30° about y-axis.",
        "output": "import numpy as np\nθ = np.deg2rad(30)\nRy = np.array([[np.cos(θ), 0, np.sin(θ)], [0,1,0], [-np.sin(θ), 0, np.cos(θ)]])\np = np.array([1,2,3])\np_rot = Ry @ p\nprint(\"Rotated point:\", p_rot)"
    },
    {
        "input": "In game development, a character moves along direction [1, 1] in a 2D rotated camera view (30°). Convert to world coordinates.",
        "output": "import numpy as np\nv_cam = np.array([1, 1])\nθ = np.deg2rad(30)\nR = np.array([[np.cos(θ), -np.sin(θ)], [np.sin(θ), np.cos(θ)]])\nv_world = R @ v_cam\nprint(\"Movement in world coordinates:\", v_world)"
    },
    {
        "input": "In space exploration, convert thrust vector [100, 0, 0] from spacecraft body frame to world frame (30° pitch, 45° yaw).",
        "output": "import numpy as np\npitch = np.deg2rad(30)\nyaw = np.deg2rad(45)\nRy = np.array([[np.cos(pitch), 0, np.sin(pitch)], [0,1,0], [-np.sin(pitch), 0, np.cos(pitch)]])\nRz = np.array([[np.cos(yaw), -np.sin(yaw), 0], [np.sin(yaw), np.cos(yaw), 0], [0,0,1]])\nR = Rz @ Ry\nv_body = np.array([100, 0, 0])\nv_world = R @ v_body\nprint(\"Thrust in world frame:\", v_world)"
    },
    {
        "input": "In control systems, convert state vector [1, 0] to new coordinates using transformation matrix [[0.6, 0.8], [-0.8, 0.6]].",
        "output": "import numpy as np\nT = np.array([[0.6, -0.8], [0.8, 0.6]])\nv = np.array([1, 0])\nv_new = T @ v\nprint(\"State in new coordinates:\", v_new)"
    },
    {
        "input": "A quadcopter has orientation with roll=30°, pitch=45°, yaw=60°. Convert [1,0,0] to global frame.",
        "output": "import numpy as np\nroll = np.deg2rad(30)\npitch = np.deg2rad(45)\nyaw = np.deg2rad(60)\nRx = np.array([[1,0,0], [0,np.cos(roll),-np.sin(roll)], [0,np.sin(roll),np.cos(roll)]])\nRy = np.array([[np.cos(pitch),0,np.sin(pitch)], [0,1,0], [-np.sin(pitch),0,np.cos(pitch)]])\nRz = np.array([[np.cos(yaw), -np.sin(yaw), 0], [np.sin(yaw), np.cos(yaw), 0], [0,0,1]])\nR = Rz @ Ry @ Rx\nv = np.array([1,0,0])\nv_global = R @ v\nprint(\"Vector in global frame:\", v_global)"
    },
    {
        "input": "In 3D animation, an object has local coordinates [1,2,3]. The world transformation matrix includes rotation and translation. Apply it.",
        "output": "import numpy as np\nR = np.eye(3)\nt = np.array([4, 5, 6])\np_local = np.array([1, 2, 3])\np_world = R @ p_local + t\nprint(\"Object in world coordinates:\", p_world)"
    },
    {
        "input": "In a CAD system, express vector [4, 4, 4] in a new orthonormal basis with b1 = [1,0,0], b2 = [0,1,1]/√2, b3 = [0,1,-1]/√2.",
        "output": "import numpy as np\nb1 = np.array([1,0,0])\nb2 = np.array([0,1,1])/np.sqrt(2)\nb3 = np.array([0,1,-1])/np.sqrt(2)\nB = np.column_stack((b1, b2, b3))\nv = np.array([4, 4, 4])\nv_new = np.linalg.inv(B) @ v\nprint(\"Vector in new basis:\", v_new)"
    },
    {
        "input": "A satellite sends a vector [5,5,0] in rotated orbital frame (90° about y). Convert to Earth-centered frame.",
        "output": "import numpy as np\nθ = np.pi/2\nRy = np.array([[np.cos(θ),0,np.sin(θ)], [0,1,0], [-np.sin(θ),0,np.cos(θ)]])\nv_orbital = np.array([5, 5, 0])\nv_earth = Ry @ v_orbital\nprint(\"Vector in Earth-centered frame:\", v_earth)"
    },
    {
        "input": "In navigation, rotate position vector [1, 1, 0] by -30° around z-axis.",
        "output": "import numpy as np\nθ = -np.deg2rad(30)\nRz = np.array([[np.cos(θ), -np.sin(θ), 0],[np.sin(θ), np.cos(θ), 0],[0, 0, 1]])\nv = np.array([1, 1, 0])\nv_rotated = Rz @ v\nprint(\"Position after rotation:\", v_rotated)"
    },
    {
        "input": "In a drone sim, convert local velocity [1, 2] m/s to inertial frame with 135° yaw.",
        "output": "import numpy as np\nθ = np.deg2rad(135)\nR = np.array([[np.cos(θ), -np.sin(θ)], [np.sin(θ), np.cos(θ)]])\nv_local = np.array([1, 2])\nv_inertial = R @ v_local\nprint(\"Velocity in inertial frame:\", v_inertial)"
    },
    {
        "input": "In control theory, change coordinates of x = [3, 2] using basis [[1, 1], [1, -1]].",
        "output": "import numpy as np\nB = np.array([[1, 1], [1, -1]])\nx = np.array([3, 2])\nx_new = np.linalg.inv(B) @ x\nprint(\"State in new coordinates:\", x_new)"
    },
    {
        "input": "In AR, a virtual object moves [2, 0] in user frame. Convert to global frame (60° rotation).",
        "output": "import numpy as np\nv_user = np.array([2, 0])\nθ = np.deg2rad(60)\nR = np.array([[np.cos(θ), -np.sin(θ)], [np.sin(θ), np.cos(θ)]])\nv_global = R @ v_user\nprint(\"Movement in global frame:\", v_global)"
    },
    {
        "input": "In data compression, project [4, 4] onto basis [1, 1], [-1, 1].",
        "output": "import numpy as np\nB = np.array([[1, -1], [1, 1]])\nv = np.array([4, 4])\nv_new = np.linalg.inv(B) @ v\nprint(\"Vector in compressed basis:\", v_new)"
    },
    {
        "input": "In aerospace dynamics, express [1,1,0] in a new frame defined by orthogonal axes u=[1,0,0], v=[0,1,0], w=[0,0,1].",
        "output": "import numpy as np\nB = np.eye(3)\nv = np.array([1,1,0])\nv_new = np.linalg.inv(B) @ v\nprint(\"Vector in new frame:\", v_new)"
    },
    {
        "input": "A robot base rotates 180° around z-axis. Convert local point [1, 2, 0] to world frame.",
        "output": "import numpy as np\nθ = np.pi\nRz = np.array([[np.cos(θ), -np.sin(θ), 0],[np.sin(θ), np.cos(θ), 0],[0, 0, 1]])\np_local = np.array([1,2,0])\np_world = Rz @ p_local\nprint(\"Point in world frame:\", p_world)"
    },
    {
        "input": "In computer graphics, rotate vector [1, 0, 0] 120° around axis [0, 0, 1].",
        "output": "import numpy as np\nθ = np.deg2rad(120)\nRz = np.array([[np.cos(θ), -np.sin(θ), 0],[np.sin(θ), np.cos(θ), 0],[0, 0, 1]])\nv = np.array([1, 0, 0])\nv_rotated = Rz @ v\nprint(\"Rotated vector:\", v_rotated)"
    },
    {
        "input": "In signal processing, change vector [3, 3] to frequency basis [[1,1], [1,-1]].",
        "output": "import numpy as np\nF = np.array([[1,1], [1,-1]])\nv = np.array([3,3])\nv_freq = np.linalg.inv(F) @ v\nprint(\"Vector in frequency basis:\", v_freq)"
    },
    {
        "input": "Given basis B = [[2, 1], [1, 2]] and vector x = [3, 4], compute coordinates of x in B and reconstruct x from those coordinates.",
        "output": "import numpy as np\nB = np.array([[2, 1], [1, 2]])\nx = np.array([3, 4])\nx_B = np.linalg.inv(B) @ x\nx_reconstructed = B @ x_B\nprint(\"Coordinates in basis B:\", x_B)\nprint(\"Reconstructed vector:\", x_reconstructed)"
    },
    {
        "input": "Transform a 3D vector [3,1,2] using eigenbasis B where eigenvectors are columns of B. B = [[1,0,1],[1,1,0],[0,1,1]].",
        "output": "import numpy as np\nB = np.array([[1,0,1], [1,1,0], [0,1,1]])\nv = np.array([3,1,2])\nv_B = np.linalg.inv(B) @ v\nprint(\"Vector in eigenbasis:\", v_B)"
    },
    {
        "input": "Rotate a vector [5, 0, 0] around axis [1,1,1] by 120°. Use Rodrigues’ formula.",
        "output": "import numpy as np\nv = np.array([5, 0, 0])\nk = np.array([1,1,1])\nk = k / np.linalg.norm(k)\ntheta = np.deg2rad(120)\nK = np.array([[0, -k[2], k[1]], [k[2], 0, -k[0]], [-k[1], k[0], 0]])\nR = np.eye(3) + np.sin(theta)*K + (1 - np.cos(theta))*(K @ K)\nv_rot = R @ v\nprint(\"Rotated vector:\", v_rot)"
    },
    {
        "input": "In robotics, a transformation matrix includes rotation and translation. Decompose matrix T into R and t components.",
        "output": "import numpy as np\nT = np.array([[1,0,0,4], [0,0,-1,3], [0,1,0,2], [0,0,0,1]])\nR = T[:3,:3]\nt = T[:3,3]\nprint(\"Rotation matrix R:\", R)\nprint(\"Translation vector t:\", t)"
    },
    {
        "input": "You are given a matrix expressed in basis A = [[2,1],[1,2]]. Transform it to basis B = [[1,0],[0,1]].",
        "output": "import numpy as np\nA_basis = np.array([[2,1],[1,2]])\nM = np.array([[4, 2],[2, 4]])\nM_std = np.linalg.inv(A_basis) @ M @ A_basis\nprint(\"Matrix in standard basis:\", M_std)"
    },
    {
        "input": "Given two orthonormal bases B1 and B2, construct the change-of-basis matrix from B1 to B2. Then convert vector x = [1,2].",
        "output": "import numpy as np\nB1 = np.array([[1,0],[0,1]])\nB2 = np.array([[0,1],[-1,0]])\nP = B2.T @ B1\nx = np.array([1,2])\nx_new = P @ x\nprint(\"Change of basis matrix:\", P)\nprint(\"x in B2 basis:\", x_new)"
    },
    {
        "input": "Apply a shear transformation to a vector [1,2] using matrix [[1,1],[0,1]] and then express the result in basis [[1,0],[0,2]].",
        "output": "import numpy as np\nshear = np.array([[1,1],[0,1]])\nB = np.array([[1,0],[0,2]])\nv = np.array([1,2])\nv_sheared = shear @ v\nv_B = np.linalg.inv(B) @ v_sheared\nprint(\"Sheared vector:\", v_sheared)\nprint(\"In new basis:\", v_B)"
    },
    {
        "input": "In linear algebra, given basis B and coordinates x_B, reconstruct the original vector x = B @ x_B.",
        "output": "import numpy as np\nB = np.array([[3,1],[2,2]])\nx_B = np.array([1,1])\nx = B @ x_B\nprint(\"Original vector:\", x)"
    },
    {
        "input": "A spacecraft rotates 30° around z and then 45° around y. Derive the total rotation matrix and apply to vector [0,0,1].",
        "output": "import numpy as np\nz = np.deg2rad(30)\ny = np.deg2rad(45)\nRz = np.array([[np.cos(z), -np.sin(z), 0],[np.sin(z), np.cos(z), 0],[0,0,1]])\nRy = np.array([[np.cos(y),0,np.sin(y)],[0,1,0],[-np.sin(y),0,np.cos(y)]])\nR = Ry @ Rz\nv = np.array([0,0,1])\nv_rot = R @ v\nprint(\"Rotated vector:\", v_rot)"
    },
    {
        "input": "Apply an affine transformation to a point [2, 1] using matrix A = [[2,0],[0,3]] and translation [4,5].",
        "output": "import numpy as np\nA = np.array([[2,0],[0,3]])\nt = np.array([4,5])\np = np.array([2,1])\np_transformed = A @ p + t\nprint(\"Affine transformed point:\", p_transformed)"
    },
    {
        "input": "Compute the inverse transformation for a matrix that rotates 90° and translates [1,2]. Apply it to point [4,5].",
        "output": "import numpy as np\nθ = np.deg2rad(90)\nR = np.array([[np.cos(θ), -np.sin(θ)], [np.sin(θ), np.cos(θ)]])\nt = np.array([1,2])\nR_inv = R.T\nt_inv = -R_inv @ t\np = np.array([4,5])\np_local = R_inv @ (p - t)\nprint(\"Point in original frame:\", p_local)"
    },
    {
        "input": "Transform a covariance matrix under a change of basis B = [[2,0],[0,0.5]]. C = [[4,1],[1,3]].",
        "output": "import numpy as np\nB = np.array([[2,0],[0,0.5]])\nC = np.array([[4,1],[1,3]])\nC_new = B.T @ C @ B\nprint(\"Transformed covariance matrix:\", C_new)"
    },
    {
        "input": "In signal analysis, express signal vector [3, 4] in DFT basis (unnormalized for N=2).",
        "output": "import numpy as np\nF = np.array([[1, 1], [1, -1]])\nv = np.array([3,4])\nv_freq = np.linalg.inv(F) @ v\nprint(\"Signal in frequency basis:\", v_freq)"
    },
    {
        "input": "A 3D point cloud needs to be aligned to a new coordinate system defined by orthonormal vectors u, v, w. Given a point [1, 2, 3], compute its coordinates in the new system.",
        "output": "import numpy as np\nu = np.array([0.707, 0.707, 0])\nv = np.array([-0.707, 0.707, 0])\nw = np.array([0, 0, 1])\nR = np.column_stack((u, v, w))\np_original = np.array([1, 2, 3])\np_new = np.linalg.inv(R) @ p_original\nprint(\"Coordinates in new system:\", p_new)"
    },
    {
        "input": "A 2D image undergoes a shear transformation defined by the matrix [[1, 0.5], [0, 1]]. Determine the new coordinates of a pixel originally at [10, 15].",
        "output": "import numpy as np\nshear_matrix = np.array([[1, 0.5], [0, 1]])\npixel = np.array([10, 15])\nnew_pixel = shear_matrix @ pixel\nprint(\"New pixel coordinates:\", new_pixel)"
    },
    {
        "input": "A car's local coordinate system has a point at [2, 3]. The car rotates 30° counterclockwise. Compute the point's coordinates in the global frame.",
        "output": "import numpy as np\nθ = np.deg2rad(30)\nR = np.array([[np.cos(θ), -np.sin(θ)], [np.sin(θ), np.cos(θ)]])\npoint_local = np.array([2, 3])\npoint_global = R @ point_local\nprint(\"Point in global frame:\", point_global)"
    },
    {
        "input": "A camera captures an image of a planar object. The homography matrix H relates the image coordinates to the world coordinates. Given H and a point [150, 200] in the image, find the corresponding point in the world.",
        "output": "import numpy as np\nH = np.array([[1.2, 0.1, 100], [0.2, 1.1, 150], [0.001, 0.002, 1]])\npoint_image = np.array([150, 200, 1])\npoint_world = H @ point_image\npoint_world /= point_world[2]\nprint(\"Point in world coordinates:\", point_world[:2])"
    },
    {
        "input": "A 2D shape undergoes a reflection across the line y = x. Given a point [3, 4], find its coordinates after the reflection.",
        "output": "import numpy as np\nR = np.array([[0, 1], [1, 0]])\npoint = np.array([3, 4])\nreflected_point = R @ point\nprint(\"Reflected point:\", reflected_point)"
    },
    {
        "input": "Given a vector v = [3, -2] in the standard basis, and a new basis B = {[1, 1], [1, -1]}, find the coordinates of v in the basis B.",
        "output": "import numpy as np\nv = np.array([3, -2])\nB = np.array([[1, 1], [1, -1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"Coordinates of v in basis B:\", v_B)"
    },
    {
        "input": "Let B = {[1, 2], [3, 4]} and C = {[2, 0], [0, 2]} be two bases. Find the change of basis matrix from B to C.",
        "output": "import numpy as np\nB = np.array([[1, 3], [2, 4]])\nC = np.array([[2, 0], [0, 2]])\nP_BC = np.linalg.inv(C) @ B\nprint(\"Change of basis matrix from B to C:\", P_BC)"
    },
    {
        "input": "A linear transformation T has a matrix representation A = [[2, 1], [0, 3]] in the standard basis. Find its representation in the basis B = {[1, 1], [1, -1]}.",
        "output": "import numpy as np\nA = np.array([[2, 1], [0, 3]])\nB = np.array([[1, 1], [1, -1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix of T in basis B:\", A_B)"
    },
    {
        "input": "Given a vector v = [1, 2, 3] in the standard basis, and an orthogonal basis B = {[1, 0, 0], [0, 1, 0], [0, 0, 1]}, find the coordinates of v in the basis B.",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nB = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\nv_B = B.T @ v\nprint(\"Coordinates of v in basis B:\", v_B)"
    },
    {
        "input": "Let B = {[1, 0], [0, 1]} and C = {[1, 1], [1, -1]} be two bases. Find the change of basis matrix from B to C.",
        "output": "import numpy as np\nB = np.array([[1, 0], [0, 1]])\nC = np.array([[1, 1], [1, -1]])\nP_BC = np.linalg.inv(C) @ B\nprint(\"Change of basis matrix from B to C:\", P_BC)"
    },
    {
        "input": "A linear transformation T has a matrix representation A = [[0, -1], [1, 0]] in the standard basis. Find its representation in the basis B = {[1, 1], [1, -1]}.",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\nB = np.array([[1, 1], [1, -1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix of T in basis B:\", A_B)"
    },
    {
        "input": "Given a vector v = [4, -3] in the standard basis, and a new basis B = {[2, 1], [1, 2]}, find the coordinates of v in the basis B.",
        "output": "import numpy as np\nv = np.array([4, -3])\nB = np.array([[2, 1], [1, 2]])\nv_B = np.linalg.inv(B) @ v\nprint(\"Coordinates of v in basis B:\", v_B)"
    },
    {
        "input": "Let B = {[2, 0], [0, 2]} and C = {[1, 1], [1, -1]} be two bases. Find the change of basis matrix from B to C.",
        "output": "import numpy as np\nB = np.array([[2, 0], [0, 2]])\nC = np.array([[1, 1], [1, -1]])\nP_BC = np.linalg.inv(C) @ B\nprint(\"Change of basis matrix from B to C:\", P_BC)"
    },
    {
        "input": "A linear transformation T has a matrix representation A = [[3, 0], [0, 2]] in the standard basis. Find its representation in the basis B = {[1, 2], [2, 1]}.",
        "output": "import numpy as np\nA = np.array([[3, 0], [0, 2]])\nB = np.array([[1, 2], [2, 1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix of T in basis B:\", A_B)"
    },
    {
        "input": "Given a vector v = [5, 5] in the standard basis, and a new basis B = {[1, 0], [0, 1]}, find the coordinates of v in the basis B.",
        "output": "import numpy as np\nv = np.array([5, 5])\nB = np.array([[1, 0], [0, 1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"Coordinates of v in basis B:\", v_B)"
    },
    {
        "input": "Let B = {[1, 1], [1, -1]} and C = {[2, 0], [0, 2]} be two bases. Find the change of basis matrix from B to C.",
        "output": "import numpy as np\nB = np.array([[1, 1], [1, -1]])\nC = np.array([[2, 0], [0, 2]])\nP_BC = np.linalg.inv(C) @ B\nprint(\"Change of basis matrix from B to C:\", P_BC)"
    },
    {
        "input": "A linear transformation T has a matrix representation A = [[1, 2], [3, 4]] in the standard basis. Find its representation in the basis B = {[2, 1], [1, 2]}.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[2, 1], [1, 2]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix of T in basis B:\", A_B)"
    },
    {
        "input": "Given basis B = {[1, 0, 1], [0, 1, 1], [1, 1, 0]}, express the standard basis vector e1 = [1, 0, 0] in terms of B.",
        "output": "import numpy as np\nB = np.array([[1, 0, 1], [0, 1, 1], [1, 1, 0]]).T\ne1 = np.array([1, 0, 0])\ne1_B = np.linalg.inv(B) @ e1\nprint(\"e1 in basis B:\", e1_B)"
    },
    {
        "input": "Find the transition matrix from basis B = {[1, 2], [2, -1]} to the standard basis.",
        "output": "import numpy as np\nB = np.array([[1, 2], [2, -1]])\nP = B\nprint(\"Transition matrix from B to standard basis:\", P)"
    },
    {
        "input": "Let v = [6, -2] be a vector in the standard basis. Express v in basis B = {[2, 1], [1, -1]}.",
        "output": "import numpy as np\nv = np.array([6, -2])\nB = np.array([[2, 1], [1, -1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"Coordinates of v in basis B:\", v_B)"
    },
    {
        "input": "A transformation T has matrix A = [[4, 1], [2, 3]]. Compute the similarity transformation under B = {[1, 1], [1, -1]}.",
        "output": "import numpy as np\nA = np.array([[4, 1], [2, 3]])\nB = np.array([[1, 1], [1, -1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"T in basis B:\", A_B)"
    },
    {
        "input": "Let v = [2, 3] in the basis B = {[1, 1], [1, -1]}. Convert v to standard basis coordinates.",
        "output": "import numpy as np\nB = np.array([[1, 1], [1, -1]])\nv_B = np.array([2, 3])\nv_std = B @ v_B\nprint(\"v in standard basis:\", v_std)"
    },
    {
        "input": "Find the matrix representation of the identity map in basis B = {[1, 1], [1, -1]}.",
        "output": "import numpy as np\nB = np.array([[1, 1], [1, -1]])\nI_B = np.linalg.inv(B) @ np.identity(2) @ B\nprint(\"Identity map in basis B:\", I_B)"
    },
    {
        "input": "Let A = [[0, 1], [1, 0]] represent a transformation in standard basis. Find its matrix in basis B = {[1, 0], [1, 1]}.",
        "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\nB = np.array([[1, 1], [0, 1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix of T in basis B:\", A_B)"
    },
    {
        "input": "Convert vector [1, 2] from basis B = {[2, 3], [1, -1]} to standard coordinates.",
        "output": "import numpy as np\nB = np.array([[2, 1], [3, -1]])\nv_B = np.array([1, 2])\nv_std = B @ v_B\nprint(\"v in standard basis:\", v_std)"
    },
    {
        "input": "Let a vector v = [3, 2] be expressed in B = {[1, 0], [0, 1]}. Convert to standard coordinates.",
        "output": "import numpy as np\nB = np.identity(2)\nv_B = np.array([3, 2])\nv_std = B @ v_B\nprint(\"v in standard basis:\", v_std)"
    },
    {
        "input": "Given transformation matrix A = [[0, -1], [1, 0]], determine its matrix in orthonormal basis B = {[1/sqrt(2), 1/sqrt(2)], [1/sqrt(2), -1/sqrt(2)]}.",
        "output": "import numpy as np\nB = np.array([[1/np.sqrt(2), 1/np.sqrt(2)], [1/np.sqrt(2), -1/np.sqrt(2)]])\nA = np.array([[0, -1], [1, 0]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"A in basis B:\", A_B)"
    },
    {
        "input": "Compute the change of basis matrix from standard basis to B = {[3, 1], [2, 2]}.",
        "output": "import numpy as np\nB = np.array([[3, 2], [1, 2]])\nP = np.linalg.inv(B)\nprint(\"Change of basis from standard to B:\", P)"
    },
    {
        "input": "Let a vector v = [7, 1] in the standard basis. Find coordinates in basis B = {[2, 2], [0, 1]}.",
        "output": "import numpy as np\nv = np.array([7, 1])\nB = np.array([[2, 0], [2, 1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"Coordinates of v in basis B:\", v_B)"
    },
    {
        "input": "Find the matrix representation of the rotation transformation by 90 degrees in basis B = {[1, 1], [-1, 1]}.",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\nB = np.array([[1, -1], [1, 1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Rotation matrix in basis B:\", A_B)"
    },
    {
        "input": "Given two bases B = {[1, 0], [1, 1]} and C = {[2, 1], [0, 1]}, find the matrix to convert B-coordinates to C-coordinates.",
        "output": "import numpy as np\nB = np.array([[1, 1], [0, 1]])\nC = np.array([[2, 0], [1, 1]])\nP = np.linalg.inv(C) @ B\nprint(\"B to C basis conversion matrix:\", P)"
    },
    {
        "input": "Convert the vector [1, 1] from basis B = {[3, 1], [1, 2]} to standard coordinates.",
        "output": "import numpy as np\nB = np.array([[3, 1], [1, 2]])\nv_B = np.array([1, 1])\nv_std = B @ v_B\nprint(\"Vector in standard basis:\", v_std)"
    },
    {
        "input": "Find the inverse of the change of basis matrix from B = {[1, 2], [3, 4]} to standard basis.",
        "output": "import numpy as np\nB = np.array([[1, 3], [2, 4]])\nP = B\nP_inv = np.linalg.inv(P)\nprint(\"Inverse of change of basis matrix:\", P_inv)"
    },
    {
        "input": "Given a transformation matrix A = [[2, 0], [0, 3]] in standard basis, and B = {[1, 1], [1, -1]}, compute its matrix in B.",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 3]])\nB = np.array([[1, 1], [1, -1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix in basis B:\", A_B)"
    },
    {
        "input": "Express the vector [5, -3] in the coordinate system of the basis B = {[1, 1], [0, 1]}.",
        "output": "import numpy as np\nv = np.array([5, -3])\nB = np.array([[1, 0], [1, 1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"Coordinates in basis B:\", v_B)"
    },
    {
        "input": "Convert v = [3, 5] from basis B = {[2, 1], [1, 3]} to standard coordinates.",
        "output": "import numpy as np\nB = np.array([[2, 1], [1, 3]])\nv_B = np.array([3, 5])\nv_std = B @ v_B\nprint(\"v in standard basis:\", v_std)"
    },
    {
        "input": "Let T be a transformation with matrix [[1, 0], [0, -1]] in standard basis. Represent it in B = {[1, 1], [1, -1]}.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, -1]])\nB = np.array([[1, 1], [1, -1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix in basis B:\", A_B)"
    },
    {
        "input": "Let B = {[1, 2, 0], [0, 1, 1], [1, 0, 1]}. Find the matrix that transforms from B to standard coordinates.",
        "output": "import numpy as np\nB = np.array([[1, 0, 1], [2, 1, 0], [0, 1, 1]]).T\nP = B\nprint(\"B to standard coordinates matrix:\", P)"
    },
    {
        "input": "Given A = [[1, 0, 0], [0, 2, 0], [0, 0, 3]] and basis B = identity, find its matrix in B.",
        "output": "import numpy as np\nA = np.diag([1, 2, 3])\nB = np.eye(3)\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix in basis B:\", A_B)"
    },
    {
        "input": "Convert vector v = [4, 1] to basis B = {[1, 1], [1, -1]}.",
        "output": "import numpy as np\nv = np.array([4, 1])\nB = np.array([[1, 1], [1, -1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "Given a vector v = [4, 2] in the standard basis, and a new basis B = {[2, 1], [1, 1]}, find the coordinates of v in the basis B.",
        "output": "import numpy as np\nv = np.array([4, 2])\nB = np.array([[2, 1], [1, 1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"Coordinates of v in basis B:\", v_B)"
    },
    {
        "input": "A linear transformation T has a matrix representation A = [[1, 2], [3, 4]] in the standard basis. Find its representation in the basis B = {[1, 1], [0, 1]}.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[1, 0], [1, 1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix of T in basis B:\", A_B)"
    },
    {
        "input": "Convert vector [7, -2] from basis B = {[1, 1], [1, -1]} to standard coordinates.",
        "output": "import numpy as np\nv_B = np.array([7, -2])\nB = np.array([[1, 1], [1, -1]])\nv_std = B @ v_B\nprint(\"Vector in standard basis:\", v_std)"
    },
    {
        "input": "Given a vector v = [2, 3] in standard coordinates, and basis B = {[3, 1], [1, 2]}, express v in B coordinates.",
        "output": "import numpy as np\nv = np.array([2, 3])\nB = np.array([[3, 1], [1, 2]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "Let B = {[1, 2, 3], [0, 1, 4], [0, 0, 1]}. Find the matrix to convert from B coordinates to standard coordinates.",
        "output": "import numpy as np\nB = np.array([[1, 0, 0], [2, 1, 0], [3, 4, 1]])\nprint(\"Matrix to convert from B to standard:\", B)"
    },
    {
        "input": "Given T: R^2 → R^2 with matrix A = [[0, 1], [1, 0]], find its representation in the basis B = {[1, 2], [3, 4]}.",
        "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\nB = np.array([[1, 3], [2, 4]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix in basis B:\", A_B)"
    },
    {
        "input": "Convert the standard basis vector [1, 0, 0] to coordinates in basis B = {[1, 1, 0], [0, 1, 1], [1, 0, 1]}.",
        "output": "import numpy as np\nv = np.array([1, 0, 0])\nB = np.array([[1, 0, 1], [1, 1, 0], [0, 1, 1]]).T\nv_B = np.linalg.inv(B) @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "Find the matrix of the reflection transformation over the x-axis in basis B = {[1, 1], [1, -1]}.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, -1]])\nB = np.array([[1, 1], [1, -1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Reflection matrix in basis B:\", A_B)"
    },
    {
        "input": "Let A = [[2, 0], [0, 3]], and B = {[1, 0], [1, 1]}. Compute A in the basis B.",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 3]])\nB = np.array([[1, 1], [0, 1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix of A in basis B:\", A_B)"
    },
    {
        "input": "Find coordinates of vector v = [6, 2, 3] in the basis B = {[1, 1, 0], [0, 1, 1], [1, 0, 1]}.",
        "output": "import numpy as np\nv = np.array([6, 2, 3])\nB = np.array([[1, 0, 1], [1, 1, 0], [0, 1, 1]]).T\nv_B = np.linalg.inv(B) @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "Given vector v = [3, 4] and basis B = {[1, 2], [2, 1]}, find v in basis B.",
        "output": "import numpy as np\nv = np.array([3, 4])\nB = np.array([[1, 2], [2, 1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"Coordinates of v in basis B:\", v_B)"
    },
    {
        "input": "Transform A = [[1, 2], [0, 1]] from standard basis to B = {[1, 1], [1, -1]}.",
        "output": "import numpy as np\nA = np.array([[1, 2], [0, 1]])\nB = np.array([[1, 1], [1, -1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"A in basis B:\", A_B)"
    },
    {
        "input": "Given a vector v = [1, 1] and B = {[1, 0], [1, 1]}, find coordinates of v in B.",
        "output": "import numpy as np\nv = np.array([1, 1])\nB = np.array([[1, 1], [0, 1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "Given basis B = {[2, 3], [1, 4]}, convert vector v = [10, 17] into B-coordinates.",
        "output": "import numpy as np\nv = np.array([10, 17])\nB = np.array([[2, 1], [3, 4]])\nv_B = np.linalg.inv(B) @ v\nprint(\"Coordinates of v in basis B:\", v_B)"
    },
    {
        "input": "Given v = [4, 1] and orthogonal basis B = {[1, 1]/√2, [1, -1]/√2}, find v's coordinates in B.",
        "output": "import numpy as np\nv = np.array([4, 1])\nb1 = np.array([1, 1]) / np.sqrt(2)\nb2 = np.array([1, -1]) / np.sqrt(2)\nv_B = np.array([np.dot(v, b1), np.dot(v, b2)])\nprint(\"v in orthogonal basis B:\", v_B)"
    },
    {
        "input": "Let A = [[0, -1], [1, 0]] (rotation). Compute A in basis B = {[1, 2], [3, 4]}.",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\nB = np.array([[1, 3], [2, 4]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Rotation matrix in basis B:\", A_B)"
    },
    {
        "input": "Find the inverse transformation matrix of A = [[3, 2], [1, 2]] in basis B = {[1, 1], [0, 1]}.",
        "output": "import numpy as np\nA = np.array([[3, 2], [1, 2]])\nB = np.array([[1, 0], [1, 1]])\nA_B = np.linalg.inv(B) @ A @ B\nA_B_inv = np.linalg.inv(A_B)\nprint(\"Inverse in basis B:\", A_B_inv)"
    },
    {
        "input": "Convert the vector [1, -2, 3] into coordinates under the basis B = {[1, 0, 0], [0, 2, 0], [0, 0, 0.5]}.",
        "output": "import numpy as np\nv = np.array([1, -2, 3])\nB = np.array([[1, 0, 0], [0, 2, 0], [0, 0, 0.5]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "Let B = {[1, -1], [1, 1]}. Compute change of basis matrix from B to standard.",
        "output": "import numpy as np\nB = np.array([[1, 1], [-1, 1]])\nP = B\nprint(\"Change of basis matrix (B to standard):\", P)"
    },
    {
        "input": "Let v = [5, 5] be in basis B = {[1, 2], [3, 4]}. Find its standard coordinates.",
        "output": "import numpy as np\nv_B = np.array([5, 5])\nB = np.array([[1, 3], [2, 4]])\nv_std = B @ v_B\nprint(\"Vector in standard coordinates:\", v_std)"
    },
    {
        "input": "Given transformation T with standard matrix [[2, 0], [0, 3]], find the matrix in basis B = {[2, 1], [1, 2]}.",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 3]])\nB = np.array([[2, 1], [1, 2]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix in basis B:\", A_B)"
    },
    {
        "input": "Convert [6, 2] from standard basis to B = {[3, 1], [1, 2]} coordinates.",
        "output": "import numpy as np\nv = np.array([6, 2])\nB = np.array([[3, 1], [1, 2]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "Let A = [[1, 2], [3, 4]] be a transformation matrix. Compute its similarity transform under B = {[1, 0], [0, 2]}.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[1, 0], [0, 2]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Similarity transform of A:\", A_B)"
    },
    {
        "input": "Find coordinates of [0, 1] in orthonormal basis {[1, 0], [0, 1]}.",
        "output": "import numpy as np\nv = np.array([0, 1])\nB = np.eye(2)\nv_B = np.linalg.inv(B) @ v\nprint(\"Coordinates in B:\", v_B)"
    },
    {
        "input": "Let v = [1, 2] and B = {[1, 1], [0, 1]}. Compute v’s coordinates in B and verify the result.",
        "output": "import numpy as np\nv = np.array([1, 2])\nB = np.array([[1, 0], [1, 1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in basis B:\", v_B)\nprint(\"Reconstructed v:\", B @ v_B)"
    },
    {
        "input": "Find matrix representation of projection onto x-axis in basis B = {[1, 1], [1, -1]}.",
        "output": "import numpy as np\nP = np.array([[1, 0], [0, 0]])\nB = np.array([[1, 1], [1, -1]])\nP_B = np.linalg.inv(B) @ P @ B\nprint(\"Projection matrix in basis B:\", P_B)"
    },
    {
        "input": "Let T be a rotation by 90 degrees counterclockwise. Find its matrix in standard basis.",
        "output": "import numpy as np\nT = np.array([[0, -1], [1, 0]])\nprint(\"Rotation matrix:\", T)"
    },
    {
        "input": "Determine the coordinates of [3, 3, 3] in B = {[1, 0, 1], [1, 1, 0], [0, 1, 1]}.",
        "output": "import numpy as np\nv = np.array([3, 3, 3])\nB = np.array([[1, 1, 0], [0, 1, 1], [1, 0, 1]]).T\nv_B = np.linalg.inv(B) @ v\nprint(\"v in B:\", v_B)"
    },
    {
        "input": "Let A = [[2, -1], [1, 3]]. Find its inverse in B = {[1, 2], [3, 4]}.",
        "output": "import numpy as np\nA = np.array([[2, -1], [1, 3]])\nB = np.array([[1, 3], [2, 4]])\nA_B = np.linalg.inv(B) @ A @ B\nA_B_inv = np.linalg.inv(A_B)\nprint(\"Inverse in B:\", A_B_inv)"
    },
    {
        "input": "Let B = {[1, 1], [2, -1]}. Find the matrix to convert from standard to B coordinates.",
        "output": "import numpy as np\nB = np.array([[1, 2], [1, -1]])\nP = np.linalg.inv(B)\nprint(\"Change of basis matrix (standard to B):\", P)"
    },
    {
        "input": "Given matrix A = [[4, 1], [2, 3]], find its action on v = [1, 0] in basis B = {[1, 2], [0, 1]}.",
        "output": "import numpy as np\nA = np.array([[4, 1], [2, 3]])\nv = np.array([1, 0])\nB = np.array([[1, 0], [2, 1]])\nA_B = np.linalg.inv(B) @ A @ B\nv_B = np.linalg.inv(B) @ v\nresult_B = A_B @ v_B\nprint(\"T(v) in basis B:\", result_B)"
    },
    {
        "input": "Compute the determinant of the transformation matrix [[1, 2], [3, 4]] in the basis {[1, 0], [1, 1]} and compare with standard basis.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[1, 1], [0, 1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Det in standard:\", np.linalg.det(A))\nprint(\"Det in basis B:\", np.linalg.det(A_B))"
    },
    {
        "input": "Let v = [2, -1, 4] and B = identity matrix. What are the coordinates of v in B?",
        "output": "import numpy as np\nv = np.array([2, -1, 4])\nB = np.eye(3)\nv_B = np.linalg.inv(B) @ v\nprint(\"v in identity basis:\", v_B)"
    },
    {
        "input": "Given basis B = {[1, 2, 3], [0, 1, 0], [1, 0, 1]}, express vector v = [4, 3, 7] in basis B.",
        "output": "import numpy as np\nB = np.array([[1, 0, 1], [2, 1, 0], [3, 0, 1]])\nv = np.array([4, 3, 7])\nv_B = np.linalg.inv(B) @ v\nprint(\"Coordinates of v in basis B:\", v_B)"
    },
    {
        "input": "Find the matrix representation of T(v) = [[1, 2], [0, 1]]v in the basis B = {[1, 1], [1, -1]}.",
        "output": "import numpy as np\nA = np.array([[1, 2], [0, 1]])\nB = np.array([[1, 1], [1, -1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix of T in basis B:\", A_B)"
    },
    {
        "input": "A linear transformation rotates vectors 90° clockwise. Express its matrix in the basis B = {[1, 0], [1, 1]}.",
        "output": "import numpy as np\nA = np.array([[0, 1], [-1, 0]])\nB = np.array([[1, 1], [0, 1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Rotation matrix in basis B:\", A_B)"
    },
    {
        "input": "Transform v = [6, -1] from standard to basis B = {[2, 1], [1, 3]} and back to standard.",
        "output": "import numpy as np\nv = np.array([6, -1])\nB = np.array([[2, 1], [1, 3]])\nv_B = np.linalg.inv(B) @ v\nv_std = B @ v_B\nprint(\"v in B:\", v_B)\nprint(\"Back in standard:\", v_std)"
    },
    {
        "input": "Find the change of basis matrix from basis B = {[1, 2], [3, 5]} to C = {[2, 0], [0, 2]}.",
        "output": "import numpy as np\nB = np.array([[1, 3], [2, 5]])\nC = np.array([[2, 0], [0, 2]])\nP = np.linalg.inv(C) @ B\nprint(\"Change of basis matrix B → C:\", P)"
    },
    {
        "input": "Determine the coordinates of [2, 3] in the basis B = {[4, 1], [-1, 2]}.",
        "output": "import numpy as np\nv = np.array([2, 3])\nB = np.array([[4, -1], [1, 2]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "Let A = [[1, 1], [0, 1]]. Find its representation in the eigenbasis of A.",
        "output": "import numpy as np\nA = np.array([[1, 1], [0, 1]])\nvals, vecs = np.linalg.eig(A)\nP = vecs\nA_diag = np.linalg.inv(P) @ A @ P\nprint(\"A in its eigenbasis:\", A_diag)"
    },
    {
        "input": "Find coordinates of the zero vector in any basis.",
        "output": "import numpy as np\nB = np.random.rand(3, 3)\nv = np.zeros(3)\nv_B = np.linalg.inv(B) @ v\nprint(\"Zero vector in any basis:\", v_B)"
    },
    {
        "input": "Let transformation A = [[0, 2], [-2, 0]]. Find its matrix in the basis B = {[1, 1], [1, -1]}.",
        "output": "import numpy as np\nA = np.array([[0, 2], [-2, 0]])\nB = np.array([[1, 1], [1, -1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix of A in basis B:\", A_B)"
    },
    {
        "input": "Convert vector [1, 0, 1] into coordinates under B = {[1, 1, 0], [0, 1, 1], [1, 0, 1]}.",
        "output": "import numpy as np\nB = np.array([[1, 0, 1], [1, 1, 0], [0, 1, 1]])\nv = np.array([1, 0, 1])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "Let transformation T = reflection over y = x. Find its matrix in standard basis.",
        "output": "import numpy as np\nT = np.array([[0, 1], [1, 0]])\nprint(\"Reflection matrix over y = x:\", T)"
    },
    {
        "input": "Let v = [3, -2] in basis B = {[2, 0], [0, 5]}. Find its coordinates in the standard basis.",
        "output": "import numpy as np\nv_B = np.array([3, -2])\nB = np.array([[2, 0], [0, 5]])\nv_std = B @ v_B\nprint(\"v in standard basis:\", v_std)"
    },
    {
        "input": "Find the inverse of the change-of-basis matrix from B = {[1, 1], [0, 1]} to standard.",
        "output": "import numpy as np\nB = np.array([[1, 0], [1, 1]])\nP = B\nP_inv = np.linalg.inv(P)\nprint(\"Inverse change-of-basis matrix:\", P_inv)"
    },
    {
        "input": "Convert [2, 1] from standard to orthonormal basis B = {[1/√2, 1/√2], [1/√2, -1/√2]}.",
        "output": "import numpy as np\nv = np.array([2, 1])\nb1 = np.array([1, 1]) / np.sqrt(2)\nb2 = np.array([1, -1]) / np.sqrt(2)\nv_B = np.array([np.dot(v, b1), np.dot(v, b2)])\nprint(\"v in orthonormal basis B:\", v_B)"
    },
    {
        "input": "Find the standard representation of vector [2, 4] originally in B = {[1, 1], [2, 1]}.",
        "output": "import numpy as np\nv_B = np.array([2, 4])\nB = np.array([[1, 2], [1, 1]])\nv_std = B @ v_B\nprint(\"Standard coordinates:\", v_std)"
    },
    {
        "input": "Let A = [[1, 2], [3, 4]]. Find a basis B such that A becomes diagonal in B.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nvals, vecs = np.linalg.eig(A)\nA_diag = np.diag(vals)\nprint(\"Eigenbasis B (columns):\\n\", vecs)\nprint(\"Diagonalized A:\", A_diag)"
    },
    {
        "input": "Use Gram-Schmidt to create an orthonormal basis from B = [[3, 1], [2, 2]].",
        "output": "import numpy as np\nB = np.array([[3, 2], [1, 2]], dtype=float)\ndef gram_schmidt(vectors):\n    ortho = []\n    for v in vectors.T:\n        v = v.copy()\n        for b in ortho:\n            v -= np.dot(v, b) * b\n        v = v / np.linalg.norm(v)\n        ortho.append(v)\n    return np.stack(ortho, axis=1)\nB_ortho = gram_schmidt(B)\nprint(\"Orthonormal basis:\\n\", B_ortho)"
    },
    {
        "input": "Find coordinates of [0, 0, 0] in basis B = {[1, 0, 0], [0, 1, 0], [1, 1, 1]} and interpret.",
        "output": "import numpy as np\nB = np.array([[1, 0, 1], [0, 1, 1], [0, 0, 1]])\nv = np.array([0, 0, 0])\nv_B = np.linalg.inv(B) @ v\nprint(\"Zero vector in B:\", v_B)"
    },
    {
        "input": "Find the coordinates of vector [1, 1] in rotated basis by 45 degrees.",
        "output": "import numpy as np\nv = np.array([1, 1])\ntheta = np.pi / 4\nQ = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])\nv_B = Q.T @ v\nprint(\"Coordinates in rotated basis:\", v_B)"
    },
    {
        "input": "Let A = [[3, 1], [0, 3]]. Transform to Jordan form.",
        "output": "import sympy as sp\nA = sp.Matrix([[3, 1], [0, 3]])\nP, J = A.jordan_form()\nprint(\"Jordan form J:\")\nsp.pprint(J)\nprint(\"Transformation matrix P:\")\nsp.pprint(P)"
    },
    {
        "input": "Let A be a projection matrix onto x-axis. Show its matrix in basis B = {[1, 1], [1, -1]}.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 0]])\nB = np.array([[1, 1], [1, -1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Projection in new basis:\", A_B)"
    },
    {
        "input": "Let B = {[1, 0], [0, 1]}. Express vector [4, 5] in basis B.",
        "output": "import numpy as np\nB = np.array([[1, 0], [0, 1]])\nv = np.array([4, 5])\nv_B = np.linalg.inv(B) @ v\nprint(\"Coordinates of v in basis B:\", v_B)"
    },
    {
        "input": "Let B = {[2, 1], [1, 1]}. Express vector [5, 3] in basis B.",
        "output": "import numpy as np\nB = np.array([[2, 1], [1, 1]])\nv = np.array([5, 3])\nv_B = np.linalg.inv(B) @ v\nprint(\"Coordinates of v in basis B:\", v_B)"
    },
    {
        "input": "Convert vector [3, 4] from basis B = {[1, 1], [1, -1]} to standard basis.",
        "output": "import numpy as np\nB = np.array([[1, 1], [1, -1]])\nv_B = np.array([3, 4])\nv = B @ v_B\nprint(\"Vector in standard basis:\", v)"
    },
    {
        "input": "Let B = {[1, 2], [3, 4]}, and v = [7, 10]. Find v in basis B and convert back.",
        "output": "import numpy as np\nB = np.array([[1, 3], [2, 4]])\nv = np.array([7, 10])\nv_B = np.linalg.inv(B) @ v\nv_recovered = B @ v_B\nprint(\"v in B:\", v_B)\nprint(\"Back to standard basis:\", v_recovered)"
    },
    {
        "input": "Diagonalize matrix A = [[2, 1], [1, 2]] using its eigenbasis.",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\nevals, evecs = np.linalg.eig(A)\nD = np.diag(evals)\nprint(\"Eigenvalues:\", evals)\nprint(\"Eigenvectors (columns):\\n\", evecs)\nprint(\"Diagonalized A (in eigenbasis):\\n\", D)"
    },
    {
        "input": "Let v = [6, 2] and B = {[2, 0], [0, 1]}. Convert v to basis B.",
        "output": "import numpy as np\nB = np.array([[2, 0], [0, 1]])\nv = np.array([6, 2])\nv_B = np.linalg.inv(B) @ v\nprint(\"Coordinates of v in B:\", v_B)"
    },
    {
        "input": "Given vector [1, 2, 3] and standard basis, express in another orthonormal basis.",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nQ, _ = np.linalg.qr(np.random.randn(3,3))\nv_Q = Q.T @ v\nprint(\"Coordinates in orthonormal basis:\", v_Q)"
    },
    {
        "input": "Let B = [[1, 1], [0, 1]]. Compute inverse and verify B⁻¹B = I.",
        "output": "import numpy as np\nB = np.array([[1, 1], [0, 1]])\nB_inv = np.linalg.inv(B)\nI = B_inv @ B\nprint(\"Inverse of B:\\n\", B_inv)\nprint(\"Product B⁻¹ * B:\\n\", I)"
    },
    {
        "input": "Let v = [1, 1] and B = [[0, 1], [1, 0]]. Convert v to B and back.",
        "output": "import numpy as np\nB = np.array([[0, 1], [1, 0]])\nv = np.array([1, 1])\nv_B = np.linalg.inv(B) @ v\nv_recovered = B @ v_B\nprint(\"v in B:\", v_B)\nprint(\"Back in standard basis:\", v_recovered)"
    },
    {
        "input": "Demonstrate that changing basis using orthogonal matrix preserves norms.",
        "output": "import numpy as np\nv = np.random.rand(3)\nQ, _ = np.linalg.qr(np.random.rand(3, 3))\nv_Q = Q.T @ v\nprint(\"Original norm:\", np.linalg.norm(v))\nprint(\"Norm in new basis:\", np.linalg.norm(v_Q))"
    },
    {
        "input": "Let v = [1, 1, 1] and B = identity matrix. Confirm v_B = v.",
        "output": "import numpy as np\nB = np.eye(3)\nv = np.array([1, 1, 1])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in B:\", v_B)"
    },
    {
        "input": "Given matrix A = [[2, 0], [0, 3]], express A in basis B = [[1, 1], [1, -1]].",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 3]])\nB = np.array([[1, 1], [1, -1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix A in basis B:\\n\", A_B)"
    },
    {
        "input": "Let B = [[3, 1], [1, 2]]. Diagonalize B if possible.",
        "output": "import numpy as np\nB = np.array([[3, 1], [1, 2]])\nevals, evecs = np.linalg.eig(B)\nD = np.diag(evals)\nprint(\"Diagonal form:\\n\", D)\nprint(\"Eigenvectors:\\n\", evecs)"
    },
    {
        "input": "Find matrix that reflects across line y = x, and show it in standard basis.",
        "output": "import numpy as np\nR = np.array([[0, 1], [1, 0]])\nprint(\"Reflection across y = x:\\n\", R)"
    },
    {
        "input": "Convert coordinates [2, -1] from basis B = [[2, 1], [1, -1]] to standard basis.",
        "output": "import numpy as np\nB = np.array([[2, 1], [1, -1]])\nv_B = np.array([2, -1])\nv = B @ v_B\nprint(\"Vector in standard basis:\", v)"
    },
    {
        "input": "Use symbolic computation to express a vector in a symbolic basis.",
        "output": "from sympy import symbols, Matrix\na, b = symbols('a b')\nv = Matrix([a + b, 2*a - b])\nB = Matrix([[1, 2], [1, -1]])\nv_B = B.inv() * v\nprint(\"v in B:\", v_B)"
    },
    {
        "input": "Let A = [[0, -1], [1, 0]]. Show it represents a 90° rotation in ℝ².",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\nv = np.array([1, 0])\nv_rot = A @ v\nprint(\"Rotated vector:\", v_rot)"
    },
    {
        "input": "Transform matrix A = [[1, 0], [0, 2]] to new basis B = [[1, 1], [-1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 2]])\nB = np.array([[1, -1], [1, 1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"A in basis B:\\n\", A_B)"
    },
    {
        "input": "Let B = [[1, 0], [0, -1]]. Show it reflects across x-axis.",
        "output": "import numpy as np\nB = np.array([[1, 0], [0, -1]])\nv = np.array([3, 4])\nv_reflected = B @ v\nprint(\"Reflected vector:\", v_reflected)"
    },
    {
        "input": "Let A = [[1, 2], [3, 4]] and B = [[1, 0], [0, 2]]. Find A in basis B.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[1, 0], [0, 2]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"A in basis B:\\n\", A_B)"
    },
    {
        "input": "Let A = [[0, 1], [-1, 0]], a 90-degree rotation. Find its representation in basis B = [[1, 1], [-1, 1]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [-1, 0]])\nB = np.array([[1, -1], [1, 1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"A in basis B:\\n\", A_B)"
    },
    {
        "input": "Given A = [[3, 1], [0, 2]] and basis B = [[1, 2], [1, -1]], compute matrix representation in B.",
        "output": "import numpy as np\nA = np.array([[3, 1], [0, 2]])\nB = np.array([[1, 1], [2, -1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"A in basis B:\\n\", A_B)"
    },
    {
        "input": "Let A = [[2, 0], [0, 3]]. Use orthogonal basis B = [[1/√2, 1/√2], [-1/√2, 1/√2]]. Find A in B.",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 3]])\nB = np.array([[1/np.sqrt(2), -1/np.sqrt(2)], [1/np.sqrt(2), 1/np.sqrt(2)]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"A in basis B:\\n\", A_B)"
    },
    {
        "input": "Let A = [[5, 2], [2, 5]]. Diagonalize A using its eigenbasis.",
        "output": "import numpy as np\nA = np.array([[5, 2], [2, 5]])\nevals, evecs = np.linalg.eig(A)\nD = np.diag(evals)\nprint(\"Eigenvalues:\", evals)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Change of basis matrix P (eigenvectors):\\n\", evecs)"
    },
    {
        "input": "Let A = [[1, 0], [0, 2]]. Find its representation in basis B = [[2, 1], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 2]])\nB = np.array([[2, 1], [1, 1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix A in basis B:\\n\", A_B)"
    },
    {
        "input": "Let A = [[1, 2], [3, 4]] and basis C = [[1, 1], [0, 1]]. Compute A in C.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nC = np.array([[1, 0], [1, 1]])\nA_C = np.linalg.inv(C) @ A @ C\nprint(\"A in basis C:\\n\", A_C)"
    },
    {
        "input": "Given linear transformation matrix A = [[4, 1], [2, 3]], find A in new basis B = [[1, 0], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[4, 1], [2, 3]])\nB = np.array([[1, 1], [0, 1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix A in new basis B:\\n\", A_B)"
    },
    {
        "input": "Let A = [[3, -1], [1, 1]]. Find a basis that diagonalizes A.",
        "output": "import numpy as np\nA = np.array([[3, -1], [1, 1]])\nevals, evecs = np.linalg.eig(A)\nprint(\"Eigenvalues:\", evals)\nprint(\"Eigenbasis:\\n\", evecs)"
    },
    {
        "input": "Given basis B = [[1, 1], [1, -1]] and linear map A = [[2, 0], [0, 3]], compute A_B.",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 3]])\nB = np.array([[1, 1], [1, -1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"Matrix in new basis:\\n\", A_B)"
    },
    {
        "input": "Prove similarity of A and A' = P⁻¹AP implies they share eigenvalues.",
        "output": "import numpy as np\nA = np.array([[4, 2], [1, 3]])\nP = np.array([[1, 1], [0, 1]])\nA_prime = np.linalg.inv(P) @ A @ P\nevals1 = np.linalg.eigvals(A)\nevals2 = np.linalg.eigvals(A_prime)\nprint(\"Eigenvalues of A:\", evals1)\nprint(\"Eigenvalues of A':\", evals2)"
    },
    {
        "input": "Let A = [[0, 1], [-2, -3]]. Find its representation in its eigenbasis.",
        "output": "import numpy as np\nA = np.array([[0, 1], [-2, -3]])\nevals, evecs = np.linalg.eig(A)\nA_diag = np.linalg.inv(evecs) @ A @ evecs\nprint(\"Diagonal matrix in eigenbasis:\\n\", A_diag)"
    },
    {
        "input": "Let A = [[1, 1], [0, 1]] be non-diagonalizable. Find Jordan form.",
        "output": "import sympy as sp\nA = sp.Matrix([[1, 1], [0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan Form:\\n\", J)"
    },
    {
        "input": "Let A = [[0, 1], [-1, 0]]. Rotate a vector and express in rotated basis.",
        "output": "import numpy as np\nA = np.array([[0, 1], [-1, 0]])\nv = np.array([1, 0])\nrotated_v = A @ v\nB = A\nv_in_B = np.linalg.inv(B) @ rotated_v\nprint(\"Vector in rotated basis:\", v_in_B)"
    },
    {
        "input": "Let A = [[1, 4], [2, 3]], and B = [[1, 0], [2, 1]]. Find matrix in B basis.",
        "output": "import numpy as np\nA = np.array([[1, 4], [2, 3]])\nB = np.array([[1, 2], [0, 1]])\nA_B = np.linalg.inv(B) @ A @ B\nprint(\"A in basis B:\\n\", A_B)"
    },
    {
        "input": "Express vector v = [3, 2] in basis B = [[1, 1], [1, -1]].",
        "output": "import numpy as np\nv = np.array([3, 2])\nB = np.array([[1, 1], [1, -1]])\nv_new = np.linalg.inv(B) @ v\nprint(\"Coordinates of v in basis B:\", v_new)"
    },
    {
        "input": "Convert v = [1, 2] from basis B = [[2, 1], [1, 1]] to standard basis.",
        "output": "import numpy as np\nv_B = np.array([1, 2])\nB = np.array([[2, 1], [1, 1]])\nv_standard = B @ v_B\nprint(\"v in standard basis:\", v_standard)"
    },
    {
        "input": "Given basis B = [[1, 2], [0, 1]] and v = [5, 3], find coordinates of v in B.",
        "output": "import numpy as np\nv = np.array([5, 3])\nB = np.array([[1, 0], [2, 1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "Find vector in standard basis given v_B = [1, -1] and B = [[1, 1], [0, 2]].",
        "output": "import numpy as np\nv_B = np.array([1, -1])\nB = np.array([[1, 0], [1, 2]])\nv_standard = B @ v_B\nprint(\"v in standard basis:\", v_standard)"
    },
    {
        "input": "Let v = [2, -1]. Find its coordinates in basis B = [[1, 0], [1, 1]].",
        "output": "import numpy as np\nv = np.array([2, -1])\nB = np.array([[1, 1], [0, 1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "Let B = [[2, 1], [-1, 1]] and v_B = [0, 3]. Find v in standard basis.",
        "output": "import numpy as np\nv_B = np.array([0, 3])\nB = np.array([[2, -1], [1, 1]])\nv_std = B @ v_B\nprint(\"v in standard basis:\", v_std)"
    },
    {
        "input": "Show change of basis and back again gives same vector: v = [4, 5], B = [[1, 1], [0, 2]].",
        "output": "import numpy as np\nv = np.array([4, 5])\nB = np.array([[1, 0], [1, 2]])\nv_B = np.linalg.inv(B) @ v\nv_back = B @ v_B\nprint(\"Back to standard:\", v_back)"
    },
    {
        "input": "Transform v = [6, -2] to coordinates in B = [[1, 2], [1, -1]].",
        "output": "import numpy as np\nv = np.array([6, -2])\nB = np.array([[1, 1], [2, -1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in B:\", v_B)"
    },
    {
        "input": "Let v = [1, 3] and basis B = [[2, 1], [1, -1]]. Find v_B and verify back-transform.",
        "output": "import numpy as np\nv = np.array([1, 3])\nB = np.array([[2, 1], [1, -1]])\nv_B = np.linalg.inv(B) @ v\nv_std = B @ v_B\nprint(\"v_B:\", v_B)\nprint(\"Back to standard:\", v_std)"
    },
    {
        "input": "Express vector [7, 4] in basis B = [[1, 3], [2, 1]].",
        "output": "import numpy as np\nv = np.array([7, 4])\nB = np.array([[1, 2], [3, 1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in basis B:\", v_B)"
    },
    {
        "input": "Convert vector [2, 0] from B = [[1, 0], [1, 1]] to standard basis.",
        "output": "import numpy as np\nv_B = np.array([2, 0])\nB = np.array([[1, 1], [0, 1]])\nv_std = B @ v_B\nprint(\"Standard basis vector:\", v_std)"
    },
    {
        "input": "Convert v = [5, 1] to basis B = [[1, -1], [1, 1]] and back to standard.",
        "output": "import numpy as np\nv = np.array([5, 1])\nB = np.array([[1, 1], [-1, 1]])\nv_B = np.linalg.inv(B) @ v\nv_std = B @ v_B\nprint(\"v_B:\", v_B)\nprint(\"v back in standard:\", v_std)"
    },
    {
        "input": "Let B = [[3, 1], [1, 2]]. Convert v = [4, 5] into B basis.",
        "output": "import numpy as np\nv = np.array([4, 5])\nB = np.array([[3, 1], [1, 2]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in B basis:\", v_B)"
    },
    {
        "input": "Convert [0, 1] to basis B = [[1, 0], [2, 1]].",
        "output": "import numpy as np\nv = np.array([0, 1])\nB = np.array([[1, 2], [0, 1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in B basis:\", v_B)"
    },
    {
        "input": "Express v = [6, 2] in rotated basis B = [[cos(pi/4), -sin(pi/4)], [sin(pi/4), cos(pi/4)]].",
        "output": "import numpy as np\nv = np.array([6, 2])\ntheta = np.pi / 4\nB = np.array([[np.cos(theta), np.sin(theta)], [-np.sin(theta), np.cos(theta)]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in rotated basis:\", v_B)"
    },
    {
        "input": "Convert v = [1, 2] to basis B = [[2, 2], [1, -1]].",
        "output": "import numpy as np\nv = np.array([1, 2])\nB = np.array([[2, 1], [2, -1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in B:\", v_B)"
    },
    {
        "input": "Let v_B = [3, -1] and B = [[4, 1], [2, 1]]. Get standard coordinates.",
        "output": "import numpy as np\nv_B = np.array([3, -1])\nB = np.array([[4, 2], [1, 1]])\nv_std = B @ v_B\nprint(\"v in standard basis:\", v_std)"
    },
    {
        "input": "Given basis B = [[1, 2], [1, -1]], find inverse transformation matrix.",
        "output": "import numpy as np\nB = np.array([[1, 1], [2, -1]])\nB_inv = np.linalg.inv(B)\nprint(\"Inverse change of basis matrix:\\n\", B_inv)"
    },
    {
        "input": "Let B = [[1, 0], [1, 1]]. Convert v = [3, 3] to B and back.",
        "output": "import numpy as np\nv = np.array([3, 3])\nB = np.array([[1, 1], [0, 1]])\nv_B = np.linalg.inv(B) @ v\nv_back = B @ v_B\nprint(\"v_B:\", v_B)\nprint(\"Back to standard:\", v_back)"
    },
    {
        "input": "Let v = [2, -3] and B = [[1, 1], [2, 1]]. Find v_B and check correctness.",
        "output": "import numpy as np\nv = np.array([2, -3])\nB = np.array([[1, 2], [1, 1]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in B:\", v_B)\nprint(\"Back to standard:\", B @ v_B)"
    },
    {
        "input": "Convert vector [7, 5] to B = [[1, 2], [3, 1]] and return to standard.",
        "output": "import numpy as np\nv = np.array([7, 5])\nB = np.array([[1, 3], [2, 1]])\nv_B = np.linalg.inv(B) @ v\nv_std = B @ v_B\nprint(\"v_B:\", v_B)\nprint(\"Back to standard:\", v_std)"
    },
    {
        "input": "Express v = [5, 6] in orthonormal basis B = [[1/√2, -1/√2], [1/√2, 1/√2]].",
        "output": "import numpy as np\nv = np.array([5, 6])\nB = np.array([[1/np.sqrt(2), 1/np.sqrt(2)], [-1/np.sqrt(2), 1/np.sqrt(2)]])\nv_B = np.linalg.inv(B) @ v\nprint(\"v in orthonormal basis:\", v_B)"
    },
    {
        "input": "Given linear transformation matrix A = [[2, 1], [0, 3]] and basis B = [[1, 1], [0, 1]], compute [T]_B.",
        "output": "import numpy as np\nA = np.array([[2, 1], [0, 3]])\nB = np.array([[1, 0], [1, 1]])\nP = B\nP_inv = np.linalg.inv(P)\nT_B = P_inv @ A @ P\nprint(\"Matrix representation [T]_B:\", T_B)"
    },
    {
        "input": "Let A = [[0, 1], [-2, -3]] and B = [[1, 1], [1, -1]]. Find representation of A in basis B.",
        "output": "import numpy as np\nA = np.array([[0, 1], [-2, -3]])\nB = np.array([[1, 1], [1, -1]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nprint(\"Matrix A in basis B:\", A_B)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]] and B = [[1, 0], [1, 1]], find its form in B basis and back to standard.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[1, 1], [0, 1]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nA_std_back = P @ A_B @ P_inv\nprint(\"A in basis B:\", A_B)\nprint(\"Back to standard:\", A_std_back)"
    },
    {
        "input": "Given transformation A = [[4, 0], [1, 3]], and B = [[1, 2], [0, 1]], find [A]_B.",
        "output": "import numpy as np\nA = np.array([[4, 0], [1, 3]])\nB = np.array([[1, 0], [2, 1]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nprint(\"[A]_B:\", A_B)"
    },
    {
        "input": "Let T: R^2 → R^2 be represented by A = [[0, 1], [1, 0]]. Find T in basis B = [[1, 1], [1, -1]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\nB = np.array([[1, 1], [1, -1]])\nP = B\nP_inv = np.linalg.inv(P)\nT_B = P_inv @ A @ P\nprint(\"T in basis B:\", T_B)"
    },
    {
        "input": "Given A = [[2, 3], [0, 1]], and B = [[1, 2], [2, 3]], compute [A]_B.",
        "output": "import numpy as np\nA = np.array([[2, 3], [0, 1]])\nB = np.array([[1, 2], [2, 3]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nprint(\"A in basis B:\", A_B)"
    },
    {
        "input": "Given transformation T(v) = Av with A = [[1, 1], [0, 1]], find its matrix under basis B = [[1, 0], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1], [0, 1]])\nB = np.array([[1, 1], [0, 1]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nprint(\"Matrix A in new basis:\", A_B)"
    },
    {
        "input": "Find matrix representation of reflection across x-axis in basis B = [[1, 1], [1, -1]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, -1]])\nB = np.array([[1, 1], [1, -1]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nprint(\"Reflection matrix in B:\", A_B)"
    },
    {
        "input": "Diagonalize matrix A = [[4, 1], [0, 4]] and find similarity transformation.",
        "output": "import numpy as np\nA = np.array([[4, 1], [0, 4]])\nw, P = np.linalg.eig(A)\nD = np.diag(w)\nP_inv = np.linalg.inv(P)\nA_diag = P @ D @ P_inv\nprint(\"Eigenvalues:\", w)\nprint(\"Diagonal matrix:\", D)\nprint(\"Reconstructed A:\", A_diag)"
    },
    {
        "input": "Given A = [[1, 2], [3, 4]] and eigenvectors [[-0.85, 0.52], [0.52, 0.85]], construct diagonal form.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\n_, P = np.linalg.eig(A)\nD = np.diag(np.linalg.eigvals(A))\nP_inv = np.linalg.inv(P)\nA_diag = P @ D @ P_inv\nprint(\"Diagonalized A:\", A_diag)"
    },
    {
        "input": "Find basis in which A = [[5, 4], [1, 2]] becomes diagonal.",
        "output": "import numpy as np\nA = np.array([[5, 4], [1, 2]])\nevals, evecs = np.linalg.eig(A)\nprint(\"Diagonal form:\", np.diag(evals))\nprint(\"Basis of eigenvectors:\", evecs)"
    },
    {
        "input": "Construct similarity transformation for A = [[0, 1], [-1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [-1, 0]])\nevals, evecs = np.linalg.eig(A)\nprint(\"Eigenvalues:\", evals)\nprint(\"Eigenvectors:\", evecs)"
    },
    {
        "input": "Use Jordan form to represent A = [[1, 1], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1], [0, 1]])\nprint(\"Jordan form of A:\", A)"
    },
    {
        "input": "Compute transformation matrix to diagonalize A = [[3, 1], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [0, 3]])\nevals, evecs = np.linalg.eig(A)\nprint(\"Eigenvalues:\", evals)\nprint(\"Eigenvectors:\", evecs)"
    },
    {
        "input": "Given A = [[4, 2], [1, 3]], compute similarity matrix P and diagonal D.",
        "output": "import numpy as np\nA = np.array([[4, 2], [1, 3]])\nevals, evecs = np.linalg.eig(A)\nP = evecs\nD = np.diag(evals)\nprint(\"P:\", P)\nprint(\"D:\", D)"
    },
    {
        "input": "Given matrix A = [[2, 1, 0], [0, 3, 1], [0, 0, 4]] and basis B = [[1,0,0], [1,1,0], [1,1,1]], compute [A]_B.",
        "output": "import numpy as np\nA = np.array([[2,1,0], [0,3,1], [0,0,4]])\nB = np.array([[1,0,0], [1,1,0], [1,1,1]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nprint(\"[A]_B:\", A_B)"
    },
    {
        "input": "Diagonalize the matrix A = [[6, 2, 1], [0, 3, 0], [0, 0, 3]] and verify A = P D P⁻¹.",
        "output": "import numpy as np\nA = np.array([[6, 2, 1], [0, 3, 0], [0, 0, 3]])\nw, P = np.linalg.eig(A)\nD = np.diag(w)\nP_inv = np.linalg.inv(P)\nA_diag = P @ D @ P_inv\nprint(\"Eigenvalues:\", w)\nprint(\"Diagonalized A:\", A_diag)"
    },
    {
        "input": "Let A = [[4,0,1], [0,2,0], [0,0,3]]. Transform A using B = [[1,1,0], [0,1,1], [1,0,1]].",
        "output": "import numpy as np\nA = np.array([[4,0,1], [0,2,0], [0,0,3]])\nB = np.array([[1,1,0], [0,1,1], [1,0,1]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nprint(\"A in basis B:\", A_B)"
    },
    {
        "input": "Given A = [[1,0,0], [0,2,0], [0,0,3]], apply a basis change with B = [[2,0,0], [0,2,0], [0,0,2]].",
        "output": "import numpy as np\nA = np.diag([1,2,3])\nB = np.diag([2,2,2])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nprint(\"Transformed A:\", A_B)"
    },
    {
        "input": "Given 3D transformation matrix A = [[0,1,0], [0,0,1], [1,0,0]], find its form in basis B = I.",
        "output": "import numpy as np\nA = np.array([[0,1,0], [0,0,1], [1,0,0]])\nI = np.identity(3)\nP_inv = np.linalg.inv(I)\nA_B = P_inv @ A @ I\nprint(\"A in identity basis:\", A_B)"
    },
    {
        "input": "Compute similarity transform for A = [[2,1,0], [0,2,1], [0,0,2]] using random invertible matrix.",
        "output": "import numpy as np\nA = np.array([[2,1,0], [0,2,1], [0,0,2]])\nP = np.array([[1,1,0], [0,1,1], [1,0,1]])\nP_inv = np.linalg.inv(P)\nA_sim = P_inv @ A @ P\nprint(\"Similarity transformed A:\", A_sim)"
    },
    {
        "input": "Let A = np.eye(4). Apply change of basis with B = [[1,0,0,0],[1,1,0,0],[1,1,1,0],[1,1,1,1]].",
        "output": "import numpy as np\nA = np.eye(4)\nB = np.array([[1,0,0,0],[1,1,0,0],[1,1,1,0],[1,1,1,1]])\nP_inv = np.linalg.inv(B)\nA_B = P_inv @ A @ B\nprint(\"Transformed A:\", A_B)"
    },
    {
        "input": "Given a 4x4 diagonal matrix A = diag([1,2,3,4]), confirm trace and determinant are basis-invariant.",
        "output": "import numpy as np\nA = np.diag([1,2,3,4])\nB = np.array([[1,0,0,0],[1,1,0,0],[1,1,1,0],[1,1,1,1]])\nP_inv = np.linalg.inv(B)\nA_B = P_inv @ A @ B\nprint(\"Trace original:\", np.trace(A))\nprint(\"Trace transformed:\", np.trace(A_B))\nprint(\"Det original:\", np.linalg.det(A))\nprint(\"Det transformed:\", np.linalg.det(A_B))"
    },
    {
        "input": "Use eigendecomposition to diagonalize A = [[1,0,0],[0,2,0],[0,0,3]].",
        "output": "import numpy as np\nA = np.diag([1,2,3])\nw, v = np.linalg.eig(A)\nP = v\nD = np.diag(w)\nP_inv = np.linalg.inv(P)\nprint(\"Diagonal matrix:\", D)"
    },
    {
        "input": "Compute the change of basis matrix from standard basis to B = [[1,2,3], [0,1,1], [1,0,1]].",
        "output": "import numpy as np\nB = np.array([[1, 0, 2], [0, 1, 1], [1, 1, 0]], dtype=float)\nP = B\nP_inv = np.linalg.inv(P)\nprint(\"Change of basis matrix P (from standard to B):\")\nprint(P)\nprint(\"Inverse P⁻¹ (from B to standard):\")\nprint(P_inv)"
    },
    {
        "input": "For transformation T: R^3 → R^3 with A = [[0,1,0],[0,0,1],[1,0,0]], compute A^3.",
        "output": "import numpy as np\nA = np.array([[0,1,0],[0,0,1],[1,0,0]])\nA3 = A @ A @ A\nprint(\"A³:\", A3)"
    },
    {
        "input": "Given A = [[2,1,0],[0,2,1],[0,0,2]], compute its minimal polynomial.",
        "output": "import numpy as np\nA = np.array([[2,1,0],[0,2,1],[0,0,2]])\nA2 = A @ A\nA3 = A2 @ A\nI = np.eye(3)\nprint(\"Try minimal polynomial (A-2I)^3 = 0:\", A3 - 6*A2 + 12*A - 8*I)"
    },
    {
        "input": "Let A be a rotation matrix in 3D around z-axis. Compute its form in a new orthogonal basis.",
        "output": "import numpy as np\nfrom scipy.spatial.transform import Rotation as R\nA = R.from_euler('z', 90, degrees=True).as_matrix()\nB = np.eye(3)\nP_inv = np.linalg.inv(B)\nA_B = P_inv @ A @ B\nprint(\"Rotation matrix in new basis:\", A_B)"
    },
    {
        "input": "Construct a transformation matrix that reflects over the yz-plane in 3D.",
        "output": "import numpy as np\nA = np.diag([-1,1,1])\nprint(\"Reflection over yz-plane:\", A)"
    },
    {
        "input": "Construct matrix for projection onto xy-plane in R^3.",
        "output": "import numpy as np\nA = np.array([[1,0,0],[0,1,0],[0,0,0]])\nprint(\"Projection onto xy-plane:\", A)"
    },
    {
        "input": "Rotate vector [1,0,0] by 120° around axis [1,1,1] using rotation matrix.",
        "output": "import numpy as np\nfrom scipy.spatial.transform import Rotation as R\nrot = R.from_rotvec((2*np.pi/3)*np.array([1,1,1])/np.sqrt(3))\nv = np.array([1,0,0])\nresult = rot.apply(v)\nprint(\"Rotated vector:\", result)"
    },
    {
        "input": "Diagonalize matrix A = [[2,1,0],[0,2,1],[0,0,2]].",
        "output": "import numpy as np\nA = np.array([[2,1,0],[0,2,1],[0,0,2]])\nevals, evecs = np.linalg.eig(A)\nprint(\"Eigenvalues:\", evals)\nprint(\"Eigenvectors:\", evecs)"
    },
    {
        "input": "Given a 4x4 matrix A = diag([1,2,3,4]), verify similarity transformation with identity matrix.",
        "output": "import numpy as np\nA = np.diag([1,2,3,4])\nP = np.eye(4)\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nprint(\"Transformed A:\", A_B)"
    },
    {
        "input": "Compute the matrix of T(x) = Ax where A = [[0,1],[1,0]] under basis B = [[1,1],[1,-1]].",
        "output": "import numpy as np\nA = np.array([[0,1],[1,0]])\nB = np.array([[1,1],[1,-1]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nprint(\"Matrix of T under B:\", A_B)"
    },
    {
        "input": "Given a matrix A = [[0,1,0], [0,0,1], [0,0,0]], compute its nilpotency index.",
        "output": "import numpy as np\nA = np.array([[0,1,0], [0,0,1], [0,0,0]])\nA2 = A @ A\nA3 = A2 @ A\nprint(\"A^3:\", A3)"
    },
    {
        "input": "Transform matrix A = [[0,-1],[1,0]] (90° rotation) into new basis B = [[1,1],[1,-1]].",
        "output": "import numpy as np\nA = np.array([[0,-1],[1,0]])\nB = np.array([[1,1],[1,-1]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nprint(\"A in basis B:\", A_B)"
    },
    {
        "input": "Let A = diag([1,2,3]). Compute A^5 using diagonal powers.",
        "output": "import numpy as np\nA = np.diag([1,2,3])\nA5 = np.diag([1**5, 2**5, 3**5])\nprint(\"A^5:\", A5)"
    },
    {
        "input": "Determine the matrix representing scaling by 3 in x, -2 in y, and 0.5 in z axes.",
        "output": "import numpy as np\nA = np.diag([3, -2, 0.5])\nprint(\"Scaling matrix:\", A)"
    },
    {
        "input": "Let A = [[3,0],[0,2]]. Construct matrix that transforms standard coordinates to eigenbasis.",
        "output": "import numpy as np\nA = np.array([[3,0],[0,2]])\nw, v = np.linalg.eig(A)\nP = v\nprint(\"Change of basis matrix:\", P)"
    },
    {
        "input": "Transform A = [[1,1],[0,1]] using a random invertible matrix and compute A'.",
        "output": "import numpy as np\nA = np.array([[1,1],[0,1]])\nP = np.array([[2,1],[1,1]])\nP_inv = np.linalg.inv(P)\nA_sim = P_inv @ A @ P\nprint(\"Similarity transform:\", A_sim)"
    },
    {
        "input": "Given A = [[2,0],[0,3]], transform into basis B = [[1,1],[1,-1]] and back to standard.",
        "output": "import numpy as np\nA = np.diag([2,3])\nB = np.array([[1,1],[1,-1]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nA_reconstructed = P @ A_B @ P_inv\nprint(\"A in B:\", A_B)\nprint(\"Reconstructed A:\", A_reconstructed)"
    },
    {
        "input": "Let T be a shear transformation in 2D: T(x, y) = (x + y, y). Write its matrix and change basis.",
        "output": "import numpy as np\nA = np.array([[1,1],[0,1]])\nB = np.array([[1,1],[1,-1]])\nP = B\nP_inv = np.linalg.inv(P)\nA_B = P_inv @ A @ P\nprint(\"Shear in new basis:\", A_B)"
    },
    {
        "input": "Diagonalize the symmetric matrix A = [[2,1],[1,2]] using eigendecomposition.",
        "output": "import numpy as np\nA = np.array([[2,1],[1,2]])\nw, v = np.linalg.eigh(A)\nD = np.diag(w)\nprint(\"Diagonal matrix:\", D)\nprint(\"Eigenvectors:\", v)"
    },
    {
        "input": "Construct matrix that projects any 3D vector onto the xz-plane.",
        "output": "import numpy as np\nA = np.array([[1,0,0],[0,0,0],[0,0,1]])\nprint(\"Projection matrix onto xz-plane:\", A)"
    },
    {
        "input": "Find eigenvectors and eigenvalues of A = [[4,1],[2,3]].",
        "output": "import numpy as np\nA = np.array([[4,1],[2,3]])\nw, v = np.linalg.eig(A)\nprint(\"Eigenvalues:\", w)\nprint(\"Eigenvectors:\", v)"
    },
    {
        "input": "Given A = [[1,1],[0,1]], find generalized eigenvectors.",
        "output": "import numpy as np\nA = np.array([[1,1],[0,1]])\nw, v = np.linalg.eig(A)\nprint(\"Eigenvalues:\", w)\nprint(\"Eigenvectors:\", v)"
    },
    {
        "input": "Rotate a vector by 180 degrees using a transformation matrix in 2D.",
        "output": "import numpy as np\nA = np.array([[-1,0],[0,-1]])\nv = np.array([3,2])\nresult = A @ v\nprint(\"Rotated vector:\", result)"
    },
    {
        "input": "Let A = [[2,3],[0,1]]. Apply similarity transformation using B = [[1,0],[1,1]].",
        "output": "import numpy as np\nA = np.array([[2,3],[0,1]])\nB = np.array([[1,0],[1,1]])\nB_inv = np.linalg.inv(B)\nA_sim = B_inv @ A @ B\nprint(\"A in new basis:\", A_sim)"
    },
    {
        "input": "Use Python to test if A = [[2,0],[0,2]] scales all vectors uniformly.",
        "output": "import numpy as np\nA = np.array([[2,0],[0,2]])\nv = np.array([1, 1])\nscaled = A @ v\nprint(\"Scaled vector:\", scaled)\nprint(\"Scale factor:\", scaled[0]/v[0])"
    },
    {
        "input": "Demonstrate that similar matrices have the same eigenvalues. Use A = [[2, 1], [0, 2]] and P = [[1, 1], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [0, 2]])\nP = np.array([[1, 1], [0, 1]])\nP_inv = np.linalg.inv(P)\nB = P_inv @ A @ P\nevals_A = np.linalg.eigvals(A)\nevals_B = np.linalg.eigvals(B)\nprint(\"Eigenvalues of A:\", evals_A)\nprint(\"Eigenvalues of B (similar to A):\", evals_B)"
    },
    {
        "input": "Change the basis of vector v = [1, 2, 3] from standard basis to new basis B = [[1, 0, 1], [0, 1, 1], [0, 0, 1]].",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nB = np.array([[1, 0, 1], [0, 1, 1], [0, 0, 1]])\nB_inv = np.linalg.inv(B)\nv_B = B_inv @ v\nprint(\"Original vector v:\", v)\nprint(\"Basis matrix B:\", B)\nprint(\"Coordinates of v in basis B:\", v_B)"
    },
    {
        "input": "Given a matrix A = [[4, 2], [1, 3]], find its representation in a basis of its eigenvectors.",
        "output": "import numpy as np\nA = np.array([[4, 2], [1, 3]])\nevals, evecs = np.linalg.eig(A)\nD = np.diag(evals)\nP = evecs\nP_inv = np.linalg.inv(P)\nA_diag = P_inv @ A @ P\nprint(\"Original matrix A:\", A)\nprint(\"Diagonalized form D:\", A_diag)\nprint(\"Eigenbasis matrix P:\", P)"
    },
    {
        "input": "Rotate a vector v = [2, 1] by 90 degrees using a change of basis.",
        "output": "import numpy as np\nv = np.array([2, 1])\ntheta = np.pi / 2\nR = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])\nv_rot = R @ v\nprint(\"Original vector:\", v)\nprint(\"Rotation matrix (90°):\", R)\nprint(\"Rotated vector:\", v_rot)"
    },
    {
        "input": "Project vector v = [2, 3, 4] onto a 2D subspace using basis B = [[1, 0], [0, 1], [0, 0]].",
        "output": "import numpy as np\nv = np.array([2, 3, 4])\nB = np.array([[1, 0], [0, 1], [0, 0]])\nB_proj = B @ np.linalg.pinv(B.T @ B) @ B.T\nv_proj = B_proj @ v\nprint(\"Original vector v:\", v)\nprint(\"Projection matrix:\", B_proj)\nprint(\"Projected vector in subspace:\", v_proj)"
    },
    {
        "input": "Verify numerically that similarity transformations preserve minimal polynomial. Use A = [[2,1],[0,2]] and B = P⁻¹AP with P = [[1,1],[0,1]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [0, 2]])\nP = np.array([[1, 1], [0, 1]])\nP_inv = np.linalg.inv(P)\nB = P_inv @ A @ P\npoly_A = np.poly(A)\npoly_B = np.poly(B)\nprint(\"Char poly of A:\", poly_A)\nprint(\"Char poly of B:\", poly_B)"
    },
    {
        "input": "Use sympy to symbolically verify change of basis of vector v = [x, y] under basis B = [[1,1],[0,1]].",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nv = sp.Matrix([x, y])\nB = sp.Matrix([[1, 1], [0, 1]])\nB_inv = B.inv()\nv_new = B_inv * v\nprint(\"Symbolic vector v:\", v)\nprint(\"New coordinates in basis B:\", v_new)"
    },
    {
        "input": "Demonstrate how Jordan blocks appear when change of basis fails to diagonalize A = [[2, 1], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [0, 2]])\nevals, evecs = np.linalg.eig(A)\nprint(\"Eigenvalues:\", evals)\nprint(\"Eigenvectors:\", evecs)"
    },
    {
        "input": "Transform matrix A = [[0,1,0],[0,0,1],[1,0,0]] into new basis B = identity.",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\nB = np.eye(3)\nB_inv = np.linalg.inv(B)\nA_new = B_inv @ A @ B\nprint(\"A in new basis:\", A_new)"
    },
    {
        "input": "Verify change of basis in symbolic 3D space using sympy. Use basis B = [[1,0,0],[1,1,0],[1,1,1]] and vector v = [a, b, c].",
        "output": "import sympy as sp\na, b, c = sp.symbols('a b c')\nv = sp.Matrix([a, b, c])\nB = sp.Matrix([[1, 0, 0], [1, 1, 0], [1, 1, 1]])\nB_inv = B.inv()\nv_new = B_inv * v\nprint(\"Symbolic vector v:\", v)\nprint(\"Coordinates in basis B:\", v_new)"
    },
    {
        "input": "Compute the change of coordinates of vector v = [2, 1, 3] in basis B = [[1,0,1], [0,1,1], [0,0,1]].",
        "output": "import numpy as np\nv = np.array([2, 1, 3])\nB = np.array([[1, 0, 1], [0, 1, 1], [0, 0, 1]])\ncoords = np.linalg.inv(B) @ v\nprint(\"Vector v in basis B:\", coords)"
    },
    {
        "input": "Demonstrate the effect of changing from one non-orthogonal basis to another in 2D.",
        "output": "import numpy as np\nv = np.array([4, 5])\nB1 = np.array([[1, 2], [1, 1]])\nB2 = np.array([[2, 1], [1, 2]])\nP = np.linalg.inv(B1) @ B2\nv_B1 = np.linalg.inv(B1) @ v\nv_B2 = P @ v_B1\nprint(\"v in basis B1:\", v_B1)\nprint(\"v in basis B2:\", v_B2)"
    },
    {
        "input": "Use a random orthogonal matrix to change the basis of a 3D vector.",
        "output": "import numpy as np\nfrom scipy.stats import ortho_group\nQ = ortho_group.rvs(3)\nv = np.array([1, 0, 0])\nv_new = Q @ v\nprint(\"Orthogonal matrix Q:\", Q)\nprint(\"v in new basis:\", v_new)"
    },
    {
        "input": "Construct a basis using the Gram-Schmidt process from vectors [[1,1,0],[1,0,1],[0,1,1]].",
        "output": "import numpy as np\ndef gram_schmidt(V):\n    U = []\n    for v in V:\n        v = v.astype(float)\n        for u in U:\n            v = v - (np.dot(u, v) / np.dot(u, u)) * u\n        U.append(v)\n    return np.array(U)\nV = [np.array([1,1,0]), np.array([1,0,1]), np.array([0,1,1])]\northonormal = gram_schmidt(V)\nprint(\"Orthonormal basis (not normalized):\\n\", orthonormal)"
    },
    {
        "input": "Convert a basis defined in cylindrical coordinates to Cartesian.",
        "output": "import numpy as np\nr, theta, z = 2, np.pi / 4, 3\nx = r * np.cos(theta)\ny = r * np.sin(theta)\nv = np.array([x, y, z])\nprint(\"Cylindrical to Cartesian:\", v)"
    },
    {
        "input": "Use symbolic matrices to check change of basis identity: B⁻¹AB.",
        "output": "import sympy as sp\nA = sp.Matrix([[a, b], [0, a]])\nB = sp.Matrix([[1, 1], [0, 1]])\nA_new = B.inv() * A * B\nprint(\"A in new basis:\", A_new)"
    },
    {
        "input": "Find the transformation matrix that rotates a 2D vector by 45 degrees.",
        "output": "import numpy as np\ntheta = np.pi / 4\nR = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])\nprint(\"Rotation matrix (45°):\", R)"
    },
    {
        "input": "Decompose a vector using a non-standard orthogonal basis. Use Q = [[1,1],[-1,1]] / √2.",
        "output": "import numpy as np\nQ = np.array([[1, 1], [-1, 1]]) / np.sqrt(2)\nv = np.array([3, 1])\nv_coords = Q.T @ v\nprint(\"Original vector:\", v)\nprint(\"Orthonormal basis Q:\", Q)\nprint(\"Coordinates in basis Q:\", v_coords)"
    },
    {
        "input": "Transform vector v = [1, 0, 1] to the basis B = [[1, 1, 0], [0, 1, 1], [1, 0, 1]] and back to standard basis.",
        "output": "import numpy as np\nv = np.array([1, 0, 1])\nB = np.array([[1, 1, 0], [0, 1, 1], [1, 0, 1]])\nB_inv = np.linalg.inv(B)\nv_coords = B_inv @ v\nv_reconstructed = B @ v_coords\nprint(\"Coordinates of v in basis B:\", v_coords)\nprint(\"Reconstructed vector in standard basis:\", v_reconstructed)"
    },
    {
        "input": "Given basis B = [[2, 0], [1, 3]] and C = [[1, 1], [0, 2]], find the change of basis matrix from B to C.",
        "output": "import numpy as np\nB = np.array([[2, 0], [1, 3]])\nC = np.array([[1, 1], [0, 2]])\nB_to_C = np.linalg.inv(C) @ B\nprint(\"Change of basis matrix from B to C:\", B_to_C)"
    },
    {
        "input": "Given a symbolic matrix A and basis B, express A in basis B using sympy.",
        "output": "import sympy as sp\nA = sp.Matrix([[a, b], [c, d]])\nB = sp.Matrix([[1, 1], [0, 1]])\nA_B = B.inv() * A * B\nprint(\"Matrix A in basis B:\")\nsp.pprint(A_B)"
    },
    {
        "input": "Apply change of basis to vector v = [3, 2] using random invertible matrix as basis.",
        "output": "import numpy as np\nB = np.random.randint(1, 5, (2, 2))\nwhile np.linalg.matrix_rank(B) < 2:\n    B = np.random.randint(1, 5, (2, 2))\nv = np.array([3, 2])\nv_B = np.linalg.inv(B) @ v\nprint(\"Random basis B:\", B)\nprint(\"Vector in new basis:\", v_B)"
    },
    {
        "input": "Change of basis for 4D vector using block-diagonal matrix. Use v = [1,2,3,4] and B = diag([[1,1],[0,1]]) twice.",
        "output": "import numpy as np\nv = np.array([1, 2, 3, 4])\nB1 = np.array([[1, 1], [0, 1]])\nB = np.block([\n    [B1, np.zeros((2, 2))],\n    [np.zeros((2, 2)), B1]\n])\nv_new = np.linalg.inv(B) @ v\nprint(\"Block-diagonal basis B:\", B)\nprint(\"v in new basis:\", v_new)"
    },
    {
        "input": "Demonstrate that rotating a basis preserves vector norms. Use Q = 2D rotation, v = [1, 0].",
        "output": "import numpy as np\ntheta = np.pi / 3\nQ = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])\nv = np.array([1, 0])\nv_rot = Q @ v\nprint(\"Rotated vector:\", v_rot)\nprint(\"Original norm:\", np.linalg.norm(v))\nprint(\"Rotated norm:\", np.linalg.norm(v_rot))"
    },
    {
        "input": "Change of basis for function space: represent f(x) = x² in terms of basis {1, x, x²}.",
        "output": "import numpy as np\nf = np.array([0, 0, 1])\nB = np.eye(3)\ncoords = np.linalg.inv(B) @ f\nprint(\"f(x) = x² coordinates in standard basis:\", coords)"
    },
    {
        "input": "Symbolically change basis for f(x) = x in {1+x, x} using sympy.",
        "output": "import sympy as sp\nf = sp.Matrix([0, 1])\nB = sp.Matrix([[1, 0], [1, 1]])\nB_inv = B.inv()\nf_coords = B_inv * f\nprint(\"f(x) in new polynomial basis:\", f_coords)"
    },
    {
        "input": "Verify inverse transformation matrix returns original vector. Use B = [[2,1],[1,2]] and v = [5,3].",
        "output": "import numpy as np\nB = np.array([[2, 1], [1, 2]])\nv = np.array([5, 3])\nv_B = np.linalg.inv(B) @ v\nv_back = B @ v_B\nprint(\"v in basis B:\", v_B)\nprint(\"Back to original:\", v_back)"
    },
    {
        "input": "Symbolically verify B⁻¹ * (B * v) = v for generic 2D basis.",
        "output": "import sympy as sp\nx, y = sp.symbols('x y')\nv = sp.Matrix([x, y])\nB = sp.Matrix([[a, b], [c, d]])\nresult = B.inv() * (B * v)\nprint(\"Simplified result:\")\nsp.pprint(result)"
    },
    {
        "input": "Generate random 3D orthonormal basis and transform a vector into it.",
        "output": "import numpy as np\nfrom scipy.stats import ortho_group\nQ = ortho_group.rvs(3)\nv = np.array([1, 2, 3])\nv_new = Q.T @ v\nprint(\"Orthonormal basis Q:\", Q)\nprint(\"Vector in orthonormal basis:\", v_new)"
    },
    {
        "input": "Use QR decomposition to produce a new basis for 3D space.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 10]])\nQ, R = np.linalg.qr(A)\nprint(\"Orthonormal basis from QR (columns of Q):\", Q)"
    },
    {
        "input": "Compute eigenbasis of A = [[0,1],[-2,-3]] and use it as change of basis.",
        "output": "import numpy as np\nA = np.array([[0, 1], [-2, -3]])\nevals, evecs = np.linalg.eig(A)\nv = np.array([1, 1])\nv_new = np.linalg.inv(evecs) @ v\nprint(\"Eigenvectors as basis:\", evecs)\nprint(\"v in eigenbasis:\", v_new)"
    },
    {
        "input": "Symbolically verify coordinate transformation between rotated and standard frame.",
        "output": "import sympy as sp\ntheta = sp.symbols('theta')\nvx, vy = sp.symbols('vx vy')\nR = sp.Matrix([[sp.cos(theta), -sp.sin(theta)], [sp.sin(theta), sp.cos(theta)]])\nv = sp.Matrix([vx, vy])\nv_rot = R.T * v\nprint(\"Rotated vector in new frame:\")\nsp.pprint(v_rot)"
    },
    {
        "input": "Diagonalize symmetric matrix A = [[4,1],[1,3]] and interpret the change of basis.",
        "output": "import numpy as np\nA = np.array([[4, 1], [1, 3]])\nevals, evecs = np.linalg.eigh(A)\nD = np.diag(evals)\nprint(\"Eigenbasis (orthonormal):\", evecs)\nprint(\"Diagonal form D:\", D)"
    },
    {
        "input": "Decompose a vector in a skewed 2D basis. Use B = [[2,1],[1,1]] and v = [5,4].",
        "output": "import numpy as np\nB = np.array([[2, 1], [1, 1]])\nv = np.array([5, 4])\nv_B = np.linalg.inv(B) @ v\nprint(\"Coordinates of v in skewed basis B:\", v_B)"
    },
    {
        "input": "Check that change of basis preserves vector length under orthogonal transformation.",
        "output": "import numpy as np\nQ = np.array([[0, 1], [1, 0]])\nv = np.array([3, 4])\nv_Q = Q @ v\nprint(\"Original length:\", np.linalg.norm(v))\nprint(\"Transformed length:\", np.linalg.norm(v_Q))"
    },
    {
        "input": "Find the coordinate vector of v = [3, 1, 4] with respect to an orthonormal basis B formed by Gram-Schmidt process.",
        "output": "import numpy as np\nfrom scipy.linalg import orth\nv = np.array([3, 1, 4])\nX = np.array([[1, 0, 1], [0, 1, 1], [1, 1, 0]])\nB = orth(X)\nv_coords = B.T @ v\nprint(\"Orthonormal basis B:\", B)\nprint(\"Coordinates of v in basis B:\", v_coords)"
    },
    {
        "input": "Construct a change of basis matrix from standard basis to a custom 3D basis B, then verify its inverse maps back.",
        "output": "import numpy as np\nB = np.array([[2, 1, 0], [0, 3, 1], [1, 0, 2]])\nP = B\nP_inv = np.linalg.inv(P)\nv = np.array([5, 2, 3])\nv_B = P_inv @ v\nv_std = P @ v_B\nprint(\"Vector in new basis:\", v_B)\nprint(\"Reconstructed in standard basis:\", v_std)"
    },
    {
        "input": "Transform a 4D vector to a random orthonormal basis using QR decomposition and convert it back.",
        "output": "import numpy as np\nA = np.random.randn(4, 4)\nQ, _ = np.linalg.qr(A)\nv = np.random.randn(4)\nv_coords = Q.T @ v\nv_reconstructed = Q @ v_coords\nprint(\"Coordinates in orthonormal basis:\", v_coords)\nprint(\"Reconstructed vector:\", v_reconstructed)"
    },
    {
        "input": "Define a matrix transformation that rotates vectors in the x-y plane and leaves z unchanged. Show basis transformation.",
        "output": "import numpy as np\nangle = np.pi / 4\nR = np.array([\n    [np.cos(angle), -np.sin(angle), 0],\n    [np.sin(angle), np.cos(angle), 0],\n    [0, 0, 1]\n])\nv = np.array([1, 0, 1])\nv_rotated = R @ v\nprint(\"Rotated vector:\", v_rotated)"
    },
    {
        "input": "Find coordinates of v = [1, 2] in a rotated 2D frame rotated by 60 degrees.",
        "output": "import numpy as np\ntheta = np.pi / 3\nR = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])\nv = np.array([1, 2])\nv_rot = R.T @ v\nprint(\"Coordinates of v in rotated basis:\", v_rot)"
    },
    {
        "input": "Transform a linear map L(x) = Ax to a different basis and compare original and new outputs.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[1, 1], [1, -1]])\nB_inv = np.linalg.inv(B)\nA_new = B_inv @ A @ B\nx = np.array([1, 0])\nLx_std = A @ x\nx_new = B_inv @ x\nLx_new = A_new @ x_new\nprint(\"L(x) in standard basis:\", Lx_std)\nprint(\"L(x) in new basis:\", B @ Lx_new)"
    },
    {
        "input": "Construct a new basis for R³ that includes a given vector v = [1,1,1].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nv = np.array([1, 1, 1])\nv = v / np.linalg.norm(v)\nnull = null_space(v.reshape(1, -1))\nB = np.column_stack((null, v))\nprint(\"Orthonormal basis including v:\", B)"
    },
    {
        "input": "Decompose a 2D vector into a skewed basis.",
        "output": "import numpy as np\nB = np.array([[1, 2], [1, 1]])\nv = np.array([3, 4])\nv_coords = np.linalg.inv(B) @ v\nprint(\"v in new basis:\", v_coords)"
    },
    {
        "input": "Project a 3D vector onto a plane spanned by a non-orthogonal basis.",
        "output": "import numpy as np\nB = np.array([[1, 1], [2, 0], [0, 2]])\nv = np.array([3, 1, 4])\nproj = B @ np.linalg.pinv(B) @ v\nprint(\"Projection of v onto plane spanned by B:\", proj)"
    },
    {
        "input": "Given two bases B and C, compute transformation matrix from B to C and apply to vector.",
        "output": "import numpy as np\nB = np.array([[2, 1], [1, 2]])\nC = np.array([[1, 1], [1, -1]])\nv = np.array([3, 4])\nT = np.linalg.inv(C) @ B\nv_in_B = np.linalg.inv(B) @ v\nv_in_C = T @ v_in_B\nprint(\"Transformation matrix B to C:\", T)\nprint(\"v in basis C:\", v_in_C)"
    },
    {
        "input": "Demonstrate that applying the identity basis results in no change to vector coordinates.",
        "output": "import numpy as np\nI = np.eye(3)\nv = np.array([5, -2, 7])\nv_coords = np.linalg.inv(I) @ v\nprint(\"Vector in identity basis:\", v_coords)"
    },
    {
        "input": "Transform vector in polynomial basis {1, x, x^2} to new basis {1+x, x+x^2, x^2}.",
        "output": "import numpy as np\nB = np.array([[1, 0, 0], [1, 1, 0], [0, 1, 1]])\nv = np.array([0, 0, 1])\nv_new = np.linalg.inv(B) @ v\nprint(\"Vector coordinates in new basis:\", v_new)"
    },
    {
        "input": "Fit a line y = mx + c using least squares for the points (1, 2), (2, 3), (3, 5).",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([2, 3, 5])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Best fit line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Use least squares to find the linear regression line for the data points: (0, 1), (1, 2), (2, 1.3), (3, 3.75).",
        "output": "import numpy as np\nx = np.array([0, 1, 2, 3])\ny = np.array([1, 2, 1.3, 3.75])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Linear regression line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Find the best fit line for the following data: x = [1, 2, 4], y = [2, 3, 6] using least squares method.",
        "output": "import numpy as np\nx = np.array([1, 2, 4])\ny = np.array([2, 3, 6])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Fitted line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Given points (1,1), (2,2), (3,2.5), (4,4), find the best fit line using least squares.",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([1, 2, 2.5, 4])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Least squares line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a linear regression line using least squares for x = [1, 3, 5], y = [1.2, 2.8, 5.1].",
        "output": "import numpy as np\nx = np.array([1, 3, 5])\ny = np.array([1.2, 2.8, 5.1])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Regression line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Find the best fit line using least squares for points (2,1), (4,3), (6,4).",
        "output": "import numpy as np\nx = np.array([2, 4, 6])\ny = np.array([1, 3, 4])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Fitted line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Given (1,1), (2,2), (3,2.9), use least squares to find y = mx + c.",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([1, 2, 2.9])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Best fit: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Use least squares to fit a line to the data x=[1,2,3,4], y=[1.5,1.7,3.2,4.8].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([1.5, 1.7, 3.2, 4.8])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Line of best fit: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Apply least squares to fit a line to (1,1.1), (2,2.0), (3,3.1), (4,3.9).",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([1.1, 2.0, 3.1, 3.9])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Linear model: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a straight line using least squares for x=[0,1,2,3], y=[2.1,2.9,3.8,5.2].",
        "output": "import numpy as np\nx = np.array([0, 1, 2, 3])\ny = np.array([2.1, 2.9, 3.8, 5.2])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Equation: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Find least squares fit for data x=[1, 2, 3], y=[3, 2, 4].",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([3, 2, 4])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Least squares line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Estimate y = mx + c for x = [1, 3, 4], y = [2, 5, 7].",
        "output": "import numpy as np\nx = np.array([1, 3, 4])\ny = np.array([2, 5, 7])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Regression result: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a line using least squares for x=[5,6,7], y=[7,8,10].",
        "output": "import numpy as np\nx = np.array([5, 6, 7])\ny = np.array([7, 8, 10])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Fitted equation: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Find regression line for points (0,0), (1,1), (2,4).",
        "output": "import numpy as np\nx = np.array([0, 1, 2])\ny = np.array([0, 1, 4])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Best fit: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Use least squares to find a line fitting (0,0.1), (2,2.2), (4,4.0).",
        "output": "import numpy as np\nx = np.array([0, 2, 4])\ny = np.array([0.1, 2.2, 4.0])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a line to data (1,2), (3,6), (5,10) using least squares.",
        "output": "import numpy as np\nx = np.array([1, 3, 5])\ny = np.array([2, 6, 10])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Linear model: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Apply least squares to find best fit line for x=[0,1,2,3], y=[1,2.1,2.9,4.2].",
        "output": "import numpy as np\nx = np.array([0, 1, 2, 3])\ny = np.array([1, 2.1, 2.9, 4.2])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Regression line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Find least squares regression line for points (1,2.1), (2,2.9), (3,3.7).",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([2.1, 2.9, 3.7])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Estimated line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Estimate the linear regression model using least squares for x=[1,2,3,4], y=[2,4,6,7.5].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([2, 4, 6, 7.5])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Model: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit y = mx + c to data x=[2,3,5], y=[3,5,9].",
        "output": "import numpy as np\nx = np.array([2, 3, 5])\ny = np.array([3, 5, 9])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Line of best fit: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Given points (0,0.5), (1,1.8), (2,3.6), find the regression line using least squares.",
        "output": "import numpy as np\nx = np.array([0, 1, 2])\ny = np.array([0.5, 1.8, 3.6])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Regression line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Use least squares to fit a line to data points (2,3), (4,6), (6,7).",
        "output": "import numpy as np\nx = np.array([2, 4, 6])\ny = np.array([3, 6, 7])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Fitted line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a regression line for x = [1, 3, 5], y = [2, 6, 9].",
        "output": "import numpy as np\nx = np.array([1, 3, 5])\ny = np.array([2, 6, 9])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Best fit line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Find least squares line for x=[0,2,4], y=[1,3,5].",
        "output": "import numpy as np\nx = np.array([0, 2, 4])\ny = np.array([1, 3, 5])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Least squares line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Use least squares to fit y = mx + c for data (1, 1), (2, 2.5), (3, 3).",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([1, 2.5, 3])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Fitted line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Find the best fitting line for x = [2, 4, 6, 8], y = [1, 3, 4, 6].",
        "output": "import numpy as np\nx = np.array([2, 4, 6, 8])\ny = np.array([1, 3, 4, 6])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Regression line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a line using least squares for points (1,2), (2,3), (4,6), (5,8).",
        "output": "import numpy as np\nx = np.array([1, 2, 4, 5])\ny = np.array([2, 3, 6, 8])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Line of best fit: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Determine y = mx + c using least squares for (0,0), (1,1), (2,2).",
        "output": "import numpy as np\nx = np.array([0, 1, 2])\ny = np.array([0, 1, 2])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Fitted line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a line to x=[1,2,3], y=[2.2,2.8,3.6] using least squares.",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([2.2, 2.8, 3.6])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Regression equation: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Estimate regression line from x=[2,4,6], y=[3,6,7].",
        "output": "import numpy as np\nx = np.array([2, 4, 6])\ny = np.array([3, 6, 7])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Find best fit line for x=[3,4,5], y=[5,6,8].",
        "output": "import numpy as np\nx = np.array([3, 4, 5])\ny = np.array([5, 6, 8])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Linear fit: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a line to (2,1), (3,2.5), (4,3.8).",
        "output": "import numpy as np\nx = np.array([2, 3, 4])\ny = np.array([1, 2.5, 3.8])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Best fit: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Use least squares to find best fit line for x = [0,1,2], y = [1,3,2].",
        "output": "import numpy as np\nx = np.array([0, 1, 2])\ny = np.array([1, 3, 2])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Regression result: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Find least squares regression for (0,1), (1,1.8), (2,3).",
        "output": "import numpy as np\nx = np.array([0, 1, 2])\ny = np.array([1, 1.8, 3])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Best fit line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit y = mx + c to data (2,2), (4,3), (6,5).",
        "output": "import numpy as np\nx = np.array([2, 4, 6])\ny = np.array([2, 3, 5])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Fitted equation: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Estimate regression line from x=[1,3,4], y=[2,3.5,5].",
        "output": "import numpy as np\nx = np.array([1, 3, 4])\ny = np.array([2, 3.5, 5])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Regression: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Use least squares on x = [1, 2, 3], y = [3, 6, 9].",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([3, 6, 9])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Find least squares solution for (1,0), (2,1.2), (3,2.8).",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([0, 1.2, 2.8])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Least squares fit: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit y = mx + c to data x=[1,3,6], y=[2,4,7].",
        "output": "import numpy as np\nx = np.array([1, 3, 6])\ny = np.array([2, 4, 7])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Fitted line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Use least squares to estimate line from x=[2,3,4], y=[3,3.5,4.8].",
        "output": "import numpy as np\nx = np.array([2, 3, 4])\ny = np.array([3, 3.5, 4.8])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Estimated line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Determine least squares fit for x=[0,2,3], y=[0,1,3].",
        "output": "import numpy as np\nx = np.array([0, 2, 3])\ny = np.array([0, 1, 3])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Best fit line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a linear model to x=[3,5,6], y=[5,8,10].",
        "output": "import numpy as np\nx = np.array([3, 5, 6])\ny = np.array([5, 8, 10])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Linear model: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "A dataset has x = [1, 2, 3, 4, 5], y = [2.1, 3.9, 6.0, 8.2, 10.1]. Fit a line using least squares.",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4, 5])\ny = np.array([2.1, 3.9, 6.0, 8.2, 10.1])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Least squares line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a line to noisy data: x = [0, 1, 2, 3, 4], y = [1.2, 2.3, 4.1, 5.9, 7.8].",
        "output": "import numpy as np\nx = np.array([0, 1, 2, 3, 4])\ny = np.array([1.2, 2.3, 4.1, 5.9, 7.8])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Fitted model: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Given daily temperatures x = [1, 2, 3, 4, 5, 6], and ice cream sales y = [3, 4.5, 5.2, 6.8, 8.1, 9.7], fit a regression line.",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4, 5, 6])\ny = np.array([3, 4.5, 5.2, 6.8, 8.1, 9.7])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Regression line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a multiple linear regression model for x1 = [1, 2, 3], x2 = [0, 1, 1], and y = [2, 4, 5].",
        "output": "import numpy as np\nX = np.array([[1, 0], [2, 1], [3, 1]])\ny = np.array([2, 4, 5])\nX_aug = np.hstack([X, np.ones((X.shape[0], 1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Model: y = {params[0]:.2f}x1 + {params[1]:.2f}x2 + {params[2]:.2f}\")"
    },
    {
        "input": "You measure speed vs. braking distance: x = [20, 30, 40, 50], y = [10, 20, 33, 47]. Fit a least squares line.",
        "output": "import numpy as np\nx = np.array([20, 30, 40, 50])\ny = np.array([10, 20, 33, 47])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Model: braking_distance = {m:.2f} * speed + {c:.2f}\")"
    },
    {
        "input": "Find the least squares line for x = [-3, -2, -1, 0, 1, 2, 3], y = [-7.8, -4.9, -2.2, 0.1, 1.8, 4.2, 6.9].",
        "output": "import numpy as np\nx = np.array([-3, -2, -1, 0, 1, 2, 3])\ny = np.array([-7.8, -4.9, -2.2, 0.1, 1.8, 4.2, 6.9])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Best fit: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "You have monthly ad spending x=[10,20,30,40,50] and sales y=[12,24,34,41,55]. Fit a least squares model.",
        "output": "import numpy as np\nx = np.array([10, 20, 30, 40, 50])\ny = np.array([12, 24, 34, 41, 55])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Sales = {m:.2f} * Spending + {c:.2f}\")"
    },
    {
        "input": "Fit a regression line to slightly nonlinear data: x = [1, 2, 3, 4], y = [1.1, 3.8, 9.2, 16.3].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([1.1, 3.8, 9.2, 16.3])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Linear approximation: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "You collect weight vs. calories: weight = [100, 200, 300], cal = [250, 470, 690]. Find the regression line.",
        "output": "import numpy as np\nx = np.array([100, 200, 300])\ny = np.array([250, 470, 690])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Calories = {m:.2f} * Weight + {c:.2f}\")"
    },
    {
        "input": "Fit a model for x = [5, 10, 15, 20, 25], y = [15, 30, 47, 65, 82].",
        "output": "import numpy as np\nx = np.array([5, 10, 15, 20, 25])\ny = np.array([15, 30, 47, 65, 82])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Fitted regression: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Given height x = [150, 160, 170, 180], and weight y = [50, 58, 67, 75], fit a linear model.",
        "output": "import numpy as np\nx = np.array([150, 160, 170, 180])\ny = np.array([50, 58, 67, 75])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Weight = {m:.2f} * Height + {c:.2f}\")"
    },
    {
        "input": "Fit least squares to temperature vs. energy use: x=[10,15,20,25], y=[50,45,40,35].",
        "output": "import numpy as np\nx = np.array([10, 15, 20, 25])\ny = np.array([50, 45, 40, 35])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Energy use = {m:.2f} * Temperature + {c:.2f}\")"
    },
    {
        "input": "You observe time vs. battery: x=[1,2,3,4], y=[95,90,84,77]. Fit a regression line.",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([95, 90, 84, 77])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Battery = {m:.2f} * Time + {c:.2f}\")"
    },
    {
        "input": "Find a line for data with small deviation: x = [0,1,2,3,4], y = [0.1,1.2,2.1,3.3,4.1].",
        "output": "import numpy as np\nx = np.array([0,1,2,3,4])\ny = np.array([0.1,1.2,2.1,3.3,4.1])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"Regression: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a model for (x1,x2) = (1,2), (2,1), (3,5), with y = [3,4,7].",
        "output": "import numpy as np\nX = np.array([[1,2],[2,1],[3,5]])\ny = np.array([3,4,7])\nX_aug = np.hstack([X,np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug,y,rcond=None)\nprint(f\"y = {params[0]:.2f}x1 + {params[1]:.2f}x2 + {params[2]:.2f}\")"
    },
    {
        "input": "You have hours studied x = [1, 2, 3, 4, 5], scores = [50, 55, 65, 70, 78]. Fit least squares line.",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4, 5])\ny = np.array([50, 55, 65, 70, 78])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Score = {m:.2f} * Hours + {c:.2f}\")"
    },
    {
        "input": "Fit a linear model for car age vs resale value. x = [1, 2, 3, 4, 5], y = [20, 18, 15.5, 13.2, 11].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4, 5])\ny = np.array([20, 18, 15.5, 13.2, 11])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Resale value = {m:.2f} * Age + {c:.2f}\")"
    },
    {
        "input": "Given x = [0, 2, 4, 6, 8], y = [1, 4.5, 7.8, 12.1, 15.9], fit a least squares line.",
        "output": "import numpy as np\nx = np.array([0, 2, 4, 6, 8])\ny = np.array([1, 4.5, 7.8, 12.1, 15.9])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Model: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a line to the number of cups of coffee (x) vs productivity score (y): x = [1, 2, 3, 4, 5], y = [50, 55, 59, 61, 60].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4, 5])\ny = np.array([50, 55, 59, 61, 60])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Productivity = {m:.2f} * Coffee + {c:.2f}\")"
    },
    {
        "input": "Find the least squares solution for x = [1, 4, 6, 8], y = [3, 9, 14, 19.5].",
        "output": "import numpy as np\nx = np.array([1, 4, 6, 8])\ny = np.array([3, 9, 14, 19.5])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a model for temperature x = [30, 35, 40, 45], and AC usage y = [20, 27, 33, 40].",
        "output": "import numpy as np\nx = np.array([30, 35, 40, 45])\ny = np.array([20, 27, 33, 40])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"AC usage = {m:.2f} * Temp + {c:.2f}\")"
    },
    {
        "input": "Fit a model to hours of training x = [0, 1, 2, 3, 4], and skill score y = [5, 7, 9.1, 10.9, 13.2].",
        "output": "import numpy as np\nx = np.array([0, 1, 2, 3, 4])\ny = np.array([5, 7, 9.1, 10.9, 13.2])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Skill = {m:.2f} * Hours + {c:.2f}\")"
    },
    {
        "input": "Using x = [10, 20, 30, 40, 50], and y = [15, 25, 35, 43, 55], fit a linear model.",
        "output": "import numpy as np\nx = np.array([10, 20, 30, 40, 50])\ny = np.array([15, 25, 35, 43, 55])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a multiple regression with x1 = [1,2,3], x2 = [0,1,1], y = [1,2.5,3.8].",
        "output": "import numpy as np\nX = np.array([[1,0],[2,1],[3,1]])\ny = np.array([1,2.5,3.8])\nX_aug = np.hstack([X,np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug,y,rcond=None)\nprint(f\"Model: y = {params[0]:.2f}x1 + {params[1]:.2f}x2 + {params[2]:.2f}\")"
    },
    {
        "input": "Fit a model for x = [1, 2, 3, 4], y = [2.5, 5.0, 6.8, 9.5].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([2.5, 5.0, 6.8, 9.5])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Fitted Line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "You have sales data: x = [5, 10, 15], y = [50, 100, 145]. Use least squares to model it.",
        "output": "import numpy as np\nx = np.array([5, 10, 15])\ny = np.array([50, 100, 145])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Sales = {m:.2f} * Units + {c:.2f}\")"
    },
    {
        "input": "Fit a model to study hours vs. performance: x = [1, 3, 5, 7], y = [60, 70, 80, 90].",
        "output": "import numpy as np\nx = np.array([1, 3, 5, 7])\ny = np.array([60, 70, 80, 90])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Performance = {m:.2f} * StudyHours + {c:.2f}\")"
    },
    {
        "input": "x = [2, 4, 6, 8], y = [3, 7, 11, 16]. Fit least squares regression.",
        "output": "import numpy as np\nx = np.array([2, 4, 6, 8])\ny = np.array([3, 7, 11, 16])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a linear model to predict salary based on years experience: x = [1,2,3,4,5], y = [35, 42, 50, 57, 65].",
        "output": "import numpy as np\nx = np.array([1,2,3,4,5])\ny = np.array([35,42,50,57,65])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"Salary = {m:.2f} * Years + {c:.2f}\")"
    },
    {
        "input": "Fit a regression for x = [1, 2, 4, 5], y = [2, 3.9, 7.9, 10.1].",
        "output": "import numpy as np\nx = np.array([1,2,4,5])\ny = np.array([2,3.9,7.9,10.1])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"Regression line: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Given x = [0, 2, 3, 4, 5], y = [1.2, 4.2, 6.0, 8.1, 10.3], use least squares to fit a line.",
        "output": "import numpy as np\nx = np.array([0,2,3,4,5])\ny = np.array([1.2,4.2,6.0,8.1,10.3])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"Model: y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a model for income vs. spending: income = [20, 30, 40, 50], spending = [22, 33, 43, 51].",
        "output": "import numpy as np\nx = np.array([20,30,40,50])\ny = np.array([22,33,43,51])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"Spending = {m:.2f} * Income + {c:.2f}\")"
    },
    {
        "input": "Fit a line for study time vs grades: x = [1,2,3,4], y = [50,58,67,72].",
        "output": "import numpy as np\nx = np.array([1,2,3,4])\ny = np.array([50,58,67,72])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"Grades = {m:.2f} * StudyTime + {c:.2f}\")"
    },
    {
        "input": "Fit a line for x = [0, 1, 2, 3, 4], y = [2, 3.8, 5.9, 8.2, 10].",
        "output": "import numpy as np\nx = np.array([0,1,2,3,4])\ny = np.array([2,3.8,5.9,8.2,10])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a least squares line to predict crop yield (y) from rainfall (x): x = [200, 300, 400, 500], y = [2.5, 3.5, 4.3, 5.1].",
        "output": "import numpy as np\nx = np.array([200, 300, 400, 500])\ny = np.array([2.5, 3.5, 4.3, 5.1])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Yield = {m:.4f} * Rainfall + {c:.4f}\")"
    },
    {
        "input": "Estimate a linear relationship between advertising cost and revenue: x = [10, 20, 30, 40], y = [60, 110, 160, 210].",
        "output": "import numpy as np\nx = np.array([10, 20, 30, 40])\ny = np.array([60, 110, 160, 210])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Revenue = {m:.2f} * AdCost + {c:.2f}\")"
    },
    {
        "input": "Fit a line to estimate calories burned from minutes of exercise: x = [15, 30, 45, 60], y = [100, 210, 310, 420].",
        "output": "import numpy as np\nx = np.array([15, 30, 45, 60])\ny = np.array([100, 210, 310, 420])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Calories = {m:.2f} * Minutes + {c:.2f}\")"
    },
    {
        "input": "Fit a model for temperature (x) vs ice cream sales (y): x = [20, 25, 30, 35], y = [100, 140, 180, 220].",
        "output": "import numpy as np\nx = np.array([20, 25, 30, 35])\ny = np.array([100, 140, 180, 220])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"Sales = {m:.2f} * Temp + {c:.2f}\")"
    },
    {
        "input": "Fit a least squares regression to predict blood pressure from age: x = [25, 35, 45, 55], y = [120, 126, 132, 139].",
        "output": "import numpy as np\nx = np.array([25, 35, 45, 55])\ny = np.array([120, 126, 132, 139])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"BP = {m:.2f} * Age + {c:.2f}\")"
    },
    {
        "input": "Predict CO2 emissions from engine size: x = [1.2, 1.6, 2.0, 2.4], y = [110, 140, 165, 190].",
        "output": "import numpy as np\nx = np.array([1.2, 1.6, 2.0, 2.4])\ny = np.array([110, 140, 165, 190])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"CO2 = {m:.2f} * EngineSize + {c:.2f}\")"
    },
    {
        "input": "Fit a linear model using x1 = hours studied, x2 = attendance, y = grade. x1 = [2,4,6], x2 = [80,85,90], y = [60,75,90].",
        "output": "import numpy as np\nX = np.array([[2,80],[4,85],[6,90]])\ny = np.array([60,75,90])\nX_aug = np.hstack([X,np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug,y,rcond=None)\nprint(f\"Grade = {params[0]:.2f}*Hours + {params[1]:.2f}*Attendance + {params[2]:.2f}\")"
    },
    {
        "input": "Predict sales from number of emails sent: x = [1000, 2000, 3000, 4000], y = [50, 95, 140, 190].",
        "output": "import numpy as np\nx = np.array([1000,2000,3000,4000])\ny = np.array([50,95,140,190])\nA = np.vstack([x, np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"Sales = {m:.4f} * Emails + {c:.2f}\")"
    },
    {
        "input": "Fit a model to estimate weight based on height: x = [150, 160, 170, 180], y = [50, 56, 63, 70].",
        "output": "import numpy as np\nx = np.array([150,160,170,180])\ny = np.array([50,56,63,70])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"Weight = {m:.2f} * Height + {c:.2f}\")"
    },
    {
        "input": "Fit a line for days since launch (x) vs active users (y): x = [1, 2, 3, 4], y = [100, 180, 250, 320].",
        "output": "import numpy as np\nx = np.array([1,2,3,4])\ny = np.array([100,180,250,320])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"Users = {m:.2f} * Days + {c:.2f}\")"
    },
    {
        "input": "Use least squares to model house price from size: x = [1000, 1500, 2000, 2500], y = [150, 200, 250, 310].",
        "output": "import numpy as np\nx = np.array([1000,1500,2000,2500])\ny = np.array([150,200,250,310])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"Price = {m:.2f} * Size + {c:.2f}\")"
    },
    {
        "input": "Fit a model: x1 = study hrs, x2 = sleep hrs, y = score. x1 = [2,3,4], x2 = [6,7,6], y = [60,70,75].",
        "output": "import numpy as np\nX = np.array([[2,6],[3,7],[4,6]])\ny = np.array([60,70,75])\nX_aug = np.hstack([X,np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug,y,rcond=None)\nprint(f\"Score = {params[0]:.2f}*Study + {params[1]:.2f}*Sleep + {params[2]:.2f}\")"
    },
    {
        "input": "Predict electricity bill from usage: x = [100, 200, 300, 400], y = [25, 45, 70, 90].",
        "output": "import numpy as np\nx = np.array([100,200,300,400])\ny = np.array([25,45,70,90])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"Bill = {m:.2f} * Usage + {c:.2f}\")"
    },
    {
        "input": "Estimate taxi fare from distance: x = [2, 5, 8, 10], y = [10, 22, 33, 40].",
        "output": "import numpy as np\nx = np.array([2,5,8,10])\ny = np.array([10,22,33,40])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"Fare = {m:.2f} * Distance + {c:.2f}\")"
    },
    {
        "input": "Fit a line: x = [0, 5, 10, 15], y = [1, 5, 8, 12].",
        "output": "import numpy as np\nx = np.array([0,5,10,15])\ny = np.array([1,5,8,12])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Fit a linear model for caffeine intake and alertness: x = [50, 100, 150, 200], y = [2, 4.5, 6.8, 8.9].",
        "output": "import numpy as np\nx = np.array([50,100,150,200])\ny = np.array([2,4.5,6.8,8.9])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"Alertness = {m:.3f} * Caffeine + {c:.2f}\")"
    },
    {
        "input": "Fit a model for x = [1,2,3,4], y = [1,4,7,10].",
        "output": "import numpy as np\nx = np.array([1,2,3,4])\ny = np.array([1,4,7,10])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Predict fuel usage from weight of vehicle: x = [1000, 1500, 2000, 2500], y = [4, 5.5, 7.2, 9.1].",
        "output": "import numpy as np\nx = np.array([1000,1500,2000,2500])\ny = np.array([4,5.5,7.2,9.1])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"Fuel = {m:.4f} * Weight + {c:.2f}\")"
    },
    {
        "input": "Fit a regression for height vs. vertical jump: x = [160, 170, 180, 190], y = [30, 35, 40, 42].",
        "output": "import numpy as np\nx = np.array([160,170,180,190])\ny = np.array([30,35,40,42])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"Jump = {m:.2f} * Height + {c:.2f}\")"
    },
    {
        "input": "Fit least squares model: x = [1, 2, 3, 4, 5], y = [3, 4.9, 6.8, 8.9, 10.2].",
        "output": "import numpy as np\nx = np.array([1,2,3,4,5])\ny = np.array([3,4.9,6.8,8.9,10.2])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Predict time to complete task from number of workers: x = [1,2,3,4], y = [100,55,38,30].",
        "output": "import numpy as np\nx = np.array([1,2,3,4])\ny = np.array([100,55,38,30])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\nprint(f\"Time = {m:.2f} * Workers + {c:.2f}\")"
    },
    {
        "input": "Use least squares to fit a quadratic model to the data: x = [1, 2, 3, 4, 5], y = [3, 7, 13, 21, 31].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4, 5])\ny = np.array([3, 7, 13, 21, 31])\nA = np.vstack([x**2, x, np.ones_like(x)]).T\ncoeffs, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"y = {coeffs[0]:.2f}x² + {coeffs[1]:.2f}x + {coeffs[2]:.2f}\")"
    },
    {
        "input": "Fit a multiple regression model with inputs: experience (x1), education level (x2), hours/week (x3) and output salary (y). x1 = [1,2,3,4], x2 = [2,3,4,5], x3 = [40,45,50,55], y = [40,50,65,80].",
        "output": "import numpy as np\nX = np.array([[1,2,40], [2,3,45], [3,4,50], [4,5,55]])\ny = np.array([40, 50, 65, 80])\nX_aug = np.hstack([X, np.ones((4,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Salary = {params[0]:.2f}*Exp + {params[1]:.2f}*Edu + {params[2]:.2f}*Hours + {params[3]:.2f}\")"
    },
    {
        "input": "Given points that approximately lie on a plane, fit the plane z = ax + by + c using least squares: x = [1,2,3], y = [2,4,6], z = [5,8,11].",
        "output": "import numpy as np\nx = np.array([1,2,3])\ny = np.array([2,4,6])\nz = np.array([5,8,11])\nA = np.vstack([x, y, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, z, rcond=None)\nprint(f\"Plane: z = {params[0]:.2f}x + {params[1]:.2f}y + {params[2]:.2f}\")"
    },
    {
        "input": "You are given noisy data from a physical process: x = [0.1, 0.4, 0.7, 1.0], y = [0.99, 0.76, 0.54, 0.30]. Fit a least squares model assuming exponential decay y = ae^(-bx).",
        "output": "import numpy as np\nx = np.array([0.1, 0.4, 0.7, 1.0])\ny = np.array([0.99, 0.76, 0.54, 0.30])\nlog_y = np.log(y)\nA = np.vstack([-x, np.ones_like(x)]).T\nb, log_a = np.linalg.lstsq(A, log_y, rcond=None)[0]\na = np.exp(log_a)\nprint(f\"Model: y = {a:.4f} * exp(-{b:.4f} * x)\")"
    },
    {
        "input": "Fit a linear model to predict sales from 3 features: store size, location score, and advertising spend. X = [[100, 8, 30], [150, 9, 40], [200, 7, 50], [250, 10, 60]], y = [200, 250, 280, 330].",
        "output": "import numpy as np\nX = np.array([[100,8,30], [150,9,40], [200,7,50], [250,10,60]])\ny = np.array([200,250,280,330])\nX_aug = np.hstack([X, np.ones((4,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Sales = {params[0]:.2f}*Size + {params[1]:.2f}*Location + {params[2]:.2f}*Ad + {params[3]:.2f}\")"
    },
    {
        "input": "Use least squares to fit a cubic model to the data: x = [1, 2, 3, 4, 5], y = [1, 8, 27, 64, 125].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4, 5])\ny = np.array([1, 8, 27, 64, 125])\nA = np.vstack([x**3, x**2, x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"y = {params[0]:.2f}x³ + {params[1]:.2f}x² + {params[2]:.2f}x + {params[3]:.2f}\")"
    },
    {
        "input": "Given 2D points, fit a line y = mx + c using least squares, then calculate and print the total squared error. x = [1,2,3,4], y = [2.1,4.2,6.3,8.5].",
        "output": "import numpy as np\nx = np.array([1,2,3,4])\ny = np.array([2.1,4.2,6.3,8.5])\nA = np.vstack([x,np.ones_like(x)]).T\nm,c = np.linalg.lstsq(A,y,rcond=None)[0]\ny_pred = m*x + c\nsse = np.sum((y - y_pred)**2)\nprint(f\"y = {m:.2f}x + {c:.2f}\")\nprint(f\"Total Squared Error: {sse:.4f}\")"
    },
    {
        "input": "Fit a polynomial of degree 3 to approximate the function f(x) = sin(x) at x = [0, π/4, π/2, 3π/4, π].",
        "output": "import numpy as np\nx = np.array([0, np.pi/4, np.pi/2, 3*np.pi/4, np.pi])\ny = np.sin(x)\nA = np.vstack([x**3, x**2, x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"Approximation: y = {params[0]:.4f}x³ + {params[1]:.4f}x² + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a multivariable model to predict crop yield from rainfall, fertilizer use, and temperature. X = [[200, 50, 20], [250, 60, 22], [300, 70, 24]], y = [2.5, 3.0, 3.6].",
        "output": "import numpy as np\nX = np.array([[200, 50, 20], [250, 60, 22], [300, 70, 24]])\ny = np.array([2.5, 3.0, 3.6])\nX_aug = np.hstack([X, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Yield = {params[0]:.4f}*Rain + {params[1]:.4f}*Fert + {params[2]:.4f}*Temp + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a quadratic curve to approximate projectile motion. Given time t = [0, 1, 2, 3, 4], and height h = [0, 5, 8, 9, 8].",
        "output": "import numpy as np\nt = np.array([0, 1, 2, 3, 4])\nh = np.array([0, 5, 8, 9, 8])\nA = np.vstack([t**2, t, np.ones_like(t)]).T\nparams, *_ = np.linalg.lstsq(A, h, rcond=None)\nprint(f\"h = {params[0]:.2f}t² + {params[1]:.2f}t + {params[2]:.2f}\")"
    },
    {
        "input": "Given 3D data, fit a plane z = ax + by + c for x = [1,2,4], y = [1,3,5], z = [2,6,10].",
        "output": "import numpy as np\nx = np.array([1, 2, 4])\ny = np.array([1, 3, 5])\nz = np.array([2, 6, 10])\nA = np.vstack([x, y, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, z, rcond=None)\nprint(f\"z = {params[0]:.2f}x + {params[1]:.2f}y + {params[2]:.2f}\")"
    },
    {
        "input": "Fit a linear model to data: temperature (°C) vs. ice cream sales. x = [20, 22, 25, 27, 30], y = [100, 115, 150, 165, 200].",
        "output": "import numpy as np\nx = np.array([20, 22, 25, 27, 30])\ny = np.array([100, 115, 150, 165, 200])\nA = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"Sales = {params[0]:.2f}*Temp + {params[1]:.2f}\")"
    },
    {
        "input": "Fit a 3rd-degree polynomial to approximate noisy data: x = [0,1,2,3,4], y = [1.1, 2.9, 7.8, 15.9, 31.2].",
        "output": "import numpy as np\nx = np.array([0,1,2,3,4])\ny = np.array([1.1, 2.9, 7.8, 15.9, 31.2])\nA = np.vstack([x**3, x**2, x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"y = {params[0]:.2f}x³ + {params[1]:.2f}x² + {params[2]:.2f}x + {params[3]:.2f}\")"
    },
    {
        "input": "You have inputs: [1, 2, 3, 4] and corresponding outputs: [2.5, 3.5, 3.0, 5.0]. Fit a line and compute the residual vector.",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([2.5, 3.5, 3.0, 5.0])\nA = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\ny_pred = A @ params\nresidual = y - y_pred\nprint(f\"Best fit: y = {params[0]:.2f}x + {params[1]:.2f}\")\nprint(\"Residual vector:\", residual)"
    },
    {
        "input": "Fit a least squares model y = ax + b to the data and compute R². x = [1, 2, 3, 4, 5], y = [2.2, 4.1, 6.0, 8.2, 10.1].",
        "output": "import numpy as np\nx = np.array([1,2,3,4,5])\ny = np.array([2.2,4.1,6.0,8.2,10.1])\nA = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\ny_pred = A @ params\nss_res = np.sum((y - y_pred)**2)\nss_tot = np.sum((y - np.mean(y))**2)\nr2 = 1 - ss_res/ss_tot\nprint(f\"y = {params[0]:.2f}x + {params[1]:.2f}\")\nprint(f\"R² = {r2:.4f}\")"
    },
    {
        "input": "Fit a plane to 3D data and find the point on the plane closest to (x, y) = (3, 3). z = [4, 5, 6] for x = [1, 2, 3], y = [1, 2, 3].",
        "output": "import numpy as np\nx = np.array([1,2,3])\ny = np.array([1,2,3])\nz = np.array([4,5,6])\nA = np.vstack([x, y, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, z, rcond=None)\nz_pred = params[0]*3 + params[1]*3 + params[2]\nprint(f\"Plane: z = {params[0]:.2f}x + {params[1]:.2f}y + {params[2]:.2f}\")\nprint(f\"Closest point on plane at (3, 3, {z_pred:.2f})\")"
    },
    {
        "input": "Fit a linear regression to house prices based on size (in sqm): x = [60, 80, 100, 120], y = [150, 200, 240, 300].",
        "output": "import numpy as np\nx = np.array([60, 80, 100, 120])\ny = np.array([150, 200, 240, 300])\nA = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"Price = {params[0]:.2f}*Size + {params[1]:.2f}\")"
    },
    {
        "input": "Fit a least squares model for y = a*log(x) + b using x = [1,2,4,8] and y = [0,1,2,3].",
        "output": "import numpy as np\nx = np.array([1,2,4,8])\ny = np.array([0,1,2,3])\nlog_x = np.log(x)\nA = np.vstack([log_x, np.ones_like(log_x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"Model: y = {params[0]:.4f}*log(x) + {params[1]:.4f}\")"
    },
    {
        "input": "Given height, weight, and age data: X = [[160, 55, 25], [170, 65, 30], [180, 75, 35]], y = [1, 2, 3], fit a model and interpret coefficients.",
        "output": "import numpy as np\nX = np.array([[160, 55, 25], [170, 65, 30], [180, 75, 35]])\ny = np.array([1,2,3])\nX_aug = np.hstack([X, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*Height + {params[1]:.4f}*Weight + {params[2]:.4f}*Age + {params[3]:.4f}\")"
    },
    {
        "input": "Use least squares to fit a model y = a*x^b to data: x = [1,2,3,4], y = [2, 4.1, 8.2, 16.3].",
        "output": "import numpy as np\nx = np.array([1,2,3,4])\ny = np.array([2,4.1,8.2,16.3])\nlog_x = np.log(x)\nlog_y = np.log(y)\nA = np.vstack([log_x, np.ones_like(log_x)]).T\nb, log_a = np.linalg.lstsq(A, log_y, rcond=None)[0]\na = np.exp(log_a)\nprint(f\"Model: y = {a:.4f} * x^{b:.4f}\")"
    },
    {
        "input": "Fit a line to x = [1, 2, 3, 4, 5], y = [5.1, 4.2, 3.2, 2.3, 1.4] and interpret the negative slope.",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4, 5])\ny = np.array([5.1, 4.2, 3.2, 2.3, 1.4])\nA = np.vstack([x, np.ones_like(x)]).T\nm, c = np.linalg.lstsq(A, y, rcond=None)[0]\nprint(f\"y = {m:.2f}x + {c:.2f}\")"
    },
    {
        "input": "Given a square matrix A = [[1,2],[3,4]] and vector b = [1,0], solve Ax = b using least squares and verify the residual.",
        "output": "import numpy as np\nA = np.array([[1,2],[3,4]])\nb = np.array([1,0])\nx, *_ = np.linalg.lstsq(A, b, rcond=None)\nresidual = b - A @ x\nprint(f\"Solution x: {x}\")\nprint(f\"Residual: {residual}\")"
    },
    {
        "input": "Use least squares to find the best fit for a polynomial of degree 4 for x = [0,1,2,3,4], y = [1,2,1,3,5].",
        "output": "import numpy as np\nx = np.array([0,1,2,3,4])\ny = np.array([1,2,1,3,5])\nA = np.vstack([x**4, x**3, x**2, x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(\"y = {:.4f}x⁴ + {:.4f}x³ + {:.4f}x² + {:.4f}x + {:.4f}\".format(*params))"
    },
    {
        "input": "Fit a model to predict the efficiency of a machine based on input voltage, current, and load. X = [[220, 10, 50], [230, 12, 55], [240, 14, 60]], y = [85, 88, 90].",
        "output": "import numpy as np\nX = np.array([[220, 10, 50], [230, 12, 55], [240, 14, 60]])\ny = np.array([85, 88, 90])\nX_aug = np.hstack([X, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Efficiency = {params[0]:.4f}*Volt + {params[1]:.4f}*Curr + {params[2]:.4f}*Load + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a quadratic model to predict car stopping distance from speed. x = [20, 30, 40, 50], y = [15, 25, 40, 60].",
        "output": "import numpy as np\nx = np.array([20, 30, 40, 50])\ny = np.array([15, 25, 40, 60])\nA = np.vstack([x**2, x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"Distance = {params[0]:.2f}x² + {params[1]:.2f}x + {params[2]:.2f}\")"
    },
    {
        "input": "Fit a logarithmic model to predict soil moisture from time. x = [1, 2, 4, 8], y = [30, 25, 18, 12].",
        "output": "import numpy as np\nx = np.array([1, 2, 4, 8])\ny = np.array([30, 25, 18, 12])\nlog_x = np.log(x)\nA = np.vstack([log_x, np.ones_like(log_x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"Moisture = {params[0]:.2f}*log(t) + {params[1]:.2f}\")"
    },
    {
        "input": "Fit a cubic model to describe the displacement of a spring over time. x = [0, 1, 2, 3, 4], y = [0, 2, 6, 14, 28].",
        "output": "import numpy as np\nx = np.array([0, 1, 2, 3, 4])\ny = np.array([0, 2, 6, 14, 28])\nA = np.vstack([x**3, x**2, x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"Displacement = {params[0]:.2f}x³ + {params[1]:.2f}x² + {params[2]:.2f}x + {params[3]:.2f}\")"
    },
    {
        "input": "Use least squares to model population growth where x = [2000, 2005, 2010, 2015], y = [2.5, 2.7, 3.1, 3.8].",
        "output": "import numpy as np\nx = np.array([2000, 2005, 2010, 2015])\ny = np.array([2.5, 2.7, 3.1, 3.8])\nA = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"Population = {params[0]:.4f}*Year + {params[1]:.4f}\")"
    },
    {
        "input": "Fit a plane to 3D data to model elevation based on coordinates: x = [1,2,3], y = [2,4,6], z = [10,15,20].",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([2, 4, 6])\nz = np.array([10, 15, 20])\nA = np.vstack([x, y, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, z, rcond=None)\nprint(f\"Elevation = {params[0]:.2f}x + {params[1]:.2f}y + {params[2]:.2f}\")"
    },
    {
        "input": "Given input frequency and power output of a circuit, fit a line: x = [100, 200, 300], y = [5, 9, 13].",
        "output": "import numpy as np\nx = np.array([100, 200, 300])\ny = np.array([5, 9, 13])\nA = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"Power = {params[0]:.4f}*Freq + {params[1]:.4f}\")"
    },
    {
        "input": "Fit a 2-variable regression model to estimate fuel efficiency: X = [[1000, 50], [1200, 45], [1500, 40]], y = [20, 18, 15].",
        "output": "import numpy as np\nX = np.array([[1000, 50], [1200, 45], [1500, 40]])\ny = np.array([20, 18, 15])\nX_aug = np.hstack([X, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Efficiency = {params[0]:.4f}*Weight + {params[1]:.4f}*Speed + {params[2]:.4f}\")"
    },
    {
        "input": "Fit a power law model y = ax^b for x = [1, 2, 3, 4], y = [3, 6.1, 12.5, 25.1].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([3, 6.1, 12.5, 25.1])\nlog_x = np.log(x)\nlog_y = np.log(y)\nA = np.vstack([log_x, np.ones_like(log_x)]).T\nb, log_a = np.linalg.lstsq(A, log_y, rcond=None)[0]\na = np.exp(log_a)\nprint(f\"Model: y = {a:.4f} * x^{b:.4f}\")"
    },
    {
        "input": "Model CPU temperature (y) from usage percentage (x): x = [10, 50, 75, 90], y = [30, 60, 75, 85].",
        "output": "import numpy as np\nx = np.array([10, 50, 75, 90])\ny = np.array([30, 60, 75, 85])\nA = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"Temp = {params[0]:.2f}*Usage + {params[1]:.2f}\")"
    },
    {
        "input": "Predict concentration of a drug in bloodstream using log-time model: x = [1,2,4,8], y = [50, 30, 15, 7].",
        "output": "import numpy as np\nx = np.array([1, 2, 4, 8])\ny = np.array([50, 30, 15, 7])\nlog_x = np.log(x)\nA = np.vstack([log_x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"Concentration = {params[0]:.2f}*log(t) + {params[1]:.2f}\")"
    },
    {
        "input": "Fit a model using temperature and humidity to predict comfort index: X = [[30, 60], [25, 70], [20, 80]], y = [50, 60, 70].",
        "output": "import numpy as np\nX = np.array([[30, 60], [25, 70], [20, 80]])\ny = np.array([50, 60, 70])\nX_aug = np.hstack([X, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Comfort = {params[0]:.2f}*Temp + {params[1]:.2f}*Humidity + {params[2]:.2f}\")"
    },
    {
        "input": "Given time (min) and distance (m): x = [0, 1, 2, 3], y = [0, 5, 20, 45], fit a quadratic curve.",
        "output": "import numpy as np\nx = np.array([0, 1, 2, 3])\ny = np.array([0, 5, 20, 45])\nA = np.vstack([x**2, x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"Distance = {params[0]:.2f}t² + {params[1]:.2f}t + {params[2]:.2f}\")"
    },
    {
        "input": "Fit an exponential decay model y = ae^(-bx) using x = [1,2,3,4], y = [10, 6, 3.7, 2.2].",
        "output": "import numpy as np\nx = np.array([1,2,3,4])\ny = np.array([10,6,3.7,2.2])\nlog_y = np.log(y)\nA = np.vstack([-x, np.ones_like(x)]).T\nb, log_a = np.linalg.lstsq(A, log_y, rcond=None)[0]\na = np.exp(log_a)\nprint(f\"Model: y = {a:.4f} * exp(-{b:.4f}x)\")"
    },
    {
        "input": "Fit a linear model where the feature is a sine transformation of time. x = [0, π/2, π, 3π/2], y = [1, 0.5, 0, -0.5].",
        "output": "import numpy as np\nx = np.array([0, np.pi/2, np.pi, 3*np.pi/2])\ny = np.array([1, 0.5, 0, -0.5])\nsin_x = np.sin(x)\nA = np.vstack([sin_x, np.ones_like(sin_x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*sin(x) + {params[1]:.4f}\")"
    },
    {
        "input": "Fit a model predicting brightness from RGB color values. X = [[255,0,0], [0,255,0], [0,0,255]], y = [0.3, 0.6, 0.1].",
        "output": "import numpy as np\nX = np.array([[255,0,0], [0,255,0], [0,0,255]])\ny = np.array([0.3, 0.6, 0.1])\nX_aug = np.hstack([X, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Brightness = {params[0]:.4f}*R + {params[1]:.4f}*G + {params[2]:.4f}*B + {params[3]:.4f}\")"
    },
    {
        "input": "Predict force from mass using the logarithm of mass. x = [1, 2, 4, 8], y = [10, 20, 40, 80].",
        "output": "import numpy as np\nx = np.array([1, 2, 4, 8])\ny = np.array([10, 20, 40, 80])\nlog_x = np.log(x)\nA = np.vstack([log_x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"Force = {params[0]:.2f}*log(mass) + {params[1]:.2f}\")"
    },
    {
        "input": "Fit a linear regression model where all input features are perfectly collinear. X = [[1, 2], [2, 4], [3, 6]], y = [3, 6, 9].",
        "output": "import numpy as np\nX = np.array([[1, 2], [2, 4], [3, 6]])\ny = np.array([3, 6, 9])\nX_aug = np.hstack([X, np.ones((3, 1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*x1 + {params[1]:.4f}*x2 + {params[2]:.4f}\")"
    },
    {
        "input": "Fit a model with polynomial features (x², x³) to predict trajectory height. x = [1, 2, 3, 4], y = [3, 8, 27, 64].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([3, 8, 27, 64])\nX = np.vstack([x**2, x**3, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"Height = {params[0]:.2f}*x² + {params[1]:.2f}*x³ + {params[2]:.2f}\")"
    },
    {
        "input": "Fit a model to predict price from log of square footage. x = [100, 400, 1600, 6400], y = [100, 200, 300, 400].",
        "output": "import numpy as np\nx = np.array([100, 400, 1600, 6400])\ny = np.array([100, 200, 300, 400])\nlog_x = np.log(x)\nA = np.vstack([log_x, np.ones_like(log_x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"Price = {params[0]:.2f}*log(SqFt) + {params[1]:.2f}\")"
    },
    {
        "input": "Fit a model where inputs are probabilities that must sum to 1. X = [[0.6,0.4], [0.2,0.8], [0.9,0.1]], y = [1, 2, 1].",
        "output": "import numpy as np\nX = np.array([[0.6,0.4], [0.2,0.8], [0.9,0.1]])\ny = np.array([1, 2, 1])\nX_aug = np.hstack([X, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Output = {params[0]:.2f}*p1 + {params[1]:.2f}*p2 + {params[2]:.2f}\")"
    },
    {
        "input": "Fit a model with symbolic transformation where input is x and model is y = a*sin(x) + b*cos(x) + c. x = [0, π/2, π], y = [1, 0, -1].",
        "output": "import numpy as np\nx = np.array([0, np.pi/2, np.pi])\ny = np.array([1, 0, -1])\nX = np.vstack([np.sin(x), np.cos(x), np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.2f}*sin(x) + {params[1]:.2f}*cos(x) + {params[2]:.2f}\")"
    },
    {
        "input": "Fit a model where input is a categorical feature encoded as one-hot. X = [[1,0,0], [0,1,0], [0,0,1]], y = [10, 20, 15].",
        "output": "import numpy as np\nX = np.array([[1,0,0], [0,1,0], [0,0,1]])\ny = np.array([10, 20, 15])\nX_aug = np.hstack([X, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"y = {params[0]:.2f}*C1 + {params[1]:.2f}*C2 + {params[2]:.2f}*C3 + {params[3]:.2f}\")"
    },
    {
        "input": "Model the bending of a metal bar using both the position and square of the position. x = [1,2,3,4], y = [2,5,10,17].",
        "output": "import numpy as np\nx = np.array([1,2,3,4])\ny = np.array([2,5,10,17])\nX = np.vstack([x, x**2, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"Bend = {params[0]:.2f}*x + {params[1]:.2f}*x² + {params[2]:.2f}\")"
    },
    {
        "input": "Use inverse of input as feature: x = [1, 2, 4], y = [10, 5, 2.5].",
        "output": "import numpy as np\nx = np.array([1, 2, 4])\ny = np.array([10, 5, 2.5])\nx_inv = 1/x\nA = np.vstack([x_inv, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"y = {params[0]:.2f}*(1/x) + {params[1]:.2f}\")"
    },
    {
        "input": "Fit a linear model where x = [1, 10, 100, 1000], y = [3, 6, 9, 12].",
        "output": "import numpy as np\nx = np.array([1, 10, 100, 1000])\ny = np.array([3, 6, 9, 12])\nA = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"y = {params[0]:.5f}*x + {params[1]:.5f}\")"
    },
    {
        "input": "Fit model with heavily imbalanced scale: x = [0.01, 1000, 5000], y = [5, 10, 20].",
        "output": "import numpy as np\nx = np.array([0.01, 1000, 5000])\ny = np.array([5, 10, 20])\nA = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"y = {params[0]:.6f}*x + {params[1]:.6f}\")"
    },
    {
        "input": "Predict rainfall given pressure and temperature with highly correlated variables. X = [[1000, 20], [1010, 21], [1020, 22]], y = [30, 32, 34].",
        "output": "import numpy as np\nX = np.array([[1000, 20], [1010, 21], [1020, 22]])\ny = np.array([30, 32, 34])\nX_aug = np.hstack([X, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Rainfall = {params[0]:.4f}*Pressure + {params[1]:.4f}*Temp + {params[2]:.4f}\")"
    },
    {
        "input": "Fit a model where the input feature is the exponential of time. x = [0, 1, 2, 3], y = [1, 2.7, 7.4, 20.1].",
        "output": "import numpy as np\nx = np.array([0, 1, 2, 3])\ny = np.array([1, 2.7, 7.4, 20.1])\nexp_x = np.exp(x)\nA = np.vstack([exp_x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*exp(x) + {params[1]:.4f}\")"
    },
    {
        "input": "Fit a linear model to approximate the square root function. x = [1, 4, 9, 16], y = [1, 2, 3, 4].",
        "output": "import numpy as np\nx = np.array([1, 4, 9, 16])\ny = np.array([1, 2, 3, 4])\nsqrt_x = np.sqrt(x)\nA = np.vstack([sqrt_x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*sqrt(x) + {params[1]:.4f}\")"
    },
    {
        "input": "Fit a model where inputs are geographic coordinates: X = [[30.1, -97.7], [34.0, -118.2], [40.7, -74.0]], y = [90, 75, 60].",
        "output": "import numpy as np\nX = np.array([[30.1, -97.7], [34.0, -118.2], [40.7, -74.0]])\ny = np.array([90, 75, 60])\nX_aug = np.hstack([X, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Value = {params[0]:.2f}*Lat + {params[1]:.2f}*Lon + {params[2]:.2f}\")"
    },
    {
        "input": "Predict crime rate using polynomial features of population size. x = [1000, 2000, 3000, 4000], y = [5, 10, 18, 30].",
        "output": "import numpy as np\nx = np.array([1000, 2000, 3000, 4000])\ny = np.array([5, 10, 18, 30])\nX = np.vstack([x, x**2, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"Crime = {params[0]:.6f}*Pop + {params[1]:.8f}*Pop² + {params[2]:.2f}\")"
    },
    {
        "input": "Fit a model where inputs include a constant feature. X = [[1, 5], [2, 5], [3, 5]], y = [10, 20, 30].",
        "output": "import numpy as np\nX = np.array([[1, 5], [2, 5], [3, 5]])\ny = np.array([10, 20, 30])\nX_aug = np.hstack([X, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"y = {params[0]:.2f}*x1 + {params[1]:.2f}*const + {params[2]:.2f}\")"
    },
    {
        "input": "Fit a model using distance from origin as the input feature. x = [[3, 4], [6, 8], [9, 12]], y = [5, 10, 15].",
        "output": "import numpy as np\nx = np.array([[3, 4], [6, 8], [9, 12]])\ny = np.array([5, 10, 15])\ndistance = np.linalg.norm(x, axis=1)\nA = np.vstack([distance, np.ones_like(distance)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"y = {params[0]:.2f}*distance + {params[1]:.2f}\")"
    },
    {
        "input": "Predict brightness using quadratic RGB values: X = [[255,0,0], [0,255,0], [0,0,255]], y = [76.5, 150.4, 29.9].",
        "output": "import numpy as np\nX = np.array([[255,0,0], [0,255,0], [0,0,255]])\ny = np.array([76.5, 150.4, 29.9])\nX_sq = X**2\nX_aug = np.hstack([X_sq, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Brightness = {params[0]:.4f}*R² + {params[1]:.4f}*G² + {params[2]:.4f}*B² + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a model where inputs are percentage values summing to 100. X = [[30, 70], [50, 50], [20, 80]], y = [60, 55, 70].",
        "output": "import numpy as np\nX = np.array([[30, 70], [50, 50], [20, 80]])\ny = np.array([60, 55, 70])\nX_aug = np.hstack([X, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Score = {params[0]:.2f}*Part1 + {params[1]:.2f}*Part2 + {params[2]:.2f}\")"
    },
    {
        "input": "Fit a model where x = [-2, -1, 0, 1, 2], y = [4, 1, 0, 1, 4] using polynomial features.",
        "output": "import numpy as np\nx = np.array([-2, -1, 0, 1, 2])\ny = np.array([4, 1, 0, 1, 4])\nX = np.vstack([x**2, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.2f}*x² + {params[1]:.2f}\")"
    },
    {
        "input": "Fit a model where output is y = a/x + b. x = [1, 2, 4, 8], y = [10, 5, 2.5, 1.25].",
        "output": "import numpy as np\nx = np.array([1, 2, 4, 8])\ny = np.array([10, 5, 2.5, 1.25])\ninv_x = 1 / x\nA = np.vstack([inv_x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"y = {params[0]:.2f}*(1/x) + {params[1]:.2f}\")"
    },
    {
        "input": "Fit a model using natural log of income to predict happiness. x = [1000, 5000, 10000, 20000], y = [4, 6, 7, 8].",
        "output": "import numpy as np\nx = np.array([1000, 5000, 10000, 20000])\ny = np.array([4, 6, 7, 8])\nlog_x = np.log(x)\nA = np.vstack([log_x, np.ones_like(log_x)]).T\nparams, *_ = np.linalg.lstsq(A, y, rcond=None)\nprint(f\"Happiness = {params[0]:.2f}*log(Income) + {params[1]:.2f}\")"
    },
    {
        "input": "Fit a model using both sine and cosine of an angle. x = [0, π/2, π], y = [1, 0, -1].",
        "output": "import numpy as np\nx = np.array([0, np.pi/2, np.pi])\ny = np.array([1, 0, -1])\nX = np.vstack([np.sin(x), np.cos(x), np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.2f}*sin(x) + {params[1]:.2f}*cos(x) + {params[2]:.2f}\")"
    },
    {
        "input": "Fit a model where one input is always zero: X = [[1,0], [2,0], [3,0]], y = [5,10,15].",
        "output": "import numpy as np\nX = np.array([[1,0], [2,0], [3,0]])\ny = np.array([5,10,15])\nX_aug = np.hstack([X, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"y = {params[0]:.2f}*x1 + {params[1]:.2f}*x2 + {params[2]:.2f}\")"
    },
    {
        "input": "Fit a linear model using time of day in radians: x = [0, π/2, π, 3π/2], y = [1, 2, 1, 0.5].",
        "output": "import numpy as np\nx = np.array([0, np.pi/2, np.pi, 3*np.pi/2])\ny = np.array([1, 2, 1, 0.5])\nX = np.vstack([np.sin(x), np.cos(x), np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*sin(t) + {params[1]:.4f}*cos(t) + {params[2]:.4f}\")"
    },
    {
        "input": "Model altitude based on barometric pressure: x = [1013, 1000, 980], y = [0, 111, 222].",
        "output": "import numpy as np\nx = np.array([1013, 1000, 980])\ny = np.array([0, 111, 222])\ninv_x = 1 / x\nX = np.vstack([inv_x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"Altitude = {params[0]:.2f}*(1/Pressure) + {params[1]:.2f}\")"
    },
    {
        "input": "Use sin(x^2) as the transformed input: x = [1, 2, 3, 4], y = [0.84, 0.91, 0.14, -0.76].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([0.84, 0.91, 0.14, -0.76])\nsin_sq = np.sin(x**2)\nX = np.vstack([sin_sq, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.3f}*sin(x²) + {params[1]:.3f}\")"
    },
    {
        "input": "Fit a linear model with one-hot encoded categories: X = [[1,0,0], [0,1,0], [0,0,1]], y = [10, 20, 30].",
        "output": "import numpy as np\nX = np.array([[1,0,0], [0,1,0], [0,0,1]])\ny = np.array([10, 20, 30])\nX_aug = np.hstack([X, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"y = {params[0]:.2f}*Cat1 + {params[1]:.2f}*Cat2 + {params[2]:.2f}*Cat3 + {params[3]:.2f}\")"
    },
    {
        "input": "Use logarithm and square of inputs: x = [1, 2, 4, 8], y = [0.1, 0.4, 1.2, 3.2].",
        "output": "import numpy as np\nx = np.array([1, 2, 4, 8])\ny = np.array([0.1, 0.4, 1.2, 3.2])\nlog_x = np.log(x)\nx_sq = x**2\nX = np.vstack([log_x, x_sq, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*log(x) + {params[1]:.4f}*x² + {params[2]:.4f}\")"
    },
    {
        "input": "Fit a model with interaction terms: x1 = [1,2,3], x2 = [4,5,6], y = [5,10,18].",
        "output": "import numpy as np\nx1 = np.array([1,2,3])\nx2 = np.array([4,5,6])\ny = np.array([5,10,18])\nX = np.vstack([x1, x2, x1*x2, np.ones_like(x1)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.2f}*x1 + {params[1]:.2f}*x2 + {params[2]:.2f}*x1*x2 + {params[3]:.2f}\")"
    },
    {
        "input": "Use cubic polynomial regression: x = [0, 1, 2, 3], y = [1, 2, 7, 20].",
        "output": "import numpy as np\nx = np.array([0, 1, 2, 3])\ny = np.array([1, 2, 7, 20])\nX = np.vstack([x**3, x**2, x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.2f}*x³ + {params[1]:.2f}*x² + {params[2]:.2f}*x + {params[3]:.2f}\")"
    },
    {
        "input": "Model y using both x and exp(-x): x = [0,1,2,3], y = [1, 1.5, 1.3, 1.1].",
        "output": "import numpy as np\nx = np.array([0,1,2,3])\ny = np.array([1, 1.5, 1.3, 1.1])\nX = np.vstack([x, np.exp(-x), np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*x + {params[1]:.4f}*exp(-x) + {params[2]:.4f}\")"
    },
    {
        "input": "Fit a model with high collinearity: X = [[1,2], [2,4.01], [3,6.02]], y = [3,6,9].",
        "output": "import numpy as np\nX = np.array([[1,2], [2,4.01], [3,6.02]])\ny = np.array([3,6,9])\nX_aug = np.hstack([X, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"y = {params[0]:.3f}*x1 + {params[1]:.3f}*x2 + {params[2]:.3f}\")"
    },
    {
        "input": "Fit a model to noisy quadratic data: x = [1,2,3,4,5], y = [2, 5.1, 10, 17.2, 26].",
        "output": "import numpy as np\nx = np.array([1,2,3,4,5])\ny = np.array([2, 5.1, 10, 17.2, 26])\nX = np.vstack([x**2, x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.3f}*x² + {params[1]:.3f}*x + {params[2]:.3f}\")"
    },
    {
        "input": "A company tracks its advertising spend in thousands of dollars and resulting sales in millions. Given: ad_spend = [2, 3, 5, 7], sales = [1.2, 1.8, 3.0, 4.1]. Use least squares to predict sales from ad spend.",
        "output": "import numpy as np\nad_spend = np.array([2, 3, 5, 7])\nsales = np.array([1.2, 1.8, 3.0, 4.1])\nX = np.vstack([ad_spend, np.ones_like(ad_spend)]).T\nparams, *_ = np.linalg.lstsq(X, sales, rcond=None)\nprint(f\"Sales = {params[0]:.4f}*AdSpend + {params[1]:.4f}\")"
    },
    {
        "input": "An engineer records machine temperature (in °C) and the number of units produced per hour: temp = [60, 65, 70, 75], units = [200, 210, 240, 250]. Build a linear model.",
        "output": "import numpy as np\ntemp = np.array([60, 65, 70, 75])\nunits = np.array([200, 210, 240, 250])\nX = np.vstack([temp, np.ones_like(temp)]).T\nparams, *_ = np.linalg.lstsq(X, units, rcond=None)\nprint(f\"Units = {params[0]:.2f}*Temp + {params[1]:.2f}\")"
    },
    {
        "input": "A bakery measures the number of loaves sold based on outside temperature (°C): temp = [10, 15, 20, 25], loaves = [100, 95, 85, 80]. Fit a least squares model.",
        "output": "import numpy as np\ntemp = np.array([10, 15, 20, 25])\nloaves = np.array([100, 95, 85, 80])\nX = np.vstack([temp, np.ones_like(temp)]).T\nparams, *_ = np.linalg.lstsq(X, loaves, rcond=None)\nprint(f\"Loaves = {params[0]:.2f}*Temp + {params[1]:.2f}\")"
    },
    {
        "input": "A farmer notes that for each increase in irrigation hours, crop yield (tons) changes: hours = [1, 2, 3, 4], yield = [1.5, 1.9, 2.7, 3.2]. Build a linear model.",
        "output": "import numpy as np\nhours = np.array([1, 2, 3, 4])\nyield_ = np.array([1.5, 1.9, 2.7, 3.2])\nX = np.vstack([hours, np.ones_like(hours)]).T\nparams, *_ = np.linalg.lstsq(X, yield_, rcond=None)\nprint(f\"Yield = {params[0]:.2f}*Hours + {params[1]:.2f}\")"
    },
    {
        "input": "A runner records distance run (km) and calories burned: distance = [2, 4, 6, 8], calories = [150, 300, 450, 600]. Fit a linear model using least squares.",
        "output": "import numpy as np\ndistance = np.array([2, 4, 6, 8])\ncalories = np.array([150, 300, 450, 600])\nX = np.vstack([distance, np.ones_like(distance)]).T\nparams, *_ = np.linalg.lstsq(X, calories, rcond=None)\nprint(f\"Calories = {params[0]:.2f}*Distance + {params[1]:.2f}\")"
    },
    {
        "input": "A student observes how many hours of sleep affect test scores: sleep = [4, 5, 6, 7, 8], scores = [60, 65, 70, 75, 80]. Create a least squares model.",
        "output": "import numpy as np\nsleep = np.array([4, 5, 6, 7, 8])\nscores = np.array([60, 65, 70, 75, 80])\nX = np.vstack([sleep, np.ones_like(sleep)]).T\nparams, *_ = np.linalg.lstsq(X, scores, rcond=None)\nprint(f\"Score = {params[0]:.2f}*Sleep + {params[1]:.2f}\")"
    },
    {
        "input": "An app measures usage time (hours) and number of interactions: usage = [1, 2, 3, 4], interactions = [20, 35, 55, 75]. Fit a linear model.",
        "output": "import numpy as np\nusage = np.array([1, 2, 3, 4])\ninteractions = np.array([20, 35, 55, 75])\nX = np.vstack([usage, np.ones_like(usage)]).T\nparams, *_ = np.linalg.lstsq(X, interactions, rcond=None)\nprint(f\"Interactions = {params[0]:.2f}*Usage + {params[1]:.2f}\")"
    },
    {
        "input": "A teacher observes students’ study time (hrs) and corresponding grades: study = [2, 4, 6, 8], grades = [55, 65, 75, 85]. Build a linear model.",
        "output": "import numpy as np\nstudy = np.array([2, 4, 6, 8])\ngrades = np.array([55, 65, 75, 85])\nX = np.vstack([study, np.ones_like(study)]).T\nparams, *_ = np.linalg.lstsq(X, grades, rcond=None)\nprint(f\"Grade = {params[0]:.2f}*Study + {params[1]:.2f}\")"
    },
    {
        "input": "A startup tracks server load and number of requests handled: load = [1, 2, 3, 4], requests = [100, 200, 300, 400]. Fit a linear model using least squares.",
        "output": "import numpy as np\nload = np.array([1, 2, 3, 4])\nrequests = np.array([100, 200, 300, 400])\nX = np.vstack([load, np.ones_like(load)]).T\nparams, *_ = np.linalg.lstsq(X, requests, rcond=None)\nprint(f\"Requests = {params[0]:.2f}*Load + {params[1]:.2f}\")"
    },
    {
        "input": "An experiment records time and bacteria count: time = [0, 1, 2, 3], count = [100, 180, 260, 340]. Use least squares to model growth.",
        "output": "import numpy as np\ntime = np.array([0, 1, 2, 3])\ncount = np.array([100, 180, 260, 340])\nX = np.vstack([time, np.ones_like(time)]).T\nparams, *_ = np.linalg.lstsq(X, count, rcond=None)\nprint(f\"Count = {params[0]:.2f}*Time + {params[1]:.2f}\")"
    },
    {
        "input": "A business tracks website visits and product purchases: visits = [100, 200, 300, 400], purchases = [5, 10, 15, 21]. Build a linear model.",
        "output": "import numpy as np\nvisits = np.array([100, 200, 300, 400])\npurchases = np.array([5, 10, 15, 21])\nX = np.vstack([visits, np.ones_like(visits)]).T\nparams, *_ = np.linalg.lstsq(X, purchases, rcond=None)\nprint(f\"Purchases = {params[0]:.4f}*Visits + {params[1]:.2f}\")"
    },
    {
        "input": "An architect studies room area (sq meters) vs. cooling cost (USD): area = [20, 30, 40, 50], cost = [100, 140, 180, 220]. Fit a model.",
        "output": "import numpy as np\narea = np.array([20, 30, 40, 50])\ncost = np.array([100, 140, 180, 220])\nX = np.vstack([area, np.ones_like(area)]).T\nparams, *_ = np.linalg.lstsq(X, cost, rcond=None)\nprint(f\"Cost = {params[0]:.2f}*Area + {params[1]:.2f}\")"
    },
    {
        "input": "A meteorologist tracks temperature vs. ice cream sales: temp = [15, 20, 25, 30], sales = [200, 300, 400, 500]. Build a linear model.",
        "output": "import numpy as np\ntemp = np.array([15, 20, 25, 30])\nsales = np.array([200, 300, 400, 500])\nX = np.vstack([temp, np.ones_like(temp)]).T\nparams, *_ = np.linalg.lstsq(X, sales, rcond=None)\nprint(f\"Sales = {params[0]:.2f}*Temp + {params[1]:.2f}\")"
    },
    {
        "input": "A gym records hours spent on treadmill and calories lost: hours = [0.5, 1.0, 1.5, 2.0], calories = [100, 200, 290, 390]. Fit a least squares model.",
        "output": "import numpy as np\nhours = np.array([0.5, 1.0, 1.5, 2.0])\ncalories = np.array([100, 200, 290, 390])\nX = np.vstack([hours, np.ones_like(hours)]).T\nparams, *_ = np.linalg.lstsq(X, calories, rcond=None)\nprint(f\"Calories = {params[0]:.2f}*Hours + {params[1]:.2f}\")"
    },
    {
        "input": "A delivery service tracks the number of packages delivered based on the distance traveled (in km): distance = [5, 10, 15, 20], packages = [50, 70, 85, 100]. Build a least squares model.",
        "output": "import numpy as np\ndistance = np.array([5, 10, 15, 20])\npackages = np.array([50, 70, 85, 100])\nX = np.vstack([distance, np.ones_like(distance)]).T\nparams, *_ = np.linalg.lstsq(X, packages, rcond=None)\nprint(f\"Packages = {params[0]:.2f}*Distance + {params[1]:.2f}\")"
    },
    {
        "input": "A chef logs the amount of flour used (in cups) and the number of cookies baked: flour = [1, 2, 3, 4], cookies = [24, 48, 68, 85]. Fit a linear model.",
        "output": "import numpy as np\nflour = np.array([1, 2, 3, 4])\ncookies = np.array([24, 48, 68, 85])\nX = np.vstack([flour, np.ones_like(flour)]).T\nparams, *_ = np.linalg.lstsq(X, cookies, rcond=None)\nprint(f\"Cookies = {params[0]:.2f}*Flour + {params[1]:.2f}\")"
    },
    {
        "input": "A school tracks students’ reading hours per week and their vocabulary test scores: hours = [1, 2, 3, 4], scores = [60, 70, 78, 85]. Fit a least squares model.",
        "output": "import numpy as np\nhours = np.array([1, 2, 3, 4])\nscores = np.array([60, 70, 78, 85])\nX = np.vstack([hours, np.ones_like(hours)]).T\nparams, *_ = np.linalg.lstsq(X, scores, rcond=None)\nprint(f\"Score = {params[0]:.2f}*Hours + {params[1]:.2f}\")"
    },
    {
        "input": "A freelance writer records number of articles written and total earnings: articles = [5, 10, 15, 20], earnings = [100, 190, 280, 370]. Fit a linear model.",
        "output": "import numpy as np\narticles = np.array([5, 10, 15, 20])\nearnings = np.array([100, 190, 280, 370])\nX = np.vstack([articles, np.ones_like(articles)]).T\nparams, *_ = np.linalg.lstsq(X, earnings, rcond=None)\nprint(f\"Earnings = {params[0]:.2f}*Articles + {params[1]:.2f}\")"
    },
    {
        "input": "An artist measures time spent painting and the size of canvas completed: time = [1, 2, 3, 4], canvas_size = [10, 22, 32, 42]. Build a linear model.",
        "output": "import numpy as np\ntime = np.array([1, 2, 3, 4])\ncanvas_size = np.array([10, 22, 32, 42])\nX = np.vstack([time, np.ones_like(time)]).T\nparams, *_ = np.linalg.lstsq(X, canvas_size, rcond=None)\nprint(f\"CanvasSize = {params[0]:.2f}*Time + {params[1]:.2f}\")"
    },
    {
        "input": "A business monitors working hours vs productivity index: hours = [6, 7, 8, 9], productivity = [65, 70, 78, 85]. Fit a model using least squares.",
        "output": "import numpy as np\nhours = np.array([6, 7, 8, 9])\nproductivity = np.array([65, 70, 78, 85])\nX = np.vstack([hours, np.ones_like(hours)]).T\nparams, *_ = np.linalg.lstsq(X, productivity, rcond=None)\nprint(f\"Productivity = {params[0]:.2f}*Hours + {params[1]:.2f}\")"
    },
    {
        "input": "A coffee shop tracks number of customers and profit (in $): customers = [50, 100, 150, 200], profit = [200, 400, 610, 820]. Build a least squares model.",
        "output": "import numpy as np\ncustomers = np.array([50, 100, 150, 200])\nprofit = np.array([200, 400, 610, 820])\nX = np.vstack([customers, np.ones_like(customers)]).T\nparams, *_ = np.linalg.lstsq(X, profit, rcond=None)\nprint(f\"Profit = {params[0]:.2f}*Customers + {params[1]:.2f}\")"
    },
    {
        "input": "A developer tracks time spent on debugging and lines of code fixed: time = [1, 2, 3, 4], fixes = [10, 20, 35, 50]. Fit a least squares model.",
        "output": "import numpy as np\ntime = np.array([1, 2, 3, 4])\nfixes = np.array([10, 20, 35, 50])\nX = np.vstack([time, np.ones_like(time)]).T\nparams, *_ = np.linalg.lstsq(X, fixes, rcond=None)\nprint(f\"Fixes = {params[0]:.2f}*Time + {params[1]:.2f}\")"
    },
    {
        "input": "A teacher tracks time spent revising and exam scores: time = [1, 2, 4, 6], scores = [50, 60, 75, 90]. Fit a linear model using least squares.",
        "output": "import numpy as np\ntime = np.array([1, 2, 4, 6])\nscores = np.array([50, 60, 75, 90])\nX = np.vstack([time, np.ones_like(time)]).T\nparams, *_ = np.linalg.lstsq(X, scores, rcond=None)\nprint(f\"Score = {params[0]:.2f}*Time + {params[1]:.2f}\")"
    },
    {
        "input": "A florist notes number of flowers sold based on weather temperature: temp = [10, 15, 20, 25], flowers = [30, 45, 60, 75]. Build a least squares model.",
        "output": "import numpy as np\ntemp = np.array([10, 15, 20, 25])\nflowers = np.array([30, 45, 60, 75])\nX = np.vstack([temp, np.ones_like(temp)]).T\nparams, *_ = np.linalg.lstsq(X, flowers, rcond=None)\nprint(f\"Flowers = {params[0]:.2f}*Temp + {params[1]:.2f}\")"
    },
    {
        "input": "A social media influencer tracks number of posts vs. new followers: posts = [1, 2, 3, 4], followers = [10, 25, 40, 55]. Fit a least squares model.",
        "output": "import numpy as np\nposts = np.array([1, 2, 3, 4])\nfollowers = np.array([10, 25, 40, 55])\nX = np.vstack([posts, np.ones_like(posts)]).T\nparams, *_ = np.linalg.lstsq(X, followers, rcond=None)\nprint(f\"Followers = {params[0]:.2f}*Posts + {params[1]:.2f}\")"
    },
    {
        "input": "A taxi service records time driven (hrs) and distance covered (km): time = [1, 2, 3, 4], distance = [20, 45, 70, 90]. Build a model using least squares.",
        "output": "import numpy as np\ntime = np.array([1, 2, 3, 4])\ndistance = np.array([20, 45, 70, 90])\nX = np.vstack([time, np.ones_like(time)]).T\nparams, *_ = np.linalg.lstsq(X, distance, rcond=None)\nprint(f\"Distance = {params[0]:.2f}*Time + {params[1]:.2f}\")"
    },
    {
        "input": "A nurse monitors medicine dose and patient response score: dose = [10, 20, 30, 40], response = [3, 5, 8, 10]. Build a linear model.",
        "output": "import numpy as np\ndose = np.array([10, 20, 30, 40])\nresponse = np.array([3, 5, 8, 10])\nX = np.vstack([dose, np.ones_like(dose)]).T\nparams, *_ = np.linalg.lstsq(X, response, rcond=None)\nprint(f\"Response = {params[0]:.2f}*Dose + {params[1]:.2f}\")"
    },
    {
        "input": "A painter observes time spent mixing colors vs. color quality score: time = [5, 10, 15, 20], score = [55, 60, 70, 80]. Fit a least squares model.",
        "output": "import numpy as np\ntime = np.array([5, 10, 15, 20])\nscore = np.array([55, 60, 70, 80])\nX = np.vstack([time, np.ones_like(time)]).T\nparams, *_ = np.linalg.lstsq(X, score, rcond=None)\nprint(f\"Score = {params[0]:.2f}*Time + {params[1]:.2f}\")"
    },
    {
        "input": "An ice cream vendor tracks hours of sunshine vs. cones sold: sun = [1, 2, 3, 4], cones = [20, 40, 65, 90]. Build a linear model.",
        "output": "import numpy as np\nsun = np.array([1, 2, 3, 4])\ncones = np.array([20, 40, 65, 90])\nX = np.vstack([sun, np.ones_like(sun)]).T\nparams, *_ = np.linalg.lstsq(X, cones, rcond=None)\nprint(f\"Cones = {params[0]:.2f}*Sunshine + {params[1]:.2f}\")"
    },
    {
        "input": "A bookstore records number of hours open per day and number of books sold: hours = [6, 7, 8, 9, 10], books = [60, 68, 74, 83, 95]. Fit a linear model.",
        "output": "import numpy as np\nhours = np.array([6, 7, 8, 9, 10])\nbooks = np.array([60, 68, 74, 83, 95])\nX = np.vstack([hours, np.ones_like(hours)]).T\nparams, *_ = np.linalg.lstsq(X, books, rcond=None)\nprint(f\"Books = {params[0]:.2f}*Hours + {params[1]:.2f}\")"
    },
    {
        "input": "A farm records temperature and humidity to predict milk yield. X = [[20, 70], [22, 65], [25, 60], [28, 55]], y = [18, 20, 22, 24]. Build a multivariable model.",
        "output": "import numpy as np\nX = np.array([[20, 70], [22, 65], [25, 60], [28, 55]])\ny = np.array([18, 20, 22, 24])\nX_aug = np.hstack([X, np.ones((X.shape[0], 1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Milk Yield = {params[0]:.2f}*Temp + {params[1]:.2f}*Humidity + {params[2]:.2f}\")"
    },
    {
        "input": "An athlete records calories burned per session and duration (minutes): duration = [30, 45, 60, 75], calories = [200, 290, 380, 470]. Fit a linear model.",
        "output": "import numpy as np\nduration = np.array([30, 45, 60, 75])\ncalories = np.array([200, 290, 380, 470])\nX = np.vstack([duration, np.ones_like(duration)]).T\nparams, *_ = np.linalg.lstsq(X, calories, rcond=None)\nprint(f\"Calories = {params[0]:.2f}*Duration + {params[1]:.2f}\")"
    },
    {
        "input": "A freelancer logs hours worked and income from different weeks: hours = [10, 15, 20, 25], income = [300, 450, 600, 750]. Fit a linear regression model.",
        "output": "import numpy as np\nhours = np.array([10, 15, 20, 25])\nincome = np.array([300, 450, 600, 750])\nX = np.vstack([hours, np.ones_like(hours)]).T\nparams, *_ = np.linalg.lstsq(X, income, rcond=None)\nprint(f\"Income = {params[0]:.2f}*Hours + {params[1]:.2f}\")"
    },
    {
        "input": "A company tracks number of ads run and resulting sales (in $1000): ads = [1, 2, 3, 4, 5], sales = [10, 20, 28, 40, 48]. Fit a linear model.",
        "output": "import numpy as np\nads = np.array([1, 2, 3, 4, 5])\nsales = np.array([10, 20, 28, 40, 48])\nX = np.vstack([ads, np.ones_like(ads)]).T\nparams, *_ = np.linalg.lstsq(X, sales, rcond=None)\nprint(f\"Sales = {params[0]:.2f}*Ads + {params[1]:.2f}\")"
    },
    {
        "input": "Predict vehicle mileage (MPG) based on engine size and weight: X = [[1.5, 1200], [2.0, 1400], [2.5, 1600], [3.0, 1800]], y = [35, 30, 26, 22].",
        "output": "import numpy as np\nX = np.array([[1.5, 1200], [2.0, 1400], [2.5, 1600], [3.0, 1800]])\ny = np.array([35, 30, 26, 22])\nX_aug = np.hstack([X, np.ones((4,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"MPG = {params[0]:.2f}*EngineSize + {params[1]:.2f}*Weight + {params[2]:.2f}\")"
    },
    {
        "input": "A bakery tracks loaves baked vs. flour used (kg): loaves = [100, 200, 300, 400], flour = [25, 48, 73, 98]. Fit a regression model.",
        "output": "import numpy as np\nloaves = np.array([100, 200, 300, 400])\nflour = np.array([25, 48, 73, 98])\nX = np.vstack([loaves, np.ones_like(loaves)]).T\nparams, *_ = np.linalg.lstsq(X, flour, rcond=None)\nprint(f\"Flour = {params[0]:.2f}*Loaves + {params[1]:.2f}\")"
    },
    {
        "input": "A café tracks time of day and number of customers. Time (in hours from 8 AM): [1, 2, 3, 4], customers = [10, 20, 30, 40]. Fit a model.",
        "output": "import numpy as np\ntime = np.array([1, 2, 3, 4])\ncustomers = np.array([10, 20, 30, 40])\nX = np.vstack([time, np.ones_like(time)]).T\nparams, *_ = np.linalg.lstsq(X, customers, rcond=None)\nprint(f\"Customers = {params[0]:.2f}*Time + {params[1]:.2f}\")"
    },
    {
        "input": "A gym records exercise time and calories burned: time = [15, 30, 45, 60], calories = [120, 230, 340, 450]. Use least squares method.",
        "output": "import numpy as np\ntime = np.array([15, 30, 45, 60])\ncalories = np.array([120, 230, 340, 450])\nX = np.vstack([time, np.ones_like(time)]).T\nparams, *_ = np.linalg.lstsq(X, calories, rcond=None)\nprint(f\"Calories = {params[0]:.2f}*Time + {params[1]:.2f}\")"
    },
    {
        "input": "Predict car price based on age and mileage: X = [[1, 10000], [2, 20000], [3, 30000], [4, 40000]], y = [20000, 18000, 16000, 14000].",
        "output": "import numpy as np\nX = np.array([[1, 10000], [2, 20000], [3, 30000], [4, 40000]])\ny = np.array([20000, 18000, 16000, 14000])\nX_aug = np.hstack([X, np.ones((4,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Price = {params[0]:.2f}*Age + {params[1]:.4f}*Mileage + {params[2]:.2f}\")"
    },
    {
        "input": "Estimate electricity bill based on AC hours used: hours = [2, 4, 6, 8], bill = [20, 35, 50, 65]. Fit a linear model.",
        "output": "import numpy as np\nhours = np.array([2, 4, 6, 8])\nbill = np.array([20, 35, 50, 65])\nX = np.vstack([hours, np.ones_like(hours)]).T\nparams, *_ = np.linalg.lstsq(X, bill, rcond=None)\nprint(f\"Bill = {params[0]:.2f}*Hours + {params[1]:.2f}\")"
    },
    {
        "input": "Predict study score from hours studied and sleep hours: X = [[1, 8], [2, 7], [3, 6], [4, 5]], y = [60, 65, 70, 75].",
        "output": "import numpy as np\nX = np.array([[1, 8], [2, 7], [3, 6], [4, 5]])\ny = np.array([60, 65, 70, 75])\nX_aug = np.hstack([X, np.ones((4,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Score = {params[0]:.2f}*StudyHours + {params[1]:.2f}*Sleep + {params[2]:.2f}\")"
    },
    {
        "input": "Model rent cost based on apartment size (sqft): size = [500, 750, 1000, 1250], rent = [800, 1100, 1400, 1700]. Fit least squares.",
        "output": "import numpy as np\nsize = np.array([500, 750, 1000, 1250])\nrent = np.array([800, 1100, 1400, 1700])\nX = np.vstack([size, np.ones_like(size)]).T\nparams, *_ = np.linalg.lstsq(X, rent, rcond=None)\nprint(f\"Rent = {params[0]:.2f}*Size + {params[1]:.2f}\")"
    },
    {
        "input": "A dog trainer records time spent per session vs. behavior score: time = [1, 2, 3, 4], score = [10, 25, 40, 55]. Fit a linear model.",
        "output": "import numpy as np\ntime = np.array([1, 2, 3, 4])\nscore = np.array([10, 25, 40, 55])\nX = np.vstack([time, np.ones_like(time)]).T\nparams, *_ = np.linalg.lstsq(X, score, rcond=None)\nprint(f\"Score = {params[0]:.2f}*Time + {params[1]:.2f}\")"
    },
    {
        "input": "A school's test scores over years are [78, 80, 83, 87] for years [2019, 2020, 2021, 2022]. Predict the score for 2025.",
        "output": "import numpy as np\nyears = np.array([2019, 2020, 2021, 2022])\nscores = np.array([78, 80, 83, 87])\nX = np.vstack([years, np.ones_like(years)]).T\nparams, *_ = np.linalg.lstsq(X, scores, rcond=None)\npred = params[0]*2025 + params[1]\nprint(f\"Predicted score in 2025: {pred:.2f}\")"
    },
    {
        "input": "Sales for the past years are: [100, 120, 135, 160] for years [2018, 2019, 2020, 2021]. Estimate 2023 sales.",
        "output": "import numpy as np\nyears = np.array([2018, 2019, 2020, 2021])\nsales = np.array([100, 120, 135, 160])\nX = np.vstack([years, np.ones_like(years)]).T\nparams, *_ = np.linalg.lstsq(X, sales, rcond=None)\npred = params[0]*2023 + params[1]\nprint(f\"Estimated sales in 2023: {pred:.2f}\")"
    },
    {
        "input": "Temperature recorded at 8 AM for the last 5 days: [15, 16, 17, 19, 20]. Days: [1, 2, 3, 4, 5]. Predict day 6 temperature.",
        "output": "import numpy as np\ndays = np.array([1, 2, 3, 4, 5])\ntemps = np.array([15, 16, 17, 19, 20])\nX = np.vstack([days, np.ones_like(days)]).T\nparams, *_ = np.linalg.lstsq(X, temps, rcond=None)\npred = params[0]*6 + params[1]\nprint(f\"Predicted temperature on day 6: {pred:.2f}°C\")"
    },
    {
        "input": "Predict monthly subscribers in month 8 if months 1–5 had subscribers: [1000, 1200, 1500, 1800, 2100].",
        "output": "import numpy as np\nmonths = np.array([1, 2, 3, 4, 5])\nsubs = np.array([1000, 1200, 1500, 1800, 2100])\nX = np.vstack([months, np.ones_like(months)]).T\nparams, *_ = np.linalg.lstsq(X, subs, rcond=None)\npred = params[0]*8 + params[1]\nprint(f\"Predicted subscribers in month 8: {pred:.0f}\")"
    },
    {
        "input": "Company revenue in millions over 4 years: [1.5, 2.0, 2.8, 3.5]. Years: [1, 2, 3, 4]. Estimate year 6 revenue.",
        "output": "import numpy as np\nyears = np.array([1, 2, 3, 4])\nrevenue = np.array([1.5, 2.0, 2.8, 3.5])\nX = np.vstack([years, np.ones_like(years)]).T\nparams, *_ = np.linalg.lstsq(X, revenue, rcond=None)\npred = params[0]*6 + params[1]\nprint(f\"Estimated revenue in year 6: {pred:.2f} million\")"
    },
    {
        "input": "Fit a model to predict fuel efficiency from year: years = [2010, 2012, 2014, 2016], mpg = [28, 29, 30.5, 32.2]. Predict for 2020.",
        "output": "import numpy as np\nyears = np.array([2010, 2012, 2014, 2016])\nmpg = np.array([28, 29, 30.5, 32.2])\nX = np.vstack([years, np.ones_like(years)]).T\nparams, *_ = np.linalg.lstsq(X, mpg, rcond=None)\npred = params[0]*2020 + params[1]\nprint(f\"Predicted MPG in 2020: {pred:.2f}\")"
    },
    {
        "input": "An influencer gained followers monthly: [500, 800, 1200, 1600]. Predict the number of followers in month 6.",
        "output": "import numpy as np\nmonths = np.array([1, 2, 3, 4])\nfollowers = np.array([500, 800, 1200, 1600])\nX = np.vstack([months, np.ones_like(months)]).T\nparams, *_ = np.linalg.lstsq(X, followers, rcond=None)\npred = params[0]*6 + params[1]\nprint(f\"Predicted followers in month 6: {pred:.0f}\")"
    },
    {
        "input": "Predict house price in 2025 based on past years: prices = [200, 220, 250, 270] (in $1000s), years = [2018, 2019, 2020, 2021].",
        "output": "import numpy as np\nyears = np.array([2018, 2019, 2020, 2021])\nprices = np.array([200, 220, 250, 270])\nX = np.vstack([years, np.ones_like(years)]).T\nparams, *_ = np.linalg.lstsq(X, prices, rcond=None)\npred = params[0]*2025 + params[1]\nprint(f\"Predicted house price in 2025: ${pred:.2f}k\")"
    },
    {
        "input": "A podcast tracks weekly listeners: [100, 250, 390, 530]. Estimate number of listeners in week 7.",
        "output": "import numpy as np\nweeks = np.array([1, 2, 3, 4])\nlisteners = np.array([100, 250, 390, 530])\nX = np.vstack([weeks, np.ones_like(weeks)]).T\nparams, *_ = np.linalg.lstsq(X, listeners, rcond=None)\npred = params[0]*7 + params[1]\nprint(f\"Estimated listeners in week 7: {pred:.0f}\")"
    },
    {
        "input": "A stock’s closing prices: [150, 155, 160, 162] over days [1, 2, 3, 4]. Predict day 6 price.",
        "output": "import numpy as np\ndays = np.array([1, 2, 3, 4])\nprices = np.array([150, 155, 160, 162])\nX = np.vstack([days, np.ones_like(days)]).T\nparams, *_ = np.linalg.lstsq(X, prices, rcond=None)\npred = params[0]*6 + params[1]\nprint(f\"Predicted price on day 6: ${pred:.2f}\")"
    },
    {
        "input": "Train delays in minutes across days: [5, 7, 6, 8], days = [1, 2, 3, 4]. Estimate day 6 delay.",
        "output": "import numpy as np\ndays = np.array([1, 2, 3, 4])\ndelays = np.array([5, 7, 6, 8])\nX = np.vstack([days, np.ones_like(days)]).T\nparams, *_ = np.linalg.lstsq(X, delays, rcond=None)\npred = params[0]*6 + params[1]\nprint(f\"Estimated delay on day 6: {pred:.2f} minutes\")"
    },
    {
        "input": "Monthly rainfall (in mm): [70, 90, 110, 130]. Predict value for month 6.",
        "output": "import numpy as np\nmonths = np.array([1, 2, 3, 4])\nrainfall = np.array([70, 90, 110, 130])\nX = np.vstack([months, np.ones_like(months)]).T\nparams, *_ = np.linalg.lstsq(X, rainfall, rcond=None)\npred = params[0]*6 + params[1]\nprint(f\"Predicted rainfall in month 6: {pred:.2f} mm\")"
    },
    {
        "input": "Fit a least squares line to x = [1, 2, 3], y = [2, 3, 5], and compute the residuals.",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([2, 3, 5])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nresiduals = y - y_pred\nprint(\"Residuals:\", residuals)"
    },
    {
        "input": "Given x = [1, 2, 3, 4], y = [1.2, 1.9, 3.0, 4.1], fit a model and compute the Mean Squared Error.",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([1.2, 1.9, 3.0, 4.1])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nmse = np.mean((y - y_pred)**2)\nprint(f\"Mean Squared Error: {mse:.4f}\")"
    },
    {
        "input": "Compute R-squared for the model fit to x = [0, 1, 2, 3], y = [1, 2, 1.3, 3.75].",
        "output": "import numpy as np\nx = np.array([0, 1, 2, 3])\ny = np.array([1, 2, 1.3, 3.75])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nss_res = np.sum((y - y_pred)**2)\nss_tot = np.sum((y - np.mean(y))**2)\nr2 = 1 - ss_res/ss_tot\nprint(f\"R-squared: {r2:.4f}\")"
    },
    {
        "input": "Find residuals of the model fit to x = [1, 2, 3], y = [3, 6, 7].",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([3, 6, 7])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nresiduals = y - y_pred\nprint(\"Residuals:\", residuals)"
    },
    {
        "input": "Use x = [0, 1, 2, 3], y = [1, 2, 2, 3] to fit a model. Report slope, intercept, and MSE.",
        "output": "import numpy as np\nx = np.array([0, 1, 2, 3])\ny = np.array([1, 2, 2, 3])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nmse = np.mean((y - y_pred)**2)\nprint(f\"Slope: {params[0]:.2f}, Intercept: {params[1]:.2f}, MSE: {mse:.4f}\")"
    },
    {
        "input": "Use least squares to model y = [2, 4, 6, 8] from x = [1, 2, 3, 4]. Compute the residual sum of squares.",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([2, 4, 6, 8])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nrss = np.sum((y - y_pred)**2)\nprint(f\"Residual Sum of Squares: {rss:.4f}\")"
    },
    {
        "input": "Evaluate the fit of y = [5, 7, 9, 11] from x = [1, 2, 3, 4] using R².",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([5, 7, 9, 11])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nss_res = np.sum((y - y_pred)**2)\nss_tot = np.sum((y - np.mean(y))**2)\nr2 = 1 - ss_res/ss_tot\nprint(f\"R-squared: {r2:.4f}\")"
    },
    {
        "input": "Given a model fit to 5 points, calculate residual variance.",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4, 5])\ny = np.array([2.1, 4.1, 6.2, 8.3, 10.5])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nresiduals = y - y_pred\nvar_res = np.var(residuals)\nprint(f\"Residual Variance: {var_res:.4f}\")"
    },
    {
        "input": "For x = [0, 1, 2], y = [1, 2.2, 3.8], calculate R² and residuals.",
        "output": "import numpy as np\nx = np.array([0, 1, 2])\ny = np.array([1, 2.2, 3.8])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nresiduals = y - y_pred\nss_res = np.sum(residuals**2)\nss_tot = np.sum((y - np.mean(y))**2)\nr2 = 1 - ss_res/ss_tot\nprint(\"Residuals:\", residuals)\nprint(f\"R-squared: {r2:.4f}\")"
    },
    {
        "input": "Fit a model to x = [1, 2, 3], y = [2, 4, 5] and calculate residuals.",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([2, 4, 5])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nresiduals = y - y_pred\nprint(\"Residuals:\", residuals)"
    },
    {
        "input": "Compute Mean Squared Error for x = [1, 2, 3, 4], y = [2, 2.9, 4.1, 5].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([2, 2.9, 4.1, 5])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nmse = np.mean((y - y_pred)**2)\nprint(f\"Mean Squared Error: {mse:.4f}\")"
    },
    {
        "input": "Given x = [1, 3, 5], y = [2, 4.5, 6.1], compute R² for the model.",
        "output": "import numpy as np\nx = np.array([1, 3, 5])\ny = np.array([2, 4.5, 6.1])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nss_res = np.sum((y - y_pred)**2)\nss_tot = np.sum((y - np.mean(y))**2)\nr2 = 1 - ss_res / ss_tot\nprint(f\"R-squared: {r2:.4f}\")"
    },
    {
        "input": "Fit a linear model and print RSS using x = [2, 4, 6], y = [3, 7, 10].",
        "output": "import numpy as np\nx = np.array([2, 4, 6])\ny = np.array([3, 7, 10])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nrss = np.sum((y - y_pred)**2)\nprint(f\"Residual Sum of Squares: {rss:.4f}\")"
    },
    {
        "input": "Use x = [0, 1, 2, 3], y = [1, 1.8, 3.1, 4.2] to calculate residuals and R².",
        "output": "import numpy as np\nx = np.array([0, 1, 2, 3])\ny = np.array([1, 1.8, 3.1, 4.2])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nresiduals = y - y_pred\nr2 = 1 - np.sum(residuals**2) / np.sum((y - np.mean(y))**2)\nprint(\"Residuals:\", residuals)\nprint(f\"R-squared: {r2:.4f}\")"
    },
    {
        "input": "Fit a model to x = [1, 2, 3, 4, 5], y = [2.2, 3.9, 6.1, 8, 10.1] and print slope and R².",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4, 5])\ny = np.array([2.2, 3.9, 6.1, 8, 10.1])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nss_res = np.sum((y - y_pred)**2)\nss_tot = np.sum((y - np.mean(y))**2)\nr2 = 1 - ss_res / ss_tot\nprint(f\"Slope: {params[0]:.4f}, Intercept: {params[1]:.4f}, R²: {r2:.4f}\")"
    },
    {
        "input": "Check residual variance for x = [1, 2, 3], y = [2.5, 5.1, 7.4].",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([2.5, 5.1, 7.4])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nvar_res = np.var(y - y_pred)\nprint(f\"Residual Variance: {var_res:.4f}\")"
    },
    {
        "input": "Evaluate model fit with x = [0, 1, 2, 3, 4], y = [1.2, 2.1, 3.8, 3.9, 5.1] using MSE and R².",
        "output": "import numpy as np\nx = np.array([0, 1, 2, 3, 4])\ny = np.array([1.2, 2.1, 3.8, 3.9, 5.1])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nmse = np.mean((y - y_pred)**2)\nr2 = 1 - np.sum((y - y_pred)**2) / np.sum((y - np.mean(y))**2)\nprint(f\"MSE: {mse:.4f}, R²: {r2:.4f}\")"
    },
    {
        "input": "Fit a least squares model and report all residuals for x = [10, 20, 30], y = [15, 28, 41].",
        "output": "import numpy as np\nx = np.array([10, 20, 30])\ny = np.array([15, 28, 41])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nresiduals = y - y_pred\nprint(\"Residuals:\", residuals)"
    },
    {
        "input": "Fit a linear model and calculate residuals for x = [2, 4, 6, 8], y = [3, 7, 10, 15].",
        "output": "import numpy as np\nx = np.array([2, 4, 6, 8])\ny = np.array([3, 7, 10, 15])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nresiduals = y - y_pred\nprint(\"Residuals:\", residuals)"
    },
    {
        "input": "Compute RSS for the model: x = [1, 2, 3], y = [2.5, 4.5, 6.8].",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([2.5, 4.5, 6.8])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nrss = np.sum((y - y_pred) ** 2)\nprint(f\"RSS: {rss:.4f}\")"
    },
    {
        "input": "Using x = [2, 4, 6], y = [5, 9, 13], calculate the model's R².",
        "output": "import numpy as np\nx = np.array([2, 4, 6])\ny = np.array([5, 9, 13])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nss_res = np.sum((y - y_pred)**2)\nss_tot = np.sum((y - np.mean(y))**2)\nr2 = 1 - ss_res / ss_tot\nprint(f\"R²: {r2:.4f}\")"
    },
    {
        "input": "Given noisy data x = [1, 2, 3], y = [2.1, 4.2, 5.8], assess MSE.",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([2.1, 4.2, 5.8])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nmse = np.mean((y - y_pred)**2)\nprint(f\"MSE: {mse:.4f}\")"
    },
    {
        "input": "Evaluate how well the model fits x = [1, 2, 3, 4], y = [2, 3.8, 6.2, 8.1]. Use RSS and R².",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([2, 3.8, 6.2, 8.1])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nrss = np.sum((y - y_pred) ** 2)\nss_tot = np.sum((y - np.mean(y)) ** 2)\nr2 = 1 - rss / ss_tot\nprint(f\"RSS: {rss:.4f}, R²: {r2:.4f}\")"
    },
    {
        "input": "Check residual spread using x = [5, 10, 15], y = [10, 21, 29].",
        "output": "import numpy as np\nx = np.array([5, 10, 15])\ny = np.array([10, 21, 29])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nresiduals = y - y_pred\nprint(\"Residual Spread:\", residuals)\nprint(\"Standard deviation:\", np.std(residuals))"
    },
    {
        "input": "Using x = [0, 1, 2, 3, 4], y = [1, 2.1, 4.3, 6.1, 8], evaluate MSE and model accuracy.",
        "output": "import numpy as np\nx = np.array([0, 1, 2, 3, 4])\ny = np.array([1, 2.1, 4.3, 6.1, 8])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nmse = np.mean((y - y_pred)**2)\nprint(f\"MSE: {mse:.4f}\")"
    },
    {
        "input": "Determine R² of linear fit for x = [3, 6, 9], y = [2.5, 6, 9.2].",
        "output": "import numpy as np\nx = np.array([3, 6, 9])\ny = np.array([2.5, 6, 9.2])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nss_res = np.sum((y - y_pred)**2)\nss_tot = np.sum((y - np.mean(y))**2)\nr2 = 1 - ss_res / ss_tot\nprint(f\"R²: {r2:.4f}\")"
    },
    {
        "input": "Using x = [1, 4, 6], y = [2, 6.1, 9.9], print both MSE and RSS.",
        "output": "import numpy as np\nx = np.array([1, 4, 6])\ny = np.array([2, 6.1, 9.9])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nresiduals = y - y_pred\nrss = np.sum(residuals**2)\nmse = np.mean(residuals**2)\nprint(f\"RSS: {rss:.4f}, MSE: {mse:.4f}\")"
    },
    {
        "input": "Using x = [1, 2, 3], y = [3, 6.2, 9.1], check if R² is close to 1.",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([3, 6.2, 9.1])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nss_res = np.sum((y - y_pred) ** 2)\nss_tot = np.sum((y - np.mean(y)) ** 2)\nr2 = 1 - ss_res / ss_tot\nprint(f\"R²: {r2:.4f}\")"
    },
    {
        "input": "Model x = [0, 2, 4, 6], y = [0.1, 4.2, 8.1, 12] and calculate residuals and their mean.",
        "output": "import numpy as np\nx = np.array([0, 2, 4, 6])\ny = np.array([0.1, 4.2, 8.1, 12])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nresiduals = y - y_pred\nprint(\"Residuals:\", residuals)\nprint(\"Mean of residuals:\", np.mean(residuals))"
    },
    {
        "input": "Given X = [[1, 2], [2, 3], [3, 5]], y = [1, 2, 2], find the least squares solution.",
        "output": "import numpy as np\nX = np.array([[1, 2], [2, 3], [3, 5]])\ny = np.array([1, 2, 2])\nX_aug = np.hstack([X, np.ones((X.shape[0], 1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(\"Parameters:\", params)"
    },
    {
        "input": "Fit a polynomial of degree 2 to x = [0, 1, 2], y = [1, 2, 5] using least squares.",
        "output": "import numpy as np\nx = np.array([0, 1, 2])\ny = np.array([1, 2, 5])\nX = np.vstack([x**2, x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(\"Quadratic coefficients:\", params)"
    },
    {
        "input": "Given x = [1, 2, 3, 4], y = [2.1, 3.9, 6.2, 8.1], compute RSS.",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([2.1, 3.9, 6.2, 8.1])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nrss = np.sum((y - y_pred) ** 2)\nprint(\"RSS:\", rss)"
    },
    {
        "input": "Fit model and compute mean residual for x = [0, 1, 2], y = [1, 2, 3.1].",
        "output": "import numpy as np\nx = np.array([0, 1, 2])\ny = np.array([1, 2, 3.1])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nresiduals = y - (X @ params)\nprint(\"Mean Residual:\", np.mean(residuals))"
    },
    {
        "input": "Compute projection of y onto col space of X = [[1], [1], [1]], y = [2, 3, 5].",
        "output": "import numpy as np\nX = np.ones((3, 1))\ny = np.array([2, 3, 5])\nproj = X @ np.linalg.pinv(X) @ y\nprint(\"Projection of y:\", proj)"
    },
    {
        "input": "Given X = [[1, 2], [1, 2], [1, 2]], y = [5, 5, 5], show the rank deficiency.",
        "output": "import numpy as np\nX = np.array([[1, 2], [1, 2], [1, 2]])\nrank = np.linalg.matrix_rank(X)\nprint(\"Rank of X:\", rank)"
    },
    {
        "input": "Use np.polyfit to fit a line to x = [1, 2, 3], y = [2, 4, 6] and compare with lstsq.",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([2, 4, 6])\ncoef_polyfit = np.polyfit(x, y, 1)\nX = np.vstack([x, np.ones_like(x)]).T\ncoef_lstsq, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(\"Polyfit:\", coef_polyfit)\nprint(\"Lstsq:\", coef_lstsq)"
    },
    {
        "input": "Explain geometrically why residual is orthogonal to column space of X.",
        "output": "import numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([1, 2, 2.5])\nX_aug = np.hstack([X, np.ones((3,1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\ny_pred = X_aug @ params\nresidual = y - y_pred\nproj = X_aug.T @ residual\nprint(\"X.T @ residual:\", proj)"
    },
    {
        "input": "Compare residual norms of two models: fit y = [2, 4, 6] to x = [1, 2, 3] and x².",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([2, 4, 6])\nX1 = np.vstack([x, np.ones_like(x)]).T\nX2 = np.vstack([x**2, np.ones_like(x)]).T\nparams1, *_ = np.linalg.lstsq(X1, y, rcond=None)\nparams2, *_ = np.linalg.lstsq(X2, y, rcond=None)\nres1 = y - X1 @ params1\nres2 = y - X2 @ params2\nprint(\"Norm Linear:\", np.linalg.norm(res1))\nprint(\"Norm Quad:\", np.linalg.norm(res2))"
    },
    {
        "input": "Fit x = [0, 1, 2, 3], y = [1, 3, 7, 13] to a quadratic model and show coefficients.",
        "output": "import numpy as np\nx = np.array([0, 1, 2, 3])\ny = np.array([1, 3, 7, 13])\nX = np.vstack([x**2, x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(\"Coefficients a, b, c:\", params)"
    },
    {
        "input": "Explain how least squares helps when system is overdetermined using x = [1, 2, 3], y = [2, 3, 4].",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([2, 3, 4])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(\"Best fit line:\", params)"
    },
    {
        "input": "Simulate noisy data and fit a model: x = [1, 2, 3, 4], y = [2.1, 4.2, 6.1, 8.2].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([2.1, 4.2, 6.1, 8.2])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(\"Fitted model:\", params)"
    },
    {
        "input": "Estimate regression line for random integers between 1 and 10.",
        "output": "import numpy as np\nnp.random.seed(0)\nx = np.random.randint(1, 10, size=10)\ny = 2 * x + 3 + np.random.randn(10)\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(\"Estimated model:\", params)"
    },
    {
        "input": "Check if matrix X = [[1, 0], [0, 1], [1, 1]] is full rank.",
        "output": "import numpy as np\nX = np.array([[1, 0], [0, 1], [1, 1]])\nrank = np.linalg.matrix_rank(X)\nprint(\"Rank of X:\", rank)"
    },
    {
        "input": "Use normal equations to solve X = [[1,2],[2,1],[3,3]], y = [5,6,7].",
        "output": "import numpy as np\nX = np.array([[1,2],[2,1],[3,3]])\ny = np.array([5,6,7])\nparams = np.linalg.inv(X.T @ X) @ X.T @ y\nprint(\"Normal eq solution:\", params)"
    },
    {
        "input": "Compute R² and RSS for noisy fit: x = [1, 2, 3], y = [2.1, 4.1, 6.1].",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([2.1, 4.1, 6.1])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\ny_pred = X @ params\nrss = np.sum((y - y_pred)**2)\nr2 = 1 - rss / np.sum((y - np.mean(y))**2)\nprint(f\"RSS: {rss:.4f}, R²: {r2:.4f}\")"
    },
    {
        "input": "Perform ridge regression to fit y = Xβ with λ = 0.1. X = [[1, 2], [2, 3], [3, 4]], y = [6, 8, 10].",
        "output": "import numpy as np\nX = np.array([[1, 2], [2, 3], [3, 4]])\ny = np.array([6, 8, 10])\nlmbda = 0.1\nX_aug = np.hstack([X, np.ones((X.shape[0], 1))])\nI = np.eye(X_aug.shape[1])\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Ridge Regression Coefficients: {params}\")"
    },
    {
        "input": "Apply ridge regression on data: X = [[1], [2], [3], [4]], y = [2.1, 4.1, 6.2, 8.2] with λ=1.",
        "output": "import numpy as np\nX = np.array([[1], [2], [3], [4]])\ny = np.array([2.1, 4.1, 6.2, 8.2])\nlmbda = 1\nX_aug = np.hstack([X, np.ones((X.shape[0], 1))])\nI = np.eye(X_aug.shape[1])\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Coefficients with Ridge: {params}\")"
    },
    {
        "input": "Estimate parameters using regularized least squares with λ=0.5. X = [[1,0],[0,1],[1,1]], y = [1,1,2].",
        "output": "import numpy as np\nX = np.array([[1,0],[0,1],[1,1]])\ny = np.array([1,1,2])\nlmbda = 0.5\nX_aug = np.hstack([X, np.ones((X.shape[0], 1))])\nI = np.eye(X_aug.shape[1])\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Regularized Coefficients: {params}\")"
    },
    {
        "input": "Use ridge regression on noisy linear data: X = [[1],[2],[3],[4]], y = [2.05, 4.02, 6.1, 7.95], λ=0.2.",
        "output": "import numpy as np\nX = np.array([[1],[2],[3],[4]])\ny = np.array([2.05, 4.02, 6.1, 7.95])\nlmbda = 0.2\nX_aug = np.hstack([X, np.ones((X.shape[0], 1))])\nI = np.eye(X_aug.shape[1])\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Ridge Fit Parameters: {params}\")"
    },
    {
        "input": "Fit a ridge regression line through X = [[5],[10],[15],[20]], y = [2, 4, 6, 8] with λ=0.3.",
        "output": "import numpy as np\nX = np.array([[5],[10],[15],[20]])\ny = np.array([2, 4, 6, 8])\nlmbda = 0.3\nX_aug = np.hstack([X, np.ones((4,1))])\nI = np.eye(X_aug.shape[1])\nI[-1,-1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Ridge Parameters: {params}\")"
    },
    {
        "input": "Fit a ridge regression model where X = [[1, 2], [3, 4], [5, 6]] and y = [5, 11, 17] with λ=0.4.",
        "output": "import numpy as np\nX = np.array([[1, 2], [3, 4], [5, 6]])\ny = np.array([5, 11, 17])\nlmbda = 0.4\nX_aug = np.hstack([X, np.ones((3, 1))])\nI = np.eye(3)\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Ridge Regression Coefficients: {params}\")"
    },
    {
        "input": "Apply regularization to a multivariate regression problem. X = [[1, 0], [0, 1], [1, 1]], y = [3, 3, 6], λ=0.2.",
        "output": "import numpy as np\nX = np.array([[1, 0], [0, 1], [1, 1]])\ny = np.array([3, 3, 6])\nlmbda = 0.2\nX_aug = np.hstack([X, np.ones((3, 1))])\nI = np.eye(3)\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Regularized Parameters: {params}\")"
    },
    {
        "input": "Use ridge regression with λ=1 on X = [[2],[4],[6]], y = [3, 7, 11].",
        "output": "import numpy as np\nX = np.array([[2],[4],[6]])\ny = np.array([3, 7, 11])\nlmbda = 1\nX_aug = np.hstack([X, np.ones((3,1))])\nI = np.eye(2)\nI[-1,-1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Ridge Fit Coefficients: {params}\")"
    },
    {
        "input": "Fit ridge regression on high-dimensional data: X = [[1,2,3,4], [2,3,4,5], [3,4,5,6]], y = [10, 14, 18], λ=0.3.",
        "output": "import numpy as np\nX = np.array([[1,2,3,4], [2,3,4,5], [3,4,5,6]])\ny = np.array([10, 14, 18])\nlmbda = 0.3\nX_aug = np.hstack([X, np.ones((3,1))])\nI = np.eye(X_aug.shape[1])\nI[-1,-1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Coefficients with Regularization: {params}\")"
    },
    {
        "input": "Implement ridge regression with bias term excluded from regularization. X = [[1],[2],[3]], y = [1,2,3], λ=5.",
        "output": "import numpy as np\nX = np.array([[1],[2],[3]])\ny = np.array([1,2,3])\nlmbda = 5\nX_aug = np.hstack([X, np.ones((3,1))])\nI = np.eye(2)\nI[-1,-1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda*I) @ X_aug.T @ y\nprint(f\"Ridge Coefficients: {params}\")"
    },
    {
        "input": "Perform ridge regression on data with slight multicollinearity. X = [[1, 2], [2, 4.1], [3, 6.2]], y = [1, 2, 3], λ=0.5.",
        "output": "import numpy as np\nX = np.array([[1, 2], [2, 4.1], [3, 6.2]])\ny = np.array([1, 2, 3])\nlmbda = 0.5\nX_aug = np.hstack([X, np.ones((3,1))])\nI = np.eye(3)\nI[-1,-1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda*I) @ X_aug.T @ y\nprint(f\"Ridge Regression Weights: {params}\")"
    },
    {
        "input": "Use ridge regression to prevent overfitting on X = [[1,1],[2,4],[3,9]], y = [2, 3, 6], λ=1.5.",
        "output": "import numpy as np\nX = np.array([[1,1],[2,4],[3,9]])\ny = np.array([2,3,6])\nlmbda = 1.5\nX_aug = np.hstack([X, np.ones((3,1))])\nI = np.eye(3)\nI[-1,-1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda*I) @ X_aug.T @ y\nprint(f\"Regularized Coefficients: {params}\")"
    },
    {
        "input": "Fit a ridge regression model on polynomial features. X = [[1,1], [2,4], [3,9]], y = [3,6,9], λ=0.7.",
        "output": "import numpy as np\nX = np.array([[1,1], [2,4], [3,9]])\ny = np.array([3,6,9])\nlmbda = 0.7\nX_aug = np.hstack([X, np.ones((3,1))])\nI = np.eye(3)\nI[-1,-1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda*I) @ X_aug.T @ y\nprint(f\"Ridge Fit Output: {params}\")"
    },
    {
        "input": "Train a regularized linear model with λ=2. X = [[0,1],[1,0],[1,1]], y = [1,2,3].",
        "output": "import numpy as np\nX = np.array([[0,1],[1,0],[1,1]])\ny = np.array([1,2,3])\nlmbda = 2\nX_aug = np.hstack([X, np.ones((3,1))])\nI = np.eye(3)\nI[-1,-1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda*I) @ X_aug.T @ y\nprint(f\"Ridge Regression Solution: {params}\")"
    },
    {
        "input": "Use ridge regression for stability in high-dimensional model. X = [[1,2,3], [4,5,6], [7,8,9]], y = [6,15,24], λ=0.6.",
        "output": "import numpy as np\nX = np.array([[1,2,3], [4,5,6], [7,8,9]])\ny = np.array([6,15,24])\nlmbda = 0.6\nX_aug = np.hstack([X, np.ones((3,1))])\nI = np.eye(4)\nI[-1,-1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda*I) @ X_aug.T @ y\nprint(f\"Ridge Coefficients: {params}\")"
    },
    {
        "input": "Apply ridge regression to a small dataset. X = [[1], [2], [3]], y = [2, 4, 6], λ=0.1.",
        "output": "import numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([2, 4, 6])\nlmbda = 0.1\nX_aug = np.hstack([X, np.ones((3, 1))])\nI = np.eye(2)\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Ridge Regression Parameters: {params}\")"
    },
    {
        "input": "Perform ridge regression where X = [[0, 1], [1, 0], [1, 1]], y = [1, 2, 3], λ=0.2.",
        "output": "import numpy as np\nX = np.array([[0, 1], [1, 0], [1, 1]])\ny = np.array([1, 2, 3])\nlmbda = 0.2\nX_aug = np.hstack([X, np.ones((3, 1))])\nI = np.eye(3)\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Ridge Regression Output: {params}\")"
    },
    {
        "input": "Fit a regularized linear model. X = [[1, 2], [2, 4], [3, 6]], y = [5, 10, 15], λ=1.0.",
        "output": "import numpy as np\nX = np.array([[1, 2], [2, 4], [3, 6]])\ny = np.array([5, 10, 15])\nlmbda = 1.0\nX_aug = np.hstack([X, np.ones((3, 1))])\nI = np.eye(3)\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Regularized Coefficients: {params}\")"
    },
    {
        "input": "Use ridge regression on polynomial features. X = [[1, 1], [2, 4], [3, 9]], y = [2, 4, 6], λ=0.5.",
        "output": "import numpy as np\nX = np.array([[1, 1], [2, 4], [3, 9]])\ny = np.array([2, 4, 6])\nlmbda = 0.5\nX_aug = np.hstack([X, np.ones((3, 1))])\nI = np.eye(3)\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Ridge Regression Fit: {params}\")"
    },
    {
        "input": "Train a ridge model with X = [[1, 3], [2, 5], [3, 7]], y = [4, 9, 14], λ=0.3.",
        "output": "import numpy as np\nX = np.array([[1, 3], [2, 5], [3, 7]])\ny = np.array([4, 9, 14])\nlmbda = 0.3\nX_aug = np.hstack([X, np.ones((3, 1))])\nI = np.eye(3)\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Fitted Ridge Model: {params}\")"
    },
    {
        "input": "Perform ridge regression with X = [[5, 1], [6, 2], [7, 3]], y = [12, 14, 16], λ=0.7.",
        "output": "import numpy as np\nX = np.array([[5, 1], [6, 2], [7, 3]])\ny = np.array([12, 14, 16])\nlmbda = 0.7\nX_aug = np.hstack([X, np.ones((3, 1))])\nI = np.eye(3)\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Ridge Output Parameters: {params}\")"
    },
    {
        "input": "Regularize the fit to X = [[1], [2], [3], [4]], y = [3, 5, 7, 9], λ=0.2.",
        "output": "import numpy as np\nX = np.array([[1], [2], [3], [4]])\ny = np.array([3, 5, 7, 9])\nlmbda = 0.2\nX_aug = np.hstack([X, np.ones((4, 1))])\nI = np.eye(2)\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Regularized Fit Coefficients: {params}\")"
    },
    {
        "input": "Use ridge regression with X = [[1, 4], [2, 5], [3, 6]], y = [7, 8, 9], λ=0.05.",
        "output": "import numpy as np\nX = np.array([[1, 4], [2, 5], [3, 6]])\ny = np.array([7, 8, 9])\nlmbda = 0.05\nX_aug = np.hstack([X, np.ones((3, 1))])\nI = np.eye(3)\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Ridge Regression Coefficients: {params}\")"
    },
    {
        "input": "Apply ridge regression on X = [[1, 0], [2, 1], [3, 2], [4, 3]], y = [2, 4, 6, 8], λ=0.4.",
        "output": "import numpy as np\nX = np.array([[1, 0], [2, 1], [3, 2], [4, 3]])\ny = np.array([2, 4, 6, 8])\nlmbda = 0.4\nX_aug = np.hstack([X, np.ones((4, 1))])\nI = np.eye(3)\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Fitted Ridge Parameters: {params}\")"
    },
    {
        "input": "Use ridge regression with moderate regularization. X = [[2, 3], [3, 5], [4, 7]], y = [10, 15, 20], λ=0.9.",
        "output": "import numpy as np\nX = np.array([[2, 3], [3, 5], [4, 7]])\ny = np.array([10, 15, 20])\nlmbda = 0.9\nX_aug = np.hstack([X, np.ones((3, 1))])\nI = np.eye(3)\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lmbda * I) @ X_aug.T @ y\nprint(f\"Regularized Linear Fit: {params}\")"
    },
    {
        "input": "Fit a quadratic polynomial to X = [0, 1, 2], y = [1, 2, 5].",
        "output": "import numpy as np\nX = np.array([0, 1, 2])\ny = np.array([1, 2, 5])\nX_poly = np.vstack([X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Fitted Quadratic: y = {params[0]:.4f}x^2 + {params[1]:.4f}x + {params[2]:.4f}\")"
    },
    {
        "input": "Fit a cubic polynomial through X = [-1, 0, 1, 2], y = [2, 0, 2, 10].",
        "output": "import numpy as np\nX = np.array([-1, 0, 1, 2])\ny = np.array([2, 0, 2, 10])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Fitted Cubic: y = {params[0]:.4f}x^3 + {params[1]:.4f}x^2 + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a degree-2 polynomial to noisy quadratic data X = [1, 2, 3, 4], y = [2.1, 3.9, 9.2, 15.8].",
        "output": "import numpy as np\nX = np.array([1, 2, 3, 4])\ny = np.array([2.1, 3.9, 9.2, 15.8])\nX_poly = np.vstack([X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Quadratic Fit: y = {params[0]:.4f}x^2 + {params[1]:.4f}x + {params[2]:.4f}\")"
    },
    {
        "input": "Fit a degree-1 polynomial to linearly increasing data X = [2, 4, 6], y = [5, 9, 13].",
        "output": "import numpy as np\nX = np.array([2, 4, 6])\ny = np.array([5, 9, 13])\nX_poly = np.vstack([X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Linear Fit: y = {params[0]:.4f}x + {params[1]:.4f}\")"
    },
    {
        "input": "Use degree-3 polynomial on X = [0, 1, 2, 3], y = [1, 8, 27, 64].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3])\ny = np.array([1, 8, 27, 64])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Cubic Polynomial Fit: y = {params[0]:.4f}x^3 + {params[1]:.4f}x^2 + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a degree-4 polynomial to X = [-2, -1, 0, 1, 2], y = [16, 1, 0, 1, 16].",
        "output": "import numpy as np\nX = np.array([-2, -1, 0, 1, 2])\ny = np.array([16, 1, 0, 1, 16])\nX_poly = np.vstack([X**4, X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Degree-4 Polynomial: y = {params[0]:.4f}x^4 + {params[1]:.4f}x^3 + {params[2]:.4f}x^2 + {params[3]:.4f}x + {params[4]:.4f}\")"
    },
    {
        "input": "Fit quadratic curve through X = [1, 2, 3, 4], y = [3, 7, 13, 21].",
        "output": "import numpy as np\nX = np.array([1, 2, 3, 4])\ny = np.array([3, 7, 13, 21])\nX_poly = np.vstack([X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Fitted Quadratic Curve: y = {params[0]:.4f}x^2 + {params[1]:.4f}x + {params[2]:.4f}\")"
    },
    {
        "input": "Fit a degree-2 polynomial on X = [0, 2, 4], y = [1, 3, 9].",
        "output": "import numpy as np\nX = np.array([0, 2, 4])\ny = np.array([1, 3, 9])\nX_poly = np.vstack([X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Quadratic Fit: y = {params[0]:.4f}x^2 + {params[1]:.4f}x + {params[2]:.4f}\")"
    },
    {
        "input": "Use degree-3 fit for sinusoidal-like data. X = [0, 1, 2, 3], y = [0, 1, 0, -1].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3])\ny = np.array([0, 1, 0, -1])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Cubic Polynomial Approximation: y = {params[0]:.4f}x^3 + {params[1]:.4f}x^2 + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a quadratic polynomial to approximate exponential-like data X = [1, 2, 3], y = [2.7, 7.4, 20.1].",
        "output": "import numpy as np\nX = np.array([1, 2, 3])\ny = np.array([2.7, 7.4, 20.1])\nX_poly = np.vstack([X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Quadratic Approximation: y = {params[0]:.4f}x^2 + {params[1]:.4f}x + {params[2]:.4f}\")"
    },
    {
        "input": "Fit linear and quadratic models and compare. X = [0, 1, 2, 3], y = [1, 2, 5, 10].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3])\ny = np.array([1, 2, 5, 10])\nX_lin = np.vstack([X, np.ones_like(X)]).T\nX_quad = np.vstack([X**2, X, np.ones_like(X)]).T\nparams_lin, *_ = np.linalg.lstsq(X_lin, y, rcond=None)\nparams_quad, *_ = np.linalg.lstsq(X_quad, y, rcond=None)\nprint(f\"Linear: y = {params_lin[0]:.4f}x + {params_lin[1]:.4f}\")\nprint(f\"Quadratic: y = {params_quad[0]:.4f}x^2 + {params_quad[1]:.4f}x + {params_quad[2]:.4f}\")"
    },
    {
        "input": "Fit polynomial of degree 3 to X = [1, 2, 3, 4], y = [2, 6, 14, 30].",
        "output": "import numpy as np\nX = np.array([1, 2, 3, 4])\ny = np.array([2, 6, 14, 30])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Cubic Fit: y = {params[0]:.4f}x^3 + {params[1]:.4f}x^2 + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a degree-3 polynomial to estimate a sequence X = [1, 2, 3, 4], y = [3, 7, 13, 21].",
        "output": "import numpy as np\nX = np.array([1, 2, 3, 4])\ny = np.array([3, 7, 13, 21])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Fitted Cubic Model: y = {params[0]:.4f}x^3 + {params[1]:.4f}x^2 + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a degree-2 polynomial to X = [-2, -1, 0, 1, 2], y = [7, 2, 1, 2, 7].",
        "output": "import numpy as np\nX = np.array([-2, -1, 0, 1, 2])\ny = np.array([7, 2, 1, 2, 7])\nX_poly = np.vstack([X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Fitted Quadratic: y = {params[0]:.4f}x^2 + {params[1]:.4f}x + {params[2]:.4f}\")"
    },
    {
        "input": "Fit a polynomial of degree 4 to X = [0, 1, 2, 3, 4], y = [1, 2, 1, 2, 1].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3, 4])\ny = np.array([1, 2, 1, 2, 1])\nX_poly = np.vstack([X**4, X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Degree-4 Fit: y = {params[0]:.4f}x^4 + {params[1]:.4f}x^3 + {params[2]:.4f}x^2 + {params[3]:.4f}x + {params[4]:.4f}\")"
    },
    {
        "input": "Fit linear and quadratic models to noisy data. X = [1, 2, 3, 4], y = [3.1, 5.9, 9.0, 13.2].",
        "output": "import numpy as np\nX = np.array([1, 2, 3, 4])\ny = np.array([3.1, 5.9, 9.0, 13.2])\nX_lin = np.vstack([X, np.ones_like(X)]).T\nX_quad = np.vstack([X**2, X, np.ones_like(X)]).T\nparams_lin, *_ = np.linalg.lstsq(X_lin, y, rcond=None)\nparams_quad, *_ = np.linalg.lstsq(X_quad, y, rcond=None)\nprint(f\"Linear: y = {params_lin[0]:.4f}x + {params_lin[1]:.4f}\")\nprint(f\"Quadratic: y = {params_quad[0]:.4f}x^2 + {params_quad[1]:.4f}x + {params_quad[2]:.4f}\")"
    },
    {
        "input": "Fit a cubic model to oscillating data: X = [0, 1, 2, 3, 4], y = [1, 0, 1, 0, 1].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3, 4])\ny = np.array([1, 0, 1, 0, 1])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Cubic Approximation: y = {params[0]:.4f}x^3 + {params[1]:.4f}x^2 + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Estimate curve using polynomial of degree 2: X = [2, 4, 6, 8], y = [1, 2, 1, 2].",
        "output": "import numpy as np\nX = np.array([2, 4, 6, 8])\ny = np.array([1, 2, 1, 2])\nX_poly = np.vstack([X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Quadratic Estimate: y = {params[0]:.4f}x^2 + {params[1]:.4f}x + {params[2]:.4f}\")"
    },
    {
        "input": "Fit a degree-5 polynomial to noisy periodic pattern X = [0, 1, 2, 3, 4, 5], y = [0, 1, 0, -1, 0, 1].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3, 4, 5])\ny = np.array([0, 1, 0, -1, 0, 1])\nX_poly = np.vstack([X**5, X**4, X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Degree-5 Fit: y = {params[0]:.4f}x^5 + {params[1]:.4f}x^4 + {params[2]:.4f}x^3 + {params[3]:.4f}x^2 + {params[4]:.4f}x + {params[5]:.4f}\")"
    },
    {
        "input": "Fit a polynomial of degree 2 to X = [1, 3, 5, 7], y = [1, 4, 9, 16].",
        "output": "import numpy as np\nX = np.array([1, 3, 5, 7])\ny = np.array([1, 4, 9, 16])\nX_poly = np.vstack([X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Quadratic Approximation: y = {params[0]:.4f}x^2 + {params[1]:.4f}x + {params[2]:.4f}\")"
    },
    {
        "input": "Fit cubic polynomial for curve interpolation: X = [-1, 0, 1, 2], y = [4, 1, 0, 1].",
        "output": "import numpy as np\nX = np.array([-1, 0, 1, 2])\ny = np.array([4, 1, 0, 1])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Fitted Cubic Curve: y = {params[0]:.4f}x^3 + {params[1]:.4f}x^2 + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Estimate data trend using degree-3 polynomial: X = [1, 2, 3, 4, 5], y = [2, 6, 14, 30, 62].",
        "output": "import numpy as np\nX = np.array([1, 2, 3, 4, 5])\ny = np.array([2, 6, 14, 30, 62])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Degree-3 Polynomial: y = {params[0]:.4f}x^3 + {params[1]:.4f}x^2 + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a linear model to almost-linear data: X = [0, 1, 2, 3], y = [1.1, 2.0, 2.9, 4.1].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3])\ny = np.array([1.1, 2.0, 2.9, 4.1])\nX_poly = np.vstack([X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Linear Approximation: y = {params[0]:.4f}x + {params[1]:.4f}\")"
    },
    {
        "input": "Use degree-3 polynomial to fit descending values. X = [1, 2, 3, 4], y = [8, 3, 0, -1].",
        "output": "import numpy as np\nX = np.array([1, 2, 3, 4])\ny = np.array([8, 3, 0, -1])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Cubic Fit: y = {params[0]:.4f}x^3 + {params[1]:.4f}x^2 + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a degree-2 polynomial to approximate y = 2x² - 3x + 1 using X = [1, 2, 3, 4], y = [0, 3, 10, 21].",
        "output": "import numpy as np\nX = np.array([1, 2, 3, 4])\ny = np.array([0, 3, 10, 21])\nX_poly = np.vstack([X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Fitted Quadratic: y = {params[0]:.4f}x² + {params[1]:.4f}x + {params[2]:.4f}\")"
    },
    {
        "input": "Fit a degree-3 polynomial to noisy cube-like data: X = [0, 1, 2, 3], y = [0.1, 1.1, 7.8, 26.9].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3])\ny = np.array([0.1, 1.1, 7.8, 26.9])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Cubic Fit: y = {params[0]:.4f}x³ + {params[1]:.4f}x² + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a degree-4 polynomial to alternating pattern: X = [0, 1, 2, 3, 4], y = [1, -1, 1, -1, 1].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3, 4])\ny = np.array([1, -1, 1, -1, 1])\nX_poly = np.vstack([X**4, X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Degree-4 Fit: y = {params[0]:.4f}x⁴ + {params[1]:.4f}x³ + {params[2]:.4f}x² + {params[3]:.4f}x + {params[4]:.4f}\")"
    },
    {
        "input": "Fit a polynomial of degree 2 to simulate parabola: X = [-2, -1, 0, 1, 2], y = [4, 1, 0, 1, 4].",
        "output": "import numpy as np\nX = np.array([-2, -1, 0, 1, 2])\ny = np.array([4, 1, 0, 1, 4])\nX_poly = np.vstack([X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Parabolic Fit: y = {params[0]:.4f}x² + {params[1]:.4f}x + {params[2]:.4f}\")"
    },
    {
        "input": "Fit linear and quadratic models to X = [1, 2, 3, 4], y = [2, 5, 10, 17]. Compare them.",
        "output": "import numpy as np\nX = np.array([1, 2, 3, 4])\ny = np.array([2, 5, 10, 17])\nX_lin = np.vstack([X, np.ones_like(X)]).T\nX_quad = np.vstack([X**2, X, np.ones_like(X)]).T\nparams_lin, *_ = np.linalg.lstsq(X_lin, y, rcond=None)\nparams_quad, *_ = np.linalg.lstsq(X_quad, y, rcond=None)\nprint(f\"Linear: y = {params_lin[0]:.4f}x + {params_lin[1]:.4f}\")\nprint(f\"Quadratic: y = {params_quad[0]:.4f}x² + {params_quad[1]:.4f}x + {params_quad[2]:.4f}\")"
    },
    {
        "input": "Fit a cubic polynomial to symmetric pattern X = [-2, -1, 0, 1, 2], y = [-8, -1, 0, 1, 8].",
        "output": "import numpy as np\nX = np.array([-2, -1, 0, 1, 2])\ny = np.array([-8, -1, 0, 1, 8])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Cubic Fit: y = {params[0]:.4f}x³ + {params[1]:.4f}x² + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Estimate curve using degree-3 polynomial: X = [0, 2, 4, 6], y = [1, 4, 15, 40].",
        "output": "import numpy as np\nX = np.array([0, 2, 4, 6])\ny = np.array([1, 4, 15, 40])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Polynomial Fit: y = {params[0]:.4f}x³ + {params[1]:.4f}x² + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a degree-5 polynomial to X = [0, 1, 2, 3, 4, 5], y = [1, 2, 3, 4, 3, 2].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3, 4, 5])\ny = np.array([1, 2, 3, 4, 3, 2])\nX_poly = np.vstack([X**5, X**4, X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Degree-5 Polynomial: y = {params[0]:.4f}x⁵ + {params[1]:.4f}x⁴ + {params[2]:.4f}x³ + {params[3]:.4f}x² + {params[4]:.4f}x + {params[5]:.4f}\")"
    },
    {
        "input": "Fit a degree-2 polynomial to simulate noisy square growth: X = [0, 1, 2, 3], y = [0.1, 1.0, 4.2, 8.9].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3])\ny = np.array([0.1, 1.0, 4.2, 8.9])\nX_poly = np.vstack([X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Noisy Quadratic Fit: y = {params[0]:.4f}x² + {params[1]:.4f}x + {params[2]:.4f}\")"
    },
    {
        "input": "Fit a degree-4 polynomial to model bumpy trend: X = [1, 2, 3, 4, 5], y = [2, 5, 3, 6, 4].",
        "output": "import numpy as np\nX = np.array([1, 2, 3, 4, 5])\ny = np.array([2, 5, 3, 6, 4])\nX_poly = np.vstack([X**4, X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Bumpy Fit: y = {params[0]:.4f}x⁴ + {params[1]:.4f}x³ + {params[2]:.4f}x² + {params[3]:.4f}x + {params[4]:.4f}\")"
    },
    {
        "input": "Fit a degree-2 polynomial to model data: X = [-1, 0, 1, 2], y = [2, 1, 2, 5].",
        "output": "import numpy as np\nX = np.array([-1, 0, 1, 2])\ny = np.array([2, 1, 2, 5])\nX_poly = np.vstack([X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Degree-2 Fit: y = {params[0]:.4f}x² + {params[1]:.4f}x + {params[2]:.4f}\")"
    },
    {
        "input": "Approximate y = sin(x) over [0, π] using a degree-3 polynomial fit on X = [0, π/4, π/2, 3π/4, π].",
        "output": "import numpy as np\nX = np.array([0, np.pi/4, np.pi/2, 3*np.pi/4, np.pi])\ny = np.sin(X)\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Sine Approximation: y = {params[0]:.4f}x³ + {params[1]:.4f}x² + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a polynomial of degree 2 to data: X = [0, 1, 2, 3, 4], y = [1, 2.9, 7.8, 14.9, 24.2].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3, 4])\ny = np.array([1, 2.9, 7.8, 14.9, 24.2])\nX_poly = np.vstack([X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Quadratic Fit: y = {params[0]:.4f}x² + {params[1]:.4f}x + {params[2]:.4f}\")"
    },
    {
        "input": "Fit a 4th-degree polynomial to data with fluctuations: X = [0, 1, 2, 3, 4, 5], y = [1, 3, 2, 4, 3, 5].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3, 4, 5])\ny = np.array([1, 3, 2, 4, 3, 5])\nX_poly = np.vstack([X**4, X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Fluctuating Fit: y = {params[0]:.4f}x⁴ + {params[1]:.4f}x³ + {params[2]:.4f}x² + {params[3]:.4f}x + {params[4]:.4f}\")"
    },
    {
        "input": "Fit a degree-3 polynomial to model trend: X = [-3, -2, -1, 0, 1, 2, 3], y = [-27, -8, -1, 0, 1, 8, 27].",
        "output": "import numpy as np\nX = np.array([-3, -2, -1, 0, 1, 2, 3])\ny = np.array([-27, -8, -1, 0, 1, 8, 27])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Cubic Trend Fit: y = {params[0]:.4f}x³ + {params[1]:.4f}x² + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Model exponential-like growth with a polynomial fit: X = [0, 1, 2, 3], y = [1, 3, 9, 27].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3])\ny = np.array([1, 3, 9, 27])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Approx. Exponential: y = {params[0]:.4f}x³ + {params[1]:.4f}x² + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a polynomial to model the bounce of a ball: X = [0, 1, 2, 3], y = [10, 5, 2.5, 1.25].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3])\ny = np.array([10, 5, 2.5, 1.25])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Bounce Approximation: y = {params[0]:.4f}x³ + {params[1]:.4f}x² + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a degree-3 polynomial to X = [0, 1, 2, 3], y = [1, 0, -1, 0].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3])\ny = np.array([1, 0, -1, 0])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Degree-3 Fit: y = {params[0]:.4f}x³ + {params[1]:.4f}x² + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a polynomial to model sensor drift: X = [0, 1, 2, 3, 4], y = [0.2, 1.1, 2.9, 4.2, 5.9].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3, 4])\ny = np.array([0.2, 1.1, 2.9, 4.2, 5.9])\nX_poly = np.vstack([X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Sensor Drift Model: y = {params[0]:.4f}x² + {params[1]:.4f}x + {params[2]:.4f}\")"
    },
    {
        "input": "Fit a cubic polynomial to noisy cube: X = [0, 1, 2, 3, 4], y = [0, 1.2, 8.1, 27.5, 65].",
        "output": "import numpy as np\nX = np.array([0, 1, 2, 3, 4])\ny = np.array([0, 1.2, 8.1, 27.5, 65])\nX_poly = np.vstack([X**3, X**2, X, np.ones_like(X)]).T\nparams, *_ = np.linalg.lstsq(X_poly, y, rcond=None)\nprint(f\"Cubic Noise Fit: y = {params[0]:.4f}x³ + {params[1]:.4f}x² + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Use Ridge Regression to fit X = [[1], [2], [3]], y = [1, 2, 3] with λ=1.",
        "output": "import numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([1, 2, 3])\nlamb = 1\nX_aug = np.hstack([X, np.ones((3,1))])\nI = np.eye(X_aug.shape[1])\nparams = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\nprint(f\"Ridge Regression Model: y = {params[0]:.4f}x + {params[1]:.4f}\")"
    },
    {
        "input": "Fit regularized linear model to noisy linear data: X = [[1], [2], [3], [4]], y = [2.1, 4.2, 6.3, 8.1], λ=0.5.",
        "output": "import numpy as np\nX = np.array([[1], [2], [3], [4]])\ny = np.array([2.1, 4.2, 6.3, 8.1])\nlamb = 0.5\nX_aug = np.hstack([X, np.ones((4,1))])\nI = np.eye(X_aug.shape[1])\nparams = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\nprint(f\"Ridge Fit: y = {params[0]:.4f}x + {params[1]:.4f}\")"
    },
    {
        "input": "Model X = [[1,2], [2,3], [3,4]], y = [6, 9, 12] using Ridge regression, λ=2.",
        "output": "import numpy as np\nX = np.array([[1,2], [2,3], [3,4]])\ny = np.array([6, 9, 12])\nlamb = 2\nX_aug = np.hstack([X, np.ones((3,1))])\nI = np.eye(X_aug.shape[1])\nparams = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\nprint(f\"Ridge Model: y = {params[0]:.4f}x1 + {params[1]:.4f}x2 + {params[2]:.4f}\")"
    },
    {
        "input": "Fit Ridge Regression for high-dimensional case: X has shape (5, 10), y = [5, 10, 15, 20, 25], λ=0.1.",
        "output": "import numpy as np\nnp.random.seed(0)\nX = np.random.rand(5, 10)\ny = np.array([5, 10, 15, 20, 25])\nlamb = 0.1\nX_aug = np.hstack([X, np.ones((5,1))])\nI = np.eye(X_aug.shape[1])\nparams = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\nprint(\"Ridge Coefficients:\")\nprint(params)"
    },
    {
        "input": "Test how increasing λ affects the fit: X = [[1], [2], [3]], y = [1, 2, 3], λ = 0.01 and 100.",
        "output": "import numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([1, 2, 3])\nX_aug = np.hstack([X, np.ones((3,1))])\nI = np.eye(X_aug.shape[1])\nfor lamb in [0.01, 100]:\n    params = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\n    print(f\"λ={lamb}: y = {params[0]:.4f}x + {params[1]:.4f}\")"
    },
    {
        "input": "Apply Ridge to X = [[1, 0], [0, 1]], y = [1, 1] with a high λ=1000.",
        "output": "import numpy as np\nX = np.array([[1, 0], [0, 1]])\ny = np.array([1, 1])\nlamb = 1000\nX_aug = np.hstack([X, np.ones((2,1))])\nI = np.eye(X_aug.shape[1])\nparams = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\nprint(\"With high λ, coefficients shrink:\")\nprint(params)"
    },
    {
        "input": "Use Ridge with X = [[1, 1], [2, 2], [3, 3]], y = [2, 4, 6], λ=0.1.",
        "output": "import numpy as np\nX = np.array([[1, 1], [2, 2], [3, 3]])\ny = np.array([2, 4, 6])\nlamb = 0.1\nX_aug = np.hstack([X, np.ones((3,1))])\nI = np.eye(X_aug.shape[1])\nparams = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\nprint(f\"Ridge output: y = {params[0]:.4f}x1 + {params[1]:.4f}x2 + {params[2]:.4f}\")"
    },
    {
        "input": "Ridge fit for polynomial features: x = [1, 2, 3], y = [1, 4, 9], λ=1.",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\nX = np.vstack([x**2, x, np.ones_like(x)]).T\ny = np.array([1, 4, 9])\nlamb = 1\nI = np.eye(X.shape[1])\nparams = np.linalg.inv(X.T @ X + lamb * I) @ X.T @ y\nprint(f\"Ridge poly fit: y = {params[0]:.4f}x^2 + {params[1]:.4f}x + {params[2]:.4f}\")"
    },
    {
        "input": "Ridge on symbolic matrix X = [[x1, x2], [x3, x4]] not supported; give numerical example.",
        "output": "import numpy as np\nX = np.array([[1, 2], [3, 4]])\ny = np.array([5, 11])\nlamb = 0.5\nX_aug = np.hstack([X, np.ones((2,1))])\nI = np.eye(X_aug.shape[1])\nparams = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\nprint(\"Ridge with dummy values:\")\nprint(params)"
    },
    {
        "input": "Apply Ridge Regression on random (100, 5) dataset, λ=0.01.",
        "output": "import numpy as np\nnp.random.seed(42)\nX = np.random.randn(100, 5)\ny = X @ np.array([2, -1, 0.5, 3, 1]) + np.random.randn(100)\nlamb = 0.01\nX_aug = np.hstack([X, np.ones((100,1))])\nI = np.eye(X_aug.shape[1])\nparams = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\nprint(\"Trained Ridge Parameters:\")\nprint(params)"
    },
    {
        "input": "Fit Ridge model for dataset with multicollinearity: X = [[1, 2], [2, 4], [3, 6]], y = [3, 6, 9], λ=1.",
        "output": "import numpy as np\nX = np.array([[1, 2], [2, 4], [3, 6]])\ny = np.array([3, 6, 9])\nlamb = 1\nX_aug = np.hstack([X, np.ones((3, 1))])\nI = np.eye(X_aug.shape[1])\nparams = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\nprint(f\"Ridge with multicollinearity: y = {params[0]:.4f}x1 + {params[1]:.4f}x2 + {params[2]:.4f}\")"
    },
    {
        "input": "Check ridge coefficients shrinkage: X = [[1, 1], [2, 2], [3, 3]], y = [2, 4, 6], λ=10.",
        "output": "import numpy as np\nX = np.array([[1, 1], [2, 2], [3, 3]])\ny = np.array([2, 4, 6])\nlamb = 10\nX_aug = np.hstack([X, np.ones((3, 1))])\nI = np.eye(X_aug.shape[1])\nparams = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\nprint(\"Shrinked Ridge Coefficients:\")\nprint(params)"
    },
    {
        "input": "Use ridge regression for underdetermined system: X = [[1,2,3],[4,5,6]], y = [1,2], λ=0.5.",
        "output": "import numpy as np\nX = np.array([[1, 2, 3], [4, 5, 6]])\ny = np.array([1, 2])\nlamb = 0.5\nX_aug = np.hstack([X, np.ones((2, 1))])\nI = np.eye(X_aug.shape[1])\nparams = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\nprint(\"Underdetermined Ridge Fit:\")\nprint(params)"
    },
    {
        "input": "Use Ridge Regression on noisy linear relation: y = 3x + noise, x in range(1,6), λ=0.1.",
        "output": "import numpy as np\nx = np.arange(1, 6)\ny = 3 * x + np.random.normal(0, 1, size=5)\nX = np.vstack([x]).T\nX_aug = np.hstack([X, np.ones((5, 1))])\nlamb = 0.1\nI = np.eye(X_aug.shape[1])\nparams = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\nprint(f\"Ridge with noise: y = {params[0]:.4f}x + {params[1]:.4f}\")"
    },
    {
        "input": "Ridge regression with polynomial features x^3, x^2, x, and constant: x = [1,2,3,4], y = [3,6,11,18], λ=0.5.",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([3, 6, 11, 18])\nX = np.vstack([x**3, x**2, x, np.ones_like(x)]).T\nlamb = 0.5\nI = np.eye(X.shape[1])\nparams = np.linalg.inv(X.T @ X + lamb * I) @ X.T @ y\nprint(f\"y = {params[0]:.4f}x^3 + {params[1]:.4f}x^2 + {params[2]:.4f}x + {params[3]:.4f}\")"
    },
    {
        "input": "Create a ridge model with categorical one-hot data: X = [[1,0], [0,1], [1,0]], y = [5, 3, 6], λ=1.",
        "output": "import numpy as np\nX = np.array([[1,0], [0,1], [1,0]])\ny = np.array([5, 3, 6])\nlamb = 1\nX_aug = np.hstack([X, np.ones((3, 1))])\nI = np.eye(X_aug.shape[1])\nparams = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\nprint(\"Ridge with one-hot categorical data:\")\nprint(params)"
    },
    {
        "input": "Use ridge regression with correlated features: X = [[1,1], [2,2], [3,3]], y = [2,4,6], λ=100.",
        "output": "import numpy as np\nX = np.array([[1,1], [2,2], [3,3]])\ny = np.array([2,4,6])\nlamb = 100\nX_aug = np.hstack([X, np.ones((3,1))])\nI = np.eye(X_aug.shape[1])\nparams = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\nprint(f\"High λ Ridge Fit: y = {params[0]:.4f}x1 + {params[1]:.4f}x2 + {params[2]:.4f}\")"
    },
    {
        "input": "Compare unregularized vs ridge: X = [[1], [2], [3]], y = [2, 4, 6], λ=0 and λ=10.",
        "output": "import numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([2, 4, 6])\nX_aug = np.hstack([X, np.ones((3,1))])\nI = np.eye(X_aug.shape[1])\nfor lamb in [0, 10]:\n    params = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\n    print(f\"λ={lamb}: y = {params[0]:.4f}x + {params[1]:.4f}\")"
    },
    {
        "input": "Apply ridge regression on data with outlier: X = [[1], [2], [3], [10]], y = [2, 4, 6, 30], λ=1.",
        "output": "import numpy as np\nX = np.array([[1], [2], [3], [10]])\ny = np.array([2, 4, 6, 30])\nlamb = 1\nX_aug = np.hstack([X, np.ones((4,1))])\nI = np.eye(X_aug.shape[1])\nparams = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\nprint(f\"Ridge fit with outlier: y = {params[0]:.4f}x + {params[1]:.4f}\")"
    },
    {
        "input": "Use Ridge for a flat data scenario: X = [[0], [0], [0]], y = [1, 1, 1], λ=1.",
        "output": "import numpy as np\nX = np.array([[0], [0], [0]])\ny = np.array([1, 1, 1])\nlamb = 1\nX_aug = np.hstack([X, np.ones((3,1))])\nI = np.eye(X_aug.shape[1])\nparams = np.linalg.inv(X_aug.T @ X_aug + lamb * I) @ X_aug.T @ y\nprint(\"Flat data Ridge model:\")\nprint(params)"
    },
    {
        "input": "Use Lasso on a dataset with one irrelevant feature: X = [[1, 100], [2, 200], [3, 300]], y = [2, 4, 6], α=0.5.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1, 100], [2, 200], [3, 300]])\ny = np.array([2, 4, 6])\nmodel = Lasso(alpha=0.5)\nmodel.fit(X, y)\nprint(f\"Coefficients: {model.coef_}, Intercept: {model.intercept_:.4f}\")"
    },
    {
        "input": "Perform Lasso regression on sparse data: X = [[0, 0], [1, 0], [0, 1]], y = [0, 1, 1], α=0.1.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[0, 0], [1, 0], [0, 1]])\ny = np.array([0, 1, 1])\nmodel = Lasso(alpha=0.1)\nmodel.fit(X, y)\nprint(f\"Coefficients: {model.coef_}, Intercept: {model.intercept_:.4f}\")"
    },
    {
        "input": "Apply Lasso to eliminate redundant predictors: X = [[1, 1, 1], [2, 2, 2], [3, 3, 3]], y = [1, 2, 3], α=5.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1, 1, 1], [2, 2, 2], [3, 3, 3]])\ny = np.array([1, 2, 3])\nmodel = Lasso(alpha=5)\nmodel.fit(X, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Test Lasso with polynomial features: x = [1,2,3], y = [1,4,9], α=0.01.",
        "output": "from sklearn.linear_model import Lasso\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.pipeline import make_pipeline\nimport numpy as np\nx = np.array([1,2,3]).reshape(-1,1)\ny = np.array([1,4,9])\nmodel = make_pipeline(PolynomialFeatures(2), Lasso(alpha=0.01))\nmodel.fit(x, y)\nprint(f\"Coefficients: {model.named_steps['lasso'].coef_}\")"
    },
    {
        "input": "Use Lasso on standardized data: X = [[1, 10], [2, 20], [3, 30]], y = [1, 2, 3], α=0.2.",
        "output": "from sklearn.linear_model import Lasso\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.pipeline import make_pipeline\nimport numpy as np\nX = np.array([[1,10],[2,20],[3,30]])\ny = np.array([1,2,3])\nmodel = make_pipeline(StandardScaler(), Lasso(alpha=0.2))\nmodel.fit(X, y)\nprint(f\"Coefficients: {model.named_steps['lasso'].coef_}\")"
    },
    {
        "input": "Demonstrate sparse solution from Lasso: X = [[1,2,3], [4,5,6], [7,8,9]], y = [1,2,3], α=100.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1,2,3], [4,5,6], [7,8,9]])\ny = np.array([1,2,3])\nmodel = Lasso(alpha=100)\nmodel.fit(X, y)\nprint(\"Lasso Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Compare Lasso and OLS: X = [[1], [2], [3]], y = [1.1, 2.1, 3.1], α=0.01.",
        "output": "from sklearn.linear_model import Lasso, LinearRegression\nimport numpy as np\nX = np.array([[1],[2],[3]])\ny = np.array([1.1, 2.1, 3.1])\nlasso = Lasso(alpha=0.01)\nols = LinearRegression()\nlasso.fit(X, y)\nols.fit(X, y)\nprint(f\"Lasso Coef: {lasso.coef_[0]:.4f}, OLS Coef: {ols.coef_[0]:.4f}\")"
    },
    {
        "input": "Apply Lasso with redundant and irrelevant features. X = [[1, 1, 100], [2, 2, 200], [3, 3, 300]], y = [2, 4, 6], α=0.3.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1,1,100],[2,2,200],[3,3,300]])\ny = np.array([2,4,6])\nmodel = Lasso(alpha=0.3)\nmodel.fit(X, y)\nprint(\"Lasso Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use Lasso on categorical encoded data: X = [[1,0], [0,1], [1,0]], y = [5, 7, 6], α=0.05.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1,0], [0,1], [1,0]])\ny = np.array([5,7,6])\nmodel = Lasso(alpha=0.05)\nmodel.fit(X, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Perform Lasso on small dataset with more features than samples: X = [[1,2,3],[4,5,6]], y = [1,2], α=0.1.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1,2,3],[4,5,6]])\ny = np.array([1,2])\nmodel = Lasso(alpha=0.1, max_iter=10000)\nmodel.fit(X, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Lasso regression on dataset with outliers: X = [[1], [2], [3], [100]], y = [1, 2, 3, 100], α=0.1.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1],[2],[3],[100]])\ny = np.array([1,2,3,100])\nmodel = Lasso(alpha=0.1)\nmodel.fit(X, y)\nprint(\"Coefficient:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Show Lasso shrinkage: X = [[1,0], [2,0], [3,0]], y = [1,2,3], α=0.5.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1,0],[2,0],[3,0]])\ny = np.array([1,2,3])\nmodel = Lasso(alpha=0.5)\nmodel.fit(X, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Lasso regression with sklearn's built-in LassoCV for α selection. X = [[1,2],[2,3],[3,4]], y = [3,5,7].",
        "output": "from sklearn.linear_model import LassoCV\nimport numpy as np\nX = np.array([[1,2],[2,3],[3,4]])\ny = np.array([3,5,7])\nmodel = LassoCV(cv=3).fit(X, y)\nprint(f\"Best α: {model.alpha_:.4f}, Coefficients: {model.coef_}\")"
    },
    {
        "input": "Use Lasso on multicollinear data: X = [[1,2], [2,4], [3,6]], y = [2, 4, 6], α=0.3.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1,2],[2,4],[3,6]])\ny = np.array([2,4,6])\nmodel = Lasso(alpha=0.3)\nmodel.fit(X, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply Lasso to a dataset where one feature is strongly correlated with the target. X = [[1, 0], [2, 0], [3, 0]], y = [2, 4, 6], α=0.1.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1, 0], [2, 0], [3, 0]])\ny = np.array([2, 4, 6])\nmodel = Lasso(alpha=0.1)\nmodel.fit(X, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Run Lasso on a feature matrix with a constant column: X = [[1, 5], [2, 5], [3, 5]], y = [3, 5, 7], α=0.2.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1, 5], [2, 5], [3, 5]])\ny = np.array([3, 5, 7])\nmodel = Lasso(alpha=0.2)\nmodel.fit(X, y)\nprint(\"Lasso Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Evaluate Lasso on noisy linear data: X = [[1], [2], [3], [4]], y = [2.1, 3.9, 6.2, 8.1], α=0.05.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1], [2], [3], [4]])\ny = np.array([2.1, 3.9, 6.2, 8.1])\nmodel = Lasso(alpha=0.05)\nmodel.fit(X, y)\nprint(\"Coefficient:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use Lasso with feature selection in high-dimensional setting: X = [[1,2,0],[3,4,0],[5,6,0]], y = [1,3,5], α=0.5.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1,2,0],[3,4,0],[5,6,0]])\ny = np.array([1,3,5])\nmodel = Lasso(alpha=0.5)\nmodel.fit(X, y)\nprint(\"Selected features:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Show effect of high regularization with Lasso: X = [[1, 2], [2, 4], [3, 6]], y = [1, 2, 3], α=10.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1, 2], [2, 4], [3, 6]])\ny = np.array([1, 2, 3])\nmodel = Lasso(alpha=10)\nmodel.fit(X, y)\nprint(\"Lasso Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Lasso regression on scaled polynomial features. X = [[1], [2], [3]], y = [1, 4, 9], α=0.1.",
        "output": "from sklearn.linear_model import Lasso\nfrom sklearn.preprocessing import PolynomialFeatures, StandardScaler\nfrom sklearn.pipeline import make_pipeline\nimport numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([1, 4, 9])\nmodel = make_pipeline(PolynomialFeatures(2), StandardScaler(), Lasso(alpha=0.1))\nmodel.fit(X, y)\nprint(\"Coefficients:\", model.named_steps['lasso'].coef_)"
    },
    {
        "input": "Predict with Lasso after training: X_train = [[1,2],[3,4]], y_train = [5,6], X_test = [[2,3]].",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX_train = np.array([[1,2],[3,4]])\ny_train = np.array([5,6])\nX_test = np.array([[2,3]])\nmodel = Lasso(alpha=0.1)\nmodel.fit(X_train, y_train)\npred = model.predict(X_test)\nprint(\"Prediction:\", pred[0])"
    },
    {
        "input": "Use Lasso on highly correlated features: X = [[1,2],[2,4],[3,6]], y = [1,2,3], α=0.4.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1,2],[2,4],[3,6]])\ny = np.array([1,2,3])\nmodel = Lasso(alpha=0.4)\nmodel.fit(X, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit Lasso with sklearn pipeline: include standardization. X = [[1,10], [2,20], [3,30]], y = [3,5,7].",
        "output": "from sklearn.linear_model import Lasso\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.preprocessing import StandardScaler\nimport numpy as np\nX = np.array([[1,10],[2,20],[3,30]])\ny = np.array([3,5,7])\nmodel = make_pipeline(StandardScaler(), Lasso(alpha=0.1))\nmodel.fit(X, y)\nprint(\"Coefficients:\", model.named_steps['lasso'].coef_)"
    },
    {
        "input": "Apply Lasso with high alpha to force zero coefficients: X = [[1,2], [2,3], [3,4]], y = [3,4,5], α=100.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1,2], [2,3], [3,4]])\ny = np.array([3,4,5])\nmodel = Lasso(alpha=100)\nmodel.fit(X, y)\nprint(\"Coefficients after shrinkage:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use Lasso on binary feature matrix: X = [[1,0,0],[0,1,0],[0,0,1]], y = [1,2,3], α=0.2.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1,0,0],[0,1,0],[0,0,1]])\ny = np.array([1,2,3])\nmodel = Lasso(alpha=0.2)\nmodel.fit(X, y)\nprint(\"Lasso Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Perform Lasso with PolynomialFeatures and interpret output. X = [[1], [2], [3]], y = [2, 5, 10], α=0.01.",
        "output": "from sklearn.pipeline import make_pipeline\nfrom sklearn.linear_model import Lasso\nfrom sklearn.preprocessing import PolynomialFeatures\nimport numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([2, 5, 10])\nmodel = make_pipeline(PolynomialFeatures(2), Lasso(alpha=0.01))\nmodel.fit(X, y)\nprint(\"Polynomial Coefficients:\", model.named_steps['lasso'].coef_)"
    },
    {
        "input": "Use Lasso on dataset with small magnitude targets: X = [[1,2], [3,4], [5,6]], y = [0.01, 0.02, 0.03], α=0.001.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1,2],[3,4],[5,6]])\ny = np.array([0.01, 0.02, 0.03])\nmodel = Lasso(alpha=0.001)\nmodel.fit(X, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use Lasso to estimate relationship in overfit situation. X = [[1,1,1],[2,2,2],[3,3,3]], y = [3,6,9], α=1.",
        "output": "from sklearn.linear_model import Lasso\nimport numpy as np\nX = np.array([[1,1,1],[2,2,2],[3,3,3]])\ny = np.array([3,6,9])\nmodel = Lasso(alpha=1)\nmodel.fit(X, y)\nprint(\"Lasso Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply Ridge regression to a simple dataset: X = [[1], [2], [3]], y = [1, 2, 3], α=0.1.",
        "output": "from sklearn.linear_model import Ridge\nimport numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([1, 2, 3])\nmodel = Ridge(alpha=0.1)\nmodel.fit(X, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use Ridge regression with multiple features: X = [[1,2], [3,4], [5,6]], y = [1,2,3], α=0.5.",
        "output": "from sklearn.linear_model import Ridge\nimport numpy as np\nX = np.array([[1,2], [3,4], [5,6]])\ny = np.array([1,2,3])\nmodel = Ridge(alpha=0.5)\nmodel.fit(X, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit Ridge regression on noisy data: X = [[1], [2], [3], [4]], y = [2.1, 4.2, 6.3, 8.4], α=0.05.",
        "output": "from sklearn.linear_model import Ridge\nimport numpy as np\nX = np.array([[1], [2], [3], [4]])\ny = np.array([2.1, 4.2, 6.3, 8.4])\nmodel = Ridge(alpha=0.05)\nmodel.fit(X, y)\nprint(\"Coefficient:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use Ridge to prevent overfitting in high-dimensional data: X = [[1,2,3], [4,5,6], [7,8,9]], y = [3,6,9], α=1.",
        "output": "from sklearn.linear_model import Ridge\nimport numpy as np\nX = np.array([[1,2,3], [4,5,6], [7,8,9]])\ny = np.array([3,6,9])\nmodel = Ridge(alpha=1)\nmodel.fit(X, y)\nprint(\"Ridge Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Perform Ridge regression with a polynomial feature matrix: X = [[1], [2], [3]], y = [1, 2, 4], α=0.2.",
        "output": "from sklearn.linear_model import Ridge\nfrom sklearn.preprocessing import PolynomialFeatures\nimport numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([1, 2, 4])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = Ridge(alpha=0.2)\nmodel.fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use Ridge with cross-validation for model selection. X = [[1, 2], [2, 3], [3, 4]], y = [1, 3, 5], α=0.3.",
        "output": "from sklearn.linear_model import RidgeCV\nimport numpy as np\nX = np.array([[1,2], [2,3], [3,4]])\ny = np.array([1,3,5])\nmodel = RidgeCV(alphas=[0.1, 0.3, 1.0], store_cv_values=True)\nmodel.fit(X, y)\nprint(\"Best Alpha:\", model.alpha_)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit Ridge regression on scaled features: X = [[1], [2], [3]], y = [1, 2, 3], α=0.5.",
        "output": "from sklearn.linear_model import Ridge\nfrom sklearn.preprocessing import StandardScaler\nimport numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([1, 2, 3])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = Ridge(alpha=0.5)\nmodel.fit(X_scaled, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply Ridge regression with high regularization: X = [[1, 2], [3, 4], [5, 6]], y = [10, 20, 30], α=100.",
        "output": "from sklearn.linear_model import Ridge\nimport numpy as np\nX = np.array([[1, 2], [3, 4], [5, 6]])\ny = np.array([10, 20, 30])\nmodel = Ridge(alpha=100)\nmodel.fit(X, y)\nprint(\"Ridge Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Perform Ridge regression for high-dimensional feature matrix: X = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], y = [1, 2, 3], α=0.7.",
        "output": "from sklearn.linear_model import Ridge\nimport numpy as np\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\ny = np.array([1, 2, 3])\nmodel = Ridge(alpha=0.7)\nmodel.fit(X, y)\nprint(\"Ridge Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit Ridge regression on noisy data with outliers: X = [[1, 1], [2, 2], [100, 100]], y = [2, 4, 100], α=0.1.",
        "output": "from sklearn.linear_model import Ridge\nimport numpy as np\nX = np.array([[1,1], [2,2], [100,100]])\ny = np.array([2,4,100])\nmodel = Ridge(alpha=0.1)\nmodel.fit(X, y)\nprint(\"Ridge Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Evaluate Ridge regression performance with different alphas: X = [[1, 2], [2, 3], [3, 4]], y = [5, 7, 9], α=0.2.",
        "output": "from sklearn.linear_model import RidgeCV\nimport numpy as np\nX = np.array([[1,2], [2,3], [3,4]])\ny = np.array([5,7,9])\nmodel = RidgeCV(alphas=[0.1, 0.2, 0.5], store_cv_values=True)\nmodel.fit(X, y)\nprint(\"Best Alpha:\", model.alpha_)\nprint(\"Ridge Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Perform Ridge regression for multi-class classification. X = [[1,2], [2,3], [3,4]], y = [0, 1, 2], α=1.",
        "output": "from sklearn.linear_model import RidgeClassifier\nimport numpy as np\nX = np.array([[1,2], [2,3], [3,4]])\ny = np.array([0,1,2])\nmodel = RidgeClassifier(alpha=1)\nmodel.fit(X, y)\nprint(\"Ridge Classifier Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply Ridge regression to predict house prices with multiple features: X = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], y = [100000, 200000, 300000], α=0.2.",
        "output": "from sklearn.linear_model import Ridge\nimport numpy as np\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\ny = np.array([100000, 200000, 300000])\nmodel = Ridge(alpha=0.2)\nmodel.fit(X, y)\nprint(\"House Price Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply ElasticNet to a simple dataset: X = [[1], [2], [3]], y = [1, 2, 3], α=0.1, l1_ratio=0.5.",
        "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([1, 2, 3])\nmodel = ElasticNet(alpha=0.1, l1_ratio=0.5)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit ElasticNet to a dataset with two features: X = [[1, 2], [3, 4], [5, 6]], y = [1, 2, 3], α=0.2, l1_ratio=0.4.",
        "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\nX = np.array([[1, 2], [3, 4], [5, 6]])\ny = np.array([1, 2, 3])\nmodel = ElasticNet(alpha=0.2, l1_ratio=0.4)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use ElasticNet to predict with noisy data: X = [[1], [2], [3]], y = [2.1, 4.2, 6.3], α=0.1, l1_ratio=0.7.",
        "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([2.1, 4.2, 6.3])\nmodel = ElasticNet(alpha=0.1, l1_ratio=0.7)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use ElasticNet for higher-dimensional data: X = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], y = [1, 2, 3], α=0.3, l1_ratio=0.5.",
        "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\ny = np.array([1, 2, 3])\nmodel = ElasticNet(alpha=0.3, l1_ratio=0.5)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit ElasticNet with multiple features: X = [[1, 2], [2, 3], [3, 4]], y = [5, 6, 7], α=0.5, l1_ratio=0.6.",
        "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\nX = np.array([[1, 2], [2, 3], [3, 4]])\ny = np.array([5, 6, 7])\nmodel = ElasticNet(alpha=0.5, l1_ratio=0.6)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit ElasticNet to high-dimensional data: X = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]], y = [1, 2, 3, 4], α=0.4, l1_ratio=0.8.",
        "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\ny = np.array([1, 2, 3, 4])\nmodel = ElasticNet(alpha=0.4, l1_ratio=0.8)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit ElasticNet with smaller alpha value to avoid overfitting: X = [[1], [2], [3]], y = [1, 2, 3], α=0.05, l1_ratio=0.9.",
        "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([1, 2, 3])\nmodel = ElasticNet(alpha=0.05, l1_ratio=0.9)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Perform ElasticNet regression with high regularization: X = [[1, 2], [3, 4], [5, 6]], y = [100, 200, 300], α=10, l1_ratio=0.7.",
        "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\nX = np.array([[1, 2], [3, 4], [5, 6]])\ny = np.array([100, 200, 300])\nmodel = ElasticNet(alpha=10, l1_ratio=0.7)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Perform ElasticNet on a dataset with outliers: X = [[1, 1], [2, 2], [100, 100]], y = [1, 2, 100], α=0.5, l1_ratio=0.5.",
        "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\nX = np.array([[1, 1], [2, 2], [100, 100]])\ny = np.array([1, 2, 100])\nmodel = ElasticNet(alpha=0.5, l1_ratio=0.5)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use ElasticNet regression for classification with multi-class targets: X = [[1, 2], [3, 4], [5, 6]], y = [0, 1, 2], α=0.1, l1_ratio=0.5.",
        "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\nX = np.array([[1, 2], [3, 4], [5, 6]])\ny = np.array([0, 1, 2])\nmodel = ElasticNet(alpha=0.1, l1_ratio=0.5)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit ElasticNet with data scaling: X = [[1], [2], [3]], y = [2.1, 4.2, 6.3], α=0.3, l1_ratio=0.4.",
        "output": "from sklearn.linear_model import ElasticNet\nfrom sklearn.preprocessing import StandardScaler\nimport numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([2.1, 4.2, 6.3])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = ElasticNet(alpha=0.3, l1_ratio=0.4)\nmodel.fit(X_scaled, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply ElasticNet with different alpha values: X = [[1, 2], [2, 3], [3, 4]], y = [1, 2, 3], α=0.6, l1_ratio=0.2.",
        "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\nX = np.array([[1,2], [2,3], [3,4]])\ny = np.array([1,2,3])\nmodel = ElasticNet(alpha=0.6, l1_ratio=0.2)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply ElasticNet to a non-linear problem: X = [[1], [2], [3]], y = [1, 4, 9], α=0.1, l1_ratio=0.5.",
        "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([1, 4, 9])\nmodel = ElasticNet(alpha=0.1, l1_ratio=0.5)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Perform ElasticNet regression with a large dataset: X = [[i] for i in range(1, 101)], y = [i*2 for i in range(1, 101)], α=0.2, l1_ratio=0.8.",
        "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\nX = np.array([[i] for i in range(1, 101)])\ny = np.array([i*2 for i in range(1, 101)])\nmodel = ElasticNet(alpha=0.2, l1_ratio=0.8)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a polynomial regression model (degree 2) to X = [1, 2, 3], y = [1, 4, 9].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3]])\ny = np.array([1, 4, 9])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply degree 3 polynomial regression on X = [0, 1, 2], y = [1, 3, 27].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[0], [1], [2]])\ny = np.array([1, 3, 27])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a quadratic model to data: X = [[1], [2], [3], [4]], y = [2.1, 4.8, 9.1, 16.2].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3], [4]])\ny = np.array([2.1, 4.8, 9.1, 16.2])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use polynomial regression to fit a cubic model: X = [1, 2, 3], y = [2, 6, 20].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[1], [2], [3]])\ny = np.array([2, 6, 20])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Cubic Model Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Model non-linear relation with degree 4 polynomial: X = [1, 2, 3, 4], y = [3, 5, 15, 33].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3], [4]])\ny = np.array([3, 5, 15, 33])\npoly = PolynomialFeatures(degree=4)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Coefficients (degree 4):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a polynomial model to sales data: X = [5, 10, 15], y = [100, 150, 300], degree = 2.",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[5], [10], [15]])\ny = np.array([100, 150, 300])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Sales Model Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Quadratic regression on price data: X = [1, 2, 3, 4], y = [50, 70, 100, 140].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3], [4]])\ny = np.array([50, 70, 100, 140])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Price Trend Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Model temperature trend using polynomial degree 3: X = [1, 2, 3, 4], y = [30, 33, 45, 65].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[1], [2], [3], [4]])\ny = np.array([30, 33, 45, 65])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Temperature Model Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict growth using 4th-degree polynomial: X = [1,2,3,4,5], y = [2, 8, 18, 32, 50].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([2, 8, 18, 32, 50])\npoly = PolynomialFeatures(degree=4)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Growth Model Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit polynomial regression (degree 5) to increasing trend data: X = [0, 1, 2, 3, 4], y = [1, 3, 7, 13, 21].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[0], [1], [2], [3], [4]])\ny = np.array([1, 3, 7, 13, 21])\npoly = PolynomialFeatures(degree=5)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Degree 5 Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Model electricity demand using a quadratic fit. X = [1, 2, 3, 4, 5], y = [100, 150, 220, 310, 420].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([100, 150, 220, 310, 420])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Electricity Demand Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a polynomial model (degree 3) to traffic flow data: X = [0, 1, 2, 3], y = [50, 80, 130, 210].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[0], [1], [2], [3]])\ny = np.array([50, 80, 130, 210])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Traffic Flow Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Model pollution levels using a cubic polynomial. X = [1, 3, 5, 7], y = [20, 30, 80, 150].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[1], [3], [5], [7]])\ny = np.array([20, 30, 80, 150])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Pollution Model Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply polynomial regression degree 2 on X = [10, 20, 30, 40], y = [100, 250, 500, 800].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[10], [20], [30], [40]])\ny = np.array([100, 250, 500, 800])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Degree 2 Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Model rainfall data with polynomial regression (degree 3): X = [5, 10, 15, 20], y = [3, 7, 18, 40].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[5], [10], [15], [20]])\ny = np.array([3, 7, 18, 40])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Rainfall Polynomial Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use polynomial regression (degree 4) to model economic index: X = [1, 2, 3, 4], y = [10, 30, 70, 130].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3], [4]])\ny = np.array([10, 30, 70, 130])\npoly = PolynomialFeatures(degree=4)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Economic Index Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a polynomial model to stock price movement (degree 3): X = [1, 2, 3, 4], y = [100, 120, 160, 220].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[1], [2], [3], [4]])\ny = np.array([100, 120, 160, 220])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Stock Price Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a degree 2 polynomial to model plant growth: X = [1, 2, 3, 4], y = [2, 6, 14, 26].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[1], [2], [3], [4]])\ny = np.array([2, 6, 14, 26])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Plant Growth Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Model academic score trend using degree 3 polynomial. X = [1, 2, 3, 4, 5], y = [65, 68, 75, 85, 98].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([65, 68, 75, 85, 98])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Score Trend Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use degree 4 polynomial to model traffic delays: X = [1, 2, 3, 4], y = [3, 6, 20, 60].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[1], [2], [3], [4]])\ny = np.array([3, 6, 20, 60])\npoly = PolynomialFeatures(degree=4)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Traffic Delay Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a polynomial regression of degree 3 to demand data: X = [1, 2, 3, 4], y = [10, 40, 90, 160].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3], [4]])\ny = np.array([10, 40, 90, 160])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Demand Curve Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply polynomial regression (degree 2) to fuel efficiency: X = [10, 20, 30, 40], y = [35, 32, 28, 25].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[10], [20], [30], [40]])\ny = np.array([35, 32, 28, 25])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Fuel Efficiency Model:\")\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Model disease spread using polynomial regression of degree 3. X = [1, 2, 3, 4], y = [3, 10, 25, 55].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[1], [2], [3], [4]])\ny = np.array([3, 10, 25, 55])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Disease Spread Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a 2nd degree polynomial to model speed vs distance. X = [1, 2, 3, 4], y = [5, 20, 45, 80].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[1], [2], [3], [4]])\ny = np.array([5, 20, 45, 80])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Speed-Distance Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use polynomial regression (degree 3) for predicting delivery times: X = [1, 2, 3, 4], y = [5, 10, 25, 50].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3], [4]])\ny = np.array([5, 10, 25, 50])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Delivery Time Model Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a polynomial regression of degree 3 to the data X = [1, 2, 3, 4], y = [3, 6, 19, 44].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([1, 2, 3, 4]).reshape(-1, 1)\ny = np.array([3, 6, 19, 44])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)\nprint(\"Model: y = {:.2f} + {:.2f}x + {:.2f}x^2 + {:.2f}x^3\".format(\n      model.intercept_, *model.coef_[1:]))"
    },
    {
        "input": "Model the interaction between advertising and pricing on sales: X = [[10, 5], [15, 3], [20, 1], [25, 0]], y = [100, 130, 160, 180].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[10, 5], [15, 3], [20, 1], [25, 0]])\ninteraction = X[:, 0] * X[:, 1]\nX_aug = np.column_stack([X, interaction])\ny = np.array([100, 130, 160, 180])\nmodel = LinearRegression().fit(X_aug, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use numpy to solve constrained least squares: X = [[1,1],[1,2]], y = [2,3], with constraint x1 + x2 = 1.",
        "output": "import numpy as np\nfrom scipy.optimize import minimize\nX = np.array([[1, 1], [1, 2]])\ny = np.array([2, 3])\nobj = lambda beta: np.sum((X @ beta - y)**2)\ncon = {'type': 'eq', 'fun': lambda beta: np.sum(beta) - 1}\nres = minimize(obj, np.zeros(2), constraints=con)\nprint(\"Optimal coefficients with constraint x1 + x2 = 1:\", res.x)"
    },
    {
        "input": "Generate a model where the independent variable is transformed logarithmically. X = [1, 10, 100, 1000], y = [0, 1, 2, 3].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.log10(np.array([1, 10, 100, 1000]).reshape(-1, 1))\ny = np.array([0, 1, 2, 3])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f}*log10(x) + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Fit a linear model where one feature is squared. X = [[1], [2], [3]], y = [1, 4, 9].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([1, 2, 3]).reshape(-1, 1)\nX_squared = X**2\ny = np.array([1, 4, 9])\nmodel = LinearRegression().fit(X_squared, y)\nprint(\"Model: y = {:.2f}x^2 + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Fit a model using orthogonal polynomials up to degree 2. X = [0, 1, 2], y = [1, 3, 7].",
        "output": "import numpy as np\nfrom numpy.polynomial.legendre import legvander\nfrom sklearn.linear_model import LinearRegression\nX = np.array([0, 1, 2])\ny = np.array([1, 3, 7])\nX_leg = legvander(X, 2)\nmodel = LinearRegression().fit(X_leg, y)\nprint(\"Coefficients (Legendre basis):\", model.coef_)"
    },
    {
        "input": "Predict a target using sinusoidal transformation. X = [0, π/2, π], y = [0, 1, 0].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([0, np.pi/2, np.pi]).reshape(-1, 1)\nX_sin = np.sin(X)\ny = np.array([0, 1, 0])\nmodel = LinearRegression().fit(X_sin, y)\nprint(\"Model: y = {:.2f}sin(x) + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Generate a fit using Chebyshev polynomial basis. X = [-1, 0, 1], y = [2, 1, 2].",
        "output": "import numpy as np\nfrom numpy.polynomial.chebyshev import chebvander\nfrom sklearn.linear_model import LinearRegression\nX = np.array([-1, 0, 1])\ny = np.array([2, 1, 2])\nX_cheb = chebvander(X, 2)\nmodel = LinearRegression().fit(X_cheb, y)\nprint(\"Coefficients (Chebyshev basis):\", model.coef_)"
    },
    {
        "input": "Use a dummy variable to include a categorical variable in the regression. Data: day = ['weekday', 'weekend'], sales = [100, 150].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[0], [1]])\ny = np.array([100, 150])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f}*is_weekend + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Perform a fit with ridge-like penalty manually via pseudo-inverse: X = [[1, 2], [3, 4]], y = [1, 2].",
        "output": "import numpy as np\nX = np.array([[1, 2], [3, 4]])\ny = np.array([1, 2])\nlambda_ = 0.1\nI = np.eye(X.shape[1])\nbeta = np.linalg.inv(X.T @ X + lambda_ * I) @ X.T @ y\nprint(\"Coefficients with manual regularization:\", beta)"
    },
    {
        "input": "Create a linear model with exponential feature transformation. X = [0, 1, 2], y = [1, 2.7, 7.4].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([0, 1, 2]).reshape(-1, 1)\nX_exp = np.exp(X)\ny = np.array([1, 2.7, 7.4])\nmodel = LinearRegression().fit(X_exp, y)\nprint(\"Model: y = {:.2f} * exp(x) + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Fit a regression model with interaction between binary and continuous variables. X = [[0, 10], [1, 10], [0, 20], [1, 20]], y = [100, 150, 200, 300].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[0, 10], [1, 10], [0, 20], [1, 20]])\ninteraction = X[:, 0] * X[:, 1]\nX_aug = np.column_stack([X, interaction])\ny = np.array([100, 150, 200, 300])\nmodel = LinearRegression().fit(X_aug, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use polynomial regression with unevenly spaced X: X = [0.5, 2.3, 3.8], y = [1, 5, 9].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([0.5, 2.3, 3.8]).reshape(-1, 1)\ny = np.array([1, 5, 9])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a model with centered features to avoid multicollinearity. X = [[1, 1], [2, 2], [3, 3]], y = [2, 4, 6].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1, 1], [2, 2], [3, 3]])\nX_centered = X - X.mean(axis=0)\ny = np.array([2, 4, 6])\nmodel = LinearRegression().fit(X_centered, y)\nprint(\"Coefficients (with centered features):\", model.coef_)"
    },
    {
        "input": "Fit a piecewise linear model manually with a breakpoint at x = 2. X = [1, 2, 3], y = [1, 2, 5].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([1, 2, 3])\nX1 = (X <= 2).astype(int) * X\nX2 = (X > 2).astype(int) * (X - 2)\nX_aug = np.column_stack([X1, X2])\ny = np.array([1, 2, 5])\nmodel = LinearRegression().fit(X_aug, y)\nprint(\"Piecewise model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use PCA-transformed features for linear regression. X = [[2, 0], [0, 2], [1, 1]], y = [3, 3, 4].",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[2, 0], [0, 2], [1, 1]])\ny = np.array([3, 3, 4])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nmodel = LinearRegression().fit(X_pca, y)\nprint(\"Coefficients on PCA features:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a model with log-transformed target: X = [[1], [2], [3]], y = [2.7, 7.4, 20.1].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3]])\ny = np.log(np.array([2.7, 7.4, 20.1]))\nmodel = LinearRegression().fit(X, y)\nprint(\"Model (log-transformed y): log(y) = {:.2f}x + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Use sklearn’s PolynomialFeatures to fit a cubic model to X = [1, 2, 3, 4], y = [2, 8, 18, 32].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([1, 2, 3, 4]).reshape(-1, 1)\ny = np.array([2, 8, 18, 32])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Cubic model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a model where the feature is reciprocal-transformed. X = [1, 2, 4], y = [4, 2, 1].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = 1 / np.array([1, 2, 4]).reshape(-1, 1)\ny = np.array([4, 2, 1])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f}(1/x) + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Fit a model using squared features: X = [[1], [2], [3]], y = [2, 5, 10].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3]])\nX_sq = X ** 2\ny = np.array([2, 5, 10])\nmodel = LinearRegression().fit(X_sq, y)\nprint(\"Model: y = {:.2f} * x^2 + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Perform linear regression after normalizing the features. X = [[10], [20], [30]], y = [100, 200, 300].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\nX = np.array([[10], [20], [30]])\ny = np.array([100, 200, 300])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use interaction term for features: X = [[1, 2], [2, 3], [3, 4]], y = [5, 11, 19].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1, 2], [2, 3], [3, 4]])\ninteraction = (X[:, 0] * X[:, 1]).reshape(-1, 1)\nX_aug = np.hstack([X, interaction])\ny = np.array([5, 11, 19])\nmodel = LinearRegression().fit(X_aug, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a model to log-transformed features: X = [[1], [10], [100]], y = [1, 2, 3].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.log(np.array([[1], [10], [100]]))\ny = np.array([1, 2, 3])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f} * log(x) + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Fit a model to predict energy consumption from temperature and humidity. X = [[30, 60], [25, 55], [20, 50]], y = [500, 400, 300].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[30, 60], [25, 55], [20, 50]])\ny = np.array([500, 400, 300])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use ridge-like penalty manually with regularized normal equation. X = [[1], [2], [3]], y = [1, 2, 3].",
        "output": "import numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([1, 2, 3])\nX_aug = np.hstack([X, np.ones((3, 1))])\nlambda_reg = 0.1\nI = np.eye(X_aug.shape[1])\nI[-1, -1] = 0\nparams = np.linalg.inv(X_aug.T @ X_aug + lambda_reg * I) @ X_aug.T @ y\nprint(\"Regularized coefficients:\", params)"
    },
    {
        "input": "Fit a linear model where inputs are sine of time. X = [[0], [1], [2]], y = [0, 0.84, 0.91].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.sin(np.array([[0], [1], [2]]))\ny = np.array([0, 0.84, 0.91])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f} * sin(t) + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Predict weight from height and age. X = [[160, 25], [170, 30], [180, 35]], y = [60, 70, 80].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[160, 25], [170, 30], [180, 35]])\ny = np.array([60, 70, 80])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients (Height, Age):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply a log-log model: X = [1, 10, 100], y = [10, 100, 1000].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.log(np.array([1, 10, 100]).reshape(-1, 1))\ny = np.log(np.array([10, 100, 1000]))\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: log(y) = {:.2f} * log(x) + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Fit a linear regression on the first differences of a time series. y = [100, 105, 110, 120].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\ny = np.array([100, 105, 110, 120])\nX = np.arange(len(y) - 1).reshape(-1, 1)\ny_diff = np.diff(y)\nmodel = LinearRegression().fit(X, y_diff)\nprint(\"Rate of change (slope):\", model.coef_[0])"
    },
    {
        "input": "Use feature scaling and fit model: X = [[5], [15], [25]], y = [50, 150, 250].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[5], [15], [25]])\ny = np.array([50, 150, 250])\nscaler = MinMaxScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit linear regression with dropped constant feature. X = [[1, 5], [1, 10], [1, 15]], y = [10, 20, 30].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1, 5], [1, 10], [1, 15]])\nX_dropped = X[:, 1].reshape(-1, 1)\ny = np.array([10, 20, 30])\nmodel = LinearRegression().fit(X_dropped, y)\nprint(\"Model without constant feature: y = {:.2f}x + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Fit a model to polynomial transformed data: X = [[1], [2], [3]], y = [3, 12, 27].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3]])\ny = np.array([3, 12, 27])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a linear model to predict salary from years of experience: X = [[1], [3], [5]], y = [40, 60, 80].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [3], [5]])\ny = np.array([40, 60, 80])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f}x + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Apply standardization before regression: X = [[5, 100], [10, 200], [15, 300]], y = [1, 2, 3].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\nX = np.array([[5, 100], [10, 200], [15, 300]])\ny = np.array([1, 2, 3])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a model using square root transformed features: X = [[1], [4], [9]], y = [1, 2, 3].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.sqrt(np.array([[1], [4], [9]]))\ny = np.array([1, 2, 3])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f} * sqrt(x) + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Fit a model on time-indexed data: X = [[1], [2], [3]], y = [10, 12, 15].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3]])\ny = np.array([10, 12, 15])\nmodel = LinearRegression().fit(X, y)\nprint(\"Slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict house price from area and number of bedrooms: X = [[1000, 2], [1500, 3], [2000, 4]], y = [100, 150, 200].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1000, 2], [1500, 3], [2000, 4]])\ny = np.array([100, 150, 200])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients (area, bedrooms):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use linear regression on distance traveled over time: X = [[1], [2], [3]], y = [30, 60, 90].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3]])\ny = np.array([30, 60, 90])\nmodel = LinearRegression().fit(X, y)\nprint(\"Speed (slope):\", model.coef_[0])\nprint(\"Initial offset:\", model.intercept_)"
    },
    {
        "input": "Apply mean normalization before regression: X = [[50], [100], [150]], y = [5, 10, 15].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[50], [100], [150]])\ny = np.array([5, 10, 15])\nX_norm = (X - X.mean()) / (X.max() - X.min())\nmodel = LinearRegression().fit(X_norm, y)\nprint(\"Model: y = {:.2f}x_norm + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Predict crop yield using soil quality and irrigation. X = [[7, 3], [8, 4], [9, 5]], y = [2.5, 3.0, 3.5].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[7, 3], [8, 4], [9, 5]])\ny = np.array([2.5, 3.0, 3.5])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit linear regression on hours studied vs score: X = [[1], [2], [4]], y = [50, 60, 80].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [4]])\ny = np.array([50, 60, 80])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f} * hours + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Predict energy consumption from temperature, humidity, and wind speed. X = [[30, 60, 10], [25, 70, 12], [20, 80, 15]], y = [400, 350, 300].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[30, 60, 10], [25, 70, 12], [20, 80, 15]])\ny = np.array([400, 350, 300])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Perform linear regression after normalizing features: X = [[10, 20], [20, 30], [30, 40]], y = [100, 150, 200].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[10, 20], [20, 30], [30, 40]])\ny = np.array([100, 150, 200])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a regression model with log-transformed features: X = [[1], [10], [100]], y = [2, 5, 9].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.log(np.array([[1], [10], [100]]))\ny = np.array([2, 5, 9])\nmodel = LinearRegression().fit(X, y)\nprint(\"Slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply a square transformation to the features before regression: X = [[2], [3], [4]], y = [4, 9, 16].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.square(np.array([[2], [3], [4]]))\ny = np.array([4, 9, 16])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f}x^2 + {:.2f}\".format(model.coef_[0], model.intercept_))"
    },
    {
        "input": "Use polynomial regression to fit nonlinear data: X = [[1], [2], [3]], y = [2, 8, 18].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[1], [2], [3]])\ny = np.array([2, 8, 18])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict crop yield from rainfall and soil pH using standardized features. X = [[100, 5.5], [200, 6.0], [300, 6.5]], y = [2.0, 2.8, 3.5].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[100, 5.5], [200, 6.0], [300, 6.5]])\ny = np.array([2.0, 2.8, 3.5])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a linear model to log-scaled inputs and outputs. X = [[10], [100], [1000]], y = [100, 1000, 10000].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.log10(np.array([[10], [100], [1000]]))\ny = np.log10(np.array([100, 1000, 10000]))\nmodel = LinearRegression().fit(X, y)\nprint(\"Slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict car mileage from engine size and weight: X = [[1.2, 1000], [1.6, 1200], [2.0, 1400]], y = [20, 18, 15].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1.2, 1000], [1.6, 1200], [2.0, 1400]])\ny = np.array([20, 18, 15])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients (engine, weight):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Perform regression using mean-centered features. X = [[2], [4], [6]], y = [3, 7, 11].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[2], [4], [6]])\ny = np.array([3, 7, 11])\nX_centered = X - X.mean()\nmodel = LinearRegression().fit(X_centered, y)\nprint(\"Coefficient:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a model to predict blood pressure from age and weight. X = [[25, 150], [35, 160], [45, 170]], y = [120, 130, 140].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[25, 150], [35, 160], [45, 170]])\ny = np.array([120, 130, 140])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients (age, weight):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use polynomial regression to predict house prices from square footage: X = [[1000], [1500], [2000]], y = [200000, 300000, 450000].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1000], [1500], [2000]])\ny = np.array([200000, 300000, 450000])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict exam scores based on study time and hours of sleep: X = [[2, 6], [4, 7], [6, 8]], y = [60, 75, 85].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[2, 6], [4, 7], [6, 8]])\ny = np.array([60, 75, 85])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients (study, sleep):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply a log transformation to y values before regression. X = [[1], [2], [3]], y = [2.7, 7.4, 20.1].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3]])\ny = np.log(np.array([2.7, 7.4, 20.1]))\nmodel = LinearRegression().fit(X, y)\nprint(\"Slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict battery life from usage hours and screen brightness. X = [[2, 50], [4, 70], [6, 90]], y = [10, 6, 3].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[2, 50], [4, 70], [6, 90]])\ny = np.array([10, 6, 3])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients (hours, brightness):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use standardized features to fit a model predicting delivery time from distance and traffic index: X = [[5, 30], [10, 40], [15, 50]], y = [15, 25, 35].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\nX = np.array([[5, 30], [10, 40], [15, 50]])\ny = np.array([15, 25, 35])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Perform regression using a square root transformation on features. X = [[1], [4], [9]], y = [2, 4, 6].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.sqrt(np.array([[1], [4], [9]]))\ny = np.array([2, 4, 6])\nmodel = LinearRegression().fit(X, y)\nprint(\"Slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict product sales using ad spend and influencer score. X = [[100, 80], [200, 90], [300, 100]], y = [1000, 2000, 3100].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[100, 80], [200, 90], [300, 100]])\ny = np.array([1000, 2000, 3100])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use polynomial regression (degree=2) to model relationship between ad clicks and revenue. X = [[10], [20], [30]], y = [50, 150, 300].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[10], [20], [30]])\ny = np.array([50, 150, 300])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a model to log-transformed house prices using number of bedrooms and bathrooms. X = [[2, 1], [3, 2], [4, 3]], y = [200000, 300000, 500000].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[2, 1], [3, 2], [4, 3]])\ny = np.log(np.array([200000, 300000, 500000]))\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict gas usage based on temperature and usage time. X = [[30, 1], [25, 2], [20, 3]], y = [10, 15, 20].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[30, 1], [25, 2], [20, 3]])\ny = np.array([10, 15, 20])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients (temp, time):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply z-score normalization and fit a linear model: X = [[3, 6], [4, 8], [5, 10]], y = [12, 16, 20].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\nX = np.array([[3, 6], [4, 8], [5, 10]])\ny = np.array([12, 16, 20])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict machine failure probability based on age and usage. X = [[1, 100], [2, 200], [3, 300]], y = [0.1, 0.3, 0.6].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1, 100], [2, 200], [3, 300]])\ny = np.array([0.1, 0.3, 0.6])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients (age, usage):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use log(x1 * x2) transformation and predict outcomes. X = [[1, 2], [2, 4], [3, 6]], y = [1, 2, 3].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX_raw = np.array([[1, 2], [2, 4], [3, 6]])\nX_trans = np.log(np.prod(X_raw, axis=1)).reshape(-1, 1)\ny = np.array([1, 2, 3])\nmodel = LinearRegression().fit(X_trans, y)\nprint(\"Slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Model sales as a function of advertising on TV and radio. X = [[100, 20], [200, 30], [300, 40]], y = [400, 800, 1200].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[100, 20], [200, 30], [300, 40]])\ny = np.array([400, 800, 1200])\nmodel = LinearRegression().fit(X, y)\nprint(\"TV coef:\", model.coef_[0])\nprint(\"Radio coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict crop yield using fertilizer and rainfall with polynomial regression (degree=2). X = [[100, 20], [150, 30], [200, 40]], y = [2, 3.5, 5.5].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[100, 20], [150, 30], [200, 40]])\ny = np.array([2, 3.5, 5.5])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Standardize inputs before fitting model to predict grades from study hours and sleep. X = [[2, 6], [4, 7], [6, 8]], y = [65, 75, 85].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\nX = np.array([[2, 6], [4, 7], [6, 8]])\ny = np.array([65, 75, 85])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a model with square root transformation on both predictors. X = [[1, 4], [4, 16], [9, 36]], y = [1.5, 3.0, 4.5].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.sqrt(np.array([[1, 4], [4, 16], [9, 36]]))\ny = np.array([1.5, 3.0, 4.5])\nmodel = LinearRegression().fit(X, y)\nprint(\"Square-root transformed coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply log-log regression: log(y) vs log(x). X = [[10], [100], [1000]], y = [2, 20, 200].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.log(np.array([[10], [100], [1000]]))\ny = np.log(np.array([2, 20, 200]))\nmodel = LinearRegression().fit(X, y)\nprint(\"Log-log slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use mean-normalized features to predict test scores from hours studied. X = [[1], [2], [3]], y = [50, 65, 80].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1], [2], [3]])\ny = np.array([50, 65, 80])\nX_centered = X - np.mean(X, axis=0)\nmodel = LinearRegression().fit(X_centered, y)\nprint(\"Slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict reaction time from caffeine intake (mg) and sleep (hrs). X = [[50, 6], [100, 5], [200, 4]], y = [1.2, 1.0, 0.8].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[50, 6], [100, 5], [200, 4]])\ny = np.array([1.2, 1.0, 0.8])\nmodel = LinearRegression().fit(X, y)\nprint(\"Caffeine coef:\", model.coef_[0])\nprint(\"Sleep coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Model log(yield) from fertilizer amount using log(fertilizer). X = [[10], [20], [40]], y = [1, 3, 6].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.log(np.array([[10], [20], [40]]))\ny = np.log(np.array([1, 3, 6]))\nmodel = LinearRegression().fit(X, y)\nprint(\"Log-log slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use linear regression on binary features: is_smoker, drinks_coffee to predict productivity. X = [[1, 1], [1, 0], [0, 1], [0, 0]], y = [50, 55, 60, 70].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1, 1], [1, 0], [0, 1], [0, 0]])\ny = np.array([50, 55, 60, 70])\nmodel = LinearRegression().fit(X, y)\nprint(\"Smoker coef:\", model.coef_[0])\nprint(\"Coffee coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Standardize a single feature and fit a regression: X = [[1], [2], [3]], y = [10, 20, 30].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\nX = np.array([[1], [2], [3]])\ny = np.array([10, 20, 30])\nscaler = StandardScaler()\nX_std = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_std, y)\nprint(\"Standardized coef:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit regression to predict weight from height and age. X = [[160, 25], [170, 30], [180, 35]], y = [60, 70, 80].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[160, 25], [170, 30], [180, 35]])\ny = np.array([60, 70, 80])\nmodel = LinearRegression().fit(X, y)\nprint(\"Height coef:\", model.coef_[0])\nprint(\"Age coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use transformed feature 1/x to model decay rate. X = [[1], [2], [4]], y = [0.9, 0.6, 0.3].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = 1 / np.array([[1], [2], [4]])\ny = np.array([0.9, 0.6, 0.3])\nmodel = LinearRegression().fit(X, y)\nprint(\"Decay slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict battery life using screen-on time and number of apps open. X = [[3, 10], [5, 15], [7, 20]], y = [10, 7, 4].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[3, 10], [5, 15], [7, 20]])\ny = np.array([10, 7, 4])\nmodel = LinearRegression().fit(X, y)\nprint(\"Screen time coef:\", model.coef_[0])\nprint(\"Apps coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a model to predict final grade based on assignments, quizzes, and midterm scores. X = [[80, 70, 75], [85, 80, 78], [90, 85, 82]], y = [78, 83, 88].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[80, 70, 75], [85, 80, 78], [90, 85, 82]])\ny = np.array([78, 83, 88])\nmodel = LinearRegression().fit(X, y)\nprint(\"Assignment coef:\", model.coef_[0])\nprint(\"Quiz coef:\", model.coef_[1])\nprint(\"Midterm coef:\", model.coef_[2])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Standardize data and predict cholesterol from fat and sugar intake. X = [[60, 30], [70, 40], [80, 50]], y = [180, 200, 220].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\nX = np.array([[60, 30], [70, 40], [80, 50]])\ny = np.array([180, 200, 220])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use square root transformation on X and fit model to predict energy from time. X = [[1], [4], [9]], y = [10, 20, 30].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.sqrt(np.array([[1], [4], [9]]))\ny = np.array([10, 20, 30])\nmodel = LinearRegression().fit(X, y)\nprint(\"Sqrt transformed slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a model using 2nd-degree polynomial on temperature to predict ice cream sales. X = [[20], [25], [30]], y = [100, 200, 400].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[20], [25], [30]])\ny = np.array([100, 200, 400])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply log transform on X to predict brightness from aperture size. X = [[1.4], [2.8], [5.6]], y = [100, 50, 25].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.log(np.array([[1.4], [2.8], [5.6]]))\ny = np.array([100, 50, 25])\nmodel = LinearRegression().fit(X, y)\nprint(\"Log-transformed slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Model price based on square footage and number of rooms. X = [[1000, 2], [1500, 3], [2000, 4]], y = [200000, 300000, 400000].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1000, 2], [1500, 3], [2000, 4]])\ny = np.array([200000, 300000, 400000])\nmodel = LinearRegression().fit(X, y)\nprint(\"Sqft coef:\", model.coef_[0])\nprint(\"Rooms coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict electricity usage from number of devices and hours used. X = [[3, 5], [4, 6], [5, 7]], y = [15, 20, 25].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[3, 5], [4, 6], [5, 7]])\ny = np.array([15, 20, 25])\nmodel = LinearRegression().fit(X, y)\nprint(\"Devices coef:\", model.coef_[0])\nprint(\"Hours coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a linear model where predictors are mean-subtracted. X = [[10], [20], [30]], y = [100, 200, 300].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[10], [20], [30]])\ny = np.array([100, 200, 300])\nX_mean = X - np.mean(X, axis=0)\nmodel = LinearRegression().fit(X_mean, y)\nprint(\"Centered slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict CO2 emissions from engine size and fuel consumption. X = [[1.2, 5], [1.6, 7], [2.0, 9]], y = [120, 150, 180].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1.2, 5], [1.6, 7], [2.0, 9]])\ny = np.array([120, 150, 180])\nmodel = LinearRegression().fit(X, y)\nprint(\"Engine coef:\", model.coef_[0])\nprint(\"Fuel coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use polynomial features of degree 2 to model house price from area. X = [[1000], [1500], [2000]], y = [150000, 225000, 325000].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nX = np.array([[1000], [1500], [2000]])\ny = np.array([150000, 225000, 325000])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Polynomial coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a model to predict heart rate from exercise duration and intensity level. X = [[30, 3], [45, 5], [60, 7]], y = [100, 130, 160].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[30, 3], [45, 5], [60, 7]])\ny = np.array([100, 130, 160])\nmodel = LinearRegression().fit(X, y)\nprint(\"Duration coef:\", model.coef_[0])\nprint(\"Intensity coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict weight based on height and age. X = [[160, 25], [170, 30], [180, 35]], y = [60, 70, 80].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[160, 25], [170, 30], [180, 35]])\ny = np.array([60, 70, 80])\nmodel = LinearRegression().fit(X, y)\nprint(\"Height coef:\", model.coef_[0])\nprint(\"Age coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Apply normalization before predicting rent from area and distance to city. X = [[600, 5], [800, 3], [1000, 2]], y = [1000, 1300, 1600].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[600, 5], [800, 3], [1000, 2]])\ny = np.array([1000, 1300, 1600])\nscaler = MinMaxScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict fuel efficiency using horsepower and weight. X = [[100, 2500], [150, 3000], [200, 3500]], y = [30, 25, 20].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[100, 2500], [150, 3000], [200, 3500]])\ny = np.array([30, 25, 20])\nmodel = LinearRegression().fit(X, y)\nprint(\"Horsepower coef:\", model.coef_[0])\nprint(\"Weight coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use log(y) transformation for population prediction based on income and employment rate. X = [[30000, 80], [40000, 85], [50000, 90]], y = [5000, 10000, 20000].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[30000, 80], [40000, 85], [50000, 90]])\ny = np.log(np.array([5000, 10000, 20000]))\nmodel = LinearRegression().fit(X, y)\nprint(\"Log-transformed population coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict temperature drop from altitude and humidity. X = [[500, 30], [1000, 40], [1500, 50]], y = [20, 15, 10].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[500, 30], [1000, 40], [1500, 50]])\ny = np.array([20, 15, 10])\nmodel = LinearRegression().fit(X, y)\nprint(\"Altitude coef:\", model.coef_[0])\nprint(\"Humidity coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a model for sales prediction using advertising on TV and online. X = [[50, 30], [60, 40], [70, 50]], y = [200, 250, 300].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[50, 30], [60, 40], [70, 50]])\ny = np.array([200, 250, 300])\nmodel = LinearRegression().fit(X, y)\nprint(\"TV coef:\", model.coef_[0])\nprint(\"Online coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Standardize predictors before fitting a model for crop output based on sunlight and water. X = [[5, 10], [6, 15], [7, 20]], y = [50, 70, 90].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[5, 10], [6, 15], [7, 20]])\ny = np.array([50, 70, 90])\nscaler = StandardScaler()\nX_std = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_std, y)\nprint(\"Standardized coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Model CO2 emissions from distance traveled and fuel used. X = [[100, 5], [200, 10], [300, 15]], y = [50, 100, 150].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[100, 5], [200, 10], [300, 15]])\ny = np.array([50, 100, 150])\nmodel = LinearRegression().fit(X, y)\nprint(\"Distance coef:\", model.coef_[0])\nprint(\"Fuel coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Use polynomial features of degree 2 to model volume from dimensions. X = [[1, 2], [2, 3], [3, 4]], y = [2, 6, 12].",
        "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1, 2], [2, 3], [3, 4]])\ny = np.array([2, 6, 12])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Polynomial coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict delivery time from package weight and delivery distance. X = [[1, 10], [2, 20], [3, 30]], y = [15, 30, 45].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[1, 10], [2, 20], [3, 30]])\ny = np.array([15, 30, 45])\nmodel = LinearRegression().fit(X, y)\nprint(\"Weight coef:\", model.coef_[0])\nprint(\"Distance coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit model to predict rating based on reviews and views. X = [[100, 1000], [200, 2000], [300, 3000]], y = [3.5, 4.0, 4.5].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[100, 1000], [200, 2000], [300, 3000]])\ny = np.array([3.5, 4.0, 4.5])\nmodel = LinearRegression().fit(X, y)\nprint(\"Reviews coef:\", model.coef_[0])\nprint(\"Views coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Predict weight loss from time spent walking and calorie deficit. X = [[30, 500], [60, 800], [90, 1000]], y = [1, 2, 3].",
        "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nX = np.array([[30, 500], [60, 800], [90, 1000]])\ny = np.array([1, 2, 3])\nmodel = LinearRegression().fit(X, y)\nprint(\"Time coef:\", model.coef_[0])\nprint(\"Deficit coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
    },
    {
        "input": "Fit a model to predict final grade based on midterm and attendance: X = [[80, 90], [85, 95], [70, 60], [90, 100]], y = [88, 92, 75, 95].",
        "output": "import numpy as np\nX = np.array([[80, 90], [85, 95], [70, 60], [90, 100]])\ny = np.array([88, 92, 75, 95])\nX_aug = np.hstack([X, np.ones((X.shape[0], 1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Grade = {params[0]:.4f}*Midterm + {params[1]:.4f}*Attendance + {params[2]:.4f}\")"
    },
    {
        "input": "Use least squares to fit the function y = a*log(x) + b to x = [1, 2, 4, 8], y = [0, 0.69, 1.38, 2.07].",
        "output": "import numpy as np\nx = np.array([1, 2, 4, 8])\ny = np.array([0, 0.69, 1.38, 2.07])\nX = np.vstack([np.log(x), np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*log(x) + {params[1]:.4f}\")"
    },
    {
        "input": "Fit a least squares model to temperature over hours: x = [0, 4, 8, 12, 16, 20], y = [30, 35, 45, 55, 50, 40].",
        "output": "import numpy as np\nx = np.array([0, 4, 8, 12, 16, 20])\ny = np.array([30, 35, 45, 55, 50, 40])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"Temperature = {params[0]:.4f}*Hour + {params[1]:.4f}\")"
    },
    {
        "input": "Estimate parameters in model y = a*x^2 + b*x for x = [1, 2, 3, 4], y = [3, 7, 13, 21].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([3, 7, 13, 21])\nX = np.vstack([x**2, x]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*x^2 + {params[1]:.4f}*x\")"
    },
    {
        "input": "Apply least squares to normalize data by fitting a line to z-scores of x = [10, 20, 30, 40], y = [15, 25, 35, 45].",
        "output": "import numpy as np\nx = np.array([10, 20, 30, 40])\ny = np.array([15, 25, 35, 45])\nx_norm = (x - x.mean()) / x.std()\nX = np.vstack([x_norm, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*z_x + {params[1]:.4f}\")"
    },
    {
        "input": "Use least squares to fit a model with squared and cube terms: x = [1, 2, 3], y = [2, 9, 28].",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([2, 9, 28])\nX = np.vstack([x**3, x**2, x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*x^3 + {params[1]:.4f}*x^2 + {params[2]:.4f}*x + {params[3]:.4f}\")"
    },
    {
        "input": "Fit a linear regression model to predict distance from time and speed: X = [[1, 10], [2, 15], [3, 20]], y = [10, 30, 60].",
        "output": "import numpy as np\nX = np.array([[1, 10], [2, 15], [3, 20]])\ny = np.array([10, 30, 60])\nX_aug = np.hstack([X, np.ones((X.shape[0], 1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Distance = {params[0]:.4f}*Time + {params[1]:.4f}*Speed + {params[2]:.4f}\")"
    },
    {
        "input": "Fit a model y = ax^2 + bx + c to x = [0, 1, 2, 3], y = [1, 2, 5, 10].",
        "output": "import numpy as np\nx = np.array([0, 1, 2, 3])\ny = np.array([1, 2, 5, 10])\nX = np.vstack([x**2, x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*x^2 + {params[1]:.4f}*x + {params[2]:.4f}\")"
    },
    {
        "input": "Estimate linear trend from seasonal sales data: x = [1, 2, 3, 4], y = [110, 150, 200, 250].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([110, 150, 200, 250])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"Sales = {params[0]:.4f}*Month + {params[1]:.4f}\")"
    },
    {
        "input": "Fit model y = a/x + b for x = [1, 2, 3, 4], y = [4, 2.5, 2, 1.8].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([4, 2.5, 2, 1.8])\nX = np.vstack([1/x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*(1/x) + {params[1]:.4f}\")"
    },
    {
        "input": "Given x = [1, 2, 3, 4], y = [2, 4, 6, 10], fit y = a*x + b using least squares.",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([2, 4, 6, 10])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*x + {params[1]:.4f}\")"
    },
    {
        "input": "Fit model to data with negative correlation: x = [1, 2, 3, 4], y = [10, 8, 6, 4].",
        "output": "import numpy as np\nx = np.array([1, 2, 3, 4])\ny = np.array([10, 8, 6, 4])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"Negative correlation model: y = {params[0]:.4f}*x + {params[1]:.4f}\")"
    },
    {
        "input": "Perform regression with engineered feature x^2 on x = [1, 2, 3], y = [2, 5, 10].",
        "output": "import numpy as np\nx = np.array([1, 2, 3])\ny = np.array([2, 5, 10])\nX = np.vstack([x**2, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*x^2 + {params[1]:.4f}\")"
    },
    {
        "input": "Predict if a student will pass (1) or fail (0) based on study hours using logistic regression. X = [[2], [4], [6], [8], [10]], y = [0, 0, 1, 1, 1].",
        "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\nX = np.array([[2], [4], [6], [8], [10]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(f\"Predicted probabilities: {model.predict_proba([[5], [7], [9]])[:,1]}\")"
    },
    {
        "input": "Use logistic regression to classify tumors as benign (0) or malignant (1) based on size. X = [[1.2], [2.3], [3.1], [3.8], [5.0]], y = [0, 0, 1, 1, 1].",
        "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\nX = np.array([[1.2], [2.3], [3.1], [3.8], [5.0]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\npred = model.predict([[2.5], [4.5]])\nprint(f\"Predictions: {pred}\")"
    },
    {
        "input": "Logistic regression to predict if a customer buys a product based on advertisement time. X = [[0.5], [1.0], [1.5], [2.0], [2.5]], y = [0, 0, 1, 1, 1].",
        "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\nX = np.array([[0.5], [1.0], [1.5], [2.0], [2.5]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Probability of purchase after 1.8 hours:\", model.predict_proba([[1.8]])[0,1])"
    },
    {
        "input": "Binary classification using logistic regression: Predict disease presence based on cholesterol levels. X = [[180], [190], [200], [210], [220]], y = [0, 0, 1, 1, 1].",
        "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\nX = np.array([[180], [190], [200], [210], [220]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Probability of disease at cholesterol 195:\", model.predict_proba([[195]])[0,1])"
    },
    {
        "input": "Logistic regression: Predict email spam status from number of links. X = [[1], [2], [3], [4], [5]], y = [0, 0, 1, 1, 1].",
        "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Spam probability with 3 links:\", model.predict_proba([[3]])[0,1])"
    },
    {
        "input": "Logistic regression: Classify customer satisfaction (0 = unsatisfied, 1 = satisfied) using service rating. X = [[1], [2], [3], [4], [5]], y = [0, 0, 1, 1, 1].",
        "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Probability of satisfaction at rating 3:\", model.predict_proba([[3]])[0,1])"
    },
    {
        "input": "Use Poisson regression to predict daily calls based on working hours. X = [[4], [6], [8], [10], [12]], y = [2, 4, 6, 8, 10].",
        "output": "from sklearn.linear_model import PoissonRegressor\nimport numpy as np\nX = np.array([[4], [6], [8], [10], [12]])\ny = np.array([2, 4, 6, 8, 10])\nmodel = PoissonRegressor()\nmodel.fit(X, y)\nprint(\"Predicted calls for 9 hours:\", model.predict([[9]])[0])"
    },
    {
        "input": "Logistic regression to predict whether a customer subscribes (1) or not (0) based on call duration. X = [[1], [3], [5], [7], [9]], y = [0, 0, 1, 1, 1].",
        "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\nX = np.array([[1], [3], [5], [7], [9]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Subscription probability for 6 mins:\", model.predict_proba([[6]])[0,1])"
    },
    {
        "input": "Poisson regression: Model foot traffic at a store from number of ads shown. X = [[1], [2], [3], [4], [5]], y = [5, 10, 15, 20, 25].",
        "output": "from sklearn.linear_model import PoissonRegressor\nimport numpy as np\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([5, 10, 15, 20, 25])\nmodel = PoissonRegressor()\nmodel.fit(X, y)\nprint(\"Predicted visits for 6 ads:\", model.predict([[6]])[0])"
    },
    {
        "input": "Use logistic regression to classify email as spam (1) or not (0) based on number of attachments. X = [[0], [1], [2], [3], [4]], y = [0, 0, 1, 1, 1].",
        "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\nX = np.array([[0], [1], [2], [3], [4]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Spam probability with 2 attachments:\", model.predict_proba([[2]])[0,1])"
    },
    {
        "input": "Poisson regression: Predict number of app downloads from ad impressions. X = [[100], [200], [300], [400], [500]], y = [1, 3, 6, 9, 11].",
        "output": "from sklearn.linear_model import PoissonRegressor\nimport numpy as np\nX = np.array([[100], [200], [300], [400], [500]])\ny = np.array([1, 3, 6, 9, 11])\nmodel = PoissonRegressor()\nmodel.fit(X, y)\nprint(\"Downloads for 350 impressions:\", model.predict([[350]])[0])"
    },
    {
        "input": "Logistic regression: Predict if a loan will default (1) or not (0) using applicant’s credit score. X = [[600], [620], [640], [680], [720]], y = [1, 1, 0, 0, 0].",
        "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\nX = np.array([[600], [620], [640], [680], [720]])\ny = np.array([1, 1, 0, 0, 0])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Default probability at score 660:\", model.predict_proba([[660]])[0,1])"
    },
    {
        "input": "Poisson regression: Predict average purchases per visit from hours spent browsing. X = [[1], [2], [3], [4], [5]], y = [1, 3, 5, 7, 9].",
        "output": "from sklearn.linear_model import PoissonRegressor\nimport numpy as np\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([1, 3, 5, 7, 9])\nmodel = PoissonRegressor()\nmodel.fit(X, y)\nprint(\"Predicted purchases for 3.5 hours:\", model.predict([[3.5]])[0])"
    },
    {
        "input": "Logistic regression: Predict if user clicks on an ad (1) or not (0) based on scroll depth. X = [[10], [20], [30], [40], [50]], y = [0, 0, 1, 1, 1].",
        "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\nX = np.array([[10], [20], [30], [40], [50]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Click probability at scroll depth 25:\", model.predict_proba([[25]])[0,1])"
    },
    {
        "input": "Poisson regression: Predict number of support tickets filed based on number of users. X = [[100], [200], [300], [400], [500]], y = [1, 2, 3, 5, 8].",
        "output": "from sklearn.linear_model import PoissonRegressor\nimport numpy as np\nX = np.array([[100], [200], [300], [400], [500]])\ny = np.array([1, 2, 3, 5, 8])\nmodel = PoissonRegressor()\nmodel.fit(X, y)\nprint(\"Predicted tickets for 350 users:\", model.predict([[350]])[0])"
    },
    {
        "input": "Logistic regression: Predict whether an exam is passed (1) or failed (0) using revision hours. X = [[1], [2], [3], [4], [5]], y = [0, 0, 1, 1, 1].",
        "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Pass probability at 3.5 hours:\", model.predict_proba([[3.5]])[0,1])"
    },
    {
        "input": "Poisson regression: Predict number of texts sent daily based on age. X = [[18], [22], [26], [30], [34]], y = [50, 45, 40, 30, 20].",
        "output": "from sklearn.linear_model import PoissonRegressor\nimport numpy as np\nX = np.array([[18], [22], [26], [30], [34]])\ny = np.array([50, 45, 40, 30, 20])\nmodel = PoissonRegressor()\nmodel.fit(X, y)\nprint(\"Predicted texts for age 28:\", model.predict([[28]])[0])"
    },
    {
        "input": "Logistic regression: Predict whether a machine breaks down (1) or not (0) based on load factor. X = [[10], [20], [30], [40], [50]], y = [0, 0, 0, 1, 1].",
        "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\nX = np.array([[10], [20], [30], [40], [50]])\ny = np.array([0, 0, 0, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Breakdown probability at 35:\", model.predict_proba([[35]])[0,1])"
    },
    {
        "input": "Poisson regression: Predict number of likes on a post from number of hashtags. X = [[1], [2], [3], [4], [5]], y = [3, 6, 10, 13, 15].",
        "output": "from sklearn.linear_model import PoissonRegressor\nimport numpy as np\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([3, 6, 10, 13, 15])\nmodel = PoissonRegressor()\nmodel.fit(X, y)\nprint(\"Likes predicted for 6 hashtags:\", model.predict([[6]])[0])"
    },
    {
        "input": "Logistic regression: Predict binary outcome of churn (1) vs retention (0) using number of complaints. X = [[0], [1], [2], [3], [4]], y = [0, 0, 1, 1, 1].",
        "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\nX = np.array([[0], [1], [2], [3], [4]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Churn probability with 2 complaints:\", model.predict_proba([[2]])[0,1])"
    },
    {
        "input": "Poisson regression: Predict number of retweets based on tweet length. X = [[20], [40], [60], [80], [100]], y = [5, 8, 11, 13, 15].",
        "output": "from sklearn.linear_model import PoissonRegressor\nimport numpy as np\nX = np.array([[20], [40], [60], [80], [100]])\ny = np.array([5, 8, 11, 13, 15])\nmodel = PoissonRegressor()\nmodel.fit(X, y)\nprint(\"Predicted retweets for 75 chars:\", model.predict([[75]])[0])"
    },
    {
        "input": "Perform a Cholesky decomposition of the matrix A = [[4, 2], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[4, 2], [2, 3]])\nL = np.linalg.cholesky(A)\nprint(\"Cholesky factor L:\\n\", L)"
    },
    {
        "input": "Check if matrix B = [[25, 15, -5], [15, 18, 0], [-5, 0, 11]] can be decomposed using Cholesky method and show the result.",
        "output": "import numpy as np\nB = np.array([[25, 15, -5], [15, 18, 0], [-5, 0, 11]])\nL = np.linalg.cholesky(B)\nprint(\"Cholesky factor L:\\n\", L)"
    },
    {
        "input": "Generate a symmetric positive definite matrix C of size 4x4 and perform Cholesky decomposition.",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(4, 4)\nC = np.dot(A, A.T) + 4*np.eye(4)\nL = np.linalg.cholesky(C)\nprint(\"Symmetric positive definite matrix C:\\n\", C)\nprint(\"Cholesky factor L:\\n\", L)"
    },
    {
        "input": "Use Cholesky decomposition to solve the linear system Ax = b, where A = [[6, 15], [15, 55]], b = [1, 2].",
        "output": "import numpy as np\nA = np.array([[6, 15], [15, 55]])\nb = np.array([1, 2])\nL = np.linalg.cholesky(A)\ny = np.linalg.solve(L, b)\nx = np.linalg.solve(L.T, y)\nprint(\"Solution x:\\n\", x)"
    },
    {
        "input": "Verify that L @ L.T reconstructs the original matrix A = [[9, 3], [3, 5]].",
        "output": "import numpy as np\nA = np.array([[9, 3], [3, 5]])\nL = np.linalg.cholesky(A)\nA_reconstructed = L @ L.T\nprint(\"Reconstructed A:\\n\", A_reconstructed)"
    },
    {
        "input": "Construct a block matrix using Cholesky-decomposed submatrices and verify it remains positive definite.",
        "output": "import numpy as np\nA = np.array([[4, 1], [1, 3]])\nB = np.array([[2, 0], [0, 1]])\nblock = np.block([[A, np.zeros((2, 2))], [np.zeros((2, 2)), B]])\nL = np.linalg.cholesky(block)\nprint(\"Block matrix:\\n\", block)\nprint(\"Cholesky factor:\\n\", L)"
    },
    {
        "input": "Find the Cholesky decomposition of the covariance matrix of dataset X = [[2.0, 3.0], [3.0, 4.0], [4.0, 6.0]].",
        "output": "import numpy as np\nX = np.array([[2.0, 3.0], [3.0, 4.0], [4.0, 6.0]])\nCov = np.cov(X.T)\nL = np.linalg.cholesky(Cov)\nprint(\"Covariance matrix:\\n\", Cov)\nprint(\"Cholesky factor:\\n\", L)"
    },
    {
        "input": "Use Cholesky decomposition to simulate samples from a multivariate normal distribution with mean=[0,0] and given covariance matrix.",
        "output": "import numpy as np\nmean = np.array([0, 0])\ncov = np.array([[2, 1], [1, 2]])\nL = np.linalg.cholesky(cov)\nsamples = np.random.randn(5, 2) @ L.T + mean\nprint(\"Simulated samples:\\n\", samples)"
    },
    {
        "input": "Given matrix A = [[10, 2, 3], [2, 5, 1], [3, 1, 6]], compute its Cholesky factor and verify the reconstruction.",
        "output": "import numpy as np\nA = np.array([[10, 2, 3], [2, 5, 1], [3, 1, 6]])\nL = np.linalg.cholesky(A)\nA_recon = L @ L.T\nprint(\"Cholesky factor L:\\n\", L)\nprint(\"Reconstructed A:\\n\", A_recon)"
    },
    {
        "input": "Use Cholesky decomposition to compute the inverse of a symmetric positive definite matrix A = [[4, 1], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[4, 1], [1, 3]])\nL = np.linalg.cholesky(A)\ninv_L = np.linalg.inv(L)\ninv_A = inv_L.T @ inv_L\nprint(\"Inverse of A using Cholesky:\\n\", inv_A)"
    },
    {
        "input": "Use Cholesky decomposition to efficiently solve a least squares problem with A.T @ A where A = [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nb = np.array([1, 2, 3])\nAtA = A.T @ A\nAtb = A.T @ b\nL = np.linalg.cholesky(AtA)\ny = np.linalg.solve(L, Atb)\nx = np.linalg.solve(L.T, y)\nprint(\"Least squares solution using Cholesky:\\n\", x)"
    },
    {
        "input": "Given a symmetric matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]], perform Cholesky decomposition.",
        "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\nL = np.linalg.cholesky(A)\nprint(\"Cholesky factor L:\\n\", L)"
    },
    {
        "input": "Write a function to perform Cholesky decomposition from scratch for a 3x3 matrix.",
        "output": "import numpy as np\ndef cholesky_manual(A):\n    n = A.shape[0]\n    L = np.zeros_like(A)\n    for i in range(n):\n        for j in range(i+1):\n            temp_sum = np.dot(L[i,:j], L[j,:j])\n            if i == j:\n                L[i,j] = np.sqrt(A[i,i] - temp_sum)\n            else:\n                L[i,j] = (A[i,j] - temp_sum) / L[j,j]\n    return L\nA = np.array([[4, 2, 2], [2, 2, 1], [2, 1, 3]])\nL = cholesky_manual(A)\nprint(\"Manual Cholesky factor:\\n\", L)"
    },
    {
        "input": "Use Cholesky decomposition to precondition a system Ax = b for faster CG convergence, A = [[6, 2], [2, 5]], b = [2, 1].",
        "output": "import numpy as np\nfrom scipy.sparse.linalg import cg\nA = np.array([[6, 2], [2, 5]])\nb = np.array([2, 1])\nL = np.linalg.cholesky(A)\nM_inv = np.linalg.inv(L).T @ np.linalg.inv(L)\nx, _ = cg(A, b, M=M_inv)\nprint(\"Preconditioned CG solution:\\n\", x)"
    },
    {
        "input": "Decompose matrix A = [[2, 1], [1, 2]] and verify each entry of L manually matches formula.",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\nL = np.linalg.cholesky(A)\nprint(\"L[0,0] = sqrt(2):\", np.sqrt(2))\nprint(\"L[1,0] = 1/sqrt(2):\", 1/np.sqrt(2))\nprint(\"L[1,1] = sqrt(2 - (1/sqrt(2))^2):\", np.sqrt(2 - (1/np.sqrt(2))**2))\nprint(\"Computed L:\\n\", L)"
    },
    {
        "input": "Generate a 5x5 positive definite matrix with random entries and compute its Cholesky factor.",
        "output": "import numpy as np\nnp.random.seed(1)\nA = np.random.randn(5, 5)\nA = A @ A.T + 5*np.eye(5)\nL = np.linalg.cholesky(A)\nprint(\"Cholesky factor L:\\n\", L)"
    },
    {
        "input": "Use Cholesky to solve a real-world linear regression problem: Fit y = Xw using normal equations with decomposition.",
        "output": "import numpy as np\nX = np.array([[1, 1], [1, 2], [1, 3]])\ny = np.array([1, 2, 2.5])\nXtX = X.T @ X\nXty = X.T @ y\nL = np.linalg.cholesky(XtX)\nz = np.linalg.solve(L, Xty)\nw = np.linalg.solve(L.T, z)\nprint(\"Regression weights using Cholesky:\\n\", w)"
    },
    {
        "input": "For matrix A = [[10, 2], [2, 2]], test Cholesky decomposition, then regularize it slightly if it fails.",
        "output": "import numpy as np\nA = np.array([[10, 2], [2, 2]])\ntry:\n    L = np.linalg.cholesky(A)\nexcept np.linalg.LinAlgError:\n    A += 1e-4 * np.eye(2)\n    L = np.linalg.cholesky(A)\nprint(\"Regularized matrix:\\n\", A)\nprint(\"Cholesky factor:\\n\", L)"
    },
    {
        "input": "Use Factor Analysis to reduce a dataset X of 4D features into 2 latent factors. X = [[2.5, 0.5, 2.2, 1.9], [1.9, 1.1, 2.3, 2.1], [3.1, 0.7, 2.9, 1.8]]",
        "output": "from sklearn.decomposition import FactorAnalysis\nimport numpy as np\nX = np.array([[2.5, 0.5, 2.2, 1.9], [1.9, 1.1, 2.3, 2.1], [3.1, 0.7, 2.9, 1.8]])\nfa = FactorAnalysis(n_components=2)\nX_reduced = fa.fit_transform(X)\nprint(\"Reduced representation (Factor Analysis):\\n\", X_reduced)"
    },
    {
        "input": "Apply NMF on a non-negative matrix X = [[1, 2], [3, 4], [5, 6]] and reduce it to 2 components.",
        "output": "from sklearn.decomposition import NMF\nimport numpy as np\nX = np.array([[1, 2], [3, 4], [5, 6]])\nnmf = NMF(n_components=2, init='random', random_state=0)\nW = nmf.fit_transform(X)\nH = nmf.components_\nprint(\"W (document-topic matrix):\\n\", W)\nprint(\"H (topic-word matrix):\\n\", H)"
    },
    {
        "input": "Reduce a 5D dataset to 3 latent variables using Factor Analysis. X = random 100x5 matrix.",
        "output": "from sklearn.decomposition import FactorAnalysis\nimport numpy as np\nX = np.random.rand(100, 5)\nfa = FactorAnalysis(n_components=3)\nX_latent = fa.fit_transform(X)\nprint(\"Latent 3D representation:\\n\", X_latent[:5])"
    },
    {
        "input": "Generate synthetic non-negative data and apply NMF to find latent topics. Use sklearn.datasets.make_multilabel_classification.",
        "output": "from sklearn.datasets import make_multilabel_classification\nfrom sklearn.decomposition import NMF\nX, _ = make_multilabel_classification(n_samples=50, n_features=10, random_state=0)\nnmf = NMF(n_components=4)\nW = nmf.fit_transform(X)\nprint(\"Latent features using NMF:\\n\", W[:5])"
    },
    {
        "input": "Compare the reconstruction quality between original and reduced data from Factor Analysis on a 50x6 dataset.",
        "output": "import numpy as np\nfrom sklearn.decomposition import FactorAnalysis\nX = np.random.randn(50, 6)\nfa = FactorAnalysis(n_components=3)\nX_reduced = fa.fit_transform(X)\nX_reconstructed = X_reduced @ fa.components_ + fa.mean_\nerror = np.mean((X - X_reconstructed)**2)\nprint(\"Reconstruction MSE:\", error)"
    },
    {
        "input": "Apply Factor Analysis to financial data (mock data) to identify underlying market factors.",
        "output": "import numpy as np\nfrom sklearn.decomposition import FactorAnalysis\nreturns = np.random.randn(100, 5)\nfa = FactorAnalysis(n_components=2)\nfactors = fa.fit_transform(returns)\nprint(\"Market factors extracted:\\n\", factors[:5])"
    },
    {
        "input": "Perform Factor Analysis and compare with PCA for the same 5D dataset.",
        "output": "import numpy as np\nfrom sklearn.decomposition import PCA, FactorAnalysis\nX = np.random.randn(100, 5)\npca = PCA(n_components=2)\nfa = FactorAnalysis(n_components=2)\nX_pca = pca.fit_transform(X)\nX_fa = fa.fit_transform(X)\nprint(\"PCA Result:\\n\", X_pca[:3])\nprint(\"Factor Analysis Result:\\n\", X_fa[:3])"
    },
    {
        "input": "Apply NMF on a music spectrogram (simulated matrix) to separate sources.",
        "output": "import numpy as np\nfrom sklearn.decomposition import NMF\nnp.random.seed(0)\nspectrogram = np.abs(np.random.randn(50, 20))\nnmf = NMF(n_components=3)\nW = nmf.fit_transform(spectrogram)\nprint(\"Decomposed components (sources):\\n\", W[:5])"
    },
    {
        "input": "Use Factor Analysis to denoise data with 10 noisy dimensions.",
        "output": "from sklearn.decomposition import FactorAnalysis\nimport numpy as np\nX = np.random.randn(100, 10) + 0.3*np.random.randn(100, 10)\nfa = FactorAnalysis(n_components=3)\nX_clean = fa.fit_transform(X)\nprint(\"Denoised representation:\\n\", X_clean[:5])"
    },
    {
        "input": "Apply NMF with sparse output on document-term matrix using l1_ratio.",
        "output": "from sklearn.decomposition import NMF\nimport numpy as np\nX = np.random.randint(0, 4, (10, 6))\nnmf = NMF(n_components=2, l1_ratio=0.9)\nW = nmf.fit_transform(X)\nprint(\"Sparse NMF components:\\n\", W)"
    },
    {
        "input": "Use NMF on a large sparse matrix and visualize the compressed topic matrix.",
        "output": "from sklearn.decomposition import NMF\nimport numpy as np\nX = np.random.poisson(1.0, (100, 50))\nnmf = NMF(n_components=5)\nW = nmf.fit_transform(X)\nprint(\"Topic space representation:\\n\", W[:5])"
    },
    {
        "input": "Compute the dot product of vectors [1, 2, 3] and [4, 5, 6].",
        "output": "import numpy as np\nvector_a = np.array([1, 2, 3])\nvector_b = np.array([4, 5, 6])\ndot_product = np.dot(vector_a, vector_b)\nprint(dot_product)"
    },
    {
        "input": "Compute the cross product of vectors [1, 0, 0] and [0, 1, 0].",
        "output": "import numpy as np\nvector_a = np.array([1, 0, 0])\nvector_b = np.array([0, 1, 0])\ncross_product = np.cross(vector_a, vector_b)\nprint(cross_product)"
    },
    {
        "input": "Compute the Hadamard product (element-wise multiplication) of matrices [[1, 2], [3, 4]] and [[5, 6], [7, 8]].",
        "output": "import numpy as np\nmatrix_a = np.array([[1, 2], [3, 4]])\nmatrix_b = np.array([[5, 6], [7, 8]])\nhadamard_product = np.multiply(matrix_a, matrix_b)\nprint(hadamard_product)"
    },
    {
        "input": "Compute the trace of the matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ntrace = np.trace(matrix)\nprint(trace)"
    },
    {
        "input": "Reshape the vector [1, 2, 3, 4, 5, 6] into a 2x3 matrix.",
        "output": "import numpy as np\nvector = np.array([1, 2, 3, 4, 5, 6])\nreshaped_matrix = vector.reshape(2, 3)\nprint(reshaped_matrix)"
    },
    {
        "input": "Flatten the matrix [[1, 2], [3, 4]] into a vector.",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nflattened_vector = matrix.flatten()\nprint(flattened_vector)"
    },
    {
        "input": "Compute the rank of the matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(rank)"
    },
    {
        "input": "Compute the singular value decomposition (SVD) of the matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nU, S, Vt = np.linalg.svd(matrix)\nprint('U:', U)\nprint('Singular values:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Compute the Moore-Penrose pseudoinverse of the matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\npseudoinverse = np.linalg.pinv(matrix)\nprint(pseudoinverse)"
    },
    {
        "input": "Compute the sum of the elements in the vector [1, 2, 3, 4, 5].",
        "output": "import numpy as np\nvector = np.array([1, 2, 3, 4, 5])\nsum_of_elements = np.sum(vector)\nprint(sum_of_elements)"
    },
    {
        "input": "Compute the outer product of vectors [1, 2, 3] and [4, 5, 6].",
        "output": "import numpy as np\nvector_a = np.array([1, 2, 3])\nvector_b = np.array([4, 5, 6])\nouter_product = np.outer(vector_a, vector_b)\nprint(outer_product)"
    },
    {
        "input": "Extract the diagonal elements from the matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ndiagonal_elements = np.diag(matrix)\nprint(diagonal_elements)"
    },
    {
        "input": "Create a 3x3 identity matrix.",
        "output": "import numpy as np\nidentity_matrix = np.eye(3)\nprint(identity_matrix)"
    },
    {
        "input": "Compute the upper triangular part of the matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nupper_triangular = np.triu(matrix)\nprint(upper_triangular)"
    },
    {
        "input": "Compute the determinant of the matrix [[2, 3], [1, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3], [1, 4]])\ndeterminant = np.linalg.det(matrix)\nprint(determinant)"
    },
    {
        "input": "Compute the inverse of the matrix [[2, 3], [1, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 3], [1, 4]])\ninverse_matrix = np.linalg.inv(matrix)\nprint(inverse_matrix)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix [[2, -1], [-1, 2]].",
        "output": "import numpy as np\nmatrix = np.array([[2, -1], [-1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(matrix)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the Kronecker product of matrices [[1, 2], [3, 4]] and [[0, 5], [6, 7]].",
        "output": "import numpy as np\nmatrix_a = np.array([[1, 2], [3, 4]])\nmatrix_b = np.array([[0, 5], [6, 7]])\nkronecker_product = np.kron(matrix_a, matrix_b)\nprint(kronecker_product)"
    },
    {
        "input": "Create a 3x3 tensor filled with the value 7.",
        "output": "import numpy as np\ntensor = np.full((3, 3), 7)\nprint(tensor)"
    },
    {
        "input": "Compute the element-wise square of matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nsquared_matrix = np.square(matrix)\nprint(squared_matrix)"
    },
    {
        "input": "Create a 3D tensor of shape (2, 2, 2) with sequential values starting from 1.",
        "output": "import numpy as np\ntensor = np.arange(1, 9).reshape((2, 2, 2))\nprint(tensor)"
    },
    {
        "input": "Compute the transpose of the 2D matrix [[1, 2, 3], [4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\ntransposed = matrix.T\nprint(transposed)"
    },
    {
        "input": "Generate a 4x4 diagonal matrix with diagonal values [1, 2, 3, 4].",
        "output": "import numpy as np\ndiagonal_matrix = np.diag([1, 2, 3, 4])\nprint(diagonal_matrix)"
    },
    {
        "input": "Create a 3x3x3 tensor with random integers between 1 and 10.",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.randint(1, 11, (3, 3, 3))\nprint(tensor)"
    },
    {
        "input": "Find the maximum value in the tensor [[[1, 5], [3, 9]], [[2, 4], [6, 8]]].",
        "output": "import numpy as np\ntensor = np.array([[[1, 5], [3, 9]], [[2, 4], [6, 8]]])\nmax_val = np.max(tensor)\nprint(max_val)"
    },
    {
        "input": "Compute the mean of all elements in a tensor of shape (2, 2, 2) with values from 1 to 8.",
        "output": "import numpy as np\ntensor = np.arange(1, 9).reshape((2, 2, 2))\nmean_val = np.mean(tensor)\nprint(mean_val)"
    },
    {
        "input": "Add two 3x3 tensors: one filled with 1s and another with 2s.",
        "output": "import numpy as np\na = np.ones((3, 3))\nb = np.full((3, 3), 2)\nresult = a + b\nprint(result)"
    },
    {
        "input": "Compute the sum along the first axis of the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
        "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nsum_axis0 = np.sum(tensor, axis=0)\nprint(sum_axis0)"
    },
    {
        "input": "Compute the sum along the second axis of the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
        "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nsum_axis1 = np.sum(tensor, axis=1)\nprint(sum_axis1)"
    },
    {
        "input": "Compute the mean along the last axis of the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
        "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nmean_last_axis = np.mean(tensor, axis=-1)\nprint(mean_last_axis)"
    },
    {
        "input": "Create a tensor of shape (2, 2, 2) filled with zeros.",
        "output": "import numpy as np\ntensor = np.zeros((2, 2, 2))\nprint(tensor)"
    },
    {
        "input": "Create a tensor of shape (2, 2, 2) filled with ones.",
        "output": "import numpy as np\ntensor = np.ones((2, 2, 2))\nprint(tensor)"
    },
    {
        "input": "Replace all elements greater than 5 in the tensor [[2, 6], [7, 4]] with 0.",
        "output": "import numpy as np\ntensor = np.array([[2, 6], [7, 4]])\ntensor[tensor > 5] = 0\nprint(tensor)"
    },
    {
        "input": "Stack two matrices [[1, 2], [3, 4]] and [[5, 6], [7, 8]] vertically.",
        "output": "import numpy as np\na = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6], [7, 8]])\nstacked = np.vstack((a, b))\nprint(stacked)"
    },
    {
        "input": "Stack two matrices [[1, 2], [3, 4]] and [[5, 6], [7, 8]] horizontally.",
        "output": "import numpy as np\na = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6], [7, 8]])\nstacked = np.hstack((a, b))\nprint(stacked)"
    },
    {
        "input": "Split the matrix [[1, 2, 3, 4], [5, 6, 7, 8]] into two along the columns.",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])\nsplit = np.hsplit(matrix, 2)\nfor part in split:\n    print(part)"
    },
    {
        "input": "Find the indices of non-zero elements in the matrix [[0, 1], [2, 0]].",
        "output": "import numpy as np\nmatrix = np.array([[0, 1], [2, 0]])\nindices = np.nonzero(matrix)\nprint(indices)"
    },
    {
        "input": "Round each element in the tensor [[1.2, 3.8], [4.5, 6.1]] to the nearest integer.",
        "output": "import numpy as np\ntensor = np.array([[1.2, 3.8], [4.5, 6.1]])\nrounded = np.rint(tensor)\nprint(rounded)"
    },
    {
        "input": "Compute the cumulative sum of elements in the vector [1, 2, 3, 4].",
        "output": "import numpy as np\nvector = np.array([1, 2, 3, 4])\ncumsum = np.cumsum(vector)\nprint(cumsum)"
    },
    {
        "input": "Sort each row of the matrix [[3, 1], [4, 2]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 1], [4, 2]])\nsorted_matrix = np.sort(matrix, axis=1)\nprint(sorted_matrix)"
    },
    {
        "input": "Compute the standard deviation of all elements in the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
        "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nstd_dev = np.std(tensor)\nprint(std_dev)"
    },
    {
        "input": "Clip the values in the matrix [[1, 8], [3, 10]] to be between 2 and 9.",
        "output": "import numpy as np\nmatrix = np.array([[1, 8], [3, 10]])\nclipped = np.clip(matrix, 2, 9)\nprint(clipped)"
    },
    {
        "input": "Get the shape of the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
        "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nshape = tensor.shape\nprint(shape)"
    },
    {
        "input": "Find the minimum value in the tensor [[3, 7], [1, 5]].",
        "output": "import numpy as np\ntensor = np.array([[3, 7], [1, 5]])\nmin_val = np.min(tensor)\nprint(min_val)"
    },
    {
        "input": "Broadcast a 1D array [1, 2] to match the shape of a 2x2 matrix.",
        "output": "import numpy as np\nvector = np.array([1, 2])\nresult = vector + np.zeros((2, 2))\nprint(result)"
    },
    {
        "input": "Reshape a 3x2 matrix [[1, 2], [3, 4], [5, 6]] into a 2x3 matrix.",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4], [5, 6]])\nreshaped = matrix.reshape(2, 3)\nprint(reshaped)"
    },
    {
        "input": "Create an identity matrix of size 4x4.",
        "output": "import numpy as np\nidentity = np.eye(4)\nprint(identity)"
    },
    {
        "input": "Generate a 5x5 matrix of random floats between 0 and 1.",
        "output": "import numpy as np\nnp.random.seed(0)\nmatrix = np.random.rand(5, 5)\nprint(matrix)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[2, 0], [0, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 0], [0, 3]])\neigenvalues, _ = np.linalg.eig(matrix)\nprint(eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of the matrix [[2, 0], [0, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 0], [0, 3]])\n_, eigenvectors = np.linalg.eig(matrix)\nprint(eigenvectors)"
    },
    {
        "input": "Repeat the vector [1, 2, 3] two times along a new axis.",
        "output": "import numpy as np\nvector = np.array([1, 2, 3])\nrepeated = np.tile(vector, (2, 1))\nprint(repeated)"
    },
    {
        "input": "Compute the inverse of the matrix [[4, 7], [2, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 7], [2, 6]])\ninverse = np.linalg.inv(matrix)\nprint(inverse)"
    },
    {
        "input": "Create a 1D tensor with values from 10 to 100 in steps of 10.",
        "output": "import numpy as np\ntensor = np.arange(10, 101, 10)\nprint(tensor)"
    },
    {
        "input": "Reshape a 1D array of size 12 into shape (3, 2, 2).",
        "output": "import numpy as np\narray = np.arange(1, 13)\nreshaped = array.reshape((3, 2, 2))\nprint(reshaped)"
    },
    {
        "input": "Swap the axes 0 and 1 of the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
        "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nswapped = np.swapaxes(tensor, 0, 1)\nprint(swapped)"
    },
    {
        "input": "Reverse the elements of the vector [1, 2, 3, 4, 5].",
        "output": "import numpy as np\nvector = np.array([1, 2, 3, 4, 5])\nreversed_vector = vector[::-1]\nprint(reversed_vector)"
    },
    {
        "input": "Multiply a 2x2 matrix [[1, 2], [3, 4]] by scalar 3.",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nresult = matrix * 3\nprint(result)"
    },
    {
        "input": "Generate a tensor of shape (2, 3) with values drawn from a standard normal distribution.",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.randn(2, 3)\nprint(tensor)"
    },
    {
        "input": "Flatten the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
        "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nflattened = tensor.flatten()\nprint(flattened)"
    },
    {
        "input": "Convert a list [[1, 2], [3, 4]] into a NumPy array.",
        "output": "import numpy as np\narray = np.array([[1, 2], [3, 4]])\nprint(array)"
    },
    {
        "input": "Get the number of dimensions of tensor [[1, 2], [3, 4]].",
        "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\ndimensions = tensor.ndim\nprint(dimensions)"
    },
    {
        "input": "Set the diagonal of a 3x3 zero matrix to [1, 2, 3].",
        "output": "import numpy as np\nmatrix = np.zeros((3, 3))\nnp.fill_diagonal(matrix, [1, 2, 3])\nprint(matrix)"
    },
    {
        "input": "Compute the outer product of vectors [1, 2] and [3, 4].",
        "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\nouter = np.outer(a, b)\nprint(outer)"
    },
    {
        "input": "Compute the inner product of vectors [1, 2] and [3, 4].",
        "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\ninner = np.inner(a, b)\nprint(inner)"
    },
    {
        "input": "Convert the tensor [[1.0, 2.5], [3.7, 4.2]] to integers.",
        "output": "import numpy as np\ntensor = np.array([[1.0, 2.5], [3.7, 4.2]])\nint_tensor = tensor.astype(int)\nprint(int_tensor)"
    },
    {
        "input": "Pad a 2x2 matrix [[1, 2], [3, 4]] with zeros on all sides.",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\npadded = np.pad(matrix, pad_width=1, mode='constant')\nprint(padded)"
    },
    {
        "input": "Create a 2x3 matrix with all elements set to 9.",
        "output": "import numpy as np\nmatrix = np.full((2, 3), 9)\nprint(matrix)"
    },
    {
        "input": "Create a 3x3 matrix with random integers from 0 to 20.",
        "output": "import numpy as np\nnp.random.seed(0)\nmatrix = np.random.randint(0, 21, size=(3, 3))\nprint(matrix)"
    },
    {
        "input": "Extract the diagonal of the matrix [[4, 5], [6, 7]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 5], [6, 7]])\ndiagonal = np.diag(matrix)\nprint(diagonal)"
    },
    {
        "input": "Find the maximum value in the matrix [[1, 9], [4, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 9], [4, 6]])\nmax_val = np.max(matrix)\nprint(max_val)"
    },
    {
        "input": "Create a 1D array with 8 evenly spaced values between 0 and 1.",
        "output": "import numpy as np\narray = np.linspace(0, 1, 8)\nprint(array)"
    },
    {
        "input": "Count the number of non-zero elements in the array [[0, 1, 2], [3, 0, 4]].",
        "output": "import numpy as np\narray = np.array([[0, 1, 2], [3, 0, 4]])\ncount = np.count_nonzero(array)\nprint(count)"
    },
    {
        "input": "Compute the sum of diagonal elements in the matrix [[2, 1], [4, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 1], [4, 3]])\ndiag_sum = np.trace(matrix)\nprint(diag_sum)"
    },
    {
        "input": "Create a 4x4 identity matrix using np.identity.",
        "output": "import numpy as np\nidentity = np.identity(4)\nprint(identity)"
    },
    {
        "input": "Repeat each element of the array [1, 2, 3] three times.",
        "output": "import numpy as np\narray = np.array([1, 2, 3])\nrepeated = np.repeat(array, 3)\nprint(repeated)"
    },
    {
        "input": "Extract elements from [10, 20, 30, 40, 50] at even indices.",
        "output": "import numpy as np\narray = np.array([10, 20, 30, 40, 50])\nevens = array[::2]\nprint(evens)"
    },
    {
        "input": "Tile the array [1, 2] to form a 2x4 matrix.",
        "output": "import numpy as np\narray = np.array([1, 2])\ntiled = np.tile(array, (2, 2))\nprint(tiled)"
    },
    {
        "input": "Get the index of the maximum element in the array [4, 9, 1, 7].",
        "output": "import numpy as np\narray = np.array([4, 9, 1, 7])\nindex = np.argmax(array)\nprint(index)"
    },
    {
        "input": "Get the index of the minimum element in the array [4, 9, 1, 7].",
        "output": "import numpy as np\narray = np.array([4, 9, 1, 7])\nindex = np.argmin(array)\nprint(index)"
    },
    {
        "input": "Round down all elements in [1.2, 3.8, 4.5] to nearest lower integer.",
        "output": "import numpy as np\narray = np.array([1.2, 3.8, 4.5])\nfloored = np.floor(array)\nprint(floored)"
    },
    {
        "input": "Round up all elements in [1.2, 3.8, 4.5] to nearest higher integer.",
        "output": "import numpy as np\narray = np.array([1.2, 3.8, 4.5])\nceiled = np.ceil(array)\nprint(ceiled)"
    },
    {
        "input": "Create a diagonal matrix from the list [5, 10, 15].",
        "output": "import numpy as np\nvalues = np.array([5, 10, 15])\ndiagonal_matrix = np.diag(values)\nprint(diagonal_matrix)"
    },
    {
        "input": "Create a 1D array of 6 zeros.",
        "output": "import numpy as np\narray = np.zeros(6)\nprint(array)"
    },
    {
        "input": "Create a 2D tensor filled with the value 7 of shape (3, 3).",
        "output": "import numpy as np\ntensor = np.full((3, 3), 7)\nprint(tensor)"
    },
    {
        "input": "Convert a NumPy array [1, 2, 3] to a Python list.",
        "output": "import numpy as np\narray = np.array([1, 2, 3])\npy_list = array.tolist()\nprint(py_list)"
    },
    {
        "input": "Generate a 1D array of 5 random integers between 1 and 10.",
        "output": "import numpy as np\nnp.random.seed(0)\nrandom_array = np.random.randint(1, 11, size=5)\nprint(random_array)"
    },
    {
        "input": "Transpose the matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ntransposed = matrix.T\nprint(transposed)"
    },
    {
        "input": "Create a 1D array of 10 linearly spaced numbers from 0 to 5.",
        "output": "import numpy as np\narray = np.linspace(0, 5, 10)\nprint(array)"
    },
    {
        "input": "Stack arrays [1, 2] and [3, 4] vertically.",
        "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\nstacked = np.vstack((a, b))\nprint(stacked)"
    },
    {
        "input": "Stack arrays [1, 2] and [3, 4] horizontally.",
        "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\nstacked = np.hstack((a, b))\nprint(stacked)"
    },
    {
        "input": "Element-wise divide matrix [[4, 8], [6, 2]] by 2.",
        "output": "import numpy as np\nmatrix = np.array([[4, 8], [6, 2]])\nresult = matrix / 2\nprint(result)"
    },
    {
        "input": "Add two matrices [[1, 2], [3, 4]] and [[5, 6], [7, 8]].",
        "output": "import numpy as np\na = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6], [7, 8]])\nsum_matrix = a + b\nprint(sum_matrix)"
    },
    {
        "input": "Subtract matrix [[2, 1], [0, 3]] from [[5, 4], [2, 6]].",
        "output": "import numpy as np\na = np.array([[5, 4], [2, 6]])\nb = np.array([[2, 1], [0, 3]])\ndiff = a - b\nprint(diff)"
    },
    {
        "input": "Multiply matrices [[1, 2], [3, 4]] and [[2, 0], [1, 2]].",
        "output": "import numpy as np\na = np.array([[1, 2], [3, 4]])\nb = np.array([[2, 0], [1, 2]])\nproduct = np.dot(a, b)\nprint(product)"
    },
    {
        "input": "Create a 2x2 matrix from flat list [1, 2, 3, 4].",
        "output": "import numpy as np\nflat_list = [1, 2, 3, 4]\nmatrix = np.array(flat_list).reshape(2, 2)\nprint(matrix)"
    },
    {
        "input": "Clip values in [0, 5, 10, 15] to be between 3 and 12.",
        "output": "import numpy as np\narray = np.array([0, 5, 10, 15])\nclipped = np.clip(array, 3, 12)\nprint(clipped)"
    },
    {
        "input": "Normalize the array [2, 4, 6] by dividing each value by the max.",
        "output": "import numpy as np\narray = np.array([2, 4, 6])\nnormalized = array / np.max(array)\nprint(normalized)"
    },
    {
        "input": "Find the mean of the array [4, 8, 6, 10].",
        "output": "import numpy as np\narray = np.array([4, 8, 6, 10])\nmean_val = np.mean(array)\nprint(mean_val)"
    },
    {
        "input": "Find the standard deviation of [2, 4, 4, 4, 5, 5, 7, 9].",
        "output": "import numpy as np\narray = np.array([2, 4, 4, 4, 5, 5, 7, 9])\nstd_dev = np.std(array)\nprint(std_dev)"
    },
    {
        "input": "Find the median of the array [3, 5, 1, 2, 4].",
        "output": "import numpy as np\narray = np.array([3, 5, 1, 2, 4])\nmedian_val = np.median(array)\nprint(median_val)"
    },
    {
        "input": "Replace all values > 10 in [5, 12, 7, 15] with 10.",
        "output": "import numpy as np\narray = np.array([5, 12, 7, 15])\narray[array > 10] = 10\nprint(array)"
    },
    {
        "input": "Reshape a 1D array [1, 2, 3, 4, 5, 6] into shape (2, 3).",
        "output": "import numpy as np\narray = np.array([1, 2, 3, 4, 5, 6])\nreshaped = array.reshape(2, 3)\nprint(reshaped)"
    },
    {
        "input": "Sort the array [4, 2, 9, 1] in ascending order.",
        "output": "import numpy as np\narray = np.array([4, 2, 9, 1])\nsorted_array = np.sort(array)\nprint(sorted_array)"
    },
    {
        "input": "Reverse the array [1, 2, 3, 4].",
        "output": "import numpy as np\narray = np.array([1, 2, 3, 4])\nreversed_array = array[::-1]\nprint(reversed_array)"
    },
    {
        "input": "Find unique elements in [1, 2, 2, 3, 4, 4, 4].",
        "output": "import numpy as np\narray = np.array([1, 2, 2, 3, 4, 4, 4])\nunique_vals = np.unique(array)\nprint(unique_vals)"
    },
    {
        "input": "Broadcast scalar 3 over a 2x2 zero matrix.",
        "output": "import numpy as np\nmatrix = np.zeros((2, 2))\nresult = matrix + 3\nprint(result)"
    },
    {
        "input": "Square each element in [1, 2, 3, 4].",
        "output": "import numpy as np\narray = np.array([1, 2, 3, 4])\nsquared = np.square(array)\nprint(squared)"
    },
    {
        "input": "Create an array with values from 5 to 14.",
        "output": "import numpy as np\narray = np.arange(5, 15)\nprint(array)"
    },
    {
        "input": "Compute the cumulative sum of [1, 2, 3, 4].",
        "output": "import numpy as np\narray = np.array([1, 2, 3, 4])\ncumsum = np.cumsum(array)\nprint(cumsum)"
    },
    {
        "input": "Compute the cumulative product of [1, 2, 3, 4].",
        "output": "import numpy as np\narray = np.array([1, 2, 3, 4])\ncumprod = np.cumprod(array)\nprint(cumprod)"
    },
    {
        "input": "Create a 3x3 matrix with values from 1 to 9.",
        "output": "import numpy as np\nmatrix = np.arange(1, 10).reshape(3, 3)\nprint(matrix)"
    },
    {
        "input": "Replace all odd numbers in [1, 2, 3, 4, 5] with -1.",
        "output": "import numpy as np\narray = np.array([1, 2, 3, 4, 5])\narray[array % 2 == 1] = -1\nprint(array)"
    },
    {
        "input": "Flatten the matrix [[1, 2], [3, 4]] into 1D.",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nflattened = matrix.flatten()\nprint(flattened)"
    },
    {
        "input": "Find the shape of the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
        "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nprint(tensor.shape)"
    },
    {
        "input": "Create a 3x1 column vector with values [1, 2, 3].",
        "output": "import numpy as np\nvector = np.array([1, 2, 3]).reshape(3, 1)\nprint(vector)"
    },
    {
        "input": "Create a 1x3 row vector with values [1, 2, 3].",
        "output": "import numpy as np\nvector = np.array([1, 2, 3]).reshape(1, 3)\nprint(vector)"
    },
    {
        "input": "Generate a 3x3 matrix with random integers between 0 and 5.",
        "output": "import numpy as np\nnp.random.seed(0)\nmatrix = np.random.randint(0, 6, (3, 3))\nprint(matrix)"
    },
    {
        "input": "Find the sum of each column in [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ncol_sum = np.sum(matrix, axis=0)\nprint(col_sum)"
    },
    {
        "input": "Find the sum of each row in [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nrow_sum = np.sum(matrix, axis=1)\nprint(row_sum)"
    },
    {
        "input": "Find the dot product of [1, 2] and [3, 4].",
        "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\ndot = np.dot(a, b)\nprint(dot)"
    },
    {
        "input": "Find the element-wise maximum of [1, 5, 3] and [2, 4, 6].",
        "output": "import numpy as np\na = np.array([1, 5, 3])\nb = np.array([2, 4, 6])\nresult = np.maximum(a, b)\nprint(result)"
    },
    {
        "input": "Find the element-wise minimum of [1, 5, 3] and [2, 4, 6].",
        "output": "import numpy as np\na = np.array([1, 5, 3])\nb = np.array([2, 4, 6])\nresult = np.minimum(a, b)\nprint(result)"
    },
    {
        "input": "Compute the sum of the vector [1, 2, 3, 4, 5].",
        "output": "import numpy as np\nvector = np.array([1, 2, 3, 4, 5])\nresult = np.sum(vector)\nprint(result)"
    },
    {
        "input": "Extract the diagonal elements of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nresult = np.diag(matrix)\nprint(result)"
    },
    {
        "input": "Compute the upper triangular part of a 3x3 matrix filled with ones.",
        "output": "import numpy as np\nmatrix = np.ones((3, 3))\nresult = np.triu(matrix)\nprint(result)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix [[4, -2], [1, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[4, -2], [1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(matrix)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Solve the system of linear equations: x + y = 2 and x - y = 0.",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, -1]])\nB = np.array([2, 0])\nresult = np.linalg.solve(A, B)\nprint(result)"
    },
    {
        "input": "Compute the inverse of the matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nresult = np.linalg.inv(matrix)\nprint(result)"
    },
    {
        "input": "Create a 2x3 tensor filled with zeros.",
        "output": "import numpy as np\ntensor = np.zeros((2, 3))\nprint(tensor)"
    },
    {
        "input": "Create a 3-dimensional tensor of shape (2, 2, 2) filled with random integers from 0 to 9.",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.randint(0, 10, size=(2, 2, 2))\nprint(tensor)"
    },
    {
        "input": "Reshape the array [1, 2, 3, 4, 5, 6] into a 2x3 tensor.",
        "output": "import numpy as np\narray = np.array([1, 2, 3, 4, 5, 6])\ntensor = array.reshape(2, 3)\nprint(tensor)"
    },
    {
        "input": "Transpose the matrix [[1, 2, 3], [4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\nresult = np.transpose(matrix)\nprint(result)"
    },
    {
        "input": "Compute the dot product of vectors [1, 3] and [2, 4].",
        "output": "import numpy as np\nvector1 = np.array([1, 3])\nvector2 = np.array([2, 4])\nresult = np.dot(vector1, vector2)\nprint(result)"
    },
    {
        "input": "Broadcast a 1D tensor [1, 2, 3] to a 3x3 tensor.",
        "output": "import numpy as np\narray = np.array([1, 2, 3])\nbroadcasted = np.tile(array, (3, 1))\nprint(broadcasted)"
    },
    {
        "input": "Flatten a 2x3 tensor [[1, 2, 3], [4, 5, 6]] into a 1D array.",
        "output": "import numpy as np\ntensor = np.array([[1, 2, 3], [4, 5, 6]])\nflattened = tensor.flatten()\nprint(flattened)"
    },
    {
        "input": "Multiply each element of the tensor [[1, 2], [3, 4]] by 5.",
        "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\nresult = tensor * 5\nprint(result)"
    },
    {
        "input": "Add two tensors [[1, 2], [3, 4]] and [[5, 6], [7, 8]].",
        "output": "import numpy as np\ntensor1 = np.array([[1, 2], [3, 4]])\ntensor2 = np.array([[5, 6], [7, 8]])\nresult = tensor1 + tensor2\nprint(result)"
    },
    {
        "input": "Compute the Frobenius norm of the matrix [[1, -2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, -2], [3, 4]])\nresult = np.linalg.norm(matrix, 'fro')\nprint(result)"
    },
    {
        "input": "Find the rank of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nresult = np.linalg.matrix_rank(matrix)\nprint(result)"
    },
    {
        "input": "Calculate the trace of the matrix [[5, 1, 2], [0, 3, -1], [4, 6, 8]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 1, 2], [0, 3, -1], [4, 6, 8]])\nresult = np.trace(matrix)\nprint(result)"
    },
    {
        "input": "Solve the system of equations: 2x + 3y + z = 1, 4x + y - z = -1, -x + 2y + 5z = 2.",
        "output": "import numpy as np\nA = np.array([[2, 3, 1], [4, 1, -1], [-1, 2, 5]])\nB = np.array([1, -1, 2])\nresult = np.linalg.solve(A, B)\nprint(result)"
    },
    {
        "input": "Compute the singular value decomposition (SVD) of the matrix [[3, 2, 2], [2, 3, -2]].",
        "output": "import numpy as np\nmatrix = np.array([[3, 2, 2], [2, 3, -2]])\nU, S, Vt = np.linalg.svd(matrix)\nprint('U:', U)\nprint('Singular values:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Find the Moore-Penrose pseudoinverse of the matrix [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4], [5, 6]])\nresult = np.linalg.pinv(matrix)\nprint(result)"
    },
    {
        "input": "Compute the determinant of the 3x3 matrix [[2, -1, 0], [1, 3, 2], [0, 1, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[2, -1, 0], [1, 3, 2], [0, 1, 1]])\nresult = np.linalg.det(matrix)\nprint(result)"
    },
    {
        "input": "Calculate the eigenvalues and eigenvectors of the matrix [[4, -2, 1], [-2, 4, -2], [1, -2, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[4, -2, 1], [-2, 4, -2], [1, -2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(matrix)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the Cholesky decomposition of the matrix [[4, 12, -16], [12, 37, -43], [-16, -43, 98]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 12, -16], [12, 37, -43], [-16, -43, 98]])\nresult = np.linalg.cholesky(matrix)\nprint(result)"
    },
    {
        "input": "Find the LU decomposition of the matrix [[7, 8], [3, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import lu\nmatrix = np.array([[7, 8], [3, 5]])\nP, L, U = lu(matrix)\nprint('P:', P)\nprint('L:', L)\nprint('U:', U)"
    },
    {
        "input": "Compute the QR decomposition of the matrix [[12, -51, 4], [6, 167, -68], [-4, 24, -41]].",
        "output": "import numpy as np\nmatrix = np.array([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])\nQ, R = np.linalg.qr(matrix)\nprint('Q:', Q)\nprint('R:', R)"
    },
    {
        "input": "Calculate the Hadamard product (element-wise multiplication) of matrices [[1, 2], [3, 4]] and [[5, 6], [7, 8]].",
        "output": "import numpy as np\nmatrix1 = np.array([[1, 2], [3, 4]])\nmatrix2 = np.array([[5, 6], [7, 8]])\nresult = np.multiply(matrix1, matrix2)\nprint(result)"
    },
    {
        "input": "Extract a sub-tensor from the 3D tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]] consisting only of the second 2x2 matrix.",
        "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nsub_tensor = tensor[1]\nprint(sub_tensor)"
    },
    {
        "input": "Compute the matrix exponential of [[0, 1], [-1, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import expm\nmatrix = np.array([[0, 1], [-1, 0]])\nresult = expm(matrix)\nprint(result)"
    },
    {
        "input": "Perform a tensor contraction on tensors A and B, where A has shape (2,3,4) and B has shape (4,3,2), over the last axis of A and the first axis of B.",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(2,3,4)\nB = np.random.rand(4,3,2)\nresult = np.tensordot(A, B, axes=([2,1], [0,1]))\nprint(result)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 symmetric matrix [[2, -1], [-1, 2]]",
        "output": "import numpy as np\nmatrix = np.array([[2, -1], [-1, 2]])\neigenvalues = np.linalg.eigvals(matrix)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Perform a batch matrix multiplication of two tensors: shape (10, 3, 4) and (10, 4, 2).",
        "output": "import numpy as np\nnp.random.seed(0)\na = np.random.rand(10, 3, 4)\nb = np.random.rand(10, 4, 2)\nresult = np.matmul(a, b)\nprint(result.shape)"
    },
    {
        "input": "Compute the norm of a rank-3 tensor [[[1,2], [3,4]], [[5,6], [7,8]]].",
        "output": "import numpy as np\ntensor = np.array([[[1,2], [3,4]], [[5,6], [7,8]]])\nresult = np.linalg.norm(tensor)\nprint(result)"
    },
    {
        "input": "Project the vector [3, 4] onto the vector [1, 0].",
        "output": "import numpy as np\na = np.array([3, 4])\nb = np.array([1, 0])\nprojection = (np.dot(a, b) / np.dot(b, b)) * b\nprint(projection)"
    },
    {
        "input": "Compute the rank-1 approximation of matrix [[1, 2], [3, 4]] using SVD.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nU, S, Vt = np.linalg.svd(A, full_matrices=False)\nrank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nprint(rank1)"
    },
    {
        "input": "Create a block matrix [[A, B], [C, D]] where A, B, C, D are 2x2 identity matrices.",
        "output": "import numpy as np\nI = np.eye(2)\nresult = np.block([[I, I], [I, I]])\nprint(result)"
    },
    {
        "input": "Compute the inverse of a 2x2 matrix [[4, 7], [2, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 7], [2, 6]])\ninverse = np.linalg.inv(matrix)\nprint(inverse)"
    },
    {
        "input": "Perform element-wise division of tensors [[10, 20], [30, 40]] and [[2, 4], [5, 8]].",
        "output": "import numpy as np\na = np.array([[10, 20], [30, 40]])\nb = np.array([[2, 4], [5, 8]])\nresult = np.divide(a, b)\nprint(result)"
    },
    {
        "input": "Generate a 4x4 identity matrix and compute its determinant.",
        "output": "import numpy as np\nidentity = np.eye(4)\ndet = np.linalg.det(identity)\nprint(det)"
    },
    {
        "input": "Generate a 3D tensor of shape (3, 3, 3) with values from 1 to 27 and slice out the middle 2D matrix.",
        "output": "import numpy as np\ntensor = np.arange(1, 28).reshape(3, 3, 3)\nmiddle_slice = tensor[1]\nprint(middle_slice)"
    },
    {
        "input": "Find the outer product of vectors [1, 2, 3] and [4, 5].",
        "output": "import numpy as np\na = np.array([1, 2, 3])\nb = np.array([4, 5])\nresult = np.outer(a, b)\nprint(result)"
    },
    {
        "input": "Convert the 2D array [[1, 2], [3, 4]] to a 3D tensor by adding a new axis at the beginning.",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ntensor = matrix[np.newaxis, :, :]\nprint(tensor)"
    },
    {
        "input": "Given a 3x3 matrix, compute its cofactor matrix.",
        "output": "import numpy as np\nfrom numpy.linalg import det\nA = np.array([[1, 2, 3], [0, 4, 5], [1, 0, 6]])\ncofactors = np.zeros_like(A)\nfor i in range(3):\n    for j in range(3):\n        minor = np.delete(np.delete(A, i, axis=0), j, axis=1)\n        cofactors[i, j] = ((-1)**(i + j)) * det(minor)\nprint(cofactors)"
    },
    {
        "input": "Find the tensor product (outer product) of two matrices [[1, 0], [0, 1]] and [[2, 3], [4, 5]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1]])\nB = np.array([[2, 3], [4, 5]])\nresult = np.tensordot(A, B, axes=0)\nprint(result)"
    },
    {
        "input": "Create a random symmetric 3x3 matrix.",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(3, 3)\nsymmetric_matrix = (A + A.T) / 2\nprint(symmetric_matrix)"
    },
    {
        "input": "Rotate the 2D tensor [[1, 2], [3, 4]] by 90 degrees counter-clockwise.",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nrotated = np.rot90(matrix)\nprint(rotated)"
    },
    {
        "input": "Create a diagonal matrix from the vector [7, 8, 9].",
        "output": "import numpy as np\nvector = np.array([7, 8, 9])\ndiagonal_matrix = np.diag(vector)\nprint(diagonal_matrix)"
    },
    {
        "input": "Compute the sum along axis 0 of the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
        "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nsum_axis0 = np.sum(tensor, axis=0)\nprint(sum_axis0)"
    },
    {
        "input": "Find the tensor shape of a reshaped 1D array with 27 elements into (3, 3, 3).",
        "output": "import numpy as np\ntensor = np.arange(27).reshape(3, 3, 3)\nprint(tensor.shape)"
    },
    {
        "input": "Create a 3x3x3 identity-like tensor with ones on the diagonal (i==j==k).",
        "output": "import numpy as np\ntensor = np.zeros((3, 3, 3))\nfor i in range(3):\n    tensor[i, i, i] = 1\nprint(tensor)"
    },
    {
        "input": "Compute the mean of all elements in the tensor [[[2, 4], [6, 8]], [[10, 12], [14, 16]]].",
        "output": "import numpy as np\ntensor = np.array([[[2, 4], [6, 8]], [[10, 12], [14, 16]]])\nmean_value = np.mean(tensor)\nprint(mean_value)"
    },
    {
        "input": "Flatten the tensor [[1, 2], [3, 4]] to a 1D array.",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nflattened = matrix.flatten()\nprint(flattened)"
    },
    {
        "input": "Transpose the last two axes of a tensor with shape (2, 3, 4).",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.rand(2, 3, 4)\ntransposed = np.transpose(tensor, (0, 2, 1))\nprint(transposed.shape)"
    },
    {
        "input": "Clip the values of a tensor [[-1, 5], [10, -3]] between 0 and 6.",
        "output": "import numpy as np\ntensor = np.array([[-1, 5], [10, -3]])\nclipped = np.clip(tensor, 0, 6)\nprint(clipped)"
    },
    {
        "input": "Broadcast a 1D array [1, 2, 3] to shape (3, 3).",
        "output": "import numpy as np\narray = np.array([1, 2, 3])\nresult = np.broadcast_to(array, (3, 3))\nprint(result)"
    },
    {
        "input": "Pad a 2D tensor [[1, 2], [3, 4]] with one layer of zeros around.",
        "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\npadded = np.pad(tensor, pad_width=1, mode='constant', constant_values=0)\nprint(padded)"
    },
    {
        "input": "Compute the trace of the matrix [[5, 1], [2, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 1], [2, 3]])\ntrace = np.trace(matrix)\nprint(trace)"
    },
    {
        "input": "Determine the Frobenius norm of matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nfro_norm = np.linalg.norm(matrix, 'fro')\nprint(fro_norm)"
    },
    {
        "input": "Compute the Hadamard (element-wise) product of [[1, 2], [3, 4]] and [[5, 6], [7, 8]].",
        "output": "import numpy as np\na = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6], [7, 8]])\nresult = np.multiply(a, b)\nprint(result)"
    },
    {
        "input": "Calculate the covariance matrix of the dataset [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\ndata = np.array([[1, 2], [3, 4], [5, 6]])\ncov_matrix = np.cov(data, rowvar=False)\nprint(cov_matrix)"
    },
    {
        "input": "Replace all negative values in tensor [[1, -2], [-3, 4]] with zero.",
        "output": "import numpy as np\ntensor = np.array([[1, -2], [-3, 4]])\nresult = np.where(tensor < 0, 0, tensor)\nprint(result)"
    },
    {
        "input": "Create a 3x3x3 tensor filled with random integers from 0 to 9.",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.randint(0, 10, size=(3, 3, 3))\nprint(tensor)"
    },
    {
        "input": "Compute the cumulative sum along axis 1 for [[1, 2, 3], [4, 5, 6]].",
        "output": "import numpy as np\ntensor = np.array([[1, 2, 3], [4, 5, 6]])\ncumsum = np.cumsum(tensor, axis=1)\nprint(cumsum)"
    },
    {
        "input": "Normalize a vector [3, 4] to have unit length.",
        "output": "import numpy as np\nv = np.array([3, 4])\nnorm = np.linalg.norm(v)\nunit_vector = v / norm\nprint(unit_vector)"
    },
    {
        "input": "Compute the determinant of a 3x3 matrix [[2, 0, 1], [3, 0, 0], [5, 1, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 0, 1], [3, 0, 0], [5, 1, 1]])\ndet = np.linalg.det(matrix)\nprint(det)"
    },
    {
        "input": "Find the angle (in radians) between vectors [1, 0] and [0, 1].",
        "output": "import numpy as np\na = np.array([1, 0])\nb = np.array([0, 1])\ndot_product = np.dot(a, b)\nmagnitude = np.linalg.norm(a) * np.linalg.norm(b)\nangle = np.arccos(dot_product / magnitude)\nprint(angle)"
    },
    {
        "input": "Transpose a rank-3 tensor of shape (2, 3, 4) to shape (4, 3, 2).",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.rand(2, 3, 4)\ntransposed = np.transpose(tensor, (2, 1, 0))\nprint(transposed.shape)"
    },
    {
        "input": "Round all values in tensor [[1.2, 3.5], [4.7, 6.1]] to the nearest integer.",
        "output": "import numpy as np\ntensor = np.array([[1.2, 3.5], [4.7, 6.1]])\nrounded = np.rint(tensor)\nprint(rounded)"
    },
    {
        "input": "Compute the dot product of vectors [2, 3, 4] and [5, 6, 7].",
        "output": "import numpy as np\na = np.array([2, 3, 4])\nb = np.array([5, 6, 7])\ndot_product = np.dot(a, b)\nprint(dot_product)"
    },
    {
        "input": "Create a 2x2 rotation matrix for 90 degrees counter-clockwise.",
        "output": "import numpy as np\nangle = np.pi / 2\nrotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]])\nprint(rotation_matrix)"
    },
    {
        "input": "Calculate the angle (in degrees) between vectors [1, 2, 2] and [2, 1, 2].",
        "output": "import numpy as np\nv1 = np.array([1, 2, 2])\nv2 = np.array([2, 1, 2])\ncos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\nangle_rad = np.arccos(cos_angle)\nangle_deg = np.degrees(angle_rad)\nprint(angle_deg)"
    },
    {
        "input": "Sum the diagonals of a 3x3 matrix [[1,2,3],[4,5,6],[7,8,9]].",
        "output": "import numpy as np\nmatrix = np.array([[1,2,3],[4,5,6],[7,8,9]])\ndiagonal_sum = np.trace(matrix)\nprint(diagonal_sum)"
    },
    {
        "input": "Extract the diagonal from a 3x3x3 tensor where i==j==k.",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.rand(3,3,3)\ndiagonal = np.array([tensor[i,i,i] for i in range(3)])\nprint(diagonal)"
    },
    {
        "input": "Flip the tensor [[1, 2], [3, 4]] vertically.",
        "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\nflipped = np.flipud(tensor)\nprint(flipped)"
    },
    {
        "input": "Compute the maximum value across axis 1 in tensor [[1, 9], [4, 2], [3, 5]].",
        "output": "import numpy as np\ntensor = np.array([[1, 9], [4, 2], [3, 5]])\nmax_vals = np.max(tensor, axis=1)\nprint(max_vals)"
    },
    {
        "input": "Tile the vector [1, 2] three times along axis 0.",
        "output": "import numpy as np\nvector = np.array([1, 2])\ntiled = np.tile(vector, 3)\nprint(tiled)"
    },
    {
        "input": "Swap axes 0 and 2 of a tensor with shape (2, 3, 4).",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.rand(2, 3, 4)\nswapped = np.swapaxes(tensor, 0, 2)\nprint(swapped.shape)"
    },
    {
        "input": "Calculate the median of the tensor [1, 3, 2, 4, 5].",
        "output": "import numpy as np\ntensor = np.array([1, 3, 2, 4, 5])\nmedian = np.median(tensor)\nprint(median)"
    },
    {
        "input": "Shift the tensor [1, 2, 3, 4, 5] one position to the right with wrap around.",
        "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4, 5])\nshifted = np.roll(tensor, 1)\nprint(shifted)"
    },
    {
        "input": "Create a 5x5 matrix with 1s on the main diagonal and -1s on the first superdiagonal.",
        "output": "import numpy as np\nmain_diag = np.eye(5)\nsuper_diag = np.diag([-1]*4, k=1)\nmatrix = main_diag + super_diag\nprint(matrix)"
    },
    {
        "input": "Reverse the columns of a 2D tensor [[1, 2], [3, 4]].",
        "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\nreversed_cols = tensor[:, ::-1]\nprint(reversed_cols)"
    },
    {
        "input": "Calculate the standard deviation of the tensor [1, 3, 5, 7, 9].",
        "output": "import numpy as np\ntensor = np.array([1, 3, 5, 7, 9])\nstd_dev = np.std(tensor)\nprint(std_dev)"
    },
    {
        "input": "Find the inverse of the matrix [[4, 7], [2, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[4, 7], [2, 6]])\ninverse = np.linalg.inv(matrix)\nprint(inverse)"
    },
    {
        "input": "Sum all values of the 3D tensor [[[1,2],[3,4]],[[5,6],[7,8]]].",
        "output": "import numpy as np\ntensor = np.array([[[1,2],[3,4]],[[5,6],[7,8]]])\ntotal_sum = np.sum(tensor)\nprint(total_sum)"
    },
    {
        "input": "Calculate the determinant of a 2x2 matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ndet = np.linalg.det(matrix)\nprint(det)"
    },
    {
        "input": "Find the rank of the matrix [[1, 2], [2, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [2, 4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(rank)"
    },
    {
        "input": "Perform element-wise square of tensor [1, 2, 3, 4].",
        "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4])\nsquared = np.square(tensor)\nprint(squared)"
    },
    {
        "input": "Convert the tensor [1, 2, 3] to float type.",
        "output": "import numpy as np\ntensor = np.array([1, 2, 3])\nfloat_tensor = tensor.astype(float)\nprint(float_tensor)"
    },
    {
        "input": "Get the shape of tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
        "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nprint(tensor.shape)"
    },
    {
        "input": "Create a tensor of shape (2, 3) filled with the value 9.",
        "output": "import numpy as np\ntensor = np.full((2, 3), 9)\nprint(tensor)"
    },
    {
        "input": "Find the minimum value in the tensor [[8, 3], [6, 1]].",
        "output": "import numpy as np\ntensor = np.array([[8, 3], [6, 1]])\nmin_value = np.min(tensor)\nprint(min_value)"
    },
    {
        "input": "Find the maximum value in the tensor [[8, 3], [6, 1]].",
        "output": "import numpy as np\ntensor = np.array([[8, 3], [6, 1]])\nmax_value = np.max(tensor)\nprint(max_value)"
    },
    {
        "input": "Calculate the mean of the tensor [10, 20, 30, 40, 50].",
        "output": "import numpy as np\ntensor = np.array([10, 20, 30, 40, 50])\nmean = np.mean(tensor)\nprint(mean)"
    },
    {
        "input": "Generate a 4x4 identity matrix.",
        "output": "import numpy as np\nidentity_matrix = np.eye(4)\nprint(identity_matrix)"
    },
    {
        "input": "Find the transpose of the matrix [[1, 2, 3], [4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\ntransposed = matrix.T\nprint(transposed)"
    },
    {
        "input": "Reshape the tensor [1, 2, 3, 4, 5, 6] into shape (2, 3).",
        "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4, 5, 6])\nreshaped = tensor.reshape(2, 3)\nprint(reshaped)"
    },
    {
        "input": "Compute the L2 norm of the vector [6, 8].",
        "output": "import numpy as np\nvector = np.array([6, 8])\nl2_norm = np.linalg.norm(vector)\nprint(l2_norm)"
    },
    {
        "input": "Create a tensor of shape (3, 3) filled with zeros.",
        "output": "import numpy as np\nzeros = np.zeros((3, 3))\nprint(zeros)"
    },
    {
        "input": "Create a tensor of shape (2, 2) filled with ones.",
        "output": "import numpy as np\nones = np.ones((2, 2))\nprint(ones)"
    },
    {
        "input": "Flatten the tensor [[1, 2], [3, 4]] into a 1D array.",
        "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\nflattened = tensor.flatten()\nprint(flattened)"
    },
    {
        "input": "Clip the values of tensor [1, 5, 9, 15] to be between 3 and 10.",
        "output": "import numpy as np\ntensor = np.array([1, 5, 9, 15])\nclipped = np.clip(tensor, 3, 10)\nprint(clipped)"
    },
    {
        "input": "Broadcast vector [1, 2, 3] to a 3x3 matrix.",
        "output": "import numpy as np\nvector = np.array([1, 2, 3])\nmatrix = np.broadcast_to(vector, (3, 3))\nprint(matrix)"
    },
    {
        "input": "Pad the tensor [1, 2, 3] with two zeros at the end.",
        "output": "import numpy as np\ntensor = np.array([1, 2, 3])\npadded = np.pad(tensor, (0, 2))\nprint(padded)"
    },
    {
        "input": "Compute the cross product of [1, 0, 0] and [0, 1, 0].",
        "output": "import numpy as np\na = np.array([1, 0, 0])\nb = np.array([0, 1, 0])\ncross = np.cross(a, b)\nprint(cross)"
    },
    {
        "input": "Round tensor [1.1, 2.5, 3.7] to the nearest integers.",
        "output": "import numpy as np\ntensor = np.array([1.1, 2.5, 3.7])\nrounded = np.rint(tensor)\nprint(rounded)"
    },
    {
        "input": "Generate a tensor with shape (2, 2) with random floats between 0 and 1.",
        "output": "import numpy as np\nnp.random.seed(0)\nrandom_tensor = np.random.rand(2, 2)\nprint(random_tensor)"
    },
    {
        "input": "Generate a diagonal matrix from vector [4, 5, 6].",
        "output": "import numpy as np\nvector = np.array([4, 5, 6])\ndiagonal_matrix = np.diag(vector)\nprint(diagonal_matrix)"
    },
    {
        "input": "Compute the trace of the matrix [[2, 0], [1, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 0], [1, 3]])\ntrace = np.trace(matrix)\nprint(trace)"
    },
    {
        "input": "Subtract matrix [[1, 2], [3, 4]] from [[5, 6], [7, 8]].",
        "output": "import numpy as np\na = np.array([[5, 6], [7, 8]])\nb = np.array([[1, 2], [3, 4]])\ndiff = a - b\nprint(diff)"
    },
    {
        "input": "Multiply the matrix [[1, 2], [3, 4]] by scalar 2.",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nscaled = matrix * 2\nprint(scaled)"
    },
    {
        "input": "Add the tensors [[1, 1], [1, 1]] and [[2, 2], [2, 2]].",
        "output": "import numpy as np\na = np.array([[1, 1], [1, 1]])\nb = np.array([[2, 2], [2, 2]])\nsum_tensor = a + b\nprint(sum_tensor)"
    },
    {
        "input": "Get the second row of the matrix [[5, 6], [7, 8], [9, 10]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 6], [7, 8], [9, 10]])\nrow = matrix[1]\nprint(row)"
    },
    {
        "input": "Create a 1D tensor with 5 evenly spaced values between 0 and 1.",
        "output": "import numpy as np\ntensor = np.linspace(0, 1, 5)\nprint(tensor)"
    },
    {
        "input": "Convert the tensor [[1, 2], [3, 4]] to a list.",
        "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\nlist_version = tensor.tolist()\nprint(list_version)"
    },
    {
        "input": "Compute the element-wise maximum between [3, 5, 1] and [4, 2, 6].",
        "output": "import numpy as np\na = np.array([3, 5, 1])\nb = np.array([4, 2, 6])\nmaximums = np.maximum(a, b)\nprint(maximums)"
    },
    {
        "input": "Get the index of the maximum value in tensor [1, 3, 7, 2, 5].",
        "output": "import numpy as np\ntensor = np.array([1, 3, 7, 2, 5])\nmax_index = np.argmax(tensor)\nprint(max_index)"
    },
    {
        "input": "Get the index of the minimum value in tensor [1, 3, 7, 2, 5].",
        "output": "import numpy as np\ntensor = np.array([1, 3, 7, 2, 5])\nmin_index = np.argmin(tensor)\nprint(min_index)"
    },
    {
        "input": "Split the tensor [1, 2, 3, 4, 5, 6] into three equal parts.",
        "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4, 5, 6])\nsplits = np.split(tensor, 3)\nprint(splits)"
    },
    {
        "input": "Compute the cumulative sum of tensor [1, 2, 3, 4].",
        "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4])\ncumsum = np.cumsum(tensor)\nprint(cumsum)"
    },
    {
        "input": "Find the dot product of vectors [2, 3] and [4, 5].",
        "output": "import numpy as np\na = np.array([2, 3])\nb = np.array([4, 5])\ndot = np.dot(a, b)\nprint(dot)"
    },
    {
        "input": "Stack tensors [1, 2] and [3, 4] vertically.",
        "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\nstacked = np.vstack((a, b))\nprint(stacked)"
    },
    {
        "input": "Stack tensors [1, 2] and [3, 4] horizontally.",
        "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\nstacked = np.hstack((a, b))\nprint(stacked)"
    },
    {
        "input": "Repeat tensor [1, 2] three times.",
        "output": "import numpy as np\ntensor = np.array([1, 2])\nrepeated = np.tile(tensor, 3)\nprint(repeated)"
    },
    {
        "input": "Generate a 2x3 matrix of random integers from 0 to 9.",
        "output": "import numpy as np\nnp.random.seed(0)\nmatrix = np.random.randint(0, 10, (2, 3))\nprint(matrix)"
    },
    {
        "input": "Transpose a 3D tensor of shape (2, 3, 4) to (4, 3, 2).",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.rand(2, 3, 4)\ntransposed = np.transpose(tensor, (2, 1, 0))\nprint(transposed.shape)"
    },
    {
        "input": "Create a tensor with shape (3, 3) filled with the value -5.",
        "output": "import numpy as np\ntensor = np.full((3, 3), -5)\nprint(tensor)"
    },
    {
        "input": "Normalize the tensor [3, 4] to unit length.",
        "output": "import numpy as np\ntensor = np.array([3, 4])\nnormalized = tensor / np.linalg.norm(tensor)\nprint(normalized)"
    },
    {
        "input": "Create a 3D tensor of shape (2, 2, 2) with all elements set to 1.",
        "output": "import numpy as np\ntensor = np.ones((2, 2, 2))\nprint(tensor)"
    },
    {
        "input": "Find the mean along columns of matrix [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4], [5, 6]])\ncolumn_means = np.mean(matrix, axis=0)\nprint(column_means)"
    },
    {
        "input": "Find the mean along rows of matrix [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4], [5, 6]])\nrow_means = np.mean(matrix, axis=1)\nprint(row_means)"
    },
    {
        "input": "Convert tensor [[1, 2], [3, 4]] to string format.",
        "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\nstring_repr = str(tensor)\nprint(string_repr)"
    },
    {
        "input": "Perform matrix multiplication between [[1, 0], [0, 1]] and [[4, 1], [2, 2]].",
        "output": "import numpy as np\na = np.array([[1, 0], [0, 1]])\nb = np.array([[4, 1], [2, 2]])\nresult = np.matmul(a, b)\nprint(result)"
    },
    {
        "input": "Find the rank of matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(rank)"
    },
    {
        "input": "Extract the diagonal of the matrix [[7, 8, 9], [4, 5, 6], [1, 2, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[7, 8, 9], [4, 5, 6], [1, 2, 3]])\ndiagonal = np.diag(matrix)\nprint(diagonal)"
    },
    {
        "input": "Flip the tensor [[1, 2], [3, 4]] horizontally.",
        "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\nflipped = np.fliplr(tensor)\nprint(flipped)"
    },
    {
        "input": "Sort the tensor [5, 1, 3, 2] in ascending order.",
        "output": "import numpy as np\ntensor = np.array([5, 1, 3, 2])\nsorted_tensor = np.sort(tensor)\nprint(sorted_tensor)"
    },
    {
        "input": "Get the shape of tensor [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4], [5, 6]])\nshape = tensor.shape\nprint(shape)"
    },
    {
        "input": "Replace values greater than 10 in [4, 15, 2, 23] with 10.",
        "output": "import numpy as np\ntensor = np.array([4, 15, 2, 23])\nreplaced = np.where(tensor > 10, 10, tensor)\nprint(replaced)"
    },
    {
        "input": "Generate a tensor of shape (2, 3) with standard normal distribution values.",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.randn(2, 3)\nprint(tensor)"
    },
    {
        "input": "Find the determinant of the matrix [[6, 1], [4, -2]].",
        "output": "import numpy as np\nmatrix = np.array([[6, 1], [4, -2]])\ndet = np.linalg.det(matrix)\nprint(det)"
    },
    {
        "input": "Round each element of tensor [1.25, 2.75, 3.50] to the nearest integer.",
        "output": "import numpy as np\ntensor = np.array([1.25, 2.75, 3.50])\nrounded = np.round(tensor)\nprint(rounded)"
    },
    {
        "input": "Transpose a matrix using np.swapaxes for matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ntransposed = np.swapaxes(matrix, 0, 1)\nprint(transposed)"
    },
    {
        "input": "Add 5 to every element of the tensor [[0, 1], [2, 3]].",
        "output": "import numpy as np\ntensor = np.array([[0, 1], [2, 3]])\nresult = tensor + 5\nprint(result)"
    },
    {
        "input": "Find the Frobenius norm of matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nfro_norm = np.linalg.norm(matrix, 'fro')\nprint(fro_norm)"
    },
    {
        "input": "Find the inverse of matrix [[2, 1], [5, 3]].",
        "output": "import numpy as np\nmatrix = np.array([[2, 1], [5, 3]])\ninverse = np.linalg.inv(matrix)\nprint(inverse)"
    },
    {
        "input": "Create a diagonal matrix with -1 on the diagonal of size 4x4.",
        "output": "import numpy as np\ndiag_matrix = np.diag([-1]*4)\nprint(diag_matrix)"
    },
    {
        "input": "Find the sum of all elements in the matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ntotal = np.sum(matrix)\nprint(total)"
    },
    {
        "input": "Square every element in the tensor [1, 2, 3, 4].",
        "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4])\nsquared = np.square(tensor)\nprint(squared)"
    },
    {
        "input": "Find the standard deviation of tensor [2, 4, 6, 8].",
        "output": "import numpy as np\ntensor = np.array([2, 4, 6, 8])\nstd_dev = np.std(tensor)\nprint(std_dev)"
    },
    {
        "input": "Find the variance of tensor [1, 3, 5, 7].",
        "output": "import numpy as np\ntensor = np.array([1, 3, 5, 7])\nvariance = np.var(tensor)\nprint(variance)"
    },
    {
        "input": "Extract all even numbers from tensor [1, 2, 3, 4, 5, 6].",
        "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4, 5, 6])\nevens = tensor[tensor % 2 == 0]\nprint(evens)"
    },
    {
        "input": "Clip the values of tensor [1, 5, 10, 15] between 3 and 12.",
        "output": "import numpy as np\ntensor = np.array([1, 5, 10, 15])\nclipped = np.clip(tensor, 3, 12)\nprint(clipped)"
    },
    {
        "input": "Reshape tensor [1, 2, 3, 4, 5, 6] to shape (2, 3).",
        "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4, 5, 6])\nreshaped = tensor.reshape((2, 3))\nprint(reshaped)"
    },
    {
        "input": "Tile a 2x1 tensor [[7], [8]] to a 2x3 shape.",
        "output": "import numpy as np\ntensor = np.array([[7], [8]])\ntiled = np.tile(tensor, (1, 3))\nprint(tiled)"
    },
    {
        "input": "Convert the 1D tensor [1, 2, 3, 4] into a column vector.",
        "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4])\ncolumn_vector = tensor.reshape(-1, 1)\nprint(column_vector)"
    },
    {
        "input": "Given a 3x3 matrix, compute its eigenvalues and eigenvectors.",
        "output": "import numpy as np\nnp.random.seed(0)\nmatrix = np.random.rand(3, 3)\neigenvalues, eigenvectors = np.linalg.eig(matrix)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Solve the system of linear equations represented by matrix [[3, 1], [2, 4]] and vector [5, 6].",
        "output": "import numpy as np\nA = np.array([[3, 1], [2, 4]])\nB = np.array([5, 6])\nsolution = np.linalg.solve(A, B)\nprint(solution)"
    },
    {
        "input": "Compute the Cholesky decomposition of the matrix [[6, 3], [3, 2]].",
        "output": "import numpy as np\nmatrix = np.array([[6, 3], [3, 2]])\nL = np.linalg.cholesky(matrix)\nprint(L)"
    },
    {
        "input": "Calculate the Moore-Penrose pseudoinverse of a non-square matrix [[1, 2, 3], [4, 5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\npseudo_inv = np.linalg.pinv(matrix)\nprint(pseudo_inv)"
    },
    {
        "input": "Compute the singular value decomposition (SVD) of matrix [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(matrix)\nprint('U:', U)\nprint('Singular values:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Find the tensor dot product of two 3D tensors of shape (2, 3, 4).",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor1 = np.random.rand(2, 3, 4)\ntensor2 = np.random.rand(2, 3, 4)\ndot_product = np.dot(tensor1.flatten(), tensor2.flatten())\nprint('Tensor dot product:', dot_product)"
    },
    {
        "input": "Compute the determinant of a 4x4 matrix with random integer values.",
        "output": "import numpy as np\nnp.random.seed(0)\nmatrix = np.random.randint(0, 10, (4, 4))\ndeterminant = np.linalg.det(matrix)\nprint(determinant)"
    },
    {
        "input": "Given a 3x3 matrix, compute its QR decomposition.",
        "output": "import numpy as np\nnp.random.seed(0)\nmatrix = np.random.rand(3, 3)\nQ, R = np.linalg.qr(matrix)\nprint('Q:', Q)\nprint('R:', R)"
    },
    {
        "input": "Calculate the condition number of the matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ncondition_number = np.linalg.cond(matrix)\nprint(condition_number)"
    },
    {
        "input": "Find the cross product of vectors [1, 2, 3] and [4, 5, 6].",
        "output": "import numpy as np\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\ncross_product = np.cross(a, b)\nprint(cross_product)"
    },
    {
        "input": "Compute the inverse of a 3x3 matrix with random integer values.",
        "output": "import numpy as np\nnp.random.seed(0)\nmatrix = np.random.randint(1, 10, (3, 3))\ninverse = np.linalg.inv(matrix)\nprint(inverse)"
    },
    {
        "input": "Calculate the trace of the matrix [[5, 1, 2], [0, 3, -1], [2, 4, 1]].",
        "output": "import numpy as np\nmatrix = np.array([[5, 1, 2], [0, 3, -1], [2, 4, 1]])\ntrace = np.trace(matrix)\nprint(trace)"
    },
    {
        "input": "Compute the matrix exponential of a 2x2 matrix [[0, -1], [1, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import expm\nmatrix = np.array([[0, -1], [1, 0]])\nexp_matrix = expm(matrix)\nprint(exp_matrix)"
    },
    {
        "input": "Compute the higher-order singular value decomposition (HOSVD) of a 3D tensor of shape (3, 3, 3).",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.rand(3, 3, 3)\nU0, _, _ = np.linalg.svd(tensor.reshape(3, -1), full_matrices=False)\nU1, _, _ = np.linalg.svd(np.moveaxis(tensor, 1, 0).reshape(3, -1), full_matrices=False)\nU2, _, _ = np.linalg.svd(np.moveaxis(tensor, 2, 0).reshape(3, -1), full_matrices=False)\ncore = np.einsum('ijk,ia->ajk', tensor, U0.T)\ncore = np.einsum('ajk,jb->abk', core, U1.T)\ncore = np.einsum('abk,kc->abc', core, U2.T)\nprint('Core tensor shape:', core.shape)\nprint('Factor matrix shapes:', U0.shape, U1.shape, U2.shape)"
    },
    {
        "input": "Flatten a 4D tensor of shape (2, 2, 2, 2) into a 2D matrix using mode-1 unfolding.",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.rand(2, 2, 2, 2)\nunfolded = np.moveaxis(tensor, 1, 0).reshape(2, -1)\nprint('Mode-1 unfolding shape:', unfolded.shape)\nprint(unfolded)"
    },
    {
        "input": "Perform tensor contraction on two 3D tensors of shape (3, 3, 3) over the last and first axes respectively.",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor1 = np.random.rand(3, 3, 3)\ntensor2 = np.random.rand(3, 3, 3)\ncontracted = np.tensordot(tensor1, tensor2, axes=([2], [0]))\nprint(contracted)"
    },
    {
        "input": "Create a rank-1 tensor of order 3 by outer product of vectors [1,2], [3,4], [5,6].",
        "output": "import numpy as np\nv1 = np.array([1, 2])\nv2 = np.array([3, 4])\nv3 = np.array([5, 6])\nrank1_tensor = np.einsum('i,j,k->ijk', v1, v2, v3)\nprint(rank1_tensor)"
    },
    {
        "input": "Calculate the spectral norm of matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nspectral_norm = np.linalg.norm(matrix, 2)\nprint(spectral_norm)"
    },
    {
        "input": "Perform mode-2 multiplication of a 3D tensor of shape (3, 4, 5) with a matrix of shape (6, 4).",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.rand(3, 4, 5)\nmatrix = np.random.rand(6, 4)\nresult = np.tensordot(matrix, tensor, axes=(1, 1))\nresult = np.moveaxis(result, 0, 1)\nprint('Result shape:', result.shape)"
    },
    {
        "input": "Compute the Frobenius norm difference between two tensors of shape (2, 2, 2).",
        "output": "import numpy as np\nnp.random.seed(0)\nt1 = np.random.rand(2, 2, 2)\nt2 = np.random.rand(2, 2, 2)\ndiff_norm = np.linalg.norm(t1 - t2)\nprint(diff_norm)"
    },
    {
        "input": "Decompose a tensor into CP format using random values for a (3, 3, 3) tensor.",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(3, 3)\nB = np.random.rand(3, 3)\nC = np.random.rand(3, 3)\nweights = np.ones(3)\ntensor_cp = np.zeros((3, 3, 3))\nfor r in range(3):\n    tensor_cp += weights[r] * np.einsum('i,j,k->ijk', A[:, r], B[:, r], C[:, r])\nprint('Simulated CP decomposition (rank=3) complete. Tensor shape:', tensor_cp.shape)"
    },
    {
        "input": "Perform matrix logarithm on a 2x2 positive definite matrix [[2.0, 0.5], [0.5, 1.5]].",
        "output": "import numpy as np\nfrom scipy.linalg import logm\nA = np.array([[2.0, 0.5], [0.5, 1.5]])\nlog_matrix = logm(A)\nprint(log_matrix)"
    },
    {
        "input": "Construct a 3x3x3 tensor with orthonormal slices along the third axis.",
        "output": "import numpy as np\nfrom scipy.linalg import orth\nnp.random.seed(0)\nslices = [orth(np.random.rand(3, 3)) for _ in range(3)]\ntensor = np.stack(slices, axis=2)\nprint(tensor)"
    },
    {
        "input": "Calculate the determinant of the Gram matrix of vectors [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nvectors = np.array([[1, 2], [3, 4], [5, 6]])\ngram = np.dot(vectors, vectors.T)\ndet = np.linalg.det(gram)\nprint(det)"
    },
    {
        "input": "Find the rank of a 3x3 matrix with symbolic entries and check if it is always full rank.",
        "output": "import sympy as sp\na, b, c, d, e, f, g, h, i = sp.symbols('a b c d e f g h i')\nmatrix = sp.Matrix([[a, b, c], [d, e, f], [g, h, i]])\nrank = matrix.rank()\nprint(rank)"
    },
    {
        "input": "Given tensor [[1,2],[3,4]], compute its eigen decomposition as a symmetric matrix.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nA_sym = (A + A.T) / 2\nevals, evecs = np.linalg.eigh(A_sym)\nprint(evals)\nprint(evecs)"
    },
    {
        "input": "Construct a symmetric positive definite matrix from a random 3x3 matrix.",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(3, 3)\nspd = np.dot(A.T, A) + np.eye(3)\nprint(spd)"
    },
    {
        "input": "Perform CP decomposition on a tensor of shape (5, 5, 5) with rank=3.",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(5, 3)\nB = np.random.rand(5, 3)\nC = np.random.rand(5, 3)\nweights = np.ones(3)\ntensor_cp = np.zeros((5, 5, 5))\nfor r in range(3):\n    tensor_cp += weights[r] * np.einsum('i,j,k->ijk', A[:, r], B[:, r], C[:, r])\nprint('Simulated CP decomposition (rank=3) complete. Tensor shape:', tensor_cp.shape)"
    },
    {
        "input": "Compute the tensor norm of a 3D tensor using order 3.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3, 3, 3)\nnorm = np.linalg.norm(T.flatten(), ord=3)\nprint('Tensor norm (order 3):', norm)"
    },
    {
        "input": "Compute eigenvalues of a Laplacian matrix constructed from adjacency [[0,1,0],[1,0,1],[0,1,0]].",
        "output": "import numpy as np\nadj = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\ndeg = np.diag(np.sum(adj, axis=1))\nlaplacian = deg - adj\nevals = np.linalg.eigvals(laplacian)\nprint(evals)"
    },
    {
        "input": "Apply a tensor permutation to swap axes (0, 2, 1) of a (3, 4, 5) tensor.",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.rand(3, 4, 5)\npermuted = np.transpose(tensor, (0, 2, 1))\nprint(permuted.shape)"
    },
    {
        "input": "Find the covariance matrix of a 3D dataset shaped (100, 3).",
        "output": "import numpy as np\nnp.random.seed(0)\ndata = np.random.rand(100, 3)\ncov_matrix = np.cov(data, rowvar=False)\nprint(cov_matrix)"
    },
    {
        "input": "Perform a high-order tensor dot over specific axes of two tensors: shape (3,4,5) and (5,4,3).",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(3, 4, 5)\nB = np.random.rand(5, 4, 3)\ndot_result = np.tensordot(A, B, axes=([0,1,2],[2,1,0]))\nprint(dot_result)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 symmetric matrix A = [[4, 1, 2], [1, 3, 0], [2, 0, 5]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 2], [1, 3, 0], [2, 0, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Perform a QR decomposition on a 3x3 matrix A = [[12, -51, 4], [6, 167, -68], [-4, 24, -41]].",
        "output": "import numpy as np\nA = np.array([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])\nQ, R = np.linalg.qr(A)\nprint('Q:', Q)\nprint('R:', R)"
    },
    {
        "input": "Calculate the Moore-Penrose pseudoinverse of a 3x2 matrix A = [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nA_pinv = np.linalg.pinv(A)\nprint('Pseudoinverse of A:', A_pinv)"
    },
    {
        "input": "Find the Cholesky decomposition of a positive definite matrix A = [[25, 15, -5], [15, 18, 0], [-5, 0, 11]].",
        "output": "import numpy as np\nA = np.array([[25, 15, -5], [15, 18, 0], [-5, 0, 11]])\nL = np.linalg.cholesky(A)\nprint('Cholesky factor L:', L)"
    },
    {
        "input": "Compute the determinant of a 4x4 matrix A = [[6, 1, 1, 3], [4, -2, 5, 1], [2, 8, 7, 6], [3, 1, 9, 7]].",
        "output": "import numpy as np\nA = np.array([[6, 1, 1, 3], [4, -2, 5, 1], [2, 8, 7, 6], [3, 1, 9, 7]])\ndet_A = np.linalg.det(A)\nprint('Determinant of A:', det_A)"
    },
    {
        "input": "Solve the system of linear equations Ax = b for A = [[3, 1], [2, 4]] and b = [5, 6].",
        "output": "import numpy as np\nA = np.array([[3, 1], [2, 4]])\nb = np.array([5, 6])\nx = np.linalg.solve(A, b)\nprint('Solution x:', x)"
    },
    {
        "input": "Compute the singular value decomposition (SVD) of a 2x3 matrix A = [[1, 2, 3], [4, 5, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('Singular values:', S)\nprint('Vt:', Vt)"
    },
    {
        "input": "Find the inverse of a 3x3 matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\nA_inv = np.linalg.inv(A)\nprint('Inverse of A:', A_inv)"
    },
    {
        "input": "Calculate the trace of a 3x3 matrix A = [[5, 1, 2], [0, 3, -1], [4, 2, 6]].",
        "output": "import numpy as np\nA = np.array([[5, 1, 2], [0, 3, -1], [4, 2, 6]])\ntrace_A = np.trace(A)\nprint('Trace of A:', trace_A)"
    },
    {
        "input": "Compute the Frobenius norm of a 3x3 matrix A = [[1, -2, 3], [-4, 5, -6], [7, -8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, -2, 3], [-4, 5, -6], [7, -8, 9]])\nfro_norm = np.linalg.norm(A, 'fro')\nprint('Frobenius norm of A:', fro_norm)"
    },
    {
        "input": "Find the rank of a 4x3 matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\nrank_A = np.linalg.matrix_rank(A)\nprint('Rank of A:', rank_A)"
    },
    {
        "input": "Compute the condition number of a matrix A = [[1, 2], [3, 4]] using the 2-norm.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ncond_A = np.linalg.cond(A, 2)\nprint('Condition number of A:', cond_A)"
    },
    {
        "input": "Compute the Kronecker product of matrices A = [[1, 2], [3, 4]] and B = [[0, 5], [6, 7]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[0, 5], [6, 7]])\nkron_product = np.kron(A, B)\nprint('Kronecker product:\\n', kron_product)"
    },
    {
        "input": "Given a 3rd-order tensor of shape (3, 3, 3), compute the mode-1 matricization.",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.rand(3, 3, 3)\nmode1_unfold = tensor.reshape(3, -1)\nprint('Mode-1 matricization:\\n', mode1_unfold)"
    },
    {
        "input": "Compute the higher-order singular value decomposition (HOSVD) of a random 3x3x3 tensor.",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.rand(3, 3, 3)\nU0, _, _ = np.linalg.svd(tensor.reshape(3, -1), full_matrices=False)\nU1, _, _ = np.linalg.svd(np.moveaxis(tensor, 1, 0).reshape(3, -1), full_matrices=False)\nU2, _, _ = np.linalg.svd(np.moveaxis(tensor, 2, 0).reshape(3, -1), full_matrices=False)\ncore = np.einsum('ijk,ia->ajk', tensor, U0.T)\ncore = np.einsum('ajk,jb->abk', core, U1.T)\ncore = np.einsum('abk,kc->abc', core, U2.T)\nprint('Core shape:', core.shape)\nprint('Factor matrices shapes:', U0.shape, U1.shape, U2.shape)"
    },
    {
        "input": "Calculate the spectral norm of a matrix A = [[1, 2], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 3]])\nspectral_norm = np.linalg.norm(A, 2)\nprint('Spectral norm:', spectral_norm)"
    },
    {
        "input": "Generate a 3x3 matrix with eigenvalues 1, 2, 3 and verify.",
        "output": "import numpy as np\nfrom scipy.linalg import eig\nnp.random.seed(0)\nP = np.random.rand(3, 3)\nD = np.diag([1, 2, 3])\nA = P @ D @ np.linalg.inv(P)\nevals, _ = eig(A)\nprint('Matrix A:\\n', A)\nprint('Eigenvalues:', evals.real)"
    },
    {
        "input": "Diagonalize the matrix A = [[4, 1], [2, 3]] if possible.",
        "output": "import numpy as np\nfrom numpy.linalg import eig\nA = np.array([[4, 1], [2, 3]])\nD, P = eig(A)\nD_matrix = np.diag(D)\nP_inv = np.linalg.inv(P)\nA_diag = P @ D_matrix @ P_inv\nprint('Diagonal matrix D:\\n', D_matrix)\nprint('Reconstructed A from diagonalization:\\n', A_diag)"
    },
    {
        "input": "Compute the tensor contraction of two 3x3x3 tensors along the last and first axes respectively.",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(3, 3, 3)\nB = np.random.rand(3, 3, 3)\nC = np.tensordot(A, B, axes=([2], [0]))\nprint('Contracted tensor shape:', C.shape)"
    },
    {
        "input": "Given a rank-1 tensor T = a ⊗ b ⊗ c, reconstruct the tensor from vectors a = [1,2], b = [0,1], c = [3,4].",
        "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([0, 1])\nc = np.array([3, 4])\nT = np.einsum('i,j,k->ijk', a, b, c)\nprint('Rank-1 tensor:\\n', T)"
    },
    {
        "input": "Perform matrix exponential on a 2x2 matrix A = [[0, 1], [-1, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import expm\nA = np.array([[0, 1], [-1, 0]])\nexp_A = expm(A)\nprint('Matrix exponential:\\n', exp_A)"
    },
    {
        "input": "Compute the Jordan form of a matrix A = [[5, 4, 2], [0, 5, 2], [0, 0, 5]].",
        "output": "import sympy as sp\nA = sp.Matrix([[5, 4, 2], [0, 5, 2], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint('Jordan form:\\n', J)"
    },
    {
        "input": "Determine the rank of a tensor A = np.ones((2,2,2)) + np.eye(2).reshape(2,1,1).",
        "output": "import numpy as np\nnp.random.seed(0)\nidentity = np.eye(2)\nidentity_tensor = np.zeros((2, 2, 2))\nidentity_tensor[:, 0, 0] = identity[:, 0]\nidentity_tensor[:, 1, 1] = identity[:, 1]\ntensor = np.ones((2, 2, 2)) + identity_tensor\ndef cp_rank_estimate(tensor, max_rank=5, tol=1e-2):\n    for rank in range(1, max_rank + 1):\n        for _ in range(20):\n            approx = np.zeros_like(tensor)\n            for r in range(rank):\n                a = np.random.rand(2)\n                b = np.random.rand(2)\n                c = np.random.rand(2)\n                approx += np.einsum('i,j,k->ijk', a, b, c)\n            if np.allclose(tensor, approx, atol=tol):\n                return rank\n    return '> ' + str(max_rank)\nrank = cp_rank_estimate(tensor)\nprint('Estimated CP rank:', rank)"
    },
    {
        "input": "Compute the rank of a matrix obtained by unfolding a 3x3x3 tensor along mode-2.",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.rand(3, 3, 3)\nunfolded = np.reshape(np.moveaxis(tensor, 2, 0), (3, -1))\nrank = np.linalg.matrix_rank(unfolded)\nprint('Rank:', rank)"
    },
    {
        "input": "Construct a 4x4 matrix with complex eigenvalues and compute them.",
        "output": "import numpy as np\nA = np.array([[0, -1, 0, 0], [1, 0, 0, 0], [0, 0, 0, -2], [0, 0, 2, 0]])\nevals, _ = np.linalg.eig(A)\nprint('Eigenvalues:', evals)"
    },
    {
        "input": "Compute the CP decomposition of a rank-1 tensor made from vectors a, b, c.",
        "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\nc = np.array([5, 6])\ntensor = np.einsum('i,j,k->ijk', a, b, c)\nweight = np.linalg.norm(a) * np.linalg.norm(b) * np.linalg.norm(c)\na_normalized = a / np.linalg.norm(a)\nb_normalized = b / np.linalg.norm(b)\nc_normalized = c / np.linalg.norm(c)\nprint('CP decomposition weight:', weight)\nprint('Factor a:', a_normalized)\nprint('Factor b:', b_normalized)\nprint('Factor c:', c_normalized)"
    },
    {
        "input": "Calculate the multilinear rank of a tensor T = np.random.rand(3,4,5).",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3, 4, 5)\nunfold_mode0 = T.reshape(3, -1)\nunfold_mode1 = np.moveaxis(T, 1, 0).reshape(4, -1)\nunfold_mode2 = np.moveaxis(T, 2, 0).reshape(5, -1)\nranks = [\n    np.linalg.matrix_rank(unfold_mode0),\n    np.linalg.matrix_rank(unfold_mode1),\n    np.linalg.matrix_rank(unfold_mode2)\n]\nprint('Multilinear rank:', ranks)"
    },
    {
        "input": "Compute the higher-order outer product of three vectors: a = [1, 0], b = [0, 1], c = [1, 1].",
        "output": "import numpy as np\na = np.array([1, 0])\nb = np.array([0, 1])\nc = np.array([1, 1])\ntensor = np.einsum('i,j,k->ijk', a, b, c)\nprint('Higher-order outer product:\\n', tensor)"
    },
    {
        "input": "Compute matrix logarithm of a 2x2 positive definite matrix A = [[2, 0], [0, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import logm\nA = np.array([[2, 0], [0, 3]])\nlog_A = logm(A)\nprint('Matrix logarithm:\\n', log_A)"
    },
    {
        "input": "Create a tensor and compute its norm along a specific mode using numpy.linalg.norm.",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.rand(3, 3, 3)\nnorm_mode0 = np.linalg.norm(tensor, axis=0)\nprint('Norm along mode-0:\\n', norm_mode0)"
    },
    {
        "input": "Compute the determinant of a 3x3 matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\ndet_A = np.linalg.det(A)\nprint('Determinant:', det_A)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[4, 1], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[4, 1], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the singular value decomposition (SVD) of the matrix A = [[3, 1], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:\\n', U)\nprint('Singular values:', S)\nprint('Vt:\\n', Vt)"
    },
    {
        "input": "Determine if the matrix A = [[1, 2], [3, 4]] is invertible and find its inverse if it exists.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ndet_A = np.linalg.det(A)\nif det_A != 0:\n    A_inv = np.linalg.inv(A)\n    print('Inverse:\\n', A_inv)\nelse:\n    print('Matrix is not invertible.')"
    },
    {
        "input": "Compute the trace of the matrix A = [[5, -2], [-2, 5]].",
        "output": "import numpy as np\nA = np.array([[5, -2], [-2, 5]])\ntrace_A = np.trace(A)\nprint('Trace:', trace_A)"
    },
    {
        "input": "Find the rank of the matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nrank_A = np.linalg.matrix_rank(A)\nprint('Rank:', rank_A)"
    },
    {
        "input": "Compute the determinant of the 4x4 matrix A = [[1, 0, 2, -1], [3, 0, 0, 5], [2, 1, 4, -3], [1, 0, 5, 0]].",
        "output": "import numpy as np\nA = np.array([[1, 0, 2, -1], [3, 0, 0, 5], [2, 1, 4, -3], [1, 0, 5, 0]])\ndet_A = np.linalg.det(A)\nprint('Determinant:', det_A)"
    },
    {
        "input": "Compute the inverse of the matrix A = [[4, 7], [2, 6]].",
        "output": "import numpy as np\nA = np.array([[4, 7], [2, 6]])\nA_inv = np.linalg.inv(A)\nprint('Inverse:\\n', A_inv)"
    },
    {
        "input": "Find the eigenvalues of the matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the inverse of a 3x3 matrix using adjoint and determinant method.",
        "output": "import numpy as np\nA = np.array([[2, -1, 0], [1, 2, 1], [1, 1, 1]])\nadj = np.linalg.inv(A).T * np.linalg.det(A)\nA_inv = adj / np.linalg.det(A)\nprint('Inverse using adjoint method:\\n', A_inv)"
    },
    {
        "input": "Perform Tucker decomposition on a tensor T = np.random.rand(3,3,3) with ranks (2,2,2).",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3, 3, 3)\nU1 = np.random.rand(3, 2)\nU2 = np.random.rand(3, 2)\nU3 = np.random.rand(3, 2)\ncore = np.einsum('ijk,il->ljk', T, U1)\ncore = np.einsum('ljk,jm->lmk', core, U2)\ncore = np.einsum('lmk,kn->lmn', core, U3)\nprint('Core shape:', core.shape)\nprint('Factor shapes:', [U1.shape, U2.shape, U3.shape])"
    },
    {
        "input": "Generate a symmetric positive definite matrix of size 4x4 and compute its Cholesky decomposition.",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(4,4)\nA = A @ A.T + 4*np.eye(4)\nL = np.linalg.cholesky(A)\nprint('Cholesky decomposition:\\n', L)"
    },
    {
        "input": "Given tensor A of shape (3,3,3), perform a cyclic permutation of its axes.",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(3, 3, 3)\nA_perm = np.transpose(A, (1, 2, 0))\nprint('Cyclically permuted tensor shape:', A_perm.shape)"
    },
    {
        "input": "Simulate contraction between two tensors of shapes (3,4,5) and (5,4,2) over axes (2,1).",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(3, 4, 5)\nB = np.random.rand(5, 4, 2)\nC = np.tensordot(A, B, axes=([2,1], [0,1]))\nprint('Shape after contraction:', C.shape)"
    },
    {
        "input": "Construct a tensor T = a ⊗ a ⊗ a where a = [1,2,3] and compute its Frobenius norm.",
        "output": "import numpy as np\na = np.array([1,2,3])\nT = np.einsum('i,j,k->ijk', a, a, a)\nfrob_norm = np.linalg.norm(T)\nprint('Frobenius norm:', frob_norm)"
    },
    {
        "input": "Calculate the determinant of a 3x3 matrix using Levi-Civita symbol and Einstein summation.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nepsilon = np.zeros((3,3,3))\nfor i in range(3):\n for j in range(3):\n  for k in range(3):\n   epsilon[i,j,k] = ((i-j)*(j-k)*(k-i))/2\ndet = np.einsum('ijk,il,jm,kn->lmn', epsilon, A, A, A).trace()\nprint('Determinant (Levi-Civita):', det)"
    },
    {
        "input": "Perform CP decomposition on a tensor T = np.random.rand(3,3,3) with rank 2 and reconstruct it.",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(3, 2)\nB = np.random.rand(3, 2)\nC = np.random.rand(3, 2)\nweights = np.ones(2)\ntensor_cp = np.zeros((3, 3, 3))\nfor r in range(2):\n    tensor_cp += weights[r] * np.einsum('i,j,k->ijk', A[:, r], B[:, r], C[:, r])\nprint('Reconstructed tensor shape:', tensor_cp.shape)\nprint('Reconstructed tensor:\\n', tensor_cp)"
    },
    {
        "input": "Given a tensor T of shape (3,3,3), compute the eigenvalues of each frontal slice.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3, 3, 3)\nevals = [np.linalg.eigvals(T[:, :, i]) for i in range(3)]\nprint('Eigenvalues per slice:', evals)"
    },
    {
        "input": "Given a rank-deficient matrix A (4x3), perform its SVD and verify its numerical rank.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 4, 6], [1, 1, 1], [0, 0, 0]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Numerical rank:', rank)"
    },
    {
        "input": "Create a diagonal 3D tensor (3x3x3) where only entries T[i][i][i] are non-zero.",
        "output": "import numpy as np\nT = np.zeros((3,3,3))\nnp.fill_diagonal(T.reshape(3, -1), [1,2,3])\nprint('Diagonal 3D tensor:\\n', T)"
    },
    {
        "input": "Compute the norm of a tensor T = np.ones((2,2,2)) under Frobenius norm.",
        "output": "import numpy as np\nT = np.ones((2,2,2))\nnorm = np.linalg.norm(T)\nprint('Frobenius norm:', norm)"
    },
    {
        "input": "Perform a mode-1 unfolding of a tensor T of shape (2,3,4).",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(2,3,4)\nunfolded = np.reshape(np.moveaxis(T, 1, 0), (3, -1))\nprint('Mode-1 unfolded shape:', unfolded.shape)"
    },
    {
        "input": "Generate two 3D tensors A and B of shape (2,2,2) and compute their Hadamard product.",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(2,2,2)\nB = np.random.rand(2,2,2)\nC = A * B\nprint('Hadamard product:\\n', C)"
    },
    {
        "input": "Construct a Kronecker product of two matrices A = [[1, 2], [3, 4]] and B = [[0, 5], [6, 7]].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\nB = np.array([[0,5], [6,7]])\nK = np.kron(A, B)\nprint('Kronecker product:\\n', K)"
    },
    {
        "input": "Generate a random tensor T of shape (3,3,3) and normalize it to unit Frobenius norm.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3,3,3)\nT_normalized = T / np.linalg.norm(T)\nprint('Frobenius norm of normalized tensor:', np.linalg.norm(T_normalized))"
    },
    {
        "input": "Construct a 3D tensor T (shape 3x3x3) where each slice along axis 2 is a skew-symmetric matrix.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    T[:,:,i] = A - A.T\nprint('Skew-symmetric tensor:\\n', T)"
    },
    {
        "input": "Compute the spectral norm (largest singular value) of a matrix extracted from a tensor slice.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3,3,3)\nM = T[:,:,0]\nspectral_norm = np.linalg.norm(M, ord=2)\nprint('Spectral norm:', spectral_norm)"
    },
    {
        "input": "Find the multilinear rank of a random tensor of shape (3,4,5).",
        "output": "import numpy as np\nfrom numpy.linalg import matrix_rank\nnp.random.seed(0)\nT = np.random.rand(3,4,5)\nmode0 = matrix_rank(T.reshape(3, -1))\nmode1 = matrix_rank(np.moveaxis(T, 1, 0).reshape(4, -1))\nmode2 = matrix_rank(T.reshape(-1, 5))\nprint('Multilinear rank:', (mode0, mode1, mode2))"
    },
    {
        "input": "Simulate outer product of three vectors of length 2 to construct a rank-1 tensor of shape (2,2,2).",
        "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\nc = np.array([5, 6])\nT = np.einsum('i,j,k->ijk', a, b, c)\nprint('Rank-1 tensor:\\n', T)"
    },
    {
        "input": "Compute the trace of each 2D slice of a 3x3x3 tensor.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3,3,3)\ntraces = [np.trace(T[:,:,i]) for i in range(3)]\nprint('Traces of slices:', traces)"
    },
    {
        "input": "Given a 4x4 matrix A, find its null space numerically.",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nnp.random.seed(0)\nA = np.random.rand(4,4)\nns = null_space(A)\nprint('Null space shape:', ns.shape)"
    },
    {
        "input": "Construct a block-diagonal matrix from two 2x2 matrices A and B.",
        "output": "import numpy as np\nfrom scipy.linalg import block_diag\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\nC = block_diag(A, B)\nprint('Block-diagonal matrix:\\n', C)"
    },
    {
        "input": "Perform contraction of a rank-4 tensor over axes (0,2) with itself.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3,4,3,4)\nC = np.tensordot(T, T, axes=([0,2],[0,2]))\nprint('Contracted tensor shape:', C.shape)"
    },
    {
        "input": "Compute the inner product of two random tensors A and B of shape (3,3,3).",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(3,3,3)\nB = np.random.rand(3,3,3)\ninner_product = np.tensordot(A, B)\nprint('Inner product:', inner_product)"
    },
    {
        "input": "Apply mode-2 multiplication of a tensor T (3x3x3) with a matrix A (3x3).",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3,3,3)\nA = np.random.rand(3,3)\nresult = np.tensordot(T, A, axes=([1], [0]))\nresult = np.moveaxis(result, -1, 1)\nprint('Result shape:', result.shape)"
    },
    {
        "input": "Generate a rank-2 tensor (matrix) with a given singular value spectrum [3, 1].",
        "output": "import numpy as np\nnp.random.seed(0)\nU, _ = np.linalg.qr(np.random.rand(3, 2))\nVt, _ = np.linalg.qr(np.random.rand(2, 2))\nS = np.diag([3, 1])\nA = U @ S @ Vt\nprint('Matrix with spectrum [3,1]:\\n', A)"
    },
    {
        "input": "Create a tensor of shape (3,3,3) with each frontal slice being a diagonal matrix.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    T[:,:,i] = np.diag(np.random.rand(3))\nprint('Tensor with diagonal slices:\\n', T)"
    },
    {
        "input": "Construct a 3D tensor of shape (2,2,2) such that all elements are unique integers from 1 to 8.",
        "output": "import numpy as np\nT = np.arange(1,9).reshape(2,2,2)\nprint('Unique integer tensor:\\n', T)"
    },
    {
        "input": "Perform a Tucker decomposition on a (3,3,3) tensor and reconstruct it.",
        "output": "import numpy as np\nnp.random.seed(0)\ntensor = np.random.rand(3, 3, 3)\nU1 = np.random.rand(3, 2)\nU2 = np.random.rand(3, 2)\nU3 = np.random.rand(3, 2)\ncore = np.random.rand(2, 2, 2)\ntemp = np.einsum('abc,ia->ibc', core, U1)\ntemp = np.einsum('ibc,jb->ijc', temp, U2)\nreconstructed = np.einsum('ijc,kc->ijk', temp, U3)\nprint('Reconstructed tensor shape:', reconstructed.shape)\nprint('Reconstructed tensor:\\n', reconstructed)"
    },
    {
        "input": "Generate a tensor and compute its element-wise cube root.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(2,2,2)\ncube_root = T ** (1/3)\nprint('Cube root tensor:\\n', cube_root)"
    },
    {
        "input": "Find the determinant of each frontal slice of a 3x3x3 tensor.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3,3,3)\ndets = [np.linalg.det(T[:,:,i]) for i in range(3)]\nprint('Determinants of slices:', dets)"
    },
    {
        "input": "Apply batch matrix multiplication to slices of two tensors A and B of shape (3,3,3).",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(3,3,3)\nB = np.random.rand(3,3,3)\nC = np.einsum('ijk,ikl->ijl', A, B)\nprint('Result tensor shape:', C.shape)"
    },
    {
        "input": "Construct a tensor T of shape (3,3,3) where each slice along the third axis is symmetric positive definite.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    T[:,:,i] = A @ A.T + np.eye(3)\nprint('Symmetric positive definite tensor:\\n', T)"
    },
    {
        "input": "Perform eigen-decomposition on each 2D slice of a tensor of shape (3,3,3).",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3,3,3)\neigenvalues = [np.linalg.eig(T[:,:,i])[0] for i in range(3)]\nprint('Eigenvalues per slice:', eigenvalues)"
    },
    {
        "input": "Create a tensor of shape (3,3,3) with all slices along axis 0 as orthonormal matrices.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.stack([np.linalg.qr(np.random.rand(3,3))[0] for _ in range(3)], axis=0)\nprint('Tensor with orthonormal slices along axis 0:\\n', T)"
    },
    {
        "input": "Compute the rank of each slice of a tensor T of shape (3,3,3) along axis 2.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3,3,3)\nranks = [np.linalg.matrix_rank(T[:,:,i]) for i in range(3)]\nprint('Ranks per slice:', ranks)"
    },
    {
        "input": "Generate a tensor of shape (4,4,4) and compute its max-norm (maximum absolute element).",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(4,4,4)\nmax_norm = np.max(np.abs(T))\nprint('Max-norm:', max_norm)"
    },
    {
        "input": "Perform element-wise multiplication of two 4D tensors A and B of shape (2,2,2,2).",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(2,2,2,2)\nB = np.random.rand(2,2,2,2)\nC = A * B\nprint('Element-wise product:\\n', C)"
    },
    {
        "input": "Simulate a rank-1 approximation of a tensor of shape (2,2,2) using CP decomposition.",
        "output": "import numpy as np\nnp.random.seed(0)\na = np.random.rand(2)\nb = np.random.rand(2)\nc = np.random.rand(2)\nrank1_tensor = np.einsum('i,j,k->ijk', a, b, c)\nprint('Rank-1 approximation:\\n', rank1_tensor)"
    },
    {
        "input": "Apply mode-3 product of a tensor T (3x3x3) with a matrix A (3x3).",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3,3,3)\nA = np.random.rand(3,3)\nT_perm = np.transpose(T, (2, 0, 1))\nresult = np.tensordot(A, T_perm, axes=(1,0))\nfinal = np.transpose(result, (1,2,0))\nprint('Mode-3 product result shape:', final.shape)"
    },
    {
        "input": "Create a tensor of shape (3,3,3) where each mode-1 unfolding is full-rank.",
        "output": "import numpy as np\nnp.random.seed(0)\nwhile True:\n    T = np.random.rand(3,3,3)\n    unfolding = T.transpose(1,0,2).reshape(3, -1)\n    if np.linalg.matrix_rank(unfolding) == 3:\n        break\nprint('Full-rank mode-1 unfolding tensor:\\n', T)"
    },
    {
        "input": "Construct a tensor T such that each slice T[:,:,i] is singular with rank 2.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,2)\n    T[:,:,i] = A @ A.T\nprint('Tensor with singular slices of rank 2:\\n', T)"
    },
    {
        "input": "Compute the mean tensor from a batch of 5 random tensors of shape (3,3,3).",
        "output": "import numpy as np\nnp.random.seed(0)\nbatch = np.random.rand(5,3,3,3)\nmean_tensor = np.mean(batch, axis=0)\nprint('Mean tensor:\\n', mean_tensor)"
    },
    {
        "input": "Construct a 3D tensor of shape (3,3,3) such that its Frobenius norm is exactly 10.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.randn(3,3,3)\nT = T / np.linalg.norm(T) * 10\nfro_norm = np.linalg.norm(T)\nprint('Tensor with Frobenius norm 10:', fro_norm)"
    },
    {
        "input": "Given a tensor T of shape (3,3,3), compute the cosine similarity between the first and second frontal slices.",
        "output": "import numpy as np\nfrom numpy.linalg import norm\nnp.random.seed(0)\nT = np.random.rand(3,3,3)\nA = T[:,:,0].flatten()\nB = T[:,:,1].flatten()\ncos_sim = np.dot(A, B) / (norm(A) * norm(B))\nprint('Cosine similarity:', cos_sim)"
    },
    {
        "input": "Create a 3x3x3 tensor such that its diagonal slices are linearly dependent.",
        "output": "import numpy as np\nnp.random.seed(0)\nbase = np.random.rand(3,3)\nT = np.stack([base, 2*base, -1*base], axis=2)\nprint('Linearly dependent slices tensor:\\n', T)"
    },
    {
        "input": "Construct a tensor T of shape (3,3,3) where the trace of each frontal slice increases by 1.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    A[np.diag_indices(3)] += i\n    T[:,:,i] = A\nprint('Trace of slices:', [np.trace(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Given a tensor of shape (3,3,3), find a scalar 'a' such that scaling the tensor by 'a' results in Frobenius norm = 1.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3,3,3)\na = 1 / np.linalg.norm(T)\nT_scaled = a * T\nprint('Frobenius norm:', np.linalg.norm(T_scaled))"
    },
    {
        "input": "Create a tensor of shape (3,3,3) where each 2D slice is orthogonal and has a determinant of -1.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    if np.linalg.det(Q) > 0:\n        Q[:,0] *= -1\n    T[:,:,i] = Q\nprint('Determinants:', [round(np.linalg.det(T[:,:,i])) for i in range(3)])"
    },
    {
        "input": "Construct a tensor of shape (3,3,3) where the L2 norm of each row across all slices is 1.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3,3,3)\nfor i in range(3):\n    for j in range(3):\n        norm = np.linalg.norm(T[i,j,:])\n        T[i,j,:] /= norm\nprint('L2 norms per row across slices:', [[round(np.linalg.norm(T[i,j,:]), 4) for j in range(3)] for i in range(3)])"
    },
    {
        "input": "Create a tensor where the determinant of each slice forms an arithmetic progression.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nd1 = 1\nfor i in range(3):\n    A = np.random.randint(1, 5, (3,3))\n    while round(np.linalg.det(A)) != d1 + i:\n        A = np.random.randint(1, 5, (3,3))\n    T[:,:,i] = A\nprint('Determinants:', [round(np.linalg.det(T[:,:,i])) for i in range(3)])"
    },
    {
        "input": "Construct a tensor such that dot product of all columns across slices equals a fixed vector.",
        "output": "import numpy as np\nv = np.array([1,2,3])\nT = np.zeros((3,3,3))\nfor i in range(3):\n    T[:,i,:] = np.outer(v, [1,1,1])\ndots = [np.dot(T[:,i,0], T[:,i,1]) for i in range(3)]\nprint('Column dot products fixed:', dots)"
    },
    {
        "input": "Create a 3x3x3 tensor T such that the mean of each mode-3 fiber is the same.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3,3,3)\nfiber_means = [np.mean(T[i,j,:]) for i in range(3) for j in range(3)]\nconsistent = all(np.isclose(m, fiber_means[0]) for m in fiber_means)\nprint('Fiber means:', fiber_means)"
    },
    {
        "input": "Generate a 3D tensor of shape (3,3,3) such that the sum of eigenvalues of all slices is constant.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nconstant = 5\nfor i in range(3):\n    A = np.random.rand(3,3)\n    trace = np.trace(A)\n    T[:,:,i] = A + np.eye(3)*(constant - trace)\nprint('Eigenvalue sums:', [np.sum(np.linalg.eigvals(T[:,:,i])) for i in range(3)])"
    },
    {
        "input": "Build a 3x3x3 tensor such that all slices are stochastic matrices (rows sum to 1).",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.rand(3,3,3)\nfor i in range(3):\n    row_sums = T[:,:,i].sum(axis=1)\n    T[:,:,i] = T[:,:,i] / row_sums[:, np.newaxis]\nprint('Row sums:', [T[:,:,i].sum(axis=1) for i in range(3)])"
    },
    {
        "input": "Build a tensor T where summing diagonals of all slices gives a geometric sequence.",
        "output": "import numpy as np\nr = 2\na = 1\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.eye(3) * (a * (r ** i))\n    T[:,:,i] = A\nsums = [np.trace(T[:,:,i]) for i in range(3)]\nprint('Diagonal sums:', sums)"
    },
    {
        "input": "Construct a tensor where every slice has rank exactly 1.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    u = np.random.rand(3,1)\n    v = np.random.rand(1,3)\n    T[:,:,i] = u @ v\nprint('Ranks:', [np.linalg.matrix_rank(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Create a tensor where flipping along the first axis results in a tensor with reversed diagonal sums.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.randint(1,5,(3,3,3))\norig_diags = [np.trace(T[:,:,i]) for i in range(3)]\nT_flipped = np.flip(T, axis=0)\nflip_diags = [np.trace(T_flipped[:,:,i]) for i in range(3)]\nprint('Original vs flipped diagonal sums:', orig_diags, flip_diags[::-1])"
    },
    {
        "input": "Generate a tensor where each slice has Frobenius norm equal to the slice index + 1.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.randn(3,3)\n    A = A / np.linalg.norm(A, 'fro') * (i + 1)\n    T[:,:,i] = A\nprint('Frobenius norms:', [np.linalg.norm(T[:,:,i], 'fro') for i in range(3)])"
    },
    {
        "input": "Create a 3x3x3 tensor where for each slice, the sum of the eigenvalues equals the trace and it's constant.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nconstant_trace = 6\nfor i in range(3):\n    A = np.random.rand(3,3)\n    trace = np.trace(A)\n    A += np.eye(3) * (constant_trace - trace)\n    T[:,:,i] = A\nprint('Trace and eigenvalue sums:', [(np.trace(T[:,:,i]), np.sum(np.linalg.eigvals(T[:,:,i]))) for i in range(3)])"
    },
    {
        "input": "Build a tensor where the rank of each frontal slice increases strictly from 1 to 3.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nT[:,:,0] = np.outer(np.ones(3), [1,0,0])\nT[:,:,1] = np.vstack([np.ones(3), np.eye(3)[1], np.eye(3)[2]])\nT[:,:,2] = np.random.rand(3,3)\nprint('Ranks of slices:', [np.linalg.matrix_rank(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Build a tensor where all elements are integers and each slice has a unique trace from 1 to 3.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.randint(1, 5, (3,3))\n    np.fill_diagonal(A, [i+1 if j==i else 0 for j in range(3)])\n    T[:,:,i] = A\nprint('Traces:', [np.trace(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Generate a tensor where every frontal slice is a rotation matrix in 2D embedded in 3x3.",
        "output": "import numpy as np\nT = np.zeros((3,3,3))\nangles = [np.pi/6, np.pi/4, np.pi/3]\nfor i, theta in enumerate(angles):\n    R = np.array([[np.cos(theta), -np.sin(theta), 0],\n                  [np.sin(theta), np.cos(theta), 0],\n                  [0, 0, 1]])\n    T[:,:,i] = R\nprint('Rotation matrices:\\n', T[:,:,0], '\\n', T[:,:,1], '\\n', T[:,:,2])"
    },
    {
        "input": "Construct a tensor where the determinant of each frontal slice is the factorial of its index (starting from 1).",
        "output": "import numpy as np\nimport math\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.eye(3) * math.factorial(i+1)**(1/3)\n    T[:,:,i] = A\nprint('Determinants:', [np.linalg.det(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Generate a tensor T such that T[:,:,0] = A, T[:,:,1] = A^2, T[:,:,2] = A^3 for some random matrix A.",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(3,3)\nT = np.stack([np.linalg.matrix_power(A, i+1) for i in range(3)], axis=2)\nprint('Powers of A:', [T[:,:,i] for i in range(3)])"
    },
    {
        "input": "Construct a tensor where the sum of elements along diagonals of all slices forms an arithmetic sequence.",
        "output": "import numpy as np\nT = np.zeros((3,3,3))\na, d = 2, 3\nfor i in range(3):\n    diag_val = a + i*d\n    T[:,:,i] = np.eye(3) * diag_val\nsums = [np.trace(T[:,:,i]) for i in range(3)]\nprint('Diagonal trace sums (arithmetic):', sums)"
    },
    {
        "input": "Build a tensor such that the angle (cosine similarity) between columns of each slice is constant.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    base = np.random.rand(3)\n    A = np.column_stack([base, base*2, base*3])\n    T[:,:,i] = A\ncosines = [np.dot(T[:,0,i], T[:,1,i]) / (np.linalg.norm(T[:,0,i]) * np.linalg.norm(T[:,1,i])) for i in range(3)]\nprint('Cosine similarities:', cosines)"
    },
    {
        "input": "Create a 3x3x3 tensor where each slice is both symmetric and has a fixed determinant of 2.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    A_sym = (A + A.T) / 2\n    eigvals, eigvecs = np.linalg.eigh(A_sym)\n    eigvals = eigvals / np.prod(eigvals) * 2\n    A_fixed = eigvecs @ np.diag(eigvals) @ eigvecs.T\n    T[:,:,i] = A_fixed\nprint('Determinants:', [np.linalg.det(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Construct a tensor such that each slice is orthogonal to the next under Frobenius inner product.",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(3,3)\nB = np.random.rand(3,3)\nB -= np.trace(A.T @ B) / np.trace(A.T @ A) * A\nC = np.random.rand(3,3)\nC -= np.trace(A.T @ C) / np.trace(A.T @ A) * A + np.trace(B.T @ C) / np.trace(B.T @ B) * B\nT = np.stack([A, B, C], axis=2)\nprint('Orthogonal under Frobenius:', [np.trace(T[:,:,i].T @ T[:,:,i+1]) for i in range(2)])"
    },
    {
        "input": "Generate a tensor T where all elements are integers and each slice has one unique prime number on the diagonal.",
        "output": "import numpy as np\nprimes = [2, 3, 5]\nT = np.zeros((3,3,3), dtype=int)\nfor i in range(3):\n    T[:,:,i] = np.eye(3, dtype=int) * primes[i]\nprint('Diagonals with unique primes:', [np.diag(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Build a tensor where all elements are rational and the mean of each slice is 1.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.randint(1, 10, (3,3))\n    A = A / A.mean()\n    T[:,:,i] = A\nprint('Slice means:', [T[:,:,i].mean() for i in range(3)])"
    },
    {
        "input": "Generate a tensor such that T[:,:,i] is a rotation by i * 30 degrees in 2D embedded in 3x3.",
        "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    theta = np.deg2rad(i * 30)\n    R = np.array([[np.cos(theta), -np.sin(theta), 0],\n                  [np.sin(theta),  np.cos(theta), 0],\n                  [0, 0, 1]])\n    T[:,:,i] = R\nprint('Rotation matrices embedded in 3x3:', T[:,:,0], T[:,:,1], T[:,:,2])"
    },
    {
        "input": "Construct a tensor T where all mode-1 fibers have standard deviation exactly 1.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.random.randn(3,3,3)\nfor i in range(3):\n    for j in range(3):\n        fiber = T[:,i,j]\n        T[:,i,j] = (fiber - np.mean(fiber)) / np.std(fiber)\nprint('Std deviation of mode-1 fibers:', [np.std(T[:,i,j]) for i in range(3) for j in range(3)])"
    },
    {
        "input": "Create a tensor such that the trace of each slice is equal and non-zero, and each slice is upper triangular.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\ntrace_val = 5\nfor i in range(3):\n    A = np.triu(np.random.rand(3,3))\n    scale = trace_val / np.trace(A)\n    T[:,:,i] = A * scale\nprint('Traces:', [np.trace(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Construct a tensor where each frontal slice has eigenvalues forming a geometric progression.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nbase, ratio = 2, 3\nfor i in range(3):\n    eigs = np.array([base * ratio**j for j in range(3)])\n    Q, _ = np.linalg.qr(np.random.rand(3,3))\n    T[:,:,i] = Q @ np.diag(eigs) @ Q.T\nprint('Eigenvalues of slices:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Create a 3x3x3 tensor such that the vectorization of each slice is orthogonal to the others.",
        "output": "import numpy as np\nnp.random.seed(0)\nQ, _ = np.linalg.qr(np.random.randn(9,9))\nvecs = Q[:, :3].T\nT = np.stack([v.reshape(3,3) for v in vecs], axis=2)\nprint('Dot products of vectorized slices:', [np.dot(vecs[i], vecs[j]) for i in range(3) for j in range(i+1, 3)])"
    },
    {
        "input": "Generate a tensor such that T[i,j,k] = i^2 + j^2 - k^2.",
        "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    for j in range(3):\n        for k in range(3):\n            T[i,j,k] = i**2 + j**2 - k**2\nprint(T)"
    },
    {
        "input": "Create a tensor where the determinant of each slice is equal to the slice index (starting from 1).",
        "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.eye(3) * (i+1)**(1/3)\n    T[:,:,i] = A\nprint('Determinants:', [np.linalg.det(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Construct a tensor such that the sum of the elements of the diagonal of each slice equals 10.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    diag = np.random.rand(3)\n    diag = diag / diag.sum() * 10\n    T[:,:,i] = np.diag(diag)\nprint('Diagonal sums:', [np.trace(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Make a tensor T such that the columns of every slice are linearly dependent.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    col1 = np.random.rand(3)\n    col2 = 2 * col1\n    col3 = -col1\n    T[:,:,i] = np.column_stack([col1, col2, col3])\nprint('Ranks of slices:', [np.linalg.matrix_rank(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Generate a tensor where each slice is symmetric and the sum of its eigenvalues is zero.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    eigvals = np.random.randn(3)\n    eigvals -= eigvals.mean()\n    Q, _ = np.linalg.qr(np.random.rand(3,3))\n    T[:,:,i] = Q @ np.diag(eigvals) @ Q.T\nprint('Eigenvalue sums:', [np.sum(np.linalg.eigvals(T[:,:,i])) for i in range(3)])"
    },
    {
        "input": "Create a tensor where each slice has condition number less than 10.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    while True:\n        A = np.random.rand(3,3) + np.eye(3)\n        if np.linalg.cond(A) < 10:\n            T[:,:,i] = A\n            break\nprint('Condition numbers:', [np.linalg.cond(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Create a 3x3x3 tensor where each slice is a lower triangular matrix with integer entries and a determinant of 1.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3), dtype=int)\nfor i in range(3):\n    L = np.tril(np.random.randint(1, 5, (3,3)))\n    L[2,2] = int(np.linalg.det(L[:2,:2]))\n    T[:,:,i] = L\nprint('Determinants:', [np.linalg.det(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Generate a tensor where each slice is a circulant matrix with eigenvalues forming an arithmetic sequence.",
        "output": "import numpy as np\nfrom scipy.linalg import circulant\nT = np.zeros((3,3,3))\nfor i in range(3):\n    first_row = np.arange(i, i+3)\n    T[:,:,i] = circulant(first_row)\nprint('Eigenvalues:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Construct a tensor where each slice is an orthogonal matrix with determinant -1.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    if np.linalg.det(Q) > 0:\n        Q[:,0] = -Q[:,0]\n    T[:,:,i] = Q\nprint('Determinants:', [np.linalg.det(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Create a tensor where each slice is a Toeplitz matrix with the first row being a geometric sequence.",
        "output": "import numpy as np\nfrom scipy.linalg import toeplitz\nT = np.zeros((3,3,3))\nfor i in range(3):\n    first_row = np.geomspace(1, 2**(i+1), num=3)\n    T[:,:,i] = toeplitz(first_row)\nprint('Toeplitz matrices:', T)"
    },
    {
        "input": "Generate a tensor where each slice is a Hankel matrix with anti-diagonals forming a harmonic sequence.",
        "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    anti_diag = 1 / np.arange(1, 4)\n    hankel_matrix = np.zeros((3, 3))\n    for row in range(3):\n        for col in range(3):\n            hankel_matrix[row, col] = anti_diag[row + col if row + col < 3 else 5 - (row + col)]\n    T[:,:,i] = hankel_matrix\nprint('Hankel matrices:', T)"
    },
    {
        "input": "Construct a tensor where each slice is a symmetric matrix with eigenvalues summing to zero and trace zero.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.randn(3,3)\n    A = (A + A.T) / 2\n    A -= np.trace(A) / 3 * np.eye(3)\n    T[:,:,i] = A\nprint('Traces:', [np.trace(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Create a tensor where each slice is a skew-symmetric matrix with integer entries.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3), dtype=int)\nfor i in range(3):\n    A = np.random.randint(-5, 6, (3,3))\n    T[:,:,i] = A - A.T\nprint('Skew-symmetric matrices:', T)"
    },
    {
        "input": "Generate a tensor where each slice is a doubly stochastic matrix.",
        "output": "import numpy as np\nfrom scipy.optimize import linprog\nT = np.zeros((3,3,3))\nfor i in range(3):\n    c = np.zeros(9)\n    A_eq = []\n    b_eq = []\n    for j in range(3):\n        row_constraint = np.zeros(9)\n        row_constraint[j*3:(j+1)*3] = 1\n        A_eq.append(row_constraint)\n        b_eq.append(1)\n    for j in range(3):\n        col_constraint = np.zeros(9)\n        col_constraint[j::3] = 1\n        A_eq.append(col_constraint)\n        b_eq.append(1)\n    bounds = [(0, 1)] * 9\n    A_eq = np.array(A_eq)\n    b_eq = np.array(b_eq)\n    res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    T[:,:,i] = res.x.reshape(3,3)\nprint('Doubly stochastic matrices:', T)"
    },
    {
        "input": "Construct a tensor where each slice is an idempotent matrix (A^2 = A) with rank 2.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.randn(3,2)\n    P = A @ np.linalg.pinv(A)\n    T[:,:,i] = P\nprint('Idempotent matrices:', T)"
    },
    {
        "input": "Create a tensor where each slice is a symmetric positive definite matrix with condition number 5.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    U, _ = np.linalg.qr(np.random.randn(3,3))\n    S = np.diag([1, 2.5, 5])\n    A = U @ S @ U.T\n    T[:,:,i] = A\nprint('Condition numbers:', [np.linalg.cond(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Generate a tensor where each slice is a matrix with eigenvalues that are all purely imaginary.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3), dtype=complex)\nfor i in range(3):\n    A = np.random.randn(3,3)\n    A = (A - A.T) * 1j\n    T[:,:,i] = A\nprint('Eigenvalues:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Generate a tensor such that each slice is a nilpotent matrix (A^k = 0 for some k).",
        "output": "import numpy as np\nT = np.zeros((3,3,1))\nA = np.array([[0,1,0],[0,0,1],[0,0,0]])\nT[:,:,0] = A\nprint('Nilpotent check:', np.linalg.matrix_power(T[:,:,0], 3))"
    },
    {
        "input": "Construct a tensor where each slice is a Jordan block with eigenvalue 1.",
        "output": "import numpy as np\nT = np.zeros((3,3,3))\nJ = np.eye(3)\nJ[0,1] = J[1,2] = 1\nfor i in range(3):\n    T[:,:,i] = J\nprint('Jordan block matrix eigenvalues:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Create a tensor such that T[i,j,k] = sin(i) * cos(j) + k^2.",
        "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    for j in range(3):\n        for k in range(3):\n            T[i,j,k] = np.sin(i) * np.cos(j) + k**2\nprint(T)"
    },
    {
        "input": "Construct a tensor where each slice is an invertible matrix with integer entries and integer inverse.",
        "output": "import numpy as np\nfrom sympy import Matrix\nnp.random.seed(0)\nT = np.zeros((3,3,3), dtype=int)\nfor i in range(3):\n    while True:\n        A = np.random.randint(-5, 6, (3,3))\n        try:\n            inv = np.array(Matrix(A).inv()).astype(int)\n            T[:,:,i] = A\n            break\n        except:\n            continue\nprint('Integer inverse slices:', T)"
    },
    {
        "input": "Generate a tensor where the rank of each slice is exactly 1.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    u = np.random.rand(3,1)\n    v = np.random.rand(1,3)\n    T[:,:,i] = u @ v\nprint('Ranks:', [np.linalg.matrix_rank(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Create a tensor where the Frobenius norm of each slice equals its spectral norm.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.zeros((3,3))\n    A[0,0] = np.random.rand()\n    T[:,:,i] = A\nprint('Norms check:', [(np.linalg.norm(T[:,:,i]), np.linalg.norm(T[:,:,i], 2)) for i in range(3)])"
    },
    {
        "input": "Create a tensor where each slice's condition number increases geometrically.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nratios = [1, 10, 100]\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.rand(3,3))\n    S = np.diag([1, 1, ratios[i]])\n    T[:,:,i] = Q @ S @ Q.T\nprint('Condition numbers:', [np.linalg.cond(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Construct a 3x3x3 tensor such that each slice is an upper triangular matrix with distinct eigenvalues.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.triu(np.random.randint(1, 10, (3,3)))\n    while len(set(np.round(np.linalg.eigvals(A), 5))) < 3:\n        A = np.triu(np.random.randint(1, 10, (3,3)))\n    T[:,:,i] = A\nprint('Eigenvalues:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Construct a tensor such that the singular values of each slice form a geometric progression.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    U, _ = np.linalg.qr(np.random.rand(3,3))\n    V, _ = np.linalg.qr(np.random.rand(3,3))\n    s = np.geomspace(1, 9, 3)\n    S = np.diag(s)\n    T[:,:,i] = U @ S @ V.T\nprint('Singular values:', [np.linalg.svd(T[:,:,i], compute_uv=False) for i in range(3)])"
    },
    {
        "input": "Create a tensor where each slice is a companion matrix of a polynomial with alternating sign coefficients.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    coeffs = [(-1)**j * np.random.randint(1, 5) for j in range(4)]\n    A = np.zeros((3,3))\n    A[1:, :-1] = np.eye(2)\n    A[0, :] = -np.array(coeffs[1:])\n    T[:,:,i] = A\nprint('Polynomials:', coeffs)"
    },
    {
        "input": "Generate a tensor where the sum over all slices results in a diagonal matrix with decreasing entries.",
        "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    D = np.diag([9-i, 6-i, 3-i])\n    T[:,:,i] = D\nS = np.sum(T, axis=2)\nprint('Summed tensor (should be diagonal decreasing):\\n', S)"
    },
    {
        "input": "Construct a tensor where each slice is a 3x3 matrix with purely imaginary eigenvalues.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3), dtype=complex)\nfor i in range(3):\n    A = np.array([[0, -np.random.rand(), 0], [np.random.rand(), 0, 0], [0, 0, 0]])\n    T[:,:,i] = A\nprint('Eigenvalues:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Generate a tensor where each slice has rank 2 and nullity 1.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,2)\n    T[:,:,i] = A @ np.random.rand(2,3)\nprint('Ranks:', [np.linalg.matrix_rank(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Create a tensor where each slice is both symmetric and has determinant equal to 1.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    while True:\n        A = np.random.rand(3,3)\n        A = (A + A.T)/2\n        if np.isclose(np.linalg.det(A), 1, atol=0.1):\n            T[:,:,i] = A\n            break\nprint('Determinants:', [np.linalg.det(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Construct a tensor where each slice is a symmetric matrix with one zero eigenvalue.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.rand(3,3))\n    D = np.diag([0, np.random.rand(), np.random.rand()])\n    T[:,:,i] = Q @ D @ Q.T\nprint('Eigenvalues:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Construct a tensor where the norm of the matrix exponential of each slice is less than 100.",
        "output": "import numpy as np\nfrom scipy.linalg import expm\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    while True:\n        A = np.random.rand(3,3) - 0.5\n        if np.linalg.norm(expm(A)) < 100:\n            T[:,:,i] = A\n            break\nprint('Exponential norms:', [np.linalg.norm(expm(T[:,:,i])) for i in range(3)])"
    },
    {
        "input": "Create a tensor where each slice is a matrix whose cube is zero but square is not.",
        "output": "import numpy as np\nT = np.zeros((3,3,3))\nA = np.array([[0,1,0],[0,0,1],[0,0,0]])\nfor i in range(3):\n    T[:,:,i] = A\nprint('Check A^2 != 0, A^3 == 0:', np.linalg.matrix_power(A,2), np.linalg.matrix_power(A,3))"
    },
    {
        "input": "Construct a tensor where each slice's trace is equal to the sum of its eigenvalues squared.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    while True:\n        A = np.random.randn(3,3)\n        eigs = np.linalg.eigvals(A)\n        if np.isclose(np.trace(A), np.sum(eigs**2), atol=0.1):\n            T[:,:,i] = A\n            break\nprint('Condition check:', [np.trace(T[:,:,i]) - np.sum(np.linalg.eigvals(T[:,:,i])**2) for i in range(3)])"
    },
    {
        "input": "Generate a tensor where the eigenvalues of each slice form an arithmetic progression.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    d = np.random.randint(1, 5)\n    a = np.random.randint(1, 5)\n    eigs = np.array([a, a+d, a+2*d])\n    A = Q @ np.diag(eigs) @ Q.T\n    T[:,:,i] = A\nprint('Eigenvalues in AP:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Create a tensor where the eigenvalues of each slice lie on the unit circle in the complex plane.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3), dtype=complex)\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3) + 1j*np.random.randn(3,3))\n    eigs = np.exp(2j * np.pi * np.random.rand(3))\n    T[:,:,i] = Q @ np.diag(eigs) @ np.linalg.inv(Q)\nprint('Eigenvalues on unit circle:', [np.abs(np.linalg.eigvals(T[:,:,i])) for i in range(3)])"
    },
    {
        "input": "Construct a tensor where each slice is a Jordan block of size 3 for eigenvalue λ=2.",
        "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.array([[2,1,0],[0,2,1],[0,0,2]])\n    T[:,:,i] = A\nprint('Jordan blocks for λ=2')"
    },
    {
        "input": "Generate a tensor where all slices are diagonalizable over ℂ but not over ℝ.",
        "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    theta = np.pi/3\n    A = np.array([[0, -theta, 0], [theta, 0, 0], [0, 0, 1]])\n    T[:,:,i] = A\nprint('Eigenvalues complex:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Create a tensor where each slice has determinant -1 and trace 0.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    while True:\n        A = np.random.randn(3,3)\n        if np.isclose(np.linalg.det(A), -1, atol=0.1) and np.isclose(np.trace(A), 0, atol=0.1):\n            T[:,:,i] = A\n            break\nprint('Det = -1 and Trace = 0 check:', [np.linalg.det(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Create a tensor where each slice is a rank-1 matrix formed by outer products of random vectors.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    v = np.random.randn(3)\n    T[:,:,i] = np.outer(v, v)\nprint('Ranks:', [np.linalg.matrix_rank(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Generate a tensor where each slice has eigenvalues forming a geometric progression.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    r = np.random.randint(2, 5)\n    eigs = np.array([1, r, r**2])\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    A = Q @ np.diag(eigs) @ np.linalg.inv(Q)\n    T[:,:,i] = A\nprint('Eigenvalues in GP:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Create a tensor where each slice is a symmetric matrix with condition number exactly 1.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    A = Q @ np.eye(3) @ Q.T\n    T[:,:,i] = A\nprint('Condition number = 1:', [np.linalg.cond(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Construct a tensor where each slice is a stochastic matrix (rows sum to 1).",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    T[:,:,i] = A / A.sum(axis=1, keepdims=True)\nprint('Row sums:', [T[:,:,i].sum(axis=1) for i in range(3)])"
    },
    {
        "input": "Generate a tensor where the SVD of each slice has singular values all equal.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    U, _ = np.linalg.qr(np.random.randn(3,3))\n    V, _ = np.linalg.qr(np.random.randn(3,3))\n    s = np.ones(3)\n    A = U @ np.diag(s) @ V.T\n    T[:,:,i] = A\nprint('Singular values:', [np.linalg.svd(T[:,:,i], compute_uv=False) for i in range(3)])"
    },
    {
        "input": "Construct a tensor where the determinant of the product of all slices equals 1.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nA = np.eye(3)\nfor i in range(3):\n    R = np.random.rand(3,3)\n    R = R / np.cbrt(np.linalg.det(R))\n    T[:,:,i] = R\n    A = A @ R\nprint('Determinant of product:', np.linalg.det(A))"
    },
    {
        "input": "Create a tensor where each slice has a Jordan form with one block of size 2 and one of size 1 for the same eigenvalue.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    λ = np.random.randint(1,5)\n    J = np.array([[λ,1,0],[0,λ,0],[0,0,λ]])\n    P = np.random.rand(3,3)\n    A = np.linalg.inv(P) @ J @ P\n    T[:,:,i] = A\nprint('Jordan block: λ with sizes 2 and 1')"
    },
    {
        "input": "Generate a tensor where the determinant of each frontal slice is zero, but the tensor slices are not all zero matrices.",
        "output": "import numpy as np\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.randn(3,2) @ np.random.randn(2,3)\n    T[:,:,i] = A\nprint('Determinants:', [np.linalg.det(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Construct a tensor where each slice has eigenvalues forming a geometric sequence.",
        "output": "import numpy as np\nfrom scipy.linalg import eigvals\nnp.random.seed(0)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    v = np.geomspace(1, 4, num=3)\n    V = np.linalg.qr(np.random.randn(3,3))[0]\n    A = V @ np.diag(v) @ np.linalg.inv(V)\n    T[:,:,i] = A.real\nprint('Eigenvalues per slice:', [eigvals(T[:,:,i]) for i in range(3)])"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[4, 2], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[4, 2], [1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[0, -1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[1, 2], [2, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[3, -2], [4, -1]].",
        "output": "import numpy as np\nA = np.array([[3, -2], [4, -1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[1, 0, 0], [0, 2, 0], [0, 0, 3]].",
        "output": "import numpy as np\nA = np.array([[1, 0, 0], [0, 2, 0], [0, 0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[5, 4, 2], [4, 5, 2], [2, 2, 2]].",
        "output": "import numpy as np\nA = np.array([[5, 4, 2], [4, 5, 2], [2, 2, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[0, 1, 0], [0, 0, 1], [1, 0, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[6, 2, 1], [2, 3, 1], [1, 1, 1]].",
        "output": "import numpy as np\nA = np.array([[6, 2, 1], [2, 3, 1], [1, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[4, 1, 2], [1, 3, 0], [2, 0, 3]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 2], [1, 3, 0], [2, 0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[1, 2, 3], [2, 1, 2], [3, 2, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 1, 2], [3, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[7, 5, 1], [5, 7, 1], [1, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[7, 5, 1], [5, 7, 1], [1, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[2, -2, 0], [-2, 2, -2], [0, -2, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -2, 0], [-2, 2, -2], [0, -2, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the identity matrix I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]].",
        "output": "import numpy as np\nA = np.eye(3)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a diagonal matrix A = [[5, 0, 0], [0, 3, 0], [0, 0, 1]].",
        "output": "import numpy as np\nA = np.array([[5, 0, 0], [0, 3, 0], [0, 0, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[8, 1, 6], [3, 5, 7], [4, 9, 2]].",
        "output": "import numpy as np\nA = np.array([[8, 1, 6], [3, 5, 7], [4, 9, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[0, 2, -1], [2, 3, 1], [-1, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[0, 2, -1], [2, 3, 1], [-1, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[1, 3, 1], [3, 1, 3], [1, 3, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 3, 1], [3, 1, 3], [1, 3, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[4, -2, 1], [-2, 4, -2], [1, -2, 4]].",
        "output": "import numpy as np\nA = np.array([[4, -2, 1], [-2, 4, -2], [1, -2, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[10, -5], [-5, 10]].",
        "output": "import numpy as np\nA = np.array([[10, -5], [-5, 10]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[1, 4, 3], [4, 1, 2], [3, 2, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 4, 3], [4, 1, 2], [3, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a symmetric matrix A = [[6, 2, -1], [2, 3, 1], [-1, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[6, 2, -1], [2, 3, 1], [-1, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[2, 2, 1], [1, 3, 1], [1, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 2, 1], [1, 3, 1], [1, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[5, -2, 2], [-2, 5, -2], [2, -2, 5]].",
        "output": "import numpy as np\nA = np.array([[5, -2, 2], [-2, 5, -2], [2, -2, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[0, 1, 2], [2, 0, 1], [1, 2, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 2], [2, 0, 1], [1, 2, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[3, 1], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[1, -1], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, -1], [1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[0, 2], [2, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 2], [2, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[5, 2], [2, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 2], [2, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[7, -2], [-2, 7]].",
        "output": "import numpy as np\nA = np.array([[7, -2], [-2, 7]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[4, 0, 1], [0, 4, 1], [1, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[4, 0, 1], [0, 4, 1], [1, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[3, -1, 0], [-1, 3, -1], [0, -1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -1, 0], [-1, 3, -1], [0, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[2, 1, 1], [1, 2, 1], [1, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[9, 3, 1], [3, 7, 2], [1, 2, 4]].",
        "output": "import numpy as np\nA = np.array([[9, 3, 1], [3, 7, 2], [1, 2, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[6, -3, 2], [-3, 6, -1], [2, -1, 3]].",
        "output": "import numpy as np\nA = np.array([[6, -3, 2], [-3, 6, -1], [2, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[2, 2, 1], [2, 3, 2], [1, 2, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 2, 1], [2, 3, 2], [1, 2, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[4, 1, 1], [1, 4, 1], [1, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 1], [1, 4, 1], [1, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[5, 2, 2], [2, 3, 1], [2, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[5, 2, 2], [2, 3, 1], [2, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[1, 2, 3], [2, 1, 2], [3, 2, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 1, 2], [3, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[4, -2, 1], [-2, 4, -2], [1, -2, 4]].",
        "output": "import numpy as np\nA = np.array([[4, -2, 1], [-2, 4, -2], [1, -2, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[5, -2, 2], [-2, 5, -2], [2, -2, 5]].",
        "output": "import numpy as np\nA = np.array([[5, -2, 2], [-2, 5, -2], [2, -2, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[1, 0, 0], [0, 2, 3], [0, 3, 2]].",
        "output": "import numpy as np\nA = np.array([[1, 0, 0], [0, 2, 3], [0, 3, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[3, 1, -1], [1, 3, 1], [-1, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1, -1], [1, 3, 1], [-1, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[4, -1, 0], [-1, 4, -1], [0, -1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, -1, 0], [-1, 4, -1], [0, -1, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[0, 2, 2], [2, 3, 2], [2, 2, 4]].",
        "output": "import numpy as np\nA = np.array([[0, 2, 2], [2, 3, 2], [2, 2, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[1, 2, 1], [2, 1, 2], [1, 2, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 1], [2, 1, 2], [1, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[2, 0, 0], [0, 3, 4], [0, 4, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 0, 0], [0, 3, 4], [0, 4, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[5, 2, 0], [2, 3, 1], [0, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[5, 2, 0], [2, 3, 1], [0, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[4, 2, 2], [2, 3, 1], [2, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[4, 2, 2], [2, 3, 1], [2, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[2, 1, 1], [1, 2, 1], [1, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[3, -2, 1], [-2, 3, -2], [1, -2, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -2, 1], [-2, 3, -2], [1, -2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[5, 3, 1], [3, 6, 2], [1, 2, 4]].",
        "output": "import numpy as np\nA = np.array([[5, 3, 1], [3, 6, 2], [1, 2, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[0, 1, -1], [1, 0, 1], [-1, 1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, -1], [1, 0, 1], [-1, 1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[10, -5, 2], [-5, 6, -2], [2, -2, 5]].",
        "output": "import numpy as np\nA = np.array([[10, -5, 2], [-5, 6, -2], [2, -2, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the 4x4 matrix A = [[4, 1, 2, -1], [1, 3, 0, 2], [2, 0, 5, 3], [-1, 2, 3, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 2, -1], [1, 3, 0, 2], [2, 0, 5, 3], [-1, 2, 3, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the complex matrix A = [[2+3j, -1j], [1j, 2-3j]].",
        "output": "import numpy as np\nA = np.array([[2+3j, -1j], [1j, 2-3j]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the 5x5 matrix A = [[5, -1, 2, 3, 1], [-1, 6, -2, 4, -3], [2, -2, 7, 1, 0], [3, 4, 1, 8, -2], [1, -3, 0, -2, 9]].",
        "output": "import numpy as np\nA = np.array([[5, -1, 2, 3, 1], [-1, 6, -2, 4, -3], [2, -2, 7, 1, 0], [3, 4, 1, 8, -2], [1, -3, 0, -2, 9]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[2, -1], [-1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1], [-1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[4, 1], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[4, 1], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[0, 1], [-1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [-1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the 3x3 matrix A = [[3, 1, 1], [1, 3, 1], [1, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1, 1], [1, 3, 1], [1, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[1, -2, 0], [-2, 1, -2], [0, -2, 1]].",
        "output": "import numpy as np\nA = np.array([[1, -2, 0], [-2, 1, -2], [0, -2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 4x4 matrix A = [[1, 2, 3, 4], [2, 1, 2, 3], [3, 2, 1, 2], [4, 3, 2, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3, 4], [2, 1, 2, 3], [3, 2, 1, 2], [4, 3, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[5, -1, 0], [-1, 5, -1], [0, -1, 5]].",
        "output": "import numpy as np\nA = np.array([[5, -1, 0], [-1, 5, -1], [0, -1, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the identity matrix A = [[1, 0, 0], [0, 1, 0], [0, 0, 1]].",
        "output": "import numpy as np\nA = np.eye(3)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the diagonal matrix A = [[2, 0, 0], [0, 5, 0], [0, 0, 7]].",
        "output": "import numpy as np\nA = np.diag([2, 5, 7])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the symmetric matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the complex matrix A = [[0, 1j], [-1j, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1j], [-1j, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 5x5 random integer matrix.",
        "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.randint(-5, 5, (5, 5))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 3x3 lower triangular matrix A = [[4, 0, 0], [-1, 3, 0], [2, -2, 2]].",
        "output": "import numpy as np\nA = np.array([[4, 0, 0], [-1, 3, 0], [2, -2, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[3, -2, 4], [-2, 6, 2], [4, 2, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -2, 4], [-2, 6, 2], [4, 2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[2, 0, 1], [0, 3, 0], [1, 0, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 0, 1], [0, 3, 0], [1, 0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the singular matrix A = [[1, 2, 3], [2, 4, 6], [3, 6, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 4, 6], [3, 6, 9]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the matrix A = [[0, 1, 1], [1, 0, 1], [1, 1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 1], [1, 0, 1], [1, 1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the matrix A = [[5, 0, 2], [0, 5, -2], [2, -2, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 0, 2], [0, 5, -2], [2, -2, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a random 4x4 symmetric matrix.",
        "output": "import numpy as np\nnp.random.seed(1)\nA = np.random.randint(-5, 5, (4, 4))\nA = (A + A.T) / 2\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the skew-symmetric matrix A = [[0, -2, 3], [2, 0, -1], [-3, 1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -2, 3], [2, 0, -1], [-3, 1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the skew-symmetric matrix A = [[0, -2, 3], [2, 0, -1], [-3, 1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -2, 3], [2, 0, -1], [-3, 1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 5x5 random symmetric matrix.",
        "output": "import numpy as np\nnp.random.seed(2)\nA = np.random.randint(-5, 5, (5, 5))\nA = (A + A.T) / 2\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 4x4 Jordan block matrix A = [[5, 1, 0, 0], [0, 5, 1, 0], [0, 0, 5, 1], [0, 0, 0, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 1, 0, 0], [0, 5, 1, 0], [0, 0, 5, 1], [0, 0, 0, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the circulant matrix A = [[0, 1, 2], [2, 0, 1], [1, 2, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import circulant\nA = circulant([0, 1, 2])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the 3x3 Toeplitz matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import toeplitz\nA = toeplitz([2, -1, 0])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a randomly generated 6x6 matrix.",
        "output": "import numpy as np\nnp.random.seed(3)\nA = np.random.randint(-10, 10, (6, 6))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the Pascal matrix A of order 4.",
        "output": "import numpy as np\nfrom scipy.linalg import pascal\nA = pascal(4)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 3x3 nilpotent matrix A = [[0, 1, 0], [0, 0, 1], [0, 0, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 5x5 diagonal matrix with repeating eigenvalues A = [[3, 0, 0, 0, 0], [0, 3, 0, 0, 0], [0, 0, 3, 0, 0], [0, 0, 0, 4, 0], [0, 0, 0, 0, 4]].",
        "output": "import numpy as np\nA = np.array([[3, 0, 0, 0, 0], [0, 3, 0, 0, 0], [0, 0, 3, 0, 0], [0, 0, 0, 4, 0], [0, 0, 0, 0, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of a random 7x7 symmetric matrix.",
        "output": "import numpy as np\nnp.random.seed(4)\nA = np.random.randint(-10, 10, (7, 7))\nA = (A + A.T) / 2\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a magic square matrix of order 4.",
        "output": "import numpy as np\nA = np.array([[16, 3, 2, 13],\n              [5, 10, 11, 8],\n              [9, 6, 7, 12],\n              [4, 15, 14, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Magic Square Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the circulant matrix A = [[1, 2, 3], [3, 1, 2], [2, 3, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import circulant\nA = circulant([1, 2, 3])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the Markov transition matrix A = [[0.7, 0.2, 0.1], [0.3, 0.5, 0.2], [0.2, 0.3, 0.5]].",
        "output": "import numpy as np\nA = np.array([[0.7, 0.2, 0.1], [0.3, 0.5, 0.2], [0.2, 0.3, 0.5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the lower triangular matrix A = [[2, 0, 0], [1, 3, 0], [4, -2, 5]].",
        "output": "import numpy as np\nA = np.array([[2, 0, 0], [1, 3, 0], [4, -2, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the random 8x8 matrix.",
        "output": "import numpy as np\nnp.random.seed(5)\nA = np.random.randint(-20, 20, (8, 8))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of a Pascal matrix of order 5.",
        "output": "import numpy as np\nfrom scipy.linalg import pascal\nA = pascal(5)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the symmetric matrix A = [[4, -2, 1], [-2, 4, -2], [1, -2, 4]].",
        "output": "import numpy as np\nA = np.array([[4, -2, 1], [-2, 4, -2], [1, -2, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 5x5 symmetric matrix A = [[4, 1, 2, 3, 5], [1, 3, -1, 2, 4], [2, -1, 5, 1, 0], [3, 2, 1, 4, -2], [5, 4, 0, -2, 3]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 2, 3, 5], [1, 3, -1, 2, 4], [2, -1, 5, 1, 0], [3, 2, 1, 4, -2], [5, 4, 0, -2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a nearly singular 4x4 matrix A = [[1e-5, 1, 2, 3], [1, 2e-5, 3, 4], [2, 3, 3e-5, 5], [3, 4, 5, 4e-5]].",
        "output": "import numpy as np\nA = np.array([[1e-5, 1, 2, 3], [1, 2e-5, 3, 4], [2, 3, 3e-5, 5], [3, 4, 5, 4e-5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 6x6 random integer matrix.",
        "output": "import numpy as np\nnp.random.seed(6)\nA = np.random.randint(-50, 50, (6, 6))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the complex matrix A = [[2+3j, -1+2j], [4-2j, 1+4j]].",
        "output": "import numpy as np\nA = np.array([[2+3j, -1+2j], [4-2j, 1+4j]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of a perturbed identity matrix A = [[1, 0.01, 0.02], [0.01, 1, 0.03], [0.02, 0.03, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 0.01, 0.02], [0.01, 1, 0.03], [0.02, 0.03, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 5x5 random symmetric matrix.",
        "output": "import numpy as np\nnp.random.seed(7)\nA = np.random.randint(-30, 30, (5, 5))\nA = (A + A.T) / 2\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a nearly singular matrix A = [[1, 2, 3, 4], [2, 4.0001, 6, 8], [3, 6, 9.0001, 12], [4, 8, 12, 16.0001]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3, 4], [2, 4.0001, 6, 8], [3, 6, 9.0001, 12], [4, 8, 12, 16.0001]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the 6x6 Jordan block matrix J = [[3, 1, 0, 0, 0, 0], [0, 3, 1, 0, 0, 0], [0, 0, 3, 1, 0, 0], [0, 0, 0, 3, 1, 0], [0, 0, 0, 0, 3, 1], [0, 0, 0, 0, 0, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1, 0, 0, 0, 0], [0, 3, 1, 0, 0, 0], [0, 0, 3, 1, 0, 0], [0, 0, 0, 3, 1, 0], [0, 0, 0, 0, 3, 1], [0, 0, 0, 0, 0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a Hankel matrix A = [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]].",
        "output": "import numpy as np\nfrom scipy.linalg import hankel\nA = hankel([1, 2, 3, 4], [4, 5, 6, 7])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 7x7 random matrix with integer values between -100 and 100.",
        "output": "import numpy as np\nnp.random.seed(8)\nA = np.random.randint(-100, 100, (7, 7))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a large 8x8 symmetric matrix with random values.",
        "output": "import numpy as np\nnp.random.seed(9)\nA = np.random.randint(-50, 50, (8, 8))\nA = (A + A.T) / 2\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of the 5x5 Toeplitz matrix A = [[2, -1, 0, 0, 0], [-1, 2, -1, 0, 0], [0, -1, 2, -1, 0], [0, 0, -1, 2, -1], [0, 0, 0, -1, 2]].",
        "output": "import numpy as np\nfrom scipy.linalg import toeplitz\nA = toeplitz([2, -1, 0, 0, 0])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the circulant matrix A = [[4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1], [1, 2, 3, 4]].",
        "output": "import numpy as np\nfrom scipy.linalg import circulant\nA = circulant([4, 1, 2, 3])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 4x4 Hermitian matrix A = [[3, 2-1j, 0, 1j], [2+1j, 5, -3j, 0], [0, 3j, 4, -2j], [-1j, 0, 2j, 6]].",
        "output": "import numpy as np\nA = np.array([[3, 2-1j, 0, 1j], [2+1j, 5, -3j, 0], [0, 3j, 4, -2j], [-1j, 0, 2j, 6]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a perturbed diagonal matrix A = [[10, 0.01, 0.02], [0.01, 20, 0.03], [0.02, 0.03, 30]].",
        "output": "import numpy as np\nA = np.array([[10, 0.01, 0.02], [0.01, 20, 0.03], [0.02, 0.03, 30]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a randomly generated 9x9 integer matrix.",
        "output": "import numpy as np\nnp.random.seed(10)\nA = np.random.randint(-25, 25, (9, 9))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 4x4 matrix where all elements are 1.",
        "output": "import numpy as np\nA = np.ones((4,4))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of a large 10x10 random symmetric matrix.",
        "output": "import numpy as np\nnp.random.seed(11)\nA = np.random.randint(-100, 100, (10, 10))\nA = (A + A.T) / 2\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a random 12x12 integer matrix.",
        "output": "import numpy as np\nnp.random.seed(12)\nA = np.random.randint(-50, 50, (12, 12))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a randomly generated 11x11 integer matrix.",
        "output": "import numpy as np\nnp.random.seed(13)\nA = np.random.randint(-30, 30, (11, 11))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a special block matrix A = [[2, 0, 0, 1], [0, 2, 1, 0], [0, 1, 2, 0], [1, 0, 0, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 0, 0, 1], [0, 2, 1, 0], [0, 1, 2, 0], [1, 0, 0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a rank-deficient 5x5 matrix A = [[1, 2, 3, 4, 5], [2, 4, 6, 8, 10], [3, 6, 9, 12, 15], [4, 8, 12, 16, 20], [5, 10, 15, 20, 25]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3, 4, 5], [2, 4, 6, 8, 10], [3, 6, 9, 12, 15], [4, 8, 12, 16, 20], [5, 10, 15, 20, 25]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of a Vandermonde matrix with base [1, 2, 3, 4].",
        "output": "import numpy as np\nfrom numpy.linalg import eig\nA = np.vander([1, 2, 3, 4])\neigenvalues, eigenvectors = eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a matrix with small perturbations: A = [[1, 1e-6], [1e-6, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1e-6], [1e-6, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a skew-symmetric matrix A = [[0, -2, -4], [2, 0, -6], [4, 6, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -2, -4], [2, 0, -6], [4, 6, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 6x6 matrix A where A[i][j] = i + j.",
        "output": "import numpy as np\nA = np.fromfunction(lambda i, j: i + j, (6, 6), dtype=int)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of the Pascal matrix of order 5.",
        "output": "import numpy as np\nfrom scipy.linalg import pascal\nA = pascal(5)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of a 6x6 diagonal matrix with values [1, 2, 3, 4, 5, 6] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([1, 2, 3, 4, 5, 6])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 5x5 lower triangular matrix where A[i][j] = i - j if i >= j, else 0.",
        "output": "import numpy as np\nA = np.tril(np.fromfunction(lambda i, j: i - j, (5, 5), dtype=int))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 5x5 matrix with all elements set to 5.",
        "output": "import numpy as np\nA = np.full((5, 5), 5)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the Hilbert matrix of order 6.",
        "output": "import numpy as np\nfrom scipy.linalg import hilbert\nA = hilbert(6)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 7x7 random matrix where values are between -10 and 10.",
        "output": "import numpy as np\nnp.random.seed(14)\nA = np.random.randint(-10, 10, (7, 7))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of a 4x4 orthogonal matrix A = [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 5x5 skew-symmetric matrix A = [[0, -3, -4, -2, -1], [3, 0, -5, -6, -7], [4, 5, 0, -8, -9], [2, 6, 8, 0, -10], [1, 7, 9, 10, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -3, -4, -2, -1], [3, 0, -5, -6, -7], [4, 5, 0, -8, -9], [2, 6, 8, 0, -10], [1, 7, 9, 10, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the companion matrix A = [[0, 0, 0, -1], [1, 0, 0, -6], [0, 1, 0, 11], [0, 0, 1, -6]].",
        "output": "import numpy as np\nA = np.array([[0, 0, 0, -1], [1, 0, 0, -6], [0, 1, 0, 11], [0, 0, 1, -6]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 6x6 circulant matrix where the first row is [1, 2, 3, 4, 5, 6].",
        "output": "import numpy as np\nfrom scipy.linalg import circulant\nA = circulant([1, 2, 3, 4, 5, 6])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 8x8 symmetric Toeplitz matrix where the first row is [4, -1, 0, 0, 0, 0, 0, -1].",
        "output": "import numpy as np\nfrom scipy.linalg import toeplitz\nA = toeplitz([4, -1, 0, 0, 0, 0, 0, -1])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 5x5 stochastic matrix where each row sums to 1.",
        "output": "import numpy as np\nA = np.array([[0.2, 0.3, 0.1, 0.2, 0.2], [0.1, 0.3, 0.3, 0.2, 0.1], [0.3, 0.1, 0.2, 0.2, 0.2], [0.2, 0.2, 0.3, 0.1, 0.2], [0.2, 0.1, 0.2, 0.3, 0.2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a block diagonal matrix with two 3x3 identity matrices on the diagonal.",
        "output": "import numpy as np\nfrom scipy.linalg import block_diag\nA = block_diag(np.eye(3), np.eye(3))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 9x9 random symmetric matrix with values between -20 and 20.",
        "output": "import numpy as np\nnp.random.seed(15)\nA = np.random.randint(-20, 20, (9, 9))\nA = (A + A.T) / 2\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a random 10x10 sparse matrix with mostly zero values.",
        "output": "import numpy as np\nfrom scipy.sparse import random\nA = random(10, 10, density=0.2, format='csr').toarray()\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 6x6 matrix where A[i][j] = min(i, j).",
        "output": "import numpy as np\nA = np.fromfunction(lambda i, j: np.minimum(i+1, j+1), (6, 6), dtype=int)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a matrix with a checkerboard pattern of 1s and 0s (6x6).",
        "output": "import numpy as np\nA = np.indices((6,6)).sum(axis=0) % 2\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 7x7 matrix where A[i][j] = cos(i + j).",
        "output": "from math import cos\nimport numpy as np\nA = np.fromfunction(lambda i, j: np.cos(i + j), (7, 7), dtype=int)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a tridiagonal matrix A where A[i][i] = 2, A[i][i-1] = A[i][i+1] = -1.",
        "output": "import numpy as np\nfrom scipy.linalg import toeplitz\nA = toeplitz([2, -1, 0, 0, 0, 0, 0])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of an 8x8 matrix A where A[i][j] = (-1)^(i+j) * (i + j).",
        "output": "import numpy as np\nA = np.fromfunction(lambda i, j: (-1)**(i+j) * (i + j), (8, 8), dtype=int)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 6x6 matrix with A[i][j] = gcd(i+1, j+1).",
        "output": "from math import gcd\nimport numpy as np\nA = np.fromfunction(lambda i, j: np.gcd(i.astype(int)+1, j.astype(int)+1), (6, 6), dtype=int)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('GCD Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 7x7 matrix where A[i][j] = 1 / (i + j + 1).",
        "output": "import numpy as np\nA = np.fromfunction(lambda i, j: 1 / (i + j + 1), (7, 7), dtype=float)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the adjacency matrix of a complete graph with 6 vertices.",
        "output": "import numpy as np\nA = np.ones((6,6)) - np.eye(6)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 Hadamard matrix.",
        "output": "import numpy as np\nfrom scipy.linalg import hadamard\nA = hadamard(4)\neigenvalues, _ = np.linalg.eig(A)\nprint('Hadamard Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a matrix with Fibonacci numbers as elements.",
        "output": "import numpy as np\nfib = [0, 1]\nfor _ in range(18):\n    fib.append(fib[-1] + fib[-2])\nfib = np.array(fib)\nA = np.fromfunction(lambda i, j: fib[(i + j).astype(int)], (5, 5), dtype=int)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Fibonacci-based Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 9x9 matrix where A[i][j] = (i+1) * (j+1).",
        "output": "import numpy as np\nA = np.fromfunction(lambda i, j: (i+1) * (j+1), (9, 9), dtype=int)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 6x6 magic square matrix.",
        "output": "import numpy as np\nfrom scipy.linalg import pascal\nA = pascal(6, kind='symmetric')\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 7x7 random skew-symmetric matrix.",
        "output": "import numpy as np\nnp.random.seed(17)\nA = np.random.randint(-10, 10, (7, 7))\nA = A - A.T\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a Vandermonde matrix with base [1, 3, 5, 7, 9, 11].",
        "output": "import numpy as np\nA = np.vander([1, 3, 5, 7, 9, 11])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 10x10 random orthogonal matrix.",
        "output": "import numpy as np\nfrom scipy.stats import ortho_group\nA = ortho_group.rvs(10)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 5x5 identity matrix multiplied by a random scalar.",
        "output": "import numpy as np\nnp.random.seed(18)\ns = np.random.randint(1, 10)\nA = s * np.eye(5)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a matrix where A[i][j] = sin(i+j).",
        "output": "from math import sin\nimport numpy as np\nA = np.fromfunction(lambda i, j: np.sin(i + j), (6, 6), dtype=float)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the adjacency matrix of a cycle graph with 7 vertices.",
        "output": "import numpy as np\nfrom scipy.linalg import circulant\nA = circulant([0, 1, 0, 0, 0, 0, 1])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a random 8x8 lower triangular matrix.",
        "output": "import numpy as np\nnp.random.seed(19)\nA = np.tril(np.random.randint(-10, 10, (8, 8)))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 9x9 upper triangular matrix where diagonal elements are [1,2,3,...,9].",
        "output": "import numpy as np\nA = np.triu(np.ones((9,9))) * np.arange(1, 10)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of an 8x8 random circulant matrix where the first row is randomly generated.",
        "output": "import numpy as np\nfrom scipy.linalg import circulant\nnp.random.seed(21)\nrow = np.random.randint(-5, 5, 8)\nA = circulant(row)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 7x7 matrix A where A[i][j] = i^2 - j^2.",
        "output": "import numpy as np\nA = np.fromfunction(lambda i, j: i**2 - j**2, (7, 7), dtype=int)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 9x9 Toeplitz matrix where the first row is [2, -1, 0, 0, 0, 0, 0, 0, -1].",
        "output": "import numpy as np\nfrom scipy.linalg import toeplitz\nA = toeplitz([2, -1, 0, 0, 0, 0, 0, 0, -1])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 6x6 symmetric matrix where A[i][j] = |i - j|.",
        "output": "import numpy as np\nA = np.fromfunction(lambda i, j: abs(i - j), (6, 6), dtype=int)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of an 8x8 anti-diagonal matrix where values are [1,2,3,...,8] on the anti-diagonal.",
        "output": "import numpy as np\nA = np.fliplr(np.diag(np.arange(1, 9)))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 5x5 symmetric matrix where A[i][j] = 1 if |i - j| ≤ 1, else 0.",
        "output": "import numpy as np\nA = np.fromfunction(lambda i, j: np.where(np.abs(i - j) <= 1, 1, 0), (5, 5), dtype=int)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Symmetric Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 2x2 identity matrix.",
        "output": "import numpy as np\nA = np.eye(2)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of the diagonal matrix [[3, 0], [0, 5]].",
        "output": "import numpy as np\nA = np.array([[3, 0], [0, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 2x2 zero matrix.",
        "output": "import numpy as np\nA = np.zeros((2, 2))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of the 2x2 matrix [[1, 2], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [0, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 diagonal matrix with values [2, 4, 6] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([2, 4, 6])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 identity matrix.",
        "output": "import numpy as np\nA = np.eye(3)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix where all elements are 1.",
        "output": "import numpy as np\nA = np.ones((2, 2))\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 2x2 symmetric matrix [[4, 1], [1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1], [1, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix with all zero values except for one nonzero diagonal element (e.g., [[0, 0], [0, 7]]).",
        "output": "import numpy as np\nA = np.array([[0, 0], [0, 7]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a triangular matrix [[2, 1], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [0, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 2x2 matrix [[2, 0], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 identity matrix.",
        "output": "import numpy as np\nA = np.eye(3)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 diagonal matrix [[1, 0, 0], [0, 5, 0], [0, 0, 9]].",
        "output": "import numpy as np\nA = np.diag([1, 5, 9])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 2x2 matrix [[0, 1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 upper triangular matrix [[2, 1, 0], [0, 4, 2], [0, 0, 6]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 0], [0, 4, 2], [0, 0, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 lower triangular matrix [[3, 0], [5, 7]].",
        "output": "import numpy as np\nA = np.array([[3, 0], [5, 7]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 2x2 matrix [[1, -1], [-1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, -1], [-1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 zero matrix.",
        "output": "import numpy as np\nA = np.zeros((3, 3))\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix where all elements are the same (e.g., [[2, 2], [2, 2]]).",
        "output": "import numpy as np\nA = np.array([[2, 2], [2, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a symmetric 3x3 matrix [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 2x2 matrix [[4, 0], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[4, 0], [0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 identity matrix multiplied by 7.",
        "output": "import numpy as np\nA = 7 * np.eye(3)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a diagonal 4x4 matrix with values [1, 2, 3, 4] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([1, 2, 3, 4])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 2x2 matrix [[3, 1], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 upper triangular matrix [[3, 2, 1], [0, 5, 4], [0, 0, 7]].",
        "output": "import numpy as np\nA = np.array([[3, 2, 1], [0, 5, 4], [0, 0, 7]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 lower triangular matrix [[5, 0], [3, 6]].",
        "output": "import numpy as np\nA = np.array([[5, 0], [3, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 2x2 matrix [[0, -1], [-1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -1], [-1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 zero matrix.",
        "output": "import numpy as np\nA = np.zeros((4, 4))\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix where all elements are 3 (e.g., [[3, 3], [3, 3]]).",
        "output": "import numpy as np\nA = np.array([[3, 3], [3, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a symmetric 3x3 matrix [[5, 2, 0], [2, 5, 2], [0, 2, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 2, 0], [2, 5, 2], [0, 2, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 2x2 matrix [[6, 0], [0, 8]].",
        "output": "import numpy as np\nA = np.array([[6, 0], [0, 8]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 identity matrix multiplied by 4.",
        "output": "import numpy as np\nA = 4 * np.eye(3)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a diagonal 3x3 matrix with values [7, 2, 5] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([7, 2, 5])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 2x2 matrix [[2, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 upper triangular matrix [[1, 3, 0], [0, 4, 5], [0, 0, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 3, 0], [0, 4, 5], [0, 0, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 lower triangular matrix [[9, 0], [4, 5]].",
        "output": "import numpy as np\nA = np.array([[9, 0], [4, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 2x2 matrix [[0, 2], [2, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 2], [2, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix where all elements are 4 (e.g., [[4, 4], [4, 4]]).",
        "output": "import numpy as np\nA = np.array([[4, 4], [4, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a symmetric 3x3 matrix [[3, 1, 0], [1, 3, 1], [0, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1, 0], [1, 3, 1], [0, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 3x3 matrix [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of the 3x3 matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the 3x3 matrix [[0, 1, 0], [-1, 0, 1], [0, -1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [-1, 0, 1], [0, -1, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 4x4 diagonal matrix with values [4, 3, 2, 1] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([4, 3, 2, 1])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 symmetric matrix [[5, 1, 2], [1, 4, 3], [2, 3, 6]].",
        "output": "import numpy as np\nA = np.array([[5, 1, 2], [1, 4, 3], [2, 3, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 triangular matrix [[2, 3, 1], [0, 5, 4], [0, 0, 7]].",
        "output": "import numpy as np\nA = np.array([[2, 3, 1], [0, 5, 4], [0, 0, 7]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 identity matrix multiplied by 9.",
        "output": "import numpy as np\nA = 9 * np.eye(4)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of the 3x3 circulant matrix [[0, 1, 1], [1, 0, 1], [1, 1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 1], [1, 0, 1], [1, 1, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 3x3 matrix with random integers between 1 and 10.",
        "output": "import numpy as np\nnp.random.seed(42)\nA = np.random.randint(1, 11, (3, 3))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 matrix with both positive and negative values [[4, -2, 1], [-2, 5, -3], [1, -3, 6]].",
        "output": "import numpy as np\nA = np.array([[4, -2, 1], [-2, 5, -3], [1, -3, 6]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 3x3 matrix [[3, -1, 0], [-1, 3, -1], [0, -1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -1, 0], [-1, 3, -1], [0, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of the 3x3 matrix [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the 3x3 symmetric matrix [[6, 2, 1], [2, 5, 3], [1, 3, 4]].",
        "output": "import numpy as np\nA = np.array([[6, 2, 1], [2, 5, 3], [1, 3, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 triangular matrix [[4, 3, 2], [0, 7, 5], [0, 0, 9]].",
        "output": "import numpy as np\nA = np.array([[4, 3, 2], [0, 7, 5], [0, 0, 9]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 diagonal matrix with values [2, -3, 5, 7] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([2, -3, 5, 7])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 matrix where all elements are 1 (e.g., [[1, 1, 1], [1, 1, 1], [1, 1, 1]]).",
        "output": "import numpy as np\nA = np.ones((3, 3))\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 3x3 matrix with negative values [[-2, -1, 0], [-1, -2, -1], [0, -1, -2]].",
        "output": "import numpy as np\nA = np.array([[-2, -1, 0], [-1, -2, -1], [0, -1, -2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 matrix [[2, -1, 1], [-1, 3, -1], [1, -1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 1], [-1, 3, -1], [1, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 upper triangular matrix with random values between 1 and 10.",
        "output": "import numpy as np\nnp.random.seed(42)\nA = np.triu(np.random.randint(1, 11, (4, 4)))\neigenvalues, _ = np.linalg.eig(A)\nprint('Matrix:\\n', A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 circulant matrix [[1, 2, 3], [3, 1, 2], [2, 3, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [3, 1, 2], [2, 3, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 3x3 matrix [[4, -2, 1], [-2, 4, -2], [1, -2, 4]].",
        "output": "import numpy as np\nA = np.array([[4, -2, 1], [-2, 4, -2], [1, -2, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of the 3x3 matrix [[1, 3, 2], [2, 1, 3], [3, 2, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 3, 2], [2, 1, 3], [3, 2, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the 3x3 symmetric matrix [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 upper triangular matrix [[5, 3, 2], [0, 4, 1], [0, 0, 6]].",
        "output": "import numpy as np\nA = np.array([[5, 3, 2], [0, 4, 1], [0, 0, 6]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 diagonal matrix with values [-1, -2, 3, 5] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([-1, -2, 3, 5])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 circulant matrix [[2, 1, 0], [0, 2, 1], [1, 0, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 0], [0, 2, 1], [1, 0, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 3x3 matrix with both positive and negative values [[3, -1, 1], [-1, 3, -1], [1, -1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -1, 1], [-1, 3, -1], [1, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 matrix [[1, 4, 2], [4, 1, 2], [2, 2, 3]].",
        "output": "import numpy as np\nA = np.array([[1, 4, 2], [4, 1, 2], [2, 2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 lower triangular matrix [[6, 0, 0], [2, 5, 0], [1, 3, 4]].",
        "output": "import numpy as np\nA = np.array([[6, 0, 0], [2, 5, 0], [1, 3, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 matrix with random integers between -5 and 5.",
        "output": "import numpy as np\nnp.random.seed(42)\nA = np.random.randint(-5, 6, (3, 3))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 3x3 matrix [[5, -1, 0], [-1, 5, -1], [0, -1, 5]].",
        "output": "import numpy as np\nA = np.array([[5, -1, 0], [-1, 5, -1], [0, -1, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of the 3x3 matrix [[3, 2, 1], [2, 3, 2], [1, 2, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 2, 1], [2, 3, 2], [1, 2, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the 3x3 symmetric matrix [[4, -2, 1], [-2, 4, -2], [1, -2, 4]].",
        "output": "import numpy as np\nA = np.array([[4, -2, 1], [-2, 4, -2], [1, -2, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 triangular matrix [[6, 2, 1], [0, 5, 3], [0, 0, 7]].",
        "output": "import numpy as np\nA = np.array([[6, 2, 1], [0, 5, 3], [0, 0, 7]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 diagonal matrix with values [-3, 2, 8, 5] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([-3, 2, 8, 5])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 circulant matrix [[3, 1, 2], [2, 3, 1], [1, 2, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1, 2], [2, 3, 1], [1, 2, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 3x3 matrix [[2, -3, 1], [-3, 2, -3], [1, -3, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -3, 1], [-3, 2, -3], [1, -3, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 matrix [[1, 5, 3], [5, 1, 3], [3, 3, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 5, 3], [5, 1, 3], [3, 3, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 lower triangular matrix [[7, 0, 0], [3, 6, 0], [1, 4, 5]].",
        "output": "import numpy as np\nA = np.array([[7, 0, 0], [3, 6, 0], [1, 4, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 matrix with random integers between -10 and 10.",
        "output": "import numpy as np\nnp.random.seed(42)\nA = np.random.randint(-10, 11, (3, 3))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 3x3 matrix [[6, -2, 1], [-2, 6, -2], [1, -2, 6]].",
        "output": "import numpy as np\nA = np.array([[6, -2, 1], [-2, 6, -2], [1, -2, 6]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of the 3x3 matrix [[4, 3, 2], [3, 4, 3], [2, 3, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 3, 2], [3, 4, 3], [2, 3, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the 3x3 symmetric matrix [[3, -1, 2], [-1, 3, -1], [2, -1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -1, 2], [-1, 3, -1], [2, -1, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 upper triangular matrix [[8, 1, 2], [0, 5, 3], [0, 0, 6]].",
        "output": "import numpy as np\nA = np.array([[8, 1, 2], [0, 5, 3], [0, 0, 6]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 diagonal matrix with values [4, -2, 7, 1] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([4, -2, 7, 1])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 circulant matrix [[5, 2, 3], [3, 5, 2], [2, 3, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 2, 3], [3, 5, 2], [2, 3, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 3x3 matrix [[1, -4, 2], [-4, 1, -4], [2, -4, 1]].",
        "output": "import numpy as np\nA = np.array([[1, -4, 2], [-4, 1, -4], [2, -4, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 matrix [[2, 6, 3], [6, 2, 3], [3, 3, 5]].",
        "output": "import numpy as np\nA = np.array([[2, 6, 3], [6, 2, 3], [3, 3, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 lower triangular matrix [[9, 0, 0], [4, 7, 0], [2, 6, 3]].",
        "output": "import numpy as np\nA = np.array([[9, 0, 0], [4, 7, 0], [2, 6, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 matrix with random integers between -7 and 7.",
        "output": "import numpy as np\nnp.random.seed(42)\nA = np.random.randint(-7, 8, (3, 3))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 4x4 matrix [[4, 2, -1, 1], [2, 5, 2, -2], [-1, 2, 6, 3], [1, -2, 3, 7]].",
        "output": "import numpy as np\nA = np.array([[4, 2, -1, 1], [2, 5, 2, -2], [-1, 2, 6, 3], [1, -2, 3, 7]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of the 4x4 matrix [[0, 1, 2, 3], [1, 0, -1, 2], [2, -1, 0, 1], [3, 2, 1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 2, 3], [1, 0, -1, 2], [2, -1, 0, 1], [3, 2, 1, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 5x5 matrix [[3, 2, 1, 0, -1], [2, 3, 2, 1, 0], [1, 2, 3, 2, 1], [0, 1, 2, 3, 2], [-1, 0, 1, 2, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 2, 1, 0, -1], [2, 3, 2, 1, 0], [1, 2, 3, 2, 1], [0, 1, 2, 3, 2], [-1, 0, 1, 2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 skew-symmetric matrix [[0, -2, 3, 4], [2, 0, -1, 2], [-3, 1, 0, 5], [-4, -2, -5, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -2, 3, 4], [2, 0, -1, 2], [-3, 1, 0, 5], [-4, -2, -5, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 4x4 circulant matrix [[1, 2, 3, 4], [4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3, 4], [4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 matrix with random integers between -10 and 10.",
        "output": "import numpy as np\nnp.random.seed(42)\nA = np.random.randint(-10, 11, (5, 5))\neigenvalues, _ = np.linalg.eig(A)\nprint('Matrix:\\n', A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the 4x4 tridiagonal matrix [[6, -2, 0, 0], [-2, 6, -2, 0], [0, -2, 6, -2], [0, 0, -2, 6]].",
        "output": "import numpy as np\nA = np.array([[6, -2, 0, 0], [-2, 6, -2, 0], [0, -2, 6, -2], [0, 0, -2, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 5x5 symmetric matrix with values between -5 and 5.",
        "output": "import numpy as np\nnp.random.seed(24)\nA = np.random.randint(-5, 6, (5, 5))\nA = (A + A.T) / 2\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 block matrix [[A, B], [B, A]] where A = [[1, 2], [2, 1]] and B = [[3, 4], [4, 3]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\nB = np.array([[3, 4], [4, 3]])\nblock_matrix = np.block([[A, B], [B, A]])\neigenvalues, _ = np.linalg.eig(block_matrix)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 matrix generated using a Toeplitz structure with first row [2, -1, 0, -1].",
        "output": "import numpy as np\nfrom scipy.linalg import toeplitz\nfirst_row = [2, -1, 0, -1]\nA = toeplitz(first_row)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 4x4 matrix [[10, -4, 1, 3], [-4, 9, -3, 2], [1, -3, 7, -2], [3, 2, -2, 6]].",
        "output": "import numpy as np\nA = np.array([[10, -4, 1, 3], [-4, 9, -3, 2], [1, -3, 7, -2], [3, 2, -2, 6]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 matrix [[3, 5, -2, 4, 1], [5, 2, 3, -1, 4], [-2, 3, 6, 2, -3], [4, -1, 2, 5, 3], [1, 4, -3, 3, 7]].",
        "output": "import numpy as np\nA = np.array([[3, 5, -2, 4, 1], [5, 2, 3, -1, 4], [-2, 3, 6, 2, -3], [4, -1, 2, 5, 3], [1, 4, -3, 3, 7]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 tridiagonal matrix [[8, -3, 0, 0], [-3, 7, -2, 0], [0, -2, 6, -1], [0, 0, -1, 5]].",
        "output": "import numpy as np\nA = np.array([[8, -3, 0, 0], [-3, 7, -2, 0], [0, -2, 6, -1], [0, 0, -1, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 5x5 symmetric matrix generated with random values between -7 and 7.",
        "output": "import numpy as np\nnp.random.seed(50)\nA = np.random.randint(-7, 8, (5, 5))\nA = (A + A.T) / 2\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Matrix:\\n', A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 block matrix [[A, B], [B, A]] where A = [[2, 3], [3, 2]] and B = [[1, 4], [4, 1]].",
        "output": "import numpy as np\nA = np.array([[2, 3], [3, 2]])\nB = np.array([[1, 4], [4, 1]])\nblock_matrix = np.block([[A, B], [B, A]])\neigenvalues, _ = np.linalg.eig(block_matrix)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 Toeplitz matrix with first row [4, -1, 0, -1, 2].",
        "output": "import numpy as np\nfrom scipy.linalg import toeplitz\nfirst_row = [4, -1, 0, -1, 2]\nA = toeplitz(first_row)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 5x5 matrix where the elements are the sum of their row and column indices.",
        "output": "import numpy as np\nA = np.array([[i + j for j in range(1, 6)] for i in range(1, 6)])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 symmetric matrix with elements A[i][j] = min(i, j) + 1.",
        "output": "import numpy as np\nA = np.array([[min(i, j) + 1 for j in range(5)] for i in range(5)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 4x4 Vandermonde matrix with values [1, 2, 3, 4].",
        "output": "import numpy as np\nA = np.vander([1, 2, 3, 4])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 Hessenberg matrix [[5, 3, 0, 2], [1, 6, 4, 0], [0, 2, 7, 5], [0, 0, 3, 8]].",
        "output": "import numpy as np\nA = np.array([[5, 3, 0, 2], [1, 6, 4, 0], [0, 2, 7, 5], [0, 0, 3, 8]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 5x5 matrix [[10, -3, 2, -1, 4], [-3, 9, -4, 2, -2], [2, -4, 8, -3, 3], [-1, 2, -3, 7, -4], [4, -2, 3, -4, 6]].",
        "output": "import numpy as np\nA = np.array([[10, -3, 2, -1, 4], [-3, 9, -4, 2, -2], [2, -4, 8, -3, 3], [-1, 2, -3, 7, -4], [4, -2, 3, -4, 6]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 6x6 random symmetric matrix generated with values between -10 and 10.",
        "output": "import numpy as np\nnp.random.seed(99)\nA = np.random.randint(-10, 11, (6, 6))\nA = (A + A.T) / 2\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 5x5 block matrix [[A, B], [B, A]] where A = [[4, -2], [-2, 4]] and B = [[2, 3], [3, 2]].",
        "output": "import numpy as np\nA = np.array([[4, -2], [-2, 4]])\nB = np.array([[2, 3], [3, 2]])\nblock_matrix = np.block([[A, B], [B, A]])\neigenvalues, _ = np.linalg.eig(block_matrix)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 circulant matrix [[5, -2, 1, 3, -1], [-1, 5, -2, 1, 3], [3, -1, 5, -2, 1], [1, 3, -1, 5, -2], [-2, 1, 3, -1, 5]].",
        "output": "import numpy as np\nA = np.array([[5, -2, 1, 3, -1], [-1, 5, -2, 1, 3], [3, -1, 5, -2, 1], [1, 3, -1, 5, -2], [-2, 1, 3, -1, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 5x5 tridiagonal matrix [[7, -2, 0, 0, 0], [-2, 6, -2, 0, 0], [0, -2, 5, -2, 0], [0, 0, -2, 4, -2], [0, 0, 0, -2, 3]].",
        "output": "import numpy as np\nA = np.array([[7, -2, 0, 0, 0], [-2, 6, -2, 0, 0], [0, -2, 5, -2, 0], [0, 0, -2, 4, -2], [0, 0, 0, -2, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 6x6 matrix where A[i][j] = min(i, j) + 1.",
        "output": "import numpy as np\nA = np.array([[min(i, j) + 1 for j in range(6)] for i in range(6)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 5x5 Vandermonde matrix with values [1, 2, 3, 4, 5].",
        "output": "import numpy as np\nA = np.vander([1, 2, 3, 4, 5])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 Toeplitz matrix with first row [3, -1, 0, 1, 2].",
        "output": "import numpy as np\nfrom scipy.linalg import toeplitz\nfirst_row = [3, -1, 0, 1, 2]\nA = toeplitz(first_row)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 5x5 Hessenberg matrix [[7, 2, 0, -1, 3], [3, 6, -2, 0, 1], [0, 4, 5, 1, -3], [0, 0, 2, 4, -1], [0, 0, 0, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[7, 2, 0, -1, 3], [3, 6, -2, 0, 1], [0, 4, 5, 1, -3], [0, 0, 2, 4, -1], [0, 0, 0, 1, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 6x6 symmetric matrix where A[i][j] = max(i, j).",
        "output": "import numpy as np\nA = np.array([[max(i, j) for j in range(6)] for i in range(6)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 6x6 matrix [[9, -2, 3, -4, 5, -6], [-2, 8, -3, 4, -5, 6], [3, -3, 7, -4, 5, -6], [-4, 4, -4, 6, -5, 6], [5, -5, 5, -5, 5, -5], [-6, 6, -6, 6, -6, 6]].",
        "output": "import numpy as np\nA = np.array([[9, -2, 3, -4, 5, -6], [-2, 8, -3, 4, -5, 6], [3, -3, 7, -4, 5, -6], [-4, 4, -4, 6, -5, 6], [5, -5, 5, -5, 5, -5], [-6, 6, -6, 6, -6, 6]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 7x7 random symmetric matrix with values between -20 and 20.",
        "output": "import numpy as np\nnp.random.seed(77)\nA = np.random.randint(-20, 21, (7, 7))\nA = (A + A.T) / 2\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 6x6 block matrix [[A, B], [B, A]] where A = [[5, -3, 1], [-3, 6, -2], [1, -2, 7]] and B = [[2, 4, -1], [4, 2, 3], [-1, 3, 2]].",
        "output": "import numpy as np\nA = np.array([[5, -3, 1], [-3, 6, -2], [1, -2, 7]])\nB = np.array([[2, 4, -1], [4, 2, 3], [-1, 3, 2]])\nblock_matrix = np.block([[A, B], [B, A]])\neigenvalues, _ = np.linalg.eig(block_matrix)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 6x6 circulant matrix with first row [6, -2, 1, -1, 3, 0].",
        "output": "import numpy as np\nfrom scipy.linalg import circulant\nfirst_row = [6, -2, 1, -1, 3, 0]\nA = circulant(first_row)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 6x6 tridiagonal matrix with diagonal 7 and off-diagonal -2.",
        "output": "import numpy as np\nA = np.diag([7]*6) + np.diag([-2]*5, 1) + np.diag([-2]*5, -1)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 7x7 matrix where A[i][j] = min(i, j) + 2.",
        "output": "import numpy as np\nA = np.array([[min(i, j) + 2 for j in range(7)] for i in range(7)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 6x6 Vandermonde matrix with values [1, 2, 3, 4, 5, 6].",
        "output": "import numpy as np\nA = np.vander([1, 2, 3, 4, 5, 6])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 6x6 Toeplitz matrix with first row [4, -1, 0, 2, -2, 1].",
        "output": "import numpy as np\nfrom scipy.linalg import toeplitz\nfirst_row = [4, -1, 0, 2, -2, 1]\nA = toeplitz(first_row)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 6x6 Hessenberg matrix [[8, 2, 0, -1, 4, 3], [2, 7, -3, 0, 2, 1], [0, -3, 6, 2, -4, 5], [0, 0, 3, 5, -1, 4], [0, 0, 0, 2, 4, -3], [0, 0, 0, 0, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[8, 2, 0, -1, 4, 3], [2, 7, -3, 0, 2, 1], [0, -3, 6, 2, -4, 5], [0, 0, 3, 5, -1, 4], [0, 0, 0, 2, 4, -3], [0, 0, 0, 0, 1, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 7x7 symmetric matrix where A[i][j] = max(i, j) + 1.",
        "output": "import numpy as np\nA = np.array([[max(i, j) + 1 for j in range(7)] for i in range(7)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 matrix where each row is a cyclic permutation of [4, -1, 2, -3].",
        "output": "import numpy as np\nfrom scipy.linalg import circulant\nfirst_row = [4, -1, 2, -3]\nA = circulant(first_row)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a matrix where each element A[i][j] = i^2 - j^2 for a 5x5 matrix.",
        "output": "import numpy as np\nA = np.array([[i**2 - j**2 for j in range(5)] for i in range(5)])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of the matrix [[cos(θ), sin(θ)], [-sin(θ), cos(θ)]] for θ = π/4.",
        "output": "from math import cos\nfrom math import sin\nimport numpy as np\ntheta = np.pi / 4\nA = np.array([[np.cos(theta), np.sin(theta)], [-np.sin(theta), np.cos(theta)]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 6x6 Pascal matrix.",
        "output": "import numpy as np\nfrom scipy.linalg import pascal\nA = pascal(6)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a matrix A such that A^2 = I, where A = [[0, 1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 5x5 matrix with all ones except the diagonal is zero.",
        "output": "import numpy as np\nA = np.ones((5, 5))\nnp.fill_diagonal(A, 0)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 matrix where A[i][j] = 1 if |i - j| ≤ 1, otherwise 0.",
        "output": "import numpy as np\nA = np.array([[1 if abs(i-j) <= 1 else 0 for j in range(4)] for i in range(4)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 magic square matrix.",
        "output": "import numpy as np\nA = np.array([[16, 3, 2, 13],\n              [5, 10, 11, 8],\n              [9, 6, 7, 12],\n              [4, 15, 14, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Magic Square Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 stochastic matrix where each row sums to 1 and entries are random.",
        "output": "import numpy as np\nnp.random.seed(10)\nA = np.random.rand(3, 3)\nA /= A.sum(axis=1, keepdims=True)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 symmetric Toeplitz matrix with first row [3, -1, 2, -2].",
        "output": "import numpy as np\nfrom scipy.linalg import toeplitz\nfirst_row = [3, -1, 2, -2]\nA = toeplitz(first_row)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 matrix where A[i][j] = (-1)^(i+j) * (i + j + 1).",
        "output": "import numpy as np\nA = np.array([[(-1)**(i+j) * (i + j + 1) for j in range(4)] for i in range(4)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 5x5 matrix where A[i][j] = i + j if i+j is even, otherwise -1.",
        "output": "import numpy as np\nA = np.array([[i + j if (i + j) % 2 == 0 else -1 for j in range(5)] for i in range(5)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a circulant matrix where the first row is the first 6 Fibonacci numbers.",
        "output": "import numpy as np\nfrom scipy.linalg import circulant\nfib = [0, 1]\nfor _ in range(4): fib.append(fib[-1] + fib[-2])\nA = circulant(fib)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 rotation matrix with θ = π/3.",
        "output": "from math import cos\nfrom math import sin\nimport numpy as np\ntheta = np.pi / 3\nA = np.array([[np.cos(theta), -np.sin(theta), 0], [np.sin(theta), np.cos(theta), 0], [0, 0, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 matrix where A[i][j] = |i - j|.",
        "output": "import numpy as np\nA = np.array([[abs(i - j) for j in range(4)] for i in range(4)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 5x5 random matrix where diagonal entries are zero and all other entries are 1.",
        "output": "import numpy as np\nA = np.ones((5, 5))\nnp.fill_diagonal(A, 0)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a doubly stochastic 3x3 matrix where each row sums to 1 and all entries are 1/3.",
        "output": "import numpy as np\nA = np.ones((3, 3)) / 3\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 5x5 symmetric Hankel matrix with first column [1, 2, 3, 4, 5].",
        "output": "import numpy as np\nfrom scipy.linalg import hankel\nA = hankel([1, 2, 3, 4, 5])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 checkerboard matrix where A[i][j] = (-1)^(i+j).",
        "output": "import numpy as np\nA = np.array([[(-1)**(i+j) for j in range(4)] for i in range(4)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 matrix where A[i][j] = i^j.",
        "output": "import numpy as np\nA = np.array([[i**j for j in range(3)] for i in range(3)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 matrix where A[i][j] = i * j mod 5.",
        "output": "import numpy as np\nA = np.array([[ (i * j) % 5 for j in range(4)] for i in range(4)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 circulant matrix where the first row is [2, -1, 0, 1, -2].",
        "output": "import numpy as np\nfrom scipy.linalg import circulant\nfirst_row = [2, -1, 0, 1, -2]\nA = circulant(first_row)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 lower triangular matrix with diagonal [3, -2, 5, 1] and random lower elements.",
        "output": "import numpy as np\nnp.random.seed(42)\nA = np.tril(np.random.randint(-10, 10, (4, 4)))\nnp.fill_diagonal(A, [3, -2, 5, 1])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 6x6 symmetric matrix where A[i][j] = max(i, j) + min(i, j).",
        "output": "import numpy as np\nA = np.array([[max(i, j) + min(i, j) for j in range(6)] for i in range(6)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 permutation matrix that swaps row 1 and 2 but leaves row 3 unchanged.",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [1, 0, 0], [0, 0, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 magic square matrix.",
        "output": "import numpy as np\nA = np.array([[17, 24,  1,  8, 15],\n              [23,  5,  7, 14, 16],\n              [ 4,  6, 13, 20, 22],\n              [10, 12, 19, 21,  3],\n              [11, 18, 25,  2,  9]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Magic Square Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 random orthogonal matrix (Q from QR decomposition of a random matrix).",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nnp.random.seed(42)\nA = np.random.rand(4, 4)\nQ, _ = qr(A)\neigenvalues, _ = np.linalg.eig(Q)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 checkerboard matrix where A[i][j] = (-1)^(i+j) * (i + j + 1).",
        "output": "import numpy as np\nA = np.array([[(-1)**(i+j) * (i + j + 1) for j in range(4)] for i in range(4)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 matrix where A[i][j] = 2^(i+j).",
        "output": "import numpy as np\nA = np.array([[2**(i+j) for j in range(3)] for i in range(3)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 upper triangular matrix with ones on the diagonal and increasing entries above it.",
        "output": "import numpy as np\nA = np.triu(np.arange(1, 17).reshape(4, 4))\nnp.fill_diagonal(A, 1)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 Vandermonde matrix with first column [1, 2, 3, 4].",
        "output": "import numpy as np\nx = [1, 2, 3, 4]\nA = np.vander(x, increasing=True)\neigenvalues, _ = np.linalg.eig(A)\nprint('Vandermonde Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 Toeplitz matrix where the first row is [3, 1, -1, 2, 0].",
        "output": "import numpy as np\nfrom scipy.linalg import toeplitz\nfirst_row = [3, 1, -1, 2, 0]\nA = toeplitz(first_row)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 matrix where A[i][j] = (i + 1) * (j + 1) if i ≠ j, else 0.",
        "output": "import numpy as np\nA = np.array([[0 if i == j else (i+1)*(j+1) for j in range(4)] for i in range(4)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 Hadamard matrix.",
        "output": "import numpy as np\nfrom scipy.linalg import hadamard\nA = hadamard(4)[:3,:3]\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 6x6 matrix where A[i][j] = gcd(i+1, j+1).",
        "output": "import numpy as np\nfrom math import gcd\nA = np.array([[gcd(i+1, j+1) for j in range(6)] for i in range(6)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 Hilbert matrix.",
        "output": "import numpy as np\nfrom scipy.linalg import hilbert\nA = hilbert(5)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 nilpotent matrix where A^3 = 0 but A ≠ 0.",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 Laplacian matrix of a cycle graph.",
        "output": "import numpy as np\nA = np.array([[2, -1, 0, -1], [-1, 2, -1, 0], [0, -1, 2, -1], [-1, 0, -1, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 matrix where A[i][j] = i^2 - j^2 + (-1)^(i+j).",
        "output": "import numpy as np\nA = np.array([[i**2 - j**2 + (-1)**(i+j) for j in range(3)] for i in range(3)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 symmetric matrix where A[i][j] = min(i, j) + max(i, j).",
        "output": "import numpy as np\nA = np.array([[min(i, j) + max(i, j) for j in range(5)] for i in range(5)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 matrix where A[i][j] = (-1)^(i+j) * (i + j + 2) mod 7.",
        "output": "import numpy as np\nA = np.array([[(-1)**(i+j) * (i + j + 2) % 7 for j in range(4)] for i in range(4)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 circulant matrix where the first row follows the pattern [1, -2, 3, -4, 5].",
        "output": "import numpy as np\nfrom scipy.linalg import circulant\nfirst_row = [1, -2, 3, -4, 5]\nA = circulant(first_row)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 upper triangular matrix with diagonal entries [5, -3, 2, 4] and nonzero random upper values.",
        "output": "import numpy as np\nnp.random.seed(42)\nA = np.triu(np.random.randint(-10, 10, (4, 4)))\nnp.fill_diagonal(A, [5, -3, 2, 4])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 magic square matrix where entries are squared.",
        "output": "import numpy as np\nmagic_square = np.array([[8, 1, 6],\n                         [3, 5, 7],\n                         [4, 9, 2]])\nA = np.square(magic_square)\neigenvalues, _ = np.linalg.eig(A)\nprint('Squared Magic Square Matrix A:\\n', A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 6x6 matrix where A[i][j] = gcd(i+2, j+2).",
        "output": "import numpy as np\nfrom math import gcd\nA = np.array([[gcd(i+2, j+2) for j in range(6)] for i in range(6)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 matrix where A[i][j] = 1/(i + j + 1).",
        "output": "import numpy as np\nA = np.array([[1/(i + j + 1) for j in range(5)] for i in range(5)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 skew-symmetric matrix where A[i][j] = i - j.",
        "output": "import numpy as np\nA = np.array([[i - j for j in range(4)] for i in range(4)])\nA = A - A.T\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 doubly stochastic matrix where all entries are 1/3.",
        "output": "import numpy as np\nA = np.ones((3, 3)) / 3\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 matrix where A[i][j] = (i + 1)^j.",
        "output": "import numpy as np\nA = np.array([[(i + 1)**j for j in range(4)] for i in range(4)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 symmetric matrix where A[i][j] = min(i+1, j+1) + max(i+1, j+1).",
        "output": "import numpy as np\nA = np.array([[min(i+1, j+1) + max(i+1, j+1) for j in range(5)] for i in range(5)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 matrix where A[i][j] = (-1)^(i+j) * (i^2 + j^2) mod 5.",
        "output": "import numpy as np\nA = np.array([[(-1)**(i+j) * (i**2 + j**2) % 5 for j in range(4)] for i in range(4)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 6x6 circulant matrix where the first row is the first 6 prime numbers.",
        "output": "import numpy as np\nfrom scipy.linalg import circulant\nprimes = [2, 3, 5, 7, 11, 13]\nA = circulant(primes)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 5x5 matrix where A[i][j] = i^j if i ≥ j, otherwise 0.",
        "output": "import numpy as np\nA = np.array([[i**j if i >= j else 0 for j in range(5)] for i in range(5)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 Laplacian matrix for a star graph with 4 edges.",
        "output": "import numpy as np\nA = np.array([[ 3, -1, -1, -1], [-1, 1, 0, 0], [-1, 0, 1, 0], [-1, 0, 0, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 block diagonal matrix with blocks [[1, 2], [2, 1]] and [[3, 4], [4, 3]].",
        "output": "import numpy as np\nfrom scipy.linalg import block_diag\nA = block_diag([[1,2],[2,1]], [[3,4],[4,3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 orthogonal matrix constructed from a random QR decomposition.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nnp.random.seed(42)\nA = np.random.rand(3, 3)\nQ, _ = qr(A)\neigenvalues, _ = np.linalg.eig(Q)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 5x5 Hankel matrix where the first column is [1, 3, 5, 7, 9].",
        "output": "import numpy as np\nfrom scipy.linalg import hankel\nA = hankel([1, 3, 5, 7, 9])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 matrix where A[i][j] = i! + j!.",
        "output": "import numpy as np\nfrom math import factorial\nA = np.array([[factorial(i) + factorial(j) for j in range(4)] for i in range(4)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 matrix where A[i][j] = (-1)^i * (i+j+1).",
        "output": "import numpy as np\nA = np.array([[(-1)**i * (i+j+1) for j in range(3)] for i in range(3)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 matrix where A[i][j] = 1/(i + j + 2).",
        "output": "import numpy as np\nA = np.array([[1/(i + j + 2) for j in range(5)] for i in range(5)])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the 2x2 identity matrix.",
        "output": "import numpy as np\nA = np.identity(2)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 diagonal matrix with values [3, 5] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([3, 5])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[2, 0], [0, -2]].",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, -2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 scalar multiple of the identity matrix (5I).",
        "output": "import numpy as np\nA = 5 * np.identity(2)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 upper triangular matrix with diagonal entries [1, 2, 3].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [0, 2, 4], [0, 0, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 matrix A = [[0, 1], [0, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [0, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[1, 2], [2, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 rotation matrix for 90 degrees.",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 diagonal matrix with values [4, -1, 7] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([4, -1, 7])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[6, 0], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[6, 0], [0, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 scalar multiple of the identity matrix (4I).",
        "output": "import numpy as np\nA = 4 * np.identity(3)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[1, -1], [-1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, -1], [-1, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 matrix A = [[2, 0, 0], [0, 3, 0], [0, 0, 5]].",
        "output": "import numpy as np\nA = np.diag([2, 3, 5])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 rotation matrix for 180 degrees.",
        "output": "import numpy as np\nA = np.array([[-1, 0], [0, -1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 lower triangular matrix with diagonal entries [2, 4, 6].",
        "output": "import numpy as np\nA = np.array([[2, 0, 0], [3, 4, 0], [1, 5, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 symmetric matrix A = [[2, 1, 1], [1, 2, 1], [1, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 matrix A = [[0, 2], [2, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 2], [2, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 matrix A = [[3, 0, 0], [0, 3, 0], [0, 0, 3]].",
        "output": "import numpy as np\nA = np.identity(3) * 3\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 diagonal matrix A = [[7, 0], [0, -4]].",
        "output": "import numpy as np\nA = np.diag([7, -4])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[4, 0], [0, 9]].",
        "output": "import numpy as np\nA = np.array([[4, 0], [0, 9]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 diagonal matrix with values [5, 7, 8] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([5, 7, 8])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 identity matrix multiplied by 6.",
        "output": "import numpy as np\nA = 6 * np.identity(2)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 upper triangular matrix with diagonal entries [1, 3, 5].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [0, 3, 4], [0, 0, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 lower triangular matrix with diagonal entries [2, -3, 4].",
        "output": "import numpy as np\nA = np.array([[2, 0, 0], [1, -3, 0], [-2, 5, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 symmetric matrix A = [[3, 2, 2], [2, 3, 2], [2, 2, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 2, 2], [2, 3, 2], [2, 2, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 matrix A = [[2, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[3, 0], [0, -3]].",
        "output": "import numpy as np\nA = np.array([[3, 0], [0, -3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 identity matrix multiplied by -2.",
        "output": "import numpy as np\nA = -2 * np.identity(3)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 rotation matrix for 45 degrees.",
        "output": "from math import cos\nfrom math import sin\nimport numpy as np\nA = np.array([[np.cos(np.pi/4), -np.sin(np.pi/4)], [np.sin(np.pi/4), np.cos(np.pi/4)]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 diagonal matrix with values [-1, 4, 2] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([-1, 4, 2])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[0, -1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 matrix A = [[1, 2], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [0, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 diagonal matrix with values [10, -5, 0] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([10, -5, 0])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[7, 0], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[7, 0], [0, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 diagonal matrix with values [9, 3, -2] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([9, 3, -2])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[5, 0], [0, -5]].",
        "output": "import numpy as np\nA = np.array([[5, 0], [0, -5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 lower triangular matrix with diagonal entries [1, 2, 3].",
        "output": "import numpy as np\nA = np.array([[1, 0, 0], [4, 2, 0], [7, 5, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 identity matrix multiplied by -3.",
        "output": "import numpy as np\nA = -3 * np.identity(2)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 rotation matrix for 30 degrees.",
        "output": "from math import cos\nfrom math import sin\nimport numpy as np\nA = np.array([[np.cos(np.pi/6), -np.sin(np.pi/6)], [np.sin(np.pi/6), np.cos(np.pi/6)]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 upper triangular matrix with diagonal entries [2, -1, 4].",
        "output": "import numpy as np\nA = np.array([[2, 1, 1], [0, -1, 2], [0, 0, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 matrix A = [[3, 1], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 diagonal matrix with values [-3, 6, 2] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([-3, 6, 2])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 identity matrix multiplied by 5.",
        "output": "import numpy as np\nA = 5 * np.identity(3)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 matrix A = [[2, -1], [-1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1], [-1, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[4, 2], [2, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 2], [2, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[8, 0], [0, -3]].",
        "output": "import numpy as np\nA = np.array([[8, 0], [0, -3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 diagonal matrix with values [10, 5, -4] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([10, 5, -4])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[0, 0], [0, 0]].",
        "output": "import numpy as np\nA = np.zeros((2,2))\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 identity matrix multiplied by 2.",
        "output": "import numpy as np\nA = 2 * np.identity(3)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 rotation matrix for 60 degrees.",
        "output": "from math import cos\nfrom math import sin\nimport numpy as np\nA = np.array([[np.cos(np.pi/3), -np.sin(np.pi/3)], [np.sin(np.pi/3), np.cos(np.pi/3)]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 upper triangular matrix with diagonal entries [4, 2, 7].",
        "output": "import numpy as np\nA = np.array([[4, 1, 3], [0, 2, 5], [0, 0, 7]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 symmetric matrix A = [[6, 2], [2, 6]].",
        "output": "import numpy as np\nA = np.array([[6, 2], [2, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 matrix A = [[3, -2], [-2, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -2], [-2, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 diagonal matrix with values [-2, 7, 4] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([-2, 7, 4])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 matrix A = [[1, 3], [3, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 3], [3, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 lower triangular matrix with diagonal entries [5, 6, -1].",
        "output": "import numpy as np\nA = np.array([[5, 0, 0], [1, 6, 0], [-2, 3, -1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 identity matrix multiplied by -5.",
        "output": "import numpy as np\nA = -5 * np.identity(2)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[2, 0], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 matrix A = [[1, 2, 3], [0, 1, 4], [0, 0, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [0, 1, 4], [0, 0, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[3, 1], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[4, 1], [1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1], [1, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 diagonal matrix with values [8, -2, 5] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([8, -2, 5])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 identity matrix multiplied by 3.",
        "output": "import numpy as np\nA = 3 * np.identity(3)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 upper triangular matrix A = [[5, 3], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[5, 3], [0, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 lower triangular matrix with diagonal entries [1, 4, 6].",
        "output": "import numpy as np\nA = np.array([[1, 0, 0], [2, 4, 0], [3, 5, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 rotation matrix for 90 degrees.",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 diagonal matrix with values [-3, 2, 7] on the diagonal.",
        "output": "import numpy as np\nA = np.diag([-3, 2, 7])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 identity matrix multiplied by -4.",
        "output": "import numpy as np\nA = -4 * np.identity(2)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 matrix A = [[6, 2], [2, 6]].",
        "output": "import numpy as np\nA = np.array([[6, 2], [2, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 upper triangular matrix with diagonal entries [4, -1, 3].",
        "output": "import numpy as np\nA = np.array([[4, 1, 2], [0, -1, 5], [0, 0, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 matrix A = [[2, -2], [-2, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -2], [-2, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 lower triangular matrix with diagonal entries [-1, 5, 3].",
        "output": "import numpy as np\nA = np.array([[-1, 0, 0], [2, 5, 0], [-3, 4, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 matrix A = [[1, 4], [4, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 4], [4, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 matrix A = [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[5, -2], [-2, 5]].",
        "output": "import numpy as np\nA = np.array([[5, -2], [-2, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 matrix A = [[1, 2, 3], [2, 4, 5], [3, 5, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 4, 5], [3, 5, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 2x2 matrix A = [[0, -1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 upper triangular matrix A = [[3, 2, 1], [0, 2, -4], [0, 0, -5]].",
        "output": "import numpy as np\nA = np.array([[3, 2, 1], [0, 2, -4], [0, 0, -5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[7, 3], [3, 7]].",
        "output": "import numpy as np\nA = np.array([[7, 3], [3, 7]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 symmetric matrix A = [[4, 1, 1], [1, 4, 1], [1, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 1], [1, 4, 1], [1, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[6, 2], [2, 8]].",
        "output": "import numpy as np\nA = np.array([[6, 2], [2, 8]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 matrix A = [[0, 1, 2], [1, 0, 3], [2, 3, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 2], [1, 0, 3], [2, 3, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 diagonal matrix A = [[3, 0, 0], [0, 5, 0], [0, 0, -2]].",
        "output": "import numpy as np\nA = np.diag([3, 5, -2])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[1, -2], [-2, 1]].",
        "output": "import numpy as np\nA = np.array([[1, -2], [-2, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 2x2 matrix A = [[5, 4], [4, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 4], [4, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 symmetric matrix A = [[6, 2, 1], [2, 3, 4], [1, 4, 5]].",
        "output": "import numpy as np\nA = np.array([[6, 2, 1], [2, 3, 4], [1, 4, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[3, -1], [-1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -1], [-1, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[9, 4], [4, 9]].",
        "output": "import numpy as np\nA = np.array([[9, 4], [4, 9]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 matrix A = [[2, 1, 0], [1, 3, 1], [0, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 0], [1, 3, 1], [0, 1, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 2x2 matrix A = [[7, 2], [2, 7]].",
        "output": "import numpy as np\nA = np.array([[7, 2], [2, 7]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 upper triangular matrix A = [[5, 1, -2], [0, 3, 4], [0, 0, 1]].",
        "output": "import numpy as np\nA = np.array([[5, 1, -2], [0, 3, 4], [0, 0, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[4, -1], [-1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, -1], [-1, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 symmetric matrix A = [[6, 1, 2], [1, 5, 3], [2, 3, 4]].",
        "output": "import numpy as np\nA = np.array([[6, 1, 2], [1, 5, 3], [2, 3, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[5, 3], [3, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 3], [3, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 matrix A = [[3, 2, 1], [2, 3, 2], [1, 2, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 2, 1], [2, 3, 2], [1, 2, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 rotation matrix for 30 degrees.",
        "output": "from math import cos\nfrom math import sin\nimport numpy as np\nA = np.array([[np.cos(np.pi/6), -np.sin(np.pi/6)], [np.sin(np.pi/6), np.cos(np.pi/6)]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 diagonal matrix A = [[7, 0, 0], [0, -3, 0], [0, 0, 2]].",
        "output": "import numpy as np\nA = np.diag([7, -3, 2])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[2, -3], [-3, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -3], [-3, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 matrix A = [[4, -2, 0], [-2, 4, -2], [0, -2, 4]].",
        "output": "import numpy as np\nA = np.array([[4, -2, 0], [-2, 4, -2], [0, -2, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 2x2 matrix A = [[6, 5], [5, 6]].",
        "output": "import numpy as np\nA = np.array([[6, 5], [5, 6]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 symmetric matrix A = [[5, 2, 3], [2, 6, 4], [3, 4, 7]].",
        "output": "import numpy as np\nA = np.array([[5, 2, 3], [2, 6, 4], [3, 4, 7]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[7, -2], [-2, 7]].",
        "output": "import numpy as np\nA = np.array([[7, -2], [-2, 7]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[8, 3], [3, 8]].",
        "output": "import numpy as np\nA = np.array([[8, 3], [3, 8]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 2x2 matrix A = [[10, 1], [1, 10]].",
        "output": "import numpy as np\nA = np.array([[10, 1], [1, 10]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 matrix A = [[6, 2, 1], [2, 6, 3], [1, 3, 6]].",
        "output": "import numpy as np\nA = np.array([[6, 2, 1], [2, 6, 3], [1, 3, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[4, 5], [5, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 5], [5, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 symmetric matrix A = [[3, -1, 1], [-1, 3, -1], [1, -1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -1, 1], [-1, 3, -1], [1, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[9, 2], [2, 9]].",
        "output": "import numpy as np\nA = np.array([[9, 2], [2, 9]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 matrix A = [[5, -2, 0], [-2, 5, -2], [0, -2, 5]].",
        "output": "import numpy as np\nA = np.array([[5, -2, 0], [-2, 5, -2], [0, -2, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 diagonal matrix A = [[8, 0, 0], [0, -4, 0], [0, 0, 3]].",
        "output": "import numpy as np\nA = np.diag([8, -4, 3])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[3, -4], [-4, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -4], [-4, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 matrix A = [[7, -3, 0], [-3, 7, -3], [0, -3, 7]].",
        "output": "import numpy as np\nA = np.array([[7, -3, 0], [-3, 7, -3], [0, -3, 7]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 2x2 matrix A = [[5, 6], [6, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 6], [6, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 symmetric matrix A = [[4, 1, 2], [1, 5, 3], [2, 3, 6]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 2], [1, 5, 3], [2, 3, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 matrix A = [[6, -3], [-3, 6]].",
        "output": "import numpy as np\nA = np.array([[6, -3], [-3, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 matrix A = [[4, 1, -2], [1, 6, 0], [-2, 0, 5]].",
        "output": "import numpy as np\nA = np.array([[4, 1, -2], [1, 6, 0], [-2, 0, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 4x4 matrix A = [[2, -1, 0, 0], [-1, 3, -1, 0], [0, -1, 4, -1], [0, 0, -1, 5]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 0, 0], [-1, 3, -1, 0], [0, -1, 4, -1], [0, 0, -1, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 matrix A = [[0, -1, 2], [1, 0, -1], [-2, 1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -1, 2], [1, 0, -1], [-2, 1, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 circulant matrix A = [[0, 1, 0, -1], [-1, 0, 1, 0], [0, -1, 0, 1], [1, 0, -1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 0, -1], [-1, 0, 1, 0], [0, -1, 0, 1], [1, 0, -1, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 3x3 matrix A = [[7, -2, 3], [-2, 8, -1], [3, -1, 6]].",
        "output": "import numpy as np\nA = np.array([[7, -2, 3], [-2, 8, -1], [3, -1, 6]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 matrix A = [[5, 2, 1, -1], [2, 6, 2, 0], [1, 2, 7, 1], [-1, 0, 1, 8]].",
        "output": "import numpy as np\nA = np.array([[5, 2, 1, -1], [2, 6, 2, 0], [1, 2, 7, 1], [-1, 0, 1, 8]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 matrix A = [[4, 2, 2], [2, 5, 1], [2, 1, 6]].",
        "output": "import numpy as np\nA = np.array([[4, 2, 2], [2, 5, 1], [2, 1, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 block matrix A = [[4, 0, 1, -1], [0, 3, -1, 2], [1, -1, 2, 0], [-1, 2, 0, 1]].",
        "output": "import numpy as np\nA = np.array([[4, 0, 1, -1], [0, 3, -1, 2], [1, -1, 2, 0], [-1, 2, 0, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 3x3 Toeplitz matrix A = [[5, -1, 0], [-1, 5, -1], [0, -1, 5]].",
        "output": "import numpy as np\nA = np.array([[5, -1, 0], [-1, 5, -1], [0, -1, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 matrix A = [[10, 3, -2, 1], [3, 9, 1, -3], [-2, 1, 8, 2], [1, -3, 2, 7]].",
        "output": "import numpy as np\nA = np.array([[10, 3, -2, 1], [3, 9, 1, -3], [-2, 1, 8, 2], [1, -3, 2, 7]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 matrix A = [[4, 1, 2, 3], [1, 5, -2, -1], [2, -2, 6, 0], [3, -1, 0, 7]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 2, 3], [1, 5, -2, -1], [2, -2, 6, 0], [3, -1, 0, 7]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 matrix A = [[9, -1, 3], [-1, 8, 1], [3, 1, 7]].",
        "output": "import numpy as np\nA = np.array([[9, -1, 3], [-1, 8, 1], [3, 1, 7]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 upper triangular matrix A = [[6, 2, 1, 3], [0, 7, -1, 2], [0, 0, 8, 1], [0, 0, 0, 9]].",
        "output": "import numpy as np\nA = np.array([[6, 2, 1, 3], [0, 7, -1, 2], [0, 0, 8, 1], [0, 0, 0, 9]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 symmetric matrix A = [[5, 2, -1, 3, 0], [2, 6, 1, 0, -2], [-1, 1, 7, 2, 1], [3, 0, 2, 8, -1], [0, -2, 1, -1, 9]].",
        "output": "import numpy as np\nA = np.array([[5, 2, -1, 3, 0], [2, 6, 1, 0, -2], [-1, 1, 7, 2, 1], [3, 0, 2, 8, -1], [0, -2, 1, -1, 9]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 3x3 matrix A = [[2, -1, 4], [-1, 3, -2], [4, -2, 5]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 4], [-1, 3, -2], [4, -2, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 matrix A = [[3, 2, -1, 0], [2, 6, 1, -1], [-1, 1, 5, 2], [0, -1, 2, 4]].",
        "output": "import numpy as np\nA = np.array([[3, 2, -1, 0], [2, 6, 1, -1], [-1, 1, 5, 2], [0, -1, 2, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 5x5 matrix A = [[10, 3, 1, 0, -1], [3, 9, 2, -1, 0], [1, 2, 8, 1, 2], [0, -1, 1, 7, -3], [-1, 0, 2, -3, 6]].",
        "output": "import numpy as np\nA = np.array([[10, 3, 1, 0, -1], [3, 9, 2, -1, 0], [1, 2, 8, 1, 2], [0, -1, 1, 7, -3], [-1, 0, 2, -3, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 symmetric matrix A = [[5, -2, 4], [-2, 6, -1], [4, -1, 7]].",
        "output": "import numpy as np\nA = np.array([[5, -2, 4], [-2, 6, -1], [4, -1, 7]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 matrix A = [[7, -1, 2, 3], [-1, 8, 0, -2], [2, 0, 9, 1], [3, -2, 1, 10]].",
        "output": "import numpy as np\nA = np.array([[7, -1, 2, 3], [-1, 8, 0, -2], [2, 0, 9, 1], [3, -2, 1, 10]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 block matrix A = [[6, 2, 0, 1, -1], [2, 7, 1, 0, 2], [0, 1, 8, 2, 3], [1, 0, 2, 9, -2], [-1, 2, 3, -2, 10]].",
        "output": "import numpy as np\nA = np.array([[6, 2, 0, 1, -1], [2, 7, 1, 0, 2], [0, 1, 8, 2, 3], [1, 0, 2, 9, -2], [-1, 2, 3, -2, 10]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 matrix A = [[8, 2, -1, 3], [2, 7, 1, -2], [-1, 1, 6, 2], [3, -2, 2, 5]].",
        "output": "import numpy as np\nA = np.array([[8, 2, -1, 3], [2, 7, 1, -2], [-1, 1, 6, 2], [3, -2, 2, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 5x5 matrix A = [[9, 1, -2, 0, 3], [1, 8, 0, -1, 2], [-2, 0, 7, 1, -3], [0, -1, 1, 6, 2], [3, 2, -3, 2, 5]].",
        "output": "import numpy as np\nA = np.array([[9, 1, -2, 0, 3], [1, 8, 0, -1, 2], [-2, 0, 7, 1, -3], [0, -1, 1, 6, 2], [3, 2, -3, 2, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 Toeplitz matrix A = [[6, -2, 1, 0], [-2, 6, -2, 1], [1, -2, 6, -2], [0, 1, -2, 6]].",
        "output": "import numpy as np\nA = np.array([[6, -2, 1, 0], [-2, 6, -2, 1], [1, -2, 6, -2], [0, 1, -2, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 diagonal-dominant matrix A = [[10, 1, -2, 0, 3], [1, 9, 0, -1, 2], [-2, 0, 8, 1, -3], [0, -1, 1, 7, 2], [3, 2, -3, 2, 6]].",
        "output": "import numpy as np\nA = np.array([[10, 1, -2, 0, 3], [1, 9, 0, -1, 2], [-2, 0, 8, 1, -3], [0, -1, 1, 7, 2], [3, 2, -3, 2, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a 3x3 matrix A = [[12, -3, 5], [-3, 11, -2], [5, -2, 9]].",
        "output": "import numpy as np\nA = np.array([[12, -3, 5], [-3, 11, -2], [5, -2, 9]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a singular 3x3 matrix A = [[2, 4, 6], [1, 3, 5], [0, 0, 0]].",
        "output": "import numpy as np\nA = np.array([[2, 4, 6], [1, 3, 5], [0, 0, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 matrix with repeated eigenvalues A = [[3, 1, 0, 0], [0, 3, 1, 0], [0, 0, 3, 1], [0, 0, 0, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1, 0, 0], [0, 3, 1, 0], [0, 0, 3, 1], [0, 0, 0, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a defective 3x3 matrix A = [[6, 2, 1], [0, 6, 1], [0, 0, 6]].",
        "output": "import numpy as np\nA = np.array([[6, 2, 1], [0, 6, 1], [0, 0, 6]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a skew-symmetric 4x4 matrix A = [[0, -3, 2, 4], [3, 0, -1, 5], [-2, 1, 0, -6], [-4, -5, 6, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -3, 2, 4], [3, 0, -1, 5], [-2, 1, 0, -6], [-4, -5, 6, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of an upper triangular matrix with repeated diagonal entries A = [[5, 1, 0, 0], [0, 5, 1, 0], [0, 0, 5, 1], [0, 0, 0, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 1, 0, 0], [0, 5, 1, 0], [0, 0, 5, 1], [0, 0, 0, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 matrix with a zero determinant A = [[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12], [4, 8, 12, 16]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12], [4, 8, 12, 16]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a circulant 3x3 matrix A = [[0, 1, -1], [-1, 0, 1], [1, -1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, -1], [-1, 0, 1], [1, -1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 matrix with a high condition number A = [[1000, 1, 2, 3], [1, 999, 4, 5], [2, 4, 998, 6], [3, 5, 6, 997]].",
        "output": "import numpy as np\nA = np.array([[1000, 1, 2, 3], [1, 999, 4, 5], [2, 4, 998, 6], [3, 5, 6, 997]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a Jordan block matrix A = [[4, 1, 0, 0], [0, 4, 1, 0], [0, 0, 4, 1], [0, 0, 0, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 0, 0], [0, 4, 1, 0], [0, 0, 4, 1], [0, 0, 0, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a matrix where all row sums are equal A = [[3, 2, 1], [1, 3, 2], [2, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 2, 1], [1, 3, 2], [2, 1, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a matrix with fractional entries A = [[0.5, 1.2, -0.8], [-1.2, 0.7, 2.5], [0.8, -2.5, 1.3]].",
        "output": "import numpy as np\nA = np.array([[0.5, 1.2, -0.8], [-1.2, 0.7, 2.5], [0.8, -2.5, 1.3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a nearly singular matrix A = [[1, 1, 1], [1, 1.00001, 1], [1, 1, 1.00002]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, 1.00001, 1], [1, 1, 1.00002]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a nilpotent 3x3 matrix A = [[0, 1, 0], [0, 0, 1], [0, 0, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a Pascal 3x3 matrix A = [[1, 1, 1], [1, 2, 3], [1, 3, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, 2, 3], [1, 3, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a Vandermonde matrix A = [[1, 2, 4], [1, 3, 9], [1, 4, 16]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 4], [1, 3, 9], [1, 4, 16]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a circulant 4x4 matrix A = [[0, 1, 2, 3], [3, 0, 1, 2], [2, 3, 0, 1], [1, 2, 3, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 2, 3], [3, 0, 1, 2], [2, 3, 0, 1], [1, 2, 3, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of an almost diagonal matrix A = [[10, 1e-10, 0], [0, 5, 1e-10], [0, 0, 2]].",
        "output": "import numpy as np\nA = np.array([[10, 1e-10, 0], [0, 5, 1e-10], [0, 0, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a doubly stochastic 3x3 matrix A = [[0.4, 0.3, 0.3], [0.3, 0.4, 0.3], [0.3, 0.3, 0.4]].",
        "output": "import numpy as np\nA = np.array([[0.4, 0.3, 0.3], [0.3, 0.4, 0.3], [0.3, 0.3, 0.4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a matrix with alternating row signs A = [[1, -1, 1], [-1, 2, -1], [1, -1, 3]].",
        "output": "import numpy as np\nA = np.array([[1, -1, 1], [-1, 2, -1], [1, -1, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a Fibonacci-like 3x3 matrix A = [[1, 1, 0], [1, 0, 1], [0, 1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 0], [1, 0, 1], [0, 1, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a highly sparse 4x4 matrix A = [[0, 0, 3, 0], [0, 4, 0, 0], [3, 0, 0, 2], [0, 0, 2, 5]].",
        "output": "import numpy as np\nA = np.array([[0, 0, 3, 0], [0, 4, 0, 0], [3, 0, 0, 2], [0, 0, 2, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a circulant 5x5 matrix A = [[0, 1, 2, 3, 4], [4, 0, 1, 2, 3], [3, 4, 0, 1, 2], [2, 3, 4, 0, 1], [1, 2, 3, 4, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 2, 3, 4], [4, 0, 1, 2, 3], [3, 4, 0, 1, 2], [2, 3, 4, 0, 1], [1, 2, 3, 4, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a Hessenberg 4x4 matrix A = [[4, 3, 2, 1], [1, 4, 3, 2], [0, 1, 4, 3], [0, 0, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 3, 2, 1], [1, 4, 3, 2], [0, 1, 4, 3], [0, 0, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a doubly stochastic 4x4 matrix A = [[0.25, 0.25, 0.25, 0.25], [0.25, 0.25, 0.25, 0.25], [0.25, 0.25, 0.25, 0.25], [0.25, 0.25, 0.25, 0.25]].",
        "output": "import numpy as np\nA = np.array([[0.25, 0.25, 0.25, 0.25], [0.25, 0.25, 0.25, 0.25], [0.25, 0.25, 0.25, 0.25], [0.25, 0.25, 0.25, 0.25]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a circulant 3x3 matrix with complex entries A = [[0, i, -i], [-i, 0, i], [i, -i, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1j, -1j], [-1j, 0, 1j], [1j, -1j, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a tridiagonal matrix A = [[2, -1, 0, 0], [-1, 2, -1, 0], [0, -1, 2, -1], [0, 0, -1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 0, 0], [-1, 2, -1, 0], [0, -1, 2, -1], [0, 0, -1, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a skew-Hermitian matrix A = [[0, i, -2i], [-i, 0, 3i], [2i, -3i, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1j, -2j], [-1j, 0, 3j], [2j, -3j, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a Hadamard 4x4 matrix A = [[1, 1, 1, 1], [1, -1, 1, -1], [1, 1, -1, -1], [1, -1, -1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 1, 1], [1, -1, 1, -1], [1, 1, -1, -1], [1, -1, -1, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a matrix that has alternating row sums A = [[1, -1, 2], [-2, 2, -3], [3, -3, 4]].",
        "output": "import numpy as np\nA = np.array([[1, -1, 2], [-2, 2, -3], [3, -3, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a matrix where every row is a permutation of the first row A = [[2, 1, 3, 4], [1, 3, 4, 2], [3, 4, 2, 1], [4, 2, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 3, 4], [1, 3, 4, 2], [3, 4, 2, 1], [4, 2, 1, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a block diagonal matrix A = [[2, 1, 0, 0], [1, 2, 0, 0], [0, 0, 3, -1], [0, 0, -1, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 0, 0], [1, 2, 0, 0], [0, 0, 3, -1], [0, 0, -1, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 5x5 Toeplitz matrix A = [[2, -1, 0, 0, 0], [-1, 2, -1, 0, 0], [0, -1, 2, -1, 0], [0, 0, -1, 2, -1], [0, 0, 0, -1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 0, 0, 0], [-1, 2, -1, 0, 0], [0, -1, 2, -1, 0], [0, 0, -1, 2, -1], [0, 0, 0, -1, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 permutation matrix A = [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a Hilbert 4x4 matrix A = [[1, 1/2, 1/3, 1/4], [1/2, 1/3, 1/4, 1/5], [1/3, 1/4, 1/5, 1/6], [1/4, 1/5, 1/6, 1/7]].",
        "output": "import numpy as np\nfrom scipy.linalg import hilbert\nA = hilbert(4)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of a companion matrix A = [[0, 0, 0, -1], [1, 0, 0, 3], [0, 1, 0, -3], [0, 0, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[0, 0, 0, -1], [1, 0, 0, 3], [0, 1, 0, -3], [0, 0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a circulant matrix with Fibonacci numbers A = [[1, 1, 2, 3], [3, 1, 1, 2], [2, 3, 1, 1], [1, 2, 3, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 2, 3], [3, 1, 1, 2], [2, 3, 1, 1], [1, 2, 3, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a symmetric 5x5 matrix with alternating sign entries A = [[1, -1, 1, -1, 1], [-1, 2, -2, 2, -2], [1, -2, 3, -3, 3], [-1, 2, -3, 4, -4], [1, -2, 3, -4, 5]].",
        "output": "import numpy as np\nA = np.array([[1, -1, 1, -1, 1], [-1, 2, -2, 2, -2], [1, -2, 3, -3, 3], [-1, 2, -3, 4, -4], [1, -2, 3, -4, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a sparse diagonal-plus-rank-one matrix A = [[3, 0, 0, 1], [0, 3, 0, 1], [0, 0, 3, 1], [1, 1, 1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 0, 0, 1], [0, 3, 0, 1], [0, 0, 3, 1], [1, 1, 1, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 Markov transition matrix A = [[0.7, 0.2, 0.1], [0.1, 0.6, 0.3], [0.2, 0.2, 0.6]].",
        "output": "import numpy as np\nA = np.array([[0.7, 0.2, 0.1], [0.1, 0.6, 0.3], [0.2, 0.2, 0.6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a matrix formed by an outer product A = [[1, 2], [2, 4]].",
        "output": "import numpy as np\nA = np.outer([1, 2], [1, 2])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 diagonal matrix A = [[3, 0], [0, 5]].",
        "output": "import numpy as np\nA = np.array([[3, 0], [0, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 identity matrix A = [[1, 0], [0, 1]].",
        "output": "import numpy as np\nA = np.eye(2)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 zero matrix A = [[0, 0], [0, 0]].",
        "output": "import numpy as np\nA = np.zeros((2,2))\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 2x2 scalar matrix A = [[4, 0], [0, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 0], [0, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 2x2 upper triangular matrix A = [[2, 1], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [0, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 diagonal matrix A = [[1, 0, 0], [0, 4, 0], [0, 0, 7]].",
        "output": "import numpy as np\nA = np.diag([1, 4, 7])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 identity matrix A = [[1, 0, 0], [0, 1, 0], [0, 0, 1]].",
        "output": "import numpy as np\nA = np.eye(3)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 zero matrix A = [[0, 0, 0], [0, 0, 0], [0, 0, 0]].",
        "output": "import numpy as np\nA = np.zeros((3,3))\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 upper triangular matrix A = [[2, 1, 0], [0, 3, 2], [0, 0, 5]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 0], [0, 3, 2], [0, 0, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 3x3 lower triangular matrix A = [[2, 0, 0], [1, 3, 0], [4, 5, 7]].",
        "output": "import numpy as np\nA = np.array([[2, 0, 0], [1, 3, 0], [4, 5, 7]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the matrix A = [[4, -2], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[4, -2], [1, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvectors of the matrix A = [[3, 1], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues of the matrix A = [[5, -4], [2, -3]].",
        "output": "import numpy as np\nA = np.array([[5, -4], [2, -3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of A = [[6, -2], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[6, -2], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of the 3x3 matrix A = [[2, 1, 1], [1, 2, 1], [1, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 upper triangular matrix A = [[3, -1, 2], [0, 4, -1], [0, 0, 5]].",
        "output": "import numpy as np\nA = np.array([[3, -1, 2], [0, 4, -1], [0, 0, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Determine the eigenvalues of A = [[1, 2, 3], [0, 1, 4], [0, 0, 2]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [0, 1, 4], [0, 0, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a symmetric 3x3 matrix A = [[4, 1, 1], [1, 4, 1], [1, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 1], [1, 4, 1], [1, 1, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a symmetric 3x3 matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 matrix A = [[0, 1, 0], [-1, 0, 1], [0, -1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [-1, 0, 1], [0, -1, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the 4x4 matrix A = [[2, -1, 0, 0], [-1, 2, -1, 0], [0, -1, 2, -1], [0, 0, -1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 0, 0], [-1, 2, -1, 0], [0, -1, 2, -1], [0, 0, -1, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 circulant matrix A = [[1, 2, 3, 4], [4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1]].",
        "output": "import numpy as np\nfrom scipy.linalg import circulant\nA = circulant([1, 2, 3, 4])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the 5x5 matrix A = [[5, 2, 0, 0, 1], [2, 4, 2, 0, 0], [0, 2, 3, 2, 0], [0, 0, 2, 2, 2], [1, 0, 0, 2, 1]].",
        "output": "import numpy as np\nA = np.array([[5, 2, 0, 0, 1], [2, 4, 2, 0, 0], [0, 2, 3, 2, 0], [0, 0, 2, 2, 2], [1, 0, 0, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of the 4x4 matrix A = [[3, -1, 0, 0], [-1, 3, -1, 0], [0, -1, 3, -1], [0, 0, -1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, -1, 0, 0], [-1, 3, -1, 0], [0, -1, 3, -1], [0, 0, -1, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 5x5 symmetric pentadiagonal matrix A = [[4, 1, 0, 0, 0], [1, 4, 1, 0, 0], [0, 1, 4, 1, 0], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 0, 0, 0], [1, 4, 1, 0, 0], [0, 1, 4, 1, 0], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Determine the eigenvalues of a 6x6 block diagonal matrix with blocks [[1, 2], [2, 1]] and [[3, 4], [4, 3]] and [[5, 6], [6, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import block_diag\nA = block_diag([[1, 2], [2, 1]], [[3, 4], [4, 3]], [[5, 6], [6, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a skew-symmetric 4x4 matrix A = [[0, 2, -3, 1], [-2, 0, 4, -2], [3, -4, 0, 5], [-1, 2, -5, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 2, -3, 1], [-2, 0, 4, -2], [3, -4, 0, 5], [-1, 2, -5, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the companion matrix A = [[0, 0, 0, -5], [1, 0, 0, 4], [0, 1, 0, -3], [0, 0, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[0, 0, 0, -5], [1, 0, 0, 4], [0, 1, 0, -3], [0, 0, 1, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a rank-one modification of an identity matrix A = I + uv^T, where u = [1, 2, 3], v = [4, 5, 6].",
        "output": "import numpy as np\nu = np.array([1, 2, 3]).reshape(-1, 1)\nv = np.array([4, 5, 6]).reshape(1, -1)\nA = np.eye(3) + np.dot(u, v)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the matrix A = [[7, 2], [2, 5]].",
        "output": "import numpy as np\nA = np.array([[7, 2], [2, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvectors of the matrix A = [[3, -1], [4, 2]].",
        "output": "import numpy as np\nA = np.array([[3, -1], [4, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues of A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 4x4 identity matrix A = I_4.",
        "output": "import numpy as np\nA = np.eye(4)\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of the upper triangular matrix A = [[1, 2, 3], [0, 4, 5], [0, 0, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [0, 4, 5], [0, 0, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a 3x3 skew-symmetric matrix A = [[0, -1, 2], [1, 0, -3], [-2, 3, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -1, 2], [1, 0, -3], [-2, 3, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of A = [[0, 1, -1], [-1, 0, 1], [1, -1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, -1], [-1, 0, 1], [1, -1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a 4x4 matrix with repeated eigenvalues: A = [[3, 1, 0, 0], [0, 3, 2, 0], [0, 0, 3, 1], [0, 0, 0, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1, 0, 0], [0, 3, 2, 0], [0, 0, 3, 1], [0, 0, 0, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a block diagonal matrix with blocks [[2, 1], [1, 2]] and [[5, 0], [0, 5]].",
        "output": "import numpy as np\nfrom scipy.linalg import block_diag\nA = block_diag([[2, 1], [1, 2]], [[5, 0], [0, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a symmetric tridiagonal matrix A = [[4, 1, 0, 0], [1, 4, 1, 0], [0, 1, 4, 1], [0, 0, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 1, 0, 0], [1, 4, 1, 0], [0, 1, 4, 1], [0, 0, 1, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the matrix A = [[2, 0], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvectors of the matrix A = [[1, 0], [0, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of A = [[5, 0], [0, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 0], [0, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Determine the eigenvectors of the matrix A = [[6, 0], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[6, 0], [0, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of a diagonal matrix A = [[7, 0], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[7, 0], [0, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvectors of the matrix A = [[9, 0], [0, 9]].",
        "output": "import numpy as np\nA = np.array([[9, 0], [0, 9]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of the matrix A = [[0, 0], [0, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 0], [0, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Determine the eigenvalues of the matrix A = [[3, 0], [0, -3]].",
        "output": "import numpy as np\nA = np.array([[3, 0], [0, -3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues of a matrix A = [[10, 0], [0, 0]].",
        "output": "import numpy as np\nA = np.array([[10, 0], [0, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[2, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of the matrix A = [[0, -1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Determine the eigenvectors of A = [[4, 2], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[4, 2], [1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of the 3x3 matrix A = [[6, 2, 1], [2, 3, 1], [1, 1, 1]].",
        "output": "import numpy as np\nA = np.array([[6, 2, 1], [2, 3, 1], [1, 1, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of a 3x3 matrix A = [[2, 0, 0], [0, 3, 4], [0, 4, 9]].",
        "output": "import numpy as np\nA = np.array([[2, 0, 0], [0, 3, 4], [0, 4, 9]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute eigenvalues of A = [[1, 2, 0], [0, 3, 0], [0, 0, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 0], [0, 3, 0], [0, 0, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find eigenvalues and eigenvectors of symmetric matrix A = [[4, 1], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[4, 1], [1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute eigenvalues of A = [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Determine eigenvectors for A = [[0, 2], [2, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 2], [2, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find eigenvalues of a 3x3 matrix A = [[1, 2, 1], [6, -1, 0], [-1, -2, -1]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 1], [6, -1, 0], [-1, -2, -1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the matrix A = [[1, 2, 3], [0, 4, 5], [1, 0, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [0, 4, 5], [1, 0, 6]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Determine the eigenvalues and eigenvectors of matrix A = [[10, -2, 3], [4, 7, -1], [2, 5, 9]].",
        "output": "import numpy as np\nA = np.array([[10, -2, 3], [4, 7, -1], [2, 5, 9]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues for the 4x4 matrix A = [[6, 2, 1, 0], [2, 3, 1, 0], [1, 1, 1, 0], [0, 0, 0, 7]].",
        "output": "import numpy as np\nA = np.array([[6, 2, 1, 0], [2, 3, 1, 0], [1, 1, 1, 0], [0, 0, 0, 7]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of a matrix with complex entries: A = [[0, -1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[2, 2, 1], [1, 3, 1], [1, 2, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 2, 1], [1, 3, 1], [1, 2, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues of the matrix A = [[4, -2, 1], [0, 3, -1], [0, 0, 2]].",
        "output": "import numpy as np\nA = np.array([[4, -2, 1], [0, 3, -1], [0, 0, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the matrix A = [[0, 1, 0], [0, 0, 1], [-1, -1, -1]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [0, 0, 1], [-1, -1, -1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of a 3x3 matrix A = [[3, 0, 1], [0, 2, 0], [1, 0, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 0, 1], [0, 2, 0], [1, 0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Determine the eigenvalues of a nearly singular matrix A = [[1, 2, 3], [4, 5, 6], [7.001, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7.001, 8, 9]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the matrix A = [[1, 1, 0], [0, 1, 1], [0, 0, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 1, 0], [0, 1, 1], [0, 0, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the matrix A = [[1, 2], [2, 1]] and comment on their multiplicity.",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Determine the eigenvectors of the nilpotent matrix A = [[0, 1], [0, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [0, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of the Jordan block matrix A = [[5, 1], [0, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 1], [0, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvectors of A = [[0, 1, 0], [0, 0, 1], [0, 0, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Check if matrix A = [[2, -2], [1, 3]] has complex eigenvalues.",
        "output": "import numpy as np\nA = np.array([[2, -2], [1, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find eigenvalues of a matrix with repeated eigenvalues: A = [[3, 1], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [0, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find eigenvalues and eigenvectors of the matrix A = [[2, 0, 0], [0, 2, 0], [0, 0, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 0, 0], [0, 2, 0], [0, 0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the eigenvalues of a rank-deficient matrix A = [[1, 2, 3], [2, 4, 6], [3, 6, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 4, 6], [3, 6, 9]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Calculate eigenvectors of A = [[4, -5], [2, -3]].",
        "output": "import numpy as np\nA = np.array([[4, -5], [2, -3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of the complex Hermitian matrix A = [[1+0j, 2-1j], [2+1j, 3+0j]].",
        "output": "import numpy as np\nA = np.array([[1+0j, 2-1j], [2+1j, 3+0j]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find the eigenvalues of the matrix A = [[3, 0], [0, 5]].",
        "output": "import numpy as np\nA = np.array([[3, 0], [0, 5]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Determine the eigenvectors of matrix A = [[2, 0], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of the matrix A = [[4, 0], [0, 4]].",
        "output": "import numpy as np\nA = np.array([[4, 0], [0, 4]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute the eigenvectors of a matrix A = [[1, 0], [0, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 6]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find eigenvalues of the matrix A = [[2, 0, 0], [0, 2, 0], [0, 0, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 0, 0], [0, 2, 0], [0, 0, 3]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Determine the eigenvalues of the matrix A = [[0, 0], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[0, 0], [0, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Compute eigenvectors of the identity matrix A = [[1, 0], [0, 1]].",
        "output": "import numpy as np\nA = np.eye(2)\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the eigenvalues of matrix A = [[5, 0, 0], [0, 2, 0], [0, 0, 1]].",
        "output": "import numpy as np\nA = np.array([[5, 0, 0], [0, 2, 0], [0, 0, 1]])\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
    },
    {
        "input": "Find eigenvalues and eigenvectors of matrix A = [[1, 0], [0, 0]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Add the matrices A = [[1, 2], [3, 4]] and B = [[5, 6], [7, 8]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\nresult = A + B\nprint(result)"
    },
    {
        "input": "Multiply the matrices A = [[2, 4], [6, 8]] and B = [[1, 3], [5, 7]].",
        "output": "import numpy as np\nA = np.array([[2, 4], [6, 8]])\nB = np.array([[1, 3], [5, 7]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Find the transpose of matrix A = [[1, 2, 3], [4, 5, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6]])\nresult = A.T\nprint(result)"
    },
    {
        "input": "Determine the inverse of matrix A = [[4, 7], [2, 6]].",
        "output": "import numpy as np\nA = np.array([[4, 7], [2, 6]])\nresult = np.linalg.inv(A)\nprint(result)"
    },
    {
        "input": "Add the matrices A = [[3, 5], [7, 9]] and B = [[2, 4], [6, 8]].",
        "output": "import numpy as np\nA = np.array([[3, 5], [7, 9]])\nB = np.array([[2, 4], [6, 8]])\nresult = A + B\nprint(result)"
    },
    {
        "input": "Multiply the matrices A = [[1, 0], [0, 1]] and B = [[5, 6], [7, 8]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1]])\nB = np.array([[5, 6], [7, 8]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Find the transpose of matrix A = [[2, 4, 6], [8, 10, 12]].",
        "output": "import numpy as np\nA = np.array([[2, 4, 6], [8, 10, 12]])\nresult = A.T\nprint(result)"
    },
    {
        "input": "Determine the inverse of matrix A = [[1, 2], [3, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nresult = np.linalg.inv(A)\nprint(result)"
    },
    {
        "input": "Add the matrices A = [[0, 1], [1, 0]] and B = [[1, 1], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\nB = np.array([[1, 1], [1, 1]])\nresult = A + B\nprint(result)"
    },
    {
        "input": "Multiply the matrices A = [[2, 3], [4, 5]] and B = [[6, 7], [8, 9]].",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nB = np.array([[6, 7], [8, 9]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Find the transpose of matrix A = [[1, 3, 5], [7, 9, 11]].",
        "output": "import numpy as np\nA = np.array([[1, 3, 5], [7, 9, 11]])\nresult = A.T\nprint(result)"
    },
    {
        "input": "Determine the inverse of matrix A = [[3, 4], [2, 5]].",
        "output": "import numpy as np\nA = np.array([[3, 4], [2, 5]])\nresult = np.linalg.inv(A)\nprint(result)"
    },
    {
        "input": "Add the matrices A = [[5, 5], [5, 5]] and B = [[2, 2], [2, 2]].",
        "output": "import numpy as np\nA = np.array([[5, 5], [5, 5]])\nB = np.array([[2, 2], [2, 2]])\nresult = A + B\nprint(result)"
    },
    {
        "input": "Multiply the matrices A = [[1, 2], [3, 4]] and B = [[2, 0], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[2, 0], [1, 2]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Find the transpose of matrix A = [[0, 2, 4], [6, 8, 10]].",
        "output": "import numpy as np\nA = np.array([[0, 2, 4], [6, 8, 10]])\nresult = A.T\nprint(result)"
    },
    {
        "input": "Determine the inverse of matrix A = [[7, 2], [3, 4]].",
        "output": "import numpy as np\nA = np.array([[7, 2], [3, 4]])\nresult = np.linalg.inv(A)\nprint(result)"
    },
    {
        "input": "Add the matrices A = [[9, 8], [7, 6]] and B = [[1, 2], [3, 4]].",
        "output": "import numpy as np\nA = np.array([[9, 8], [7, 6]])\nB = np.array([[1, 2], [3, 4]])\nresult = A + B\nprint(result)"
    },
    {
        "input": "Add the matrices A = [[2, 3], [4, 5]] and B = [[6, 7], [8, 9]].",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nB = np.array([[6, 7], [8, 9]])\nresult = A + B\nprint(result)"
    },
    {
        "input": "Multiply the matrices A = [[3, 1], [4, 2]] and B = [[5, 6], [7, 8]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [4, 2]])\nB = np.array([[5, 6], [7, 8]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Find the transpose of matrix A = [[1, 4, 7], [2, 5, 8]].",
        "output": "import numpy as np\nA = np.array([[1, 4, 7], [2, 5, 8]])\nresult = A.T\nprint(result)"
    },
    {
        "input": "Determine the inverse of matrix A = [[4, 3], [3, 2]].",
        "output": "import numpy as np\nA = np.array([[4, 3], [3, 2]])\nresult = np.linalg.inv(A)\nprint(result)"
    },
    {
        "input": "Add the matrices A = [[1, 1], [1, 1]] and B = [[2, 2], [2, 2]].",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, 1]])\nB = np.array([[2, 2], [2, 2]])\nresult = A + B\nprint(result)"
    },
    {
        "input": "Given matrices A = [[3, 5], [7, 9]] and B = [[2, 4], [6, 8]], compute the product AB and then find the transpose of the result.",
        "output": "import numpy as np\nA = np.array([[3, 5], [7, 9]])\nB = np.array([[2, 4], [6, 8]])\nproduct = A @ B\nresult = product.T\nprint(result)"
    },
    {
        "input": "For matrix A = [[2, -1, 0], [1, 3, 2], [0, 4, 5]], calculate the determinant .",
        "output": "import numpy as np\nA = np.array([[2, -1, 0], [1, 3, 2], [0, 4, 5]])\ndet_A = np.linalg.det(A)\nprint(det_A)"
    },
    {
        "input": "Compute the inverse of matrix A = [[4, 7], [2, 6]] .",
        "output": "import numpy as np\nA = np.array([[4, 7], [2, 6]])\nA_inv = np.linalg.inv(A)\nprint(A_inv)"
    },
    {
        "input": "Given matrices A = [[1, 2], [3, 4]] and B = [[5, 6], [7, 8]], compute AB - BA.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\nAB = A @ B\nBA = B @ A\nresult = AB - BA\nprint(result)"
    },
    {
        "input": "For matrix A = [[0, -1], [1, 0]], compute A^3.",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\nA_cubed = np.linalg.matrix_power(A, 3)\nprint(A_cubed)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of matrix A = [[4, -2], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[4, -2], [1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(eigenvalues)\nprint(eigenvectors)"
    },
    {
        "input": "Given matrix A = [[3, 1], [4, 2]], compute the determinant of A^2.",
        "output": "import numpy as np\nA = np.array([[3, 1], [4, 2]])\nA_squared = A @ A\ndet_A_squared = np.linalg.det(A_squared)\nprint(det_A_squared)"
    },
    {
        "input": "Verify if matrix A = [[1, 2], [3, 4]] satisfies the equation A^2 - 5A + 6I = 0, where I is the identity matrix.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nI = np.eye(2)\nleft_side = A @ A - 5*A + 6*I\nprint(left_side)"
    },
    {
        "input": "Compute the rank of matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nrank_A = np.linalg.matrix_rank(A)\nprint(rank_A)"
    },
    {
        "input": "Given matrix A = [[2, 3], [5, 7]], compute the inverse of A and then find the inverse of A^T.",
        "output": "import numpy as np\nA = np.array([[2, 3], [5, 7]])\nA_inv = np.linalg.inv(A)\nA_T_inv = np.linalg.inv(A.T)\nprint(A_inv)\nprint(A_T_inv)"
    },
    {
        "input": "Compute the determinant of the 3x3 matrix A = [[1, 2, 3], [0, 1, 4], [5, 6, 0]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [0, 1, 4], [5, 6, 0]])\ndet_A = np.linalg.det(A)\nprint(det_A)"
    },
    {
        "input": "Find the trace (sum of diagonal elements) of matrix A = [[4, 2], [3, 1]].",
        "output": "import numpy as np\nA = np.array([[4, 2], [3, 1]])\ntrace_A = np.trace(A)\nprint(trace_A)"
    },
    {
        "input": "Multiply the matrices A = [[2, 0], [1, 3]] and B = [[4, 5], [6, 7]].",
        "output": "import numpy as np\nA = np.array([[2, 0], [1, 3]])\nB = np.array([[4, 5], [6, 7]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Compute the product of matrices A = [[1, 2], [3, 4]] and B = [[2, 0], [1, 2]], then find the transpose of the result.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[2, 0], [1, 2]])\nproduct = A @ B\nresult = product.T\nprint(result)"
    },
    {
        "input": "Given matrix A = [[3, 1], [4, 2]], compute A squared (A^2).",
        "output": "import numpy as np\nA = np.array([[3, 1], [4, 2]])\nresult = A @ A\nprint(result)"
    },
    {
        "input": "Find the inverse of matrix A = [[2, 3], [5, 7]] .",
        "output": "import numpy as np\nA = np.array([[2, 3], [5, 7]])\nA_inv = np.linalg.inv(A)\nprint(A_inv)"
    },
    {
        "input": "Compute the determinant of matrix A = [[1, 2], [3, 4]] .",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ndet_A = np.linalg.det(A)\nprint('Determinant:',det_A)"
    },
    {
        "input": "Given matrix A = [[2, -1], [1, 3]], find A^3 (A cubed).",
        "output": "import numpy as np\nA = np.array([[2, -1], [1, 3]])\nA_cubed = np.linalg.matrix_power(A, 3)\nprint(A_cubed)"
    },
    {
        "input": "Compute the inverse of matrix A = [[4, 7], [2, 6]] and then find the inverse of A^T (transpose of A).",
        "output": "import numpy as np\nA = np.array([[4, 7], [2, 6]])\nA_inv = np.linalg.inv(A)\nA_T_inv = np.linalg.inv(A.T)\nprint(A_inv)\nprint(A_T_inv)"
    },
    {
        "input": "For matrix A = [[0, -1], [1, 0]], compute A^4.",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\nA_fourth = np.linalg.matrix_power(A, 4)\nprint(A_fourth)"
    },
    {
        "input": "For matrix A = [[2, 3], [5, 7]], compute the determinant of A^2.",
        "output": "import numpy as np\nA = np.array([[2, 3], [5, 7]])\nA_squared = A @ A\ndet = np.linalg.det(A_squared)\nprint(det)"
    },
    {
        "input": "Given matrices A = [[1, 2], [3, 4]] and B = [[5, 6], [7, 8]], compute A * B.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Given matrices A = [[1, 2], [3, 4]] and B = [[2, 0], [1, 2]], compute A + B and A - B.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[2, 0], [1, 2]])\nsum_result = A + B\ndiff_result = A - B\nprint(sum_result)\nprint(diff_result)"
    },
    {
        "input": "Given matrices A = [[2, 3], [4, 5]] and B = [[1, 2], [3, 4]], compute A + B.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nB = np.array([[1, 2], [3, 4]])\nresult = A + B\nprint(result)"
    },
    {
        "input": "Given matrices A = [[2, 3], [4, 5]] and B = [[1, 2], [3, 4]], compute A - B.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nB = np.array([[1, 2], [3, 4]])\nresult = A - B\nprint(result)"
    },
    {
        "input": "Given matrices A = [[1, 2], [3, 4]] and B = [[5, 6], [7, 8]], compute A * B and B * A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\nresult_AB = A @ B\nresult_BA = B @ A\nprint(result_AB)\nprint(result_BA)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute the transpose of A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nresult = A.T\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute the inverse of A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nresult = np.linalg.inv(A)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute A^2.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nresult = A @ A\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute A^3.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nresult = np.linalg.matrix_power(A, 3)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute the determinant of A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ndet_A = np.linalg.det(A)\nprint(det_A)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute the rank of A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nrank_A = np.linalg.matrix_rank(A)\nprint(rank_A)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute the trace of A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ntrace_A = np.trace(A)\nprint(trace_A)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute the eigenvalues of A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\neigenvalues_A = np.linalg.eigvals(A)\nprint(eigenvalues_A)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute the eigenvectors of A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\neigenvalues_A, eigenvectors_A = np.linalg.eig(A)\nprint(eigenvectors_A)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute the singular value decomposition of A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nU, S, Vt = np.linalg.svd(A)\nprint(U)\nprint(S)\nprint(Vt)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute the Moore-Penrose pseudoinverse of A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nA_pseudo_inv = np.linalg.pinv(A)\nprint(A_pseudo_inv)"
    },
    {
        "input": "Given matrices A = [[1, 2], [3, 4]] and B = [[5, 6], [7, 8]], compute A + B and A - B.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\nresult_add = A + B\nresult_sub = A - B\nprint(result_add)\nprint(result_sub)"
    },
    {
        "input": "Given matrices A = [[1, 2], [3, 4]] and B = [[5, 6], [7, 8]], compute A + B.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\nresult = A + B\nprint(result)"
    },
    {
        "input": "Given matrices A = [[1, 2], [3, 4]] and B = [[5, 6], [7, 8]], compute A - B.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\nresult = A - B\nprint(result)"
    },
    {
        "input": "Given matrix A = [[2, 3], [4, 5]] and B = [[1, 2], [3, 4]], compute A * B.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nB = np.array([[1, 2], [3, 4]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Given matrix A = [[2, 3], [4, 5]] and B = [[1, 2], [3, 4]], compute A + B.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nB = np.array([[1, 2], [3, 4]])\nresult = A + B\nprint(result)"
    },
    {
        "input": "Given matrix A = [[2, 3], [4, 5]] and B = [[1, 2], [3, 4]], compute A - B.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nB = np.array([[1, 2], [3, 4]])\nresult = A - B\nprint(result)"
    },
    {
        "input": "Given matrix A = [[2, 3], [4, 5]], compute A^2.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nresult = A @ A\nprint(result)"
    },
    {
        "input": "Given matrix A = [[2, 3], [4, 5]], compute the determinant of A.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\ndet_A = np.linalg.det(A)\nprint(det_A)"
    },
    {
        "input": "Given matrix A = [[2, 3], [4, 5]], compute the rank of A.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nrank_A = np.linalg.matrix_rank(A)\nprint(rank_A)"
    },
    {
        "input": "Given matrix A = [[2, 3], [4, 5]], compute the trace of A.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\ntrace_A = np.trace(A)\nprint(trace_A)"
    },
    {
        "input": "Given matrix A = [[2, 3], [4, 5]], compute the eigenvalues of A.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\neigenvalues_A = np.linalg.eigvals(A)\nprint(eigenvalues_A)"
    },
    {
        "input": "Given matrix A = [[2, 3], [4, 5]], compute the eigenvectors of A.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\neigenvalues_A, eigenvectors_A = np.linalg.eig(A)\nprint(eigenvectors_A)"
    },
    {
        "input": "Given matrices A = [[1, 2], [3, 4]] and B = [[5, 6], [7, 8]], compute AB and BA.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\nAB = A @ B\nBA = B @ A\nprint(AB)\nprint(BA)"
    },
    {
        "input": "Given matrices A = [[1, 2], [3, 4]] and B = [[2, 0], [1, 2]], compute A * B.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[2, 0], [1, 2]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute the inverse of A^T.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nA_inv_T = np.linalg.inv(A.T)\nprint(A_inv_T)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute the determinant of A^2.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ndet_A_squared = np.linalg.det(A @ A)\nprint(det_A_squared)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute A^2 + A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nresult = A @ A + A\nprint(result)"
    },
    {
        "input": "Given matrix A = [[2, 3], [4, 5]], compute A + A^T.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nresult = A + A.T\nprint(result)"
    },
    {
        "input": "Given matrix A = [[3, 4], [5, 6]], compute the eigenvectors and eigenvalues of A.",
        "output": "import numpy as np\nA = np.array([[3, 4], [5, 6]])\neigenvalues_A, eigenvectors_A = np.linalg.eig(A)\nprint(eigenvalues_A)\nprint(eigenvectors_A)"
    },
    {
        "input": "Given matrices A = [[1, 2], [3, 4]] and B = [[2, 0], [1, 2]], compute A * B .",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[2, 0], [1, 2]])\nAB = A @ B\nprint(AB)"
    },
    {
        "input": "Given matrix A = [[4, 7], [2, 6]], compute the inverse of A and verify by multiplying it with A.",
        "output": "import numpy as np\nA = np.array([[4, 7], [2, 6]])\nA_inv = np.linalg.inv(A)\nverification = A @ A_inv\nprint(A_inv)\nprint(verification)"
    },
    {
        "input": "Given matrix A = [[2, 3], [4, 5]], compute A * A^T.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nresult = np.dot(A, A.T)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2, 3], [4, 5, 6]], compute the rank of A.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6]])\nrank_A = np.linalg.matrix_rank(A)\nprint(rank_A)"
    },
    {
        "input": "Given matrix A = [[4, 7], [2, 6]], compute the determinant of A.",
        "output": "import numpy as np\nA = np.array([[4, 7], [2, 6]])\ndet_A = np.linalg.det(A)\nprint(det_A)"
    },
    {
        "input": "Given matrices A = [[1, 2], [3, 4]] and B = [[5, 6], [7, 8]], compute AB .",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\nAB = A @ B\nprint(AB)"
    },
    {
        "input": "Given matrices A = [[2, 4], [1, 3]] and B = [[5, 6], [7, 8]], compute the product A * B.",
        "output": "import numpy as np\nA = np.array([[2, 4], [1, 3]])\nB = np.array([[5, 6], [7, 8]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 3], [2, 4]], compute A * A^T.",
        "output": "import numpy as np\nA = np.array([[1, 3], [2, 4]])\nresult = np.dot(A, A.T)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 0], [0, 1]], compute the inverse of A.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1]])\nresult = np.linalg.inv(A)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[5, 7], [1, 3]], compute A * 2.",
        "output": "import numpy as np\nA = np.array([[5, 7], [1, 3]])\nresult = 2 * A\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]] and B = [[4, 3], [2, 1]], compute A * B.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[4, 3], [2, 1]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute A * A^T.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nresult = np.dot(A, A.T)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[3, 5], [2, 4]], compute the inverse of A.",
        "output": "import numpy as np\nA = np.array([[3, 5], [2, 4]])\nresult = np.linalg.inv(A)\nprint(result)"
    },
    {
        "input": "Given matrices A = [[3, 5], [2, 4]] and B = [[1, 2], [3, 4]], compute A * B.",
        "output": "import numpy as np\nA = np.array([[3, 5], [2, 4]])\nB = np.array([[1, 2], [3, 4]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Given matrix A = [[2, 3], [4, 5]], compute A^3.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nresult = np.linalg.matrix_power(A, 3)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2, 3], [4, 5, 6]], compute A^T.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6]])\nresult = A.T\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 1], [1, 1]], compute A^2.",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, 1]])\nresult = A @ A\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute A^T * A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nresult = np.dot(A.T, A)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[5, 6], [7, 8]], compute A^T.",
        "output": "import numpy as np\nA = np.array([[5, 6], [7, 8]])\nresult = A.T\nprint(result)"
    },
    {
        "input": "Given matrix A = [[3, 4], [2, 1]], compute the inverse of A.",
        "output": "import numpy as np\nA = np.array([[3, 4], [2, 1]])\nresult = np.linalg.inv(A)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[5, 6], [7, 8]], compute the determinant of A.",
        "output": "import numpy as np\nA = np.array([[5, 6], [7, 8]])\ndet_A = np.linalg.det(A)\nprint(det_A)"
    },
    {
        "input": "Given matrices A = [[1, 2], [3, 4]] and B = [[2, 1], [4, 3]], compute AB.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[2, 1], [4, 3]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Given matrices A = [[1, 0], [0, 1]] and B = [[2, 3], [4, 5]], compute AB.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1]])\nB = np.array([[2, 3], [4, 5]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Given matrix A = [[3, 5], [7, 9]], compute A * A^T.",
        "output": "import numpy as np\nA = np.array([[3, 5], [7, 9]])\nresult = np.dot(A, A.T)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 0], [0, 1]], compute the determinant of A.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1]])\ndet_A = np.linalg.det(A)\nprint(det_A)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute the trace of A^T.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ntrace_A_T = np.trace(A.T)\nprint(trace_A_T)"
    },
    {
        "input": "Given matrix A = [[2, 1], [3, 4]], compute A + A^T.",
        "output": "import numpy as np\nA = np.array([[2, 1], [3, 4]])\nresult = A + A.T\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]] and B = [[4, 3], [2, 1]], compute A * B and B * A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[4, 3], [2, 1]])\nAB = A @ B\nBA = B @ A\nprint(AB)\nprint(BA)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute A^T * A^T.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nresult = np.dot(A.T, A.T)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[3, 2], [1, 4]], compute the determinant of A * A^T.",
        "output": "import numpy as np\nA = np.array([[3, 2], [1, 4]])\ndet_A_A_T = np.linalg.det(np.dot(A, A.T))\nprint(det_A_A_T)"
    },
    {
        "input": "Given matrix A = [[2, 3], [4, 5]], compute the inverse of A.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nresult = np.linalg.inv(A)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[3, 1], [2, 4]], compute A * A^2.",
        "output": "import numpy as np\nA = np.array([[3, 1], [2, 4]])\nresult = np.dot(A, A @ A)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute A * 3.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nresult = 3 * A\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 3], [2, 4]], compute A^2 + A^T.",
        "output": "import numpy as np\nA = np.array([[1, 3], [2, 4]])\nresult = A @ A + A.T\nprint(result)"
    },
    {
        "input": "Given matrix A = [[2, 3], [5, 6]], compute A * A^T.",
        "output": "import numpy as np\nA = np.array([[2, 3], [5, 6]])\nresult = np.dot(A, A.T)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[2, 1], [3, 4]], compute A^T * A.",
        "output": "import numpy as np\nA = np.array([[2, 1], [3, 4]])\nresult = np.dot(A.T, A)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[2, 3], [4, 5]], compute A * 0.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nresult = 0 * A\nprint(result)"
    },
    {
        "input": "Given matrix A = [[3, 6], [7, 1]], compute A^T.",
        "output": "import numpy as np\nA = np.array([[3, 6], [7, 1]])\nresult = A.T\nprint(result)"
    },
    {
        "input": "Given matrix A = [[2, 5], [3, 6]], compute A^2.",
        "output": "import numpy as np\nA = np.array([[2, 5], [3, 6]])\nresult = A @ A\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 0], [0, 1]], compute A^T.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1]])\nresult = A.T\nprint(result)"
    },
    {
        "input": "Given matrix A = [[4, 3], [2, 1]], compute the inverse of A.",
        "output": "import numpy as np\nA = np.array([[4, 3], [2, 1]])\nresult = np.linalg.inv(A)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute A + A^T.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nresult = A + A.T\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 1], [1, 1]], compute the determinant of A.",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, 1]])\ndet_A = np.linalg.det(A)\nprint(det_A)"
    },
    {
        "input": "Given matrix A = [[2, 3], [5, 6]], compute A * B where B = [[1, 0], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[2, 3], [5, 6]])\nB = np.array([[1, 0], [0, 1]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Given matrix A = [[2, 3], [4, 5]], compute A^T * A.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nresult = np.dot(A.T, A)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[4, 2], [1, 3]], compute the inverse of A * A^T.",
        "output": "import numpy as np\nA = np.array([[4, 2], [1, 3]])\nresult = np.linalg.inv(np.dot(A, A.T))\nprint(result)"
    },
    {
        "input": "Given matrix A = [[3, 5], [7, 1]], compute A^2.",
        "output": "import numpy as np\nA = np.array([[3, 5], [7, 1]])\nresult = A @ A\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 3], [2, 4]], compute the transpose of A^2.",
        "output": "import numpy as np\nA = np.array([[1, 3], [2, 4]])\nresult = np.transpose(A @ A)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[2, 5], [1, 3]], compute A^T * A + A.",
        "output": "import numpy as np\nA = np.array([[2, 5], [1, 3]])\nresult = np.dot(A.T, A) + A\nprint(result)"
    },
    {
        "input": "Given matrix A = [[5, 4], [3, 6]], compute the determinant of A.",
        "output": "import numpy as np\nA = np.array([[5, 4], [3, 6]])\ndet_A = np.linalg.det(A)\nprint(det_A)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]] and B = [[5, 6], [7, 8]], compute the matrix A + B^T.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\nresult = A + B.T\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute the matrix A^T * A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nresult = np.dot(A.T, A)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[2, 1], [1, 2]], compute the inverse of A.",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\nresult = np.linalg.inv(A)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [2, 1]], compute A * 3 + A^T.",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\nresult = 3 * A + A.T\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute the determinant of A * A^T.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ndet_A_A_T = np.linalg.det(np.dot(A, A.T))\nprint(det_A_A_T)"
    },
    {
        "input": "Given matrix A = [[3, 1], [2, 4]], compute the trace of A^2.",
        "output": "import numpy as np\nA = np.array([[3, 1], [2, 4]])\nresult = np.trace(A @ A)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[3, 1], [2, 4]], compute A^T.",
        "output": "import numpy as np\nA = np.array([[3, 1], [2, 4]])\nresult = A.T\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 3], [2, 4]], compute the inverse of A * A^T.",
        "output": "import numpy as np\nA = np.array([[1, 3], [2, 4]])\nresult = np.linalg.inv(np.dot(A, A.T))\nprint(result)"
    },
    {
        "input": "Given matrix A = [[4, 7], [2, 6]], compute A^2 + A.",
        "output": "import numpy as np\nA = np.array([[4, 7], [2, 6]])\nresult = A @ A + A\nprint(result)"
    },
    {
        "input": "Given matrix A = [[2, 3], [5, 6]], compute the inverse of A * A^T.",
        "output": "import numpy as np\nA = np.array([[2, 3], [5, 6]])\nresult = np.linalg.inv(np.dot(A, A.T))\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 1], [1, 1]], compute A^T.",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, 1]])\nresult = A.T\nprint(result)"
    },
    {
        "input": "Given matrix A = [[3, 1], [4, 2]], compute A + A^T.",
        "output": "import numpy as np\nA = np.array([[3, 1], [4, 2]])\nresult = A + A.T\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute the determinant of A^T * A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ndet_A_T_A = np.linalg.det(np.dot(A.T, A))\nprint(det_A_T_A)"
    },
    {
        "input": "Given matrix A = [[3, 1], [4, 2]], compute A * A^T.",
        "output": "import numpy as np\nA = np.array([[3, 1], [4, 2]])\nresult = np.dot(A, A.T)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[4, 3], [2, 1]], compute the determinant of A * A^T.",
        "output": "import numpy as np\nA = np.array([[4, 3], [2, 1]])\ndet_A_A_T = np.linalg.det(np.dot(A, A.T))\nprint(det_A_A_T)"
    },
    {
        "input": "Given matrix A = [[5, 4], [3, 2]], compute A * A^T.",
        "output": "import numpy as np\nA = np.array([[5, 4], [3, 2]])\nresult = np.dot(A, A.T)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[2, 1], [1, 2]], compute A * A.",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\nresult = A @ A\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute A * 2.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nresult = 2 * A\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 0], [0, 1]], compute A * A^T.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1]])\nresult = np.dot(A, A.T)\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 3], [2, 4]], compute the determinant of A^T.",
        "output": "import numpy as np\nA = np.array([[1, 3], [2, 4]])\ndet_A_T = np.linalg.det(A.T)\nprint(det_A_T)"
    },
    {
        "input": "Given matrix A = [[3, 6], [1, 2]], compute A + A^T.",
        "output": "import numpy as np\nA = np.array([[3, 6], [1, 2]])\nresult = A + A.T\nprint(result)"
    },
    {
        "input": "Given matrices A = [[2, 3], [4, 5]] and B = [[6, 7], [8, 9]], compute A * B.",
        "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nB = np.array([[6, 7], [8, 9]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Given matrix A = [[3, 5], [2, 1]], compute the determinant of A.",
        "output": "import numpy as np\nA = np.array([[3, 5], [2, 1]])\ndet_A = np.linalg.det(A)\nprint(det_A)"
    },
    {
        "input": "Given matrix A = [[1, 3], [2, 4]], compute the trace of A.",
        "output": "import numpy as np\nA = np.array([[1, 3], [2, 4]])\ntrace_A = np.trace(A)\nprint(trace_A)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute A^T.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nresult = A.T\nprint(result)"
    },
    {
        "input": "Given matrix A = [[1, 2], [3, 4]], compute 3 * A.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nresult = 3 * A\nprint(result)"
    },
    {
        "input": "Determine if the vector (5, 6) is in the span of {(1, 2), (3, 4)}.",
        "output": "import numpy as np\nA = np.array([[1, 3], [2, 4]])\nb = np.array([5, 6])\ntry:\n    coeffs = np.linalg.solve(A, b)\n    print(coeffs)\nexcept np.linalg.LinAlgError:\n    print('The vector is not in the span.')"
    },
    {
        "input": "Find the dimension of the vector space spanned by {(1, 0, 0), (0, 1, 0), (0, 0, 1), (1, 1, 1)}.",
        "output": "import numpy as np\nvectors = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1]])\nrank = np.linalg.matrix_rank(vectors)\nprint(rank)"
    },
    {
        "input": "Compute the projection of vector (3, 4) onto vector (1, 2).",
        "output": "import numpy as np\nv = np.array([3, 4])\nu = np.array([1, 2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find a basis for the null space of matrix [[1, 2, 3], [4, 5, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 2, 3], [4, 5, 6]])\nnull_basis = null_space(A)\nprint(null_basis)"
    },
    {
        "input": "Find the coordinates of vector (3, 4) relative to the basis {(1, 0), (0, 1)}.",
        "output": "import numpy as np\nv = np.array([3, 4])\nbasis = np.array([[1, 0], [0, 1]])\ncoordinates = np.linalg.solve(basis.T, v)\nprint(coordinates)"
    },
    {
        "input": "Compute the Gram-Schmidt orthogonalization of {(1, 1), (1, -1)}.",
        "output": "import numpy as np\nv1 = np.array([1, 1])\nv2 = np.array([1, -1])\nu1 = v1\nu2 = v2 - (np.dot(v2, u1) / np.dot(u1, u1)) * u1\nprint(u1, u2)"
    },
    {
        "input": "Find the dimension of the subspace of R^4 spanned by {(1, 2, 3, 4), (2, 4, 6, 8), (0, 1, 0, 1)}.",
        "output": "import numpy as np\nvectors = np.array([[1, 2, 3, 4], [2, 4, 6, 8], [0, 1, 0, 1]])\nrank = np.linalg.matrix_rank(vectors)\nprint(rank)"
    },
    {
        "input": "Find a basis for the column space of matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.linalg.matrix_rank(A)\nbasis = A[:, :rank]\nprint(basis)"
    },
    {
        "input": "Compute the rank of the matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nrank = np.linalg.matrix_rank(A)\nprint(rank)"
    },
    {
        "input": "Find the orthogonal projection of vector (3, 4, 5) onto the subspace spanned by {(1, 0, 0), (0, 1, 0)}.",
        "output": "import numpy as np\nv = np.array([3, 4, 5])\nU = np.array([[1, 0, 0], [0, 1, 0]])\nprojection = U.T @ np.linalg.inv(U @ U.T) @ U @ v\nprint(projection)"
    },
    {
        "input": "Find a basis for the row space of matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.linalg.matrix_rank(A)\nbasis = Vt[:rank, :]\nprint(basis)"
    },
    {
        "input": "Compute the dimension of the subspace of R^3 defined by the equation x + y + z = 0.",
        "output": "import numpy as np\nA = np.array([[1, 1, 1]])\nnullity = 3 - np.linalg.matrix_rank(A)\nprint(nullity)"
    },
    {
        "input": "Find the dimension of the subspace of R^3 spanned by {(1, 0, 0), (0, 1, 0), (1, 1, 0)}.",
        "output": "import numpy as np\nvectors = np.array([[1, 0, 0], [0, 1, 0], [1, 1, 0]])\nrank = np.linalg.matrix_rank(vectors)\nprint(rank)"
    },
    {
        "input": "Find a basis for the null space of matrix A = [[2, 4, 6], [1, 2, 3], [3, 6, 9]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[2, 4, 6], [1, 2, 3], [3, 6, 9]])\nnull_basis = null_space(A)\nprint(null_basis)"
    },
    {
        "input": "Compute the rank of the matrix A = [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nrank = np.linalg.matrix_rank(A)\nprint(rank)"
    },
    {
        "input": "Find the coordinates of vector (4, 5, 6) relative to the basis {(1, 0, 0), (0, 1, 1), (0, 0, 1)}.",
        "output": "import numpy as np\nB = np.array([[1, 0, 0], [0, 1, 1], [0, 0, 1]])\nv = np.array([4, 5, 6])\ncoordinates = np.linalg.solve(B, v)\nprint(coordinates)"
    },
    {
        "input": "Find a basis for the row space of matrix A = [[1, 2, 3], [2, 4, 6], [3, 6, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 4, 6], [3, 6, 9]])\nU, s, Vt = np.linalg.svd(A)\nrank = np.sum(s > 1e-10)\nbasis = Vt[:rank]\nprint(basis)"
    },
    {
        "input": "Compute the dimension of the subspace of R^4 defined by the equations x + y + z + w = 0 and x - y + z - w = 0.",
        "output": "import numpy as np\nA = np.array([[1, 1, 1, 1], [1, -1, 1, -1]])\nnullity = 4 - np.linalg.matrix_rank(A)\nprint(nullity)"
    },
    {
        "input": "Find the orthogonal projection of vector (1, 2, 3) onto the subspace spanned by {(1, 0, 1), (0, 1, 1)}.",
        "output": "import numpy as np\nv = np.array([1, 2, 3])\nU = np.array([[1, 0, 1], [0, 1, 1]])\nU = U.T\nproj = U @ np.linalg.pinv(U.T @ U) @ U.T @ v\nprint(proj)"
    },
    {
        "input": "Find a basis for the solution space of the homogeneous system: x + 2y + 3z = 0, 4x + 5y + 6z = 0.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6]])\nU, S, Vt = np.linalg.svd(A)\ntol = 1e-10\nrank = (S > tol).sum()\nnull_space = Vt[rank:].T\nprint(null_space)"
    },
    {
        "input": "Find the dimension of the subspace of R^4 spanned by the vectors {(1, 2, 3, 4), (2, 4, 6, 8), (3, 6, 9, 12)}.",
        "output": "import numpy as np\nvectors = np.array([[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12]])\nrank = np.linalg.matrix_rank(vectors)\nprint(rank)"
    },
    {
        "input": "Find a basis for the column space of the matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nQ, R, P = qr(A, mode='economic', pivoting=True)\nindependent_cols = P[:np.linalg.matrix_rank(A)]\nbasis = A[:, independent_cols]\nprint(basis)"
    },
    {
        "input": "Find a basis for the null space of the matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nnull_basis = null_space(A)\nprint(null_basis)"
    },
    {
        "input": "Find the dimension of the subspace of R^4 spanned by the vectors {(1, 0, 0, 0), (0, 1, 0, 0), (1, 1, 1, 1)}.",
        "output": "import numpy as np\nvectors = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [1, 1, 1, 1]])\nrank = np.linalg.matrix_rank(vectors)\nprint(rank)"
    },
    {
        "input": "Find a basis for the row space of matrix A = [[2, 4, 6], [1, 2, 3], [3, 6, 9]].",
        "output": "import numpy as np\nA = np.array([[2, 4, 6], [1, 2, 3], [3, 6, 9]])\nU, s, Vt = np.linalg.svd(A)\nrank = np.sum(s > 1e-10)\nbasis = Vt[:rank]\nprint(basis)"
    },
    {
        "input": "Find the coordinates of vector (3, 4, 5) relative to the basis {(1, 0, 0), (0, 1, 1), (0, 0, 1)}.",
        "output": "import numpy as np\nB = np.array([[1, 0, 0], [0, 1, 1], [0, 0, 1]])\nv = np.array([3, 4, 5])\ncoordinates = np.linalg.solve(B, v)\nprint(coordinates)"
    },
    {
        "input": "Find the orthogonal complement of the subspace spanned by {(1, 2, 3), (4, 5, 6)} in R^3.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nnull_space = Vt[rank:].T\nprint(null_space)"
    },
    {
        "input": "Find the dimension of the subspace of R^4 consisting of vectors (a, b, c, d) such that a + b + c + d = 0.",
        "output": "import numpy as np\nA = np.array([[1, 1, 1, 1]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\ndimension = A.shape[1] - rank\nprint(dimension)"
    },
    {
        "input": "Find the dimension of the solution space of the system Ax = 0, where A = [[1, 2, 3], [4, 5, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 2, 3], [4, 5, 6]])\nnull_space_A = null_space(A)\ndimension = null_space_A.shape[1]\nprint(dimension)"
    },
    {
        "input": "Find a basis for the subspace of R^4 spanned by the vectors {(1, 2, 3, 4), (2, 4, 6, 8), (3, 6, 9, 12), (4, 5, 6, 7)}.",
        "output": "import numpy as np\nvectors = np.array([[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12], [4, 5, 6, 7]])\nU, s, Vt = np.linalg.svd(vectors)\nrank = np.sum(s > 1e-10)\nbasis = Vt[:rank]\nprint(basis)"
    },
    {
        "input": "Find the rank of the matrix A = [[1, 2, 3, 4], [2, 4, 6, 8], [0, 0, 0, 0], [4, 5, 6, 7]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3, 4], [2, 4, 6, 8], [0, 0, 0, 0], [4, 5, 6, 7]])\nrank = np.linalg.matrix_rank(A)\nprint(rank)"
    },
    {
        "input": "Find a basis for the row space of matrix A = [[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12], [4, 5, 6, 7]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12], [4, 5, 6, 7]])\nU, s, Vt = np.linalg.svd(A)\nrank = np.sum(s > 1e-10)\nbasis = Vt[:rank]\nprint(basis)"
    },
    {
        "input": "Compute the orthogonal projection of vector v = [3, 4, 5] onto the subspace spanned by u = [1, 0, 0].",
        "output": "import numpy as np\nv = np.array([3, 4, 5])\nu = np.array([1, 0, 0])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the nullity of the matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nrank = np.linalg.matrix_rank(A)\nnullity = A.shape[1] - rank\nprint(nullity)"
    },
    {
        "input": "Compute the determinant of the matrix A = [[4, 3], [6, 3]].",
        "output": "import numpy as np\nA = np.array([[4, 3], [6, 3]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find the inverse of the matrix A = [[2, 1], [5, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [5, 3]])\nA_inv = np.linalg.inv(A)\nprint(A_inv)"
    },
    {
        "input": "Compute the characteristic polynomial of the matrix A = [[0, -1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\nchar_poly = np.poly(A)\nprint(char_poly)"
    },
    {
        "input": "Compute the Gram-Schmidt orthonormalization of the set of vectors {(1, 1, 0), (1, 0, 1), (0, 1, 1)} in R^3.",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    orthonormal_basis = []\n    for v in vectors:\n        w = v - sum(np.dot(v, b) * b for b in orthonormal_basis)\n        w = w / np.linalg.norm(w)\n        orthonormal_basis.append(w)\n    return np.array(orthonormal_basis)\nvectors = np.array([[1, 1, 0], [1, 0, 1], [0, 1, 1]])\northonormal_basis = gram_schmidt(vectors)\nprint(orthonormal_basis)"
    },
    {
        "input": "Find the singular value decomposition (SVD) of the matrix A = [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, s, Vt = np.linalg.svd(A)\nprint(U)\nprint(s)\nprint(Vt)"
    },
    {
        "input": "Determine the rank and nullity of the matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\nrank = np.linalg.matrix_rank(A)\nnullity = A.shape[1] - rank\nprint(rank)\nprint(nullity)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[4, -2], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[4, -2], [1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(eigenvalues)\nprint(eigenvectors)"
    },
    {
        "input": "Compute the Moore-Penrose pseudoinverse of the matrix A = [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\npseudoinverse = np.linalg.pinv(A)\nprint(pseudoinverse)"
    },
    {
        "input": "Find a basis for the null space of the matrix A = [[2, 4, 6], [1, 3, 5], [0, 0, 0]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[2, 4, 6], [1, 3, 5], [0, 0, 0]])\nnullspace = null_space(A)\nprint('Basis for the null space:')\nprint(nullspace)"
    },
    {
        "input": "Compute the determinant of the matrix A = [[3, 1, 4], [1, 5, 9], [2, 6, 5]].",
        "output": "import numpy as np\nA = np.array([[3, 1, 4], [1, 5, 9], [2, 6, 5]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find the angle between the vectors u = (1, 0, 0) and v = (0, 1, 0) in R^3.",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([0, 1, 0])\ncos_theta = np.dot(u, v) / (np.linalg.norm(u) * np.linalg.norm(v))\nangle_rad = np.arccos(cos_theta)\nangle_deg = np.degrees(angle_rad)\nprint(angle_rad)\nprint(angle_deg)"
    },
    {
        "input": "Find the dimension of the subspace spanned by the vectors {(1, 2, 3), (4, 5, 6), (7, 8, 9)} in R^3.",
        "output": "import numpy as np\nvectors = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nrank = np.linalg.matrix_rank(vectors)\nprint(rank)"
    },
    {
        "input": "Find the coordinates of the vector v = (3, 4, 5) relative to the basis B = {(1, 0, 0), (0, 1, 0), (0, 0, 1)}.",
        "output": "import numpy as np\nB = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\nv = np.array([3, 4, 5])\ncoordinates = np.linalg.solve(B.T, v)\nprint(coordinates)"
    },
    {
        "input": "Compute the determinant of the matrix A = [[1, 2, 3], [0, 1, 4], [0, 0, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [0, 1, 4], [0, 0, 1]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find a basis for the row space of the matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nbasis = Vt[:rank]\nprint(basis)"
    },
    {
        "input": "Compute the characteristic polynomial of the matrix A = [[2, -1], [-1, 2]].",
        "output": "import sympy as sp\nA = sp.Matrix([[2, -1], [-1, 2]])\nλ = sp.symbols('λ')\nchar_poly = A.charpoly(λ).as_expr()\nprint(char_poly)"
    },
    {
        "input": "Find the dimension of the subspace spanned by the vectors {(1, 0, 0), (0, 1, 0), (0, 0, 1), (1, 1, 1)} in R^3.",
        "output": "import numpy as np\nvectors = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1]])\nrank = np.linalg.matrix_rank(vectors)\nprint(rank)"
    },
    {
        "input": "Compute the rank of the matrix A = [[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12], [4, 8, 12, 16]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12], [4, 8, 12, 16]])\nrank = np.linalg.matrix_rank(A)\nprint(rank)"
    },
    {
        "input": "Find the coordinates of the vector v = (4, 5, 6) relative to the basis B = {(1, 0, 0), (0, 1, 0), (0, 0, 1)}.",
        "output": "import numpy as np\nB = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\nv = np.array([4, 5, 6])\ncoordinates = np.linalg.solve(B.T, v)\nprint(coordinates)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[3, 1], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(eigenvalues)\nprint(eigenvectors)"
    },
    {
        "input": "Compute the determinant of the matrix A = [[2, 3, 1], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[2, 3, 1], [4, 5, 6], [7, 8, 9]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find a basis for the row space of the matrix A = [[2, 4, 6], [1, 3, 5], [0, 0, 0]].",
        "output": "import numpy as np\nA = np.array([[2, 4, 6], [1, 3, 5], [0, 0, 0]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nbasis = Vt[:rank]\nprint(basis)"
    },
    {
        "input": "Find the projection of vector v = (3, 4, 5) onto the subspace spanned by {(1, 0, 0), (0, 1, 0)} in R^3.",
        "output": "import numpy as np\nv = np.array([3, 4, 5])\nB = np.array([[1, 0, 0], [0, 1, 0]])\nprojection = B.T @ np.linalg.inv(B @ B.T) @ B @ v\nprint(projection)"
    },
    {
        "input": "Find the null space of the matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.isclose(S, 0)]\nprint(null_space)"
    },
    {
        "input": "Compute the characteristic polynomial of the matrix A = [[2, -1], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[2, -1], [1, 3]])\nchar_poly = np.poly(A)\nprint(char_poly)"
    },
    {
        "input": "Find the orthonormal basis for the column space of the matrix A = [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nQ, R = np.linalg.qr(A)\nprint(Q)"
    },
    {
        "input": "Compute the singular value decomposition (SVD) of the matrix A = [[1, 2], [3, 4], [5, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nprint(U)\nprint(S)\nprint(Vt)"
    },
    {
        "input": "Find the coordinates of the vector v = (2, -1, 3) relative to the basis B = {(1, 0, 1), (0, 1, 1), (1, 1, 0)}.",
        "output": "import numpy as np\nB = np.array([[1, 0, 1], [0, 1, 1], [1, 1, 0]]).T\nv = np.array([2, -1, 3])\ncoordinates = np.linalg.solve(B, v)\nprint(coordinates)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[0, -1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(eigenvalues)\nprint(eigenvectors)"
    },
    {
        "input": "Find the magnitude of the vector v = (3, 4).",
        "output": "import numpy as np\nv = np.array([3, 4])\nmagnitude = np.linalg.norm(v)\nprint(magnitude)"
    },
    {
        "input": "Compute the dot product of vectors u = (1, 2, 3) and v = (4, 5, 6).",
        "output": "import numpy as np\nu = np.array([1, 2, 3])\nv = np.array([4, 5, 6])\ndot_product = np.dot(u, v)\nprint(dot_product)"
    },
    {
        "input": "Find the angle between vectors u = (1, 2) and v = (2, 3).",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([2, 3])\ncos_theta = np.dot(u, v) / (np.linalg.norm(u) * np.linalg.norm(v))\nangle = np.arccos(cos_theta)\nprint(angle)"
    },
    {
        "input": "Compute the cross product of vectors u = (1, 0, 0) and v = (0, 1, 0).",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([0, 1, 0])\ncross_product = np.cross(u, v)\nprint(cross_product)"
    },
    {
        "input": "Find the projection of vector v = (3, 4, 5) onto vector u = (1, 0, 0).",
        "output": "import numpy as np\nv = np.array([3, 4, 5])\nu = np.array([1, 0, 0])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Compute the determinant of the matrix A = [[1, 2], [3, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ndeterminant = np.linalg.det(A)\nprint(determinant)"
    },
    {
        "input": "Find the inverse of the matrix A = [[1, 2], [3, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nA_inv = np.linalg.inv(A)\nprint(A_inv)"
    },
    {
        "input": "Solve the system of equations: x + y = 2, 2x + 3y = 5.",
        "output": "import numpy as np\nA = np.array([[1, 1], [2, 3]])\nb = np.array([2, 5])\nsolution = np.linalg.solve(A, b)\nprint(solution)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[2, -1], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[2, -1], [1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(eigenvalues)\nprint(eigenvectors)"
    },
    {
        "input": "Find the unit vector in the direction of v = (6, 8).",
        "output": "import numpy as np\nv = np.array([6, 8])\nunit_vector = v / np.linalg.norm(v)\nprint(unit_vector)"
    },
    {
        "input": "Compute the outer product of vectors u = (1, 2) and v = (3, 4).",
        "output": "import numpy as np\nu = np.array([1, 2])\nv = np.array([3, 4])\nouter_product = np.outer(u, v)\nprint(outer_product)"
    },
    {
        "input": "Find the area of the parallelogram formed by vectors u = (1, 0, 0) and v = (0, 1, 0).",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([0, 1, 0])\nparallelogram_area = np.linalg.norm(np.cross(u, v))\nprint(parallelogram_area)"
    },
    {
        "input": "Compute the Gram matrix for the set of vectors u = (1, 0), v = (1, 1), and w = (0, 1).",
        "output": "import numpy as np\nu = np.array([1, 0])\nv = np.array([1, 1])\nw = np.array([0, 1])\nvectors = np.array([u, v, w])\ngram_matrix = np.dot(vectors, vectors.T)\nprint(gram_matrix)"
    },
    {
        "input": "Find the null space of the matrix A = [[1, 2], [2, 4], [3, 6]].",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.array([[1, 2], [2, 4], [3, 6]])\nnull_space_A = null_space(A)\nprint(null_space_A)"
    },
    {
        "input": "Find the change of basis matrix from the standard basis to the basis B = {(1, 1), (1, -1)}.",
        "output": "import numpy as np\nB = np.array([[1, 1], [1, -1]])\nchange_of_basis_matrix = np.linalg.inv(B)\nprint(change_of_basis_matrix)"
    },
    {
        "input": "Compute the trace of the matrix A = [[5, 2], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[5, 2], [1, 3]])\ntrace = np.trace(A)\nprint(trace)"
    },
    {
        "input": "Find the characteristic polynomial of the matrix A = [[2, -1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1], [1, 2]])\nchar_poly_coeffs = np.poly(A)\nprint(char_poly_coeffs)"
    },
    {
        "input": "Find the rank and nullity of the matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nrank = np.linalg.matrix_rank(A)\nnullity = A.shape[1] - rank\nprint(rank)\nprint(nullity)"
    },
    {
        "input": "Find the least squares solution to the system Ax = b, where A = [[1, 1], [1, -1], [2, 0]] and b = [3, 1, 2].",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, -1], [2, 0]])\nb = np.array([3, 1, 2])\nleast_squares_solution = np.linalg.lstsq(A, b, rcond=None)[0]\nprint(least_squares_solution)"
    },
    {
        "input": "Compute the determinant of the matrix A = [[2, 3, 1], [4, 1, -3], [3, 4, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 3, 1], [4, 1, -3], [3, 4, 2]])\ndeterminant = np.linalg.det(A)\nprint(determinant)"
    },
    {
        "input": "Find the inverse of the matrix A = [[2, 3], [1, 4]].",
        "output": "import numpy as np\nA = np.array([[2, 3], [1, 4]])\nA_inv = np.linalg.inv(A)\nprint(A_inv)"
    },
    {
        "input": "Solve the system of equations: x + 2y + z = 6, 2x + y + 3z = 14, 3x + 4y + 5z = 26.",
        "output": "import numpy as np\nA = np.array([[1, 2, 1], [2, 1, 3], [3, 4, 5]])\nb = np.array([6, 14, 26])\nsolution = np.linalg.solve(A, b)\nprint(solution)"
    },
    {
        "input": "Compute the angle between vectors u = (1, 0, 0) and v = (0, 1, 0) in degrees.",
        "output": "import numpy as np\nu = np.array([1, 0, 0])\nv = np.array([0, 1, 0])\ncos_theta = np.dot(u, v) / (np.linalg.norm(u) * np.linalg.norm(v))\nangle = np.arccos(cos_theta) * (180 / np.pi)\nprint(angle, 'degrees')"
    },
    {
        "input": "Compute the determinant of the matrix A = [[1, 2, 3], [0, 1, 4], [5, 6, 0]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [0, 1, 4], [5, 6, 0]])\ndeterminant = np.linalg.det(A)\nprint(determinant)"
    },
    {
        "input": "Find the inverse of the matrix A = [[4, 7], [2, 6]].",
        "output": "import numpy as np\nA = np.array([[4, 7], [2, 6]])\nA_inv = np.linalg.inv(A)\nprint(A_inv)"
    },
    {
        "input": "Solve the system of equations: x + 2y + 3z = 6, 2x + y + 4z = 8, 3x + 4y + 5z = 10.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 1, 4], [3, 4, 5]])\nb = np.array([6, 8, 10])\nsolution = np.linalg.solve(A, b)\nprint(solution)"
    },
    {
        "input": "Find a basis for the subspace W = span{(1, 2, 3), (4, 5, 6)} in R³.",
        "output": "import numpy as np\nv1 = np.array([1, 2, 3])\nv2 = np.array([4, 5, 6])\nA = np.vstack([v1, v2])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nbasis = Vt[:rank]\nprint(basis)"
    },
    {
        "input": "Determine the dimension of the subspace W = {(x, y, z, w) ∈ R⁴ | x + y + z + w = 0 and x - y + z - w = 0}.",
        "output": "import numpy as np\nA = np.array([[1, 1, 1, 1], [1, -1, 1, -1]])\nrank = np.linalg.matrix_rank(A)\ndimension = 4 - rank\nprint(dimension)"
    },
    {
        "input": "Find the intersection of subspaces W₁ = span{(1, 0, 0), (0, 1, 0)} and W₂ = span{(0, 1, 0), (0, 0, 1)} in R³.",
        "output": "import numpy as np\nfrom scipy.linalg import null_space\nW1 = np.array([[1, 0, 0], [0, 1, 0]])\nW2 = np.array([[0, 1, 0], [0, 0, 1]])\nQ1, _ = np.linalg.qr(W1.T)\nQ2, _ = np.linalg.qr(W2.T)\nA = np.hstack([Q1, -Q2])\nns = null_space(A)\nintersection_basis = Q1 @ ns[:Q1.shape[1], :]\nprint(intersection_basis.T)"
    },
    {
        "input": "Find the dimension of the subspace of R^4 defined by x + y + z + w = 0 and x - y + z - w = 0.",
        "output": "import numpy as np\nA = np.array([[1, 1, 1, 1], [1, -1, 1, -1]])\nrank = np.linalg.matrix_rank(A)\ndimension = 4 - rank\nprint(dimension)"
    },
    {
        "input": "Find the inner product of u = (3, -1, 2) and v = (-1, 4, 0).",
        "output": "import numpy as np\nu = np.array([3, -1, 2])\nv = np.array([-1, 4, 0])\ninner_product = np.dot(u, v)\nprint(inner_product)"
    },
    {
        "input": "Find the orthogonal projection of v = (4, 2, -3) onto u = (1, 1, 1).",
        "output": "import numpy as np\nv = np.array([4, 2, -3])\nu = np.array([1, 1, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the matrix representation of the linear transformation T(x, y, z) = (x + y, y - z, z + x).",
        "output": "import numpy as np\nT = np.array([[1, 1, 0], [0, 1, -1], [1, 0, 1]])\nprint(T)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of A = [[0, -1], [1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(eigenvalues)\nprint(eigenvectors)"
    },
    {
        "input": "Compute the Gram-Schmidt process for the vectors v1 = (1, 1, 0), v2 = (1, 0, 1).",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    basis = []\n    for v in vectors:\n        v = v.astype(float)\n        for u in basis:\n            v -= np.dot(v, u) / np.dot(u, u) * u\n        norm = np.linalg.norm(v)\n        if norm > 1e-10:\n            basis.append(v / norm)\n    return np.array(basis)\nvectors = np.array([[1, 1, 0], [1, 0, 1]], dtype=float)\northonormal_basis = gram_schmidt(vectors)\nprint(orthonormal_basis)"
    },
    {
        "input": "Find the rank and nullity of the transformation given by matrix A = [[2, 3, 5], [4, 6, 10], [1, -1, 0]].",
        "output": "import numpy as np\nA = np.array([[2, 3, 5], [4, 6, 10], [1, -1, 0]])\nrank = np.linalg.matrix_rank(A)\nnullity = A.shape[1] - rank\nprint(\"Rank:\", rank, \"Nullity:\", nullity)"
    },
    {
        "input": "Find the dimension of the span of the vectors v1 = (1, 2, 3), v2 = (4, 5, 6), v3 = (7, 8, 9).",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nspan_dim = np.linalg.matrix_rank(A)\nprint(span_dim)"
    },
    {
        "input": "Compute the orthonormal basis using Gram-Schmidt for vectors v1 = (1,1,0), v2 = (1,0,1), v3 = (0,1,1).",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    basis = []\n    for v in vectors:\n        v = v.astype(float)\n        for u in basis:\n            v -= np.dot(v, u) / np.dot(u, u) * u\n        norm = np.linalg.norm(v)\n        if norm > 1e-10:\n            basis.append(v / norm)\n    return np.array(basis)\nvectors = np.array([[1,1,0], [1,0,1], [0,1,1]], dtype=float)\northonormal_basis = gram_schmidt(vectors)\nprint(orthonormal_basis)"
    },
    {
        "input": "Find the eigenvalues of the transformation T(x, y) = (3x - y, x + 2y).",
        "output": "import numpy as np\nA = np.array([[3, -1], [1, 2]])\neigenvalues, _ = np.linalg.eig(A)\nprint(eigenvalues)"
    },
    {
        "input": "Find the coordinates of v = (3, 1) in the basis B = {(1,2), (2,3)}.",
        "output": "import numpy as np\nB = np.array([[1, 2], [2, 3]])\nv = np.array([3, 1])\ncoordinates = np.linalg.solve(B, v)\nprint(coordinates)"
    },
    {
        "input": "Find the projection of v = (3, 4, 5) onto the subspace spanned by u = (1, 1, 1).",
        "output": "import numpy as np\nv = np.array([3, 4, 5])\nu = np.array([1, 1, 1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the inverse of the matrix A = [[1, 2, 3], [0, 1, 4], [5, 6, 0]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [0, 1, 4], [5, 6, 0]])\nA_inv = np.linalg.inv(A)\nprint(A_inv)"
    },
    {
        "input": "Find the determinant of the linear transformation represented by A = [[2, -1, 0], [1, 3, -2], [0, 1, 4]].",
        "output": "import numpy as np\nA = np.array([[2, -1, 0], [1, 3, -2], [0, 1, 4]])\ndet_A = np.linalg.det(A)\nprint(det_A)"
    },
    {
        "input": "Find the dimension of the subspace spanned by the vectors {(1,0,1), (2,1,3), (3,2,4)}.",
        "output": "import numpy as np\nA = np.array([[1,0,1], [2,1,3], [3,2,4]])\ndimension = np.linalg.matrix_rank(A)\nprint(dimension)"
    },
    {
        "input": "Find the coordinates of v = (4,5,6) in the basis B = {(1,0,0), (0,1,1), (1,1,0)}.",
        "output": "import numpy as np\nB = np.array([[1,0,0], [0,1,1], [1,1,0]])\nv = np.array([4,5,6])\ncoordinates = np.linalg.solve(B, v)\nprint(coordinates)"
    },
    {
        "input": "Compute the rank and nullity of the matrix A = [[1, 2, 3], [2, 4, 6], [1, -1, 0]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 4, 6], [1, -1, 0]])\nrank = np.linalg.matrix_rank(A)\nnullity = A.shape[1] - rank\nprint(\"Rank:\", rank, \"Nullity:\", nullity)"
    },
    {
        "input": "Find an orthonormal basis for the span of {(1,2,3), (4,5,6)} using Gram-Schmidt.",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    basis = []\n    for v in vectors:\n        v = v.astype(float)\n        for u in basis:\n            v -= np.dot(v, u) / np.dot(u, u) * u\n        norm = np.linalg.norm(v)\n        if norm > 1e-10:\n            basis.append(v / norm)\n    return np.array(basis)\nvectors = np.array([[1, 2, 3], [4, 5, 6]], dtype=float)\northonormal_basis = gram_schmidt(vectors)\nprint(orthonormal_basis)"
    },
    {
        "input": "Compute the projection of v = (3,4,5) onto the subspace spanned by w = (1,1,1).",
        "output": "import numpy as np\nv = np.array([3,4,5])\nw = np.array([1,1,1])\nprojection = (np.dot(v, w) / np.dot(w, w)) * w\nprint(projection)"
    },
    {
        "input": "Find the dimension of the subspace spanned by {(1,2,1,0), (2,4,2,0), (3,6,3,1)} in R⁴.",
        "output": "import numpy as np\nA = np.array([[1,2,1,0], [2,4,2,0], [3,6,3,1]])\ndimension = np.linalg.matrix_rank(A)\nprint(dimension)"
    },
    {
        "input": "Find an orthonormal basis for the span of {(1,2,3,4), (2,3,4,5)} using Gram-Schmidt.",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    basis = []\n    for v in vectors:\n        v = v.astype(float)\n        for u in basis:\n            v -= np.dot(v, u) / np.dot(u, u) * u\n        norm = np.linalg.norm(v)\n        if norm > 1e-10:\n            basis.append(v / norm)\n    return np.array(basis)\nvectors = np.array([[1, 2, 3, 4], [2, 3, 4, 5]], dtype=float)\northonormal_basis = gram_schmidt(vectors)\nprint(orthonormal_basis)"
    },
    {
        "input": "Find the rank and nullity of A = [[1,2,3],[2,4,6],[3,5,7]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [2,4,6], [3,5,7]])\nrank = np.linalg.matrix_rank(A)\nnullity = A.shape[1] - rank\nprint(\"Rank:\", rank, \"Nullity:\", nullity)"
    },
    {
        "input": "Find the matrix representation of T: R² → R², where T(x, y) = (x + y, x - y).",
        "output": "import numpy as np\nT_matrix = np.array([[1,1], [1,-1]])\nprint(T_matrix)"
    },
    {
        "input": "Compute the Gram-Schmidt process for the set {(1,1,0), (1,0,1), (0,1,1)}.",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    basis = []\n    for v in vectors:\n        v = v.astype(float)\n        for u in basis:\n            v -= np.dot(v, u) / np.dot(u, u) * u\n        norm = np.linalg.norm(v)\n        if norm > 1e-10:\n            basis.append(v / norm)\n    return np.array(basis)\nvectors = np.array([[1, 1, 0], [1, 0, 1], [0, 1, 1]], dtype=float)\northonormal_basis = gram_schmidt(vectors)\nprint(orthonormal_basis)"
    },
    {
        "input": "Find the rank and nullity of the transformation T: R³ → R² given by T(x,y,z) = (x+y, y+z).",
        "output": "import numpy as np\nA = np.array([[1, 1, 0], [0, 1, 1]])\nrank = np.linalg.matrix_rank(A)\nnullity = A.shape[1] - rank\nprint(\"Rank:\", rank, \"Nullity:\", nullity)"
    },
    {
        "input": "Find the coordinates of v = (3,5,7) in the basis B = {(1,1,0), (0,1,1), (1,0,1)}.",
        "output": "import numpy as np\nB = np.array([[1,1,0], [0,1,1], [1,0,1]])\nv = np.array([3,5,7])\ncoordinates = np.linalg.solve(B, v)\nprint(coordinates)"
    },
    {
        "input": "Find an orthonormal basis for the subspace spanned by {(1,2,1), (3,4,1)}.",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    basis = []\n    for v in vectors:\n        v = v.astype(float)\n        for u in basis:\n            v -= np.dot(v, u) / np.dot(u, u) * u\n        norm = np.linalg.norm(v)\n        if norm > 1e-10:\n            basis.append(v / norm)\n    return np.array(basis)\nvectors = np.array([[1, 2, 1], [3, 4, 1]], dtype=float)\northonormal_basis = gram_schmidt(vectors)\nprint(orthonormal_basis)"
    },
    {
        "input": "Find the matrix representation of the linear transformation T(x, y) = (x + 2y, 3x - y) in standard basis.",
        "output": "import numpy as np\nT_matrix = np.array([[1,2], [3,-1]])\nprint(T_matrix)"
    },
    {
        "input": "Find the eigenvalues of the linear transformation T given by the matrix [[2,1], [1,2]].",
        "output": "import numpy as np\nA = np.array([[2,1], [1,2]])\neigenvalues = np.linalg.eigvals(A)\nprint(eigenvalues)"
    },
    {
        "input": "Find the rank and nullity of the transformation T: R³ → R² given by T(x,y,z) = (x+2y, 3y+z).",
        "output": "import numpy as np\nA = np.array([[1, 2, 0], [0, 3, 1]])\nrank = np.linalg.matrix_rank(A)\nnullity = A.shape[1] - rank\nprint(\"Rank:\", rank, \"Nullity:\", nullity)"
    },
    {
        "input": "Find the orthogonal projection of v = (3,4,5) onto the subspace spanned by (1,1,1).",
        "output": "import numpy as np\ndef projection(v, u):\n    return (np.dot(v, u) / np.dot(u, u)) * u\nv = np.array([3,4,5])\nu = np.array([1,1,1])\nproj_v = projection(v, u)\nprint(proj_v)"
    },
    {
        "input": "Find the dimension of the null space of A = [[1,2,3,4], [2,4,6,8]].",
        "output": "import numpy as np\nA = np.array([[1,2,3,4], [2,4,6,8]])\nrank = np.linalg.matrix_rank(A)\nnullity = A.shape[1] - rank\nprint(nullity)"
    },
    {
        "input": "Compute the determinant of the matrix representing the linear transformation T(x,y,z) = (x+y, 2y+z, x+z).",
        "output": "import numpy as np\nA = np.array([[1,1,0], [0,2,1], [1,0,1]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find the inverse of the transformation matrix [[1,2], [3,4]], if it exists.",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\nif np.linalg.det(A) != 0:\n    A_inv = np.linalg.inv(A)\n    print(A_inv)\nelse:\n    print('Matrix is not invertible.')"
    },
    {
        "input": "Compute the angle between the vectors (2,3) and (4,5) using the inner product.",
        "output": "import numpy as np\nv1 = np.array([2,3])\nv2 = np.array([4,5])\ndot_product = np.dot(v1, v2)\nnorms = np.linalg.norm(v1) * np.linalg.norm(v2)\nangle = np.arccos(dot_product / norms)\nprint(angle)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the transformation matrix [[3,1], [1,3]].",
        "output": "import numpy as np\nA = np.array([[3,1], [1,3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(eigenvalues)\nprint(eigenvectors)"
    },
    {
        "input": "Find the matrix representation of the linear transformation T: R² → R² defined by T(x,y) = (x + y, 2x - y).",
        "output": "import numpy as np\nT_matrix = np.array([[1,1], [2,-1]])\nprint(T_matrix)"
    },
    {
        "input": "Find an orthonormal basis for the span of {(1,2), (3,4)}.",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    basis = []\n    for v in vectors:\n        v = v.astype(float)\n        for u in basis:\n            v -= np.dot(v, u) / np.dot(u, u) * u\n        norm = np.linalg.norm(v)\n        if norm > 1e-10:\n            basis.append(v / norm)\n    return np.array(basis)\nvectors = np.array([[1, 2], [3, 4]], dtype=float)\northonormal_basis = gram_schmidt(vectors)\nprint(orthonormal_basis)"
    },
    {
        "input": "Find the rank of A = [[1,2,3], [4,5,6], [7,8,9]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\nrank = np.linalg.matrix_rank(A)\nprint(rank)"
    },
    {
        "input": "Compute the orthonormal basis for the subspace spanned by {(2,2,1), (1,0,1)} using Gram-Schmidt process.",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    basis = []\n    for v in vectors:\n        v = v.astype(float)\n        for u in basis:\n            v -= np.dot(v, u) / np.dot(u, u) * u\n        norm = np.linalg.norm(v)\n        if norm > 1e-10:\n            basis.append(v / norm)\n    return np.array(basis)\nvectors = np.array([[2, 2, 1], [1, 0, 1]], dtype=float)\northonormal_basis = gram_schmidt(vectors)\nprint(orthonormal_basis)"
    },
    {
        "input": "Find the rank of the transformation matrix T: R³ → R³ given by T(x,y,z) = (x+y, y+z, x-z).",
        "output": "import numpy as np\nA = np.array([[1,1,0], [0,1,1], [1,0,-1]])\nrank = np.linalg.matrix_rank(A)\nprint(rank)"
    },
    {
        "input": "Find the determinant of the linear transformation matrix for T(x,y,z) = (x+2y, 2x+3y, y+z).",
        "output": "import numpy as np\nA = np.array([[1,2,0], [2,3,0], [0,1,1]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find the least squares solution to Ax = b where A = [[1,1], [2,3], [3,5]] and b = [3,7,11].",
        "output": "import numpy as np\nA = np.array([[1,1], [2,3], [3,5]])\nb = np.array([3,7,11])\nx_ls = np.linalg.lstsq(A, b, rcond=None)[0]\nprint(x_ls)"
    },
    {
        "input": "Find the matrix representation of the linear transformation T: R² → R² defined by T(x,y) = (x - y, 2x + 3y).",
        "output": "import numpy as np\nT_matrix = np.array([[1,-1], [2,3]])\nprint(T_matrix)"
    },
    {
        "input": "Find the rank of A = [[1,2,3,4], [0,1,2,3], [0,0,1,2]].",
        "output": "import numpy as np\nA = np.array([[1,2,3,4], [0,1,2,3], [0,0,1,2]])\nrank = np.linalg.matrix_rank(A)\nprint(rank)"
    },
    {
        "input": "Find the nullity of A = [[1,0,0], [0,1,0], [0,0,0]].",
        "output": "import numpy as np\nA = np.array([[1,0,0], [0,1,0], [0,0,0]])\nrank = np.linalg.matrix_rank(A)\nnullity = A.shape[1] - rank\nprint(nullity)"
    },
    {
        "input": "Find the dimension of the vector space of all 2×2 upper triangular matrices.",
        "output": "import sympy as sp\nA = sp.Matrix([[sp.Symbol('a'), sp.Symbol('b')], [0, sp.Symbol('c')]])\ndim = len(A.free_symbols)\nprint(dim)"
    },
    {
        "input": "Find the orthonormal basis for the column space of A = [[3,1], [4,2], [0,1]] using Gram-Schmidt.",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    basis = []\n    for v in vectors:\n        v = v.astype(float)\n        for u in basis:\n            v -= np.dot(v, u) / np.dot(u, u) * u\n        norm = np.linalg.norm(v)\n        if norm > 1e-10:\n            basis.append(v / norm)\n    return np.array(basis)\nA = np.array([[3,1], [4,2], [0,1]], dtype=float)\nvectors = A.T\northonormal_basis = gram_schmidt(vectors.T)\nprint(orthonormal_basis)"
    },
    {
        "input": "Compute the rank-nullity of the transformation T(x,y,z) = (x+y, y-z, 2x+3y).",
        "output": "import numpy as np\nA = np.array([[1, 1, 0], [0, 1, -1], [2, 3, 0]])\nrank = np.linalg.matrix_rank(A)\nnullity = A.shape[1] - rank\nprint(\"Rank:\", rank, \"Nullity:\", nullity)"
    },
    {
        "input": "Find the eigenvalues of the matrix A = [[2,1], [1,2]].",
        "output": "import numpy as np\nA = np.array([[2,1], [1,2]])\neigenvalues = np.linalg.eigvals(A)\nprint(eigenvalues)"
    },
    {
        "input": "Find the determinant of the transformation matrix T: ℝ³ → ℝ³ given by T(x,y,z) = (x+2y, y+z, x−z).",
        "output": "import numpy as np\nA = np.array([[1,2,0], [0,1,1], [1,0,-1]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Compute the dot product of vectors u = (2,3,4) and v = (1,0,-1).",
        "output": "import numpy as np\nu = np.array([2,3,4])\nv = np.array([1,0,-1])\ndot_product = np.dot(u, v)\nprint(dot_product)"
    },
    {
        "input": "Find the angle between the vectors (3,4) and (5,12).",
        "output": "import numpy as np\nu = np.array([3,4])\nv = np.array([5,12])\ndot_product = np.dot(u, v)\nnorm_u = np.linalg.norm(u)\nnorm_v = np.linalg.norm(v)\nangle = np.arccos(dot_product / (norm_u * norm_v))\nprint(angle)"
    },
    {
        "input": "Find the dimension of the space spanned by {(1,0,0,1), (0,1,0,1), (0,0,1,1)} in R⁴.",
        "output": "import numpy as np\nA = np.array([[1,0,0,1], [0,1,0,1], [0,0,1,1]])\nrank = np.linalg.matrix_rank(A)\nprint(rank)"
    },
    {
        "input": "Find the determinant of the transformation matrix T: R² → R² defined by T(x,y) = (2x + y, x - 3y).",
        "output": "import numpy as np\nA = np.array([[2,1], [1,-3]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find the standard matrix for the linear transformation T: R² → R² where T rotates vectors by 90 degrees counterclockwise.",
        "output": "import numpy as np\ntheta = np.pi / 2\nrotation_matrix = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])\nprint(rotation_matrix)"
    },
    {
        "input": "Find the orthonormal basis of the subspace spanned by {(1,1), (1,-1)} using Gram-Schmidt.",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    basis = []\n    for v in vectors:\n        v = v.astype(float)\n        for u in basis:\n            v -= np.dot(v, u) / np.dot(u, u) * u\n        norm = np.linalg.norm(v)\n        if norm > 1e-10:\n            basis.append(v / norm)\n    return np.array(basis)\nvectors = np.array([[1, 1], [1, -1]], dtype=float)\northonormal_basis = gram_schmidt(vectors)\nprint(orthonormal_basis)"
    },
    {
        "input": "Find the eigenvectors of the matrix A = [[3,1], [1,3]].",
        "output": "import numpy as np\nA = np.array([[3,1], [1,3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(eigenvectors)"
    },
    {
        "input": "Determine the dimension of the subspace of R³ spanned by {(1,2,3), (2,4,6)}.",
        "output": "import numpy as np\nA = np.array([[1,2,3], [2,4,6]])\nrank = np.linalg.matrix_rank(A)\nprint(rank)"
    },
    {
        "input": "Find the transition matrix from basis B = {(1,1), (1,-1)} to standard basis.",
        "output": "import numpy as np\nB = np.array([[1,1], [1,-1]])\nP = np.linalg.inv(B)\nprint(P)"
    },
    {
        "input": "Find the determinant of the transformation matrix for T(x,y) = (2x + y, -x + 3y).",
        "output": "import numpy as np\nA = np.array([[2,1], [-1,3]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find an orthonormal basis for the space spanned by {(1,1,0), (1,0,1)} using Gram-Schmidt.",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    basis = []\n    for v in vectors:\n        v = v.astype(float).copy()\n        for u in basis:\n            v = v - np.dot(v, u) / np.dot(u, u) * u\n        norm = np.linalg.norm(v)\n        if norm > 1e-10:\n            basis.append(v / norm)\n    return np.array(basis)\nvectors = np.array([[1,1,0], [1,0,1]], dtype=float)\northonormal_basis = gram_schmidt(vectors)\nprint(orthonormal_basis)"
    },
    {
        "input": "Find the rank of the matrix A = [[1,2,3], [4,5,6], [7,8,9]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\nrank = np.linalg.matrix_rank(A)\nprint(rank)"
    },
    {
        "input": "Find the determinant of the change of basis matrix from B = {(1,2), (2,4)} to the standard basis.",
        "output": "import numpy as np\nB = np.array([[1,2], [2,4]])\ndet = np.linalg.det(B)\nprint(det)"
    },
    {
        "input": "Find a vector orthogonal to both (1,2,3) and (4,5,6).",
        "output": "import numpy as np\nu = np.array([1,2,3])\nv = np.array([4,5,6])\northogonal_vector = np.cross(u, v)\nprint(orthogonal_vector)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of A = [[2,0,0], [0,3,0], [0,0,4]].",
        "output": "import numpy as np\nA = np.array([[2,0,0], [0,3,0], [0,0,4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(eigenvalues, 'Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the angle between the vectors (1,2,3) and (4,5,6).",
        "output": "import numpy as np\nu = np.array([1,2,3])\nv = np.array([4,5,6])\ndot_product = np.dot(u, v)\nnorm_u = np.linalg.norm(u)\nnorm_v = np.linalg.norm(v)\nangle = np.arccos(dot_product / (norm_u * norm_v))\nprint(angle)"
    },
    {
        "input": "Find the trace of the matrix A = [[1,2,3], [4,5,6], [7,8,9]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\ntrace = np.trace(A)\nprint(trace)"
    },
    {
        "input": "Find the least-squares solution to Ax=b where A = [[1,1], [1,-1]], b = [3,1].",
        "output": "import numpy as np\nA = np.array([[1,1], [1,-1]])\nb = np.array([3,1])\nleast_squares_solution = np.linalg.lstsq(A, b, rcond=None)[0]\nprint(least_squares_solution)"
    },
    {
        "input": "Find the orthogonal projection of v = (3,4,5) onto the vector u = (1,2,2).",
        "output": "import numpy as np\nv = np.array([3,4,5])\nu = np.array([1,2,2])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the matrix representation of T(x,y) = (2x + y, x - y) in the standard basis.",
        "output": "import numpy as np\nA = np.array([[2,1], [1,-1]])\nprint(A)"
    },
    {
        "input": "Find the rank and nullity of the matrix A = [[1,2,3], [4,5,6], [7,8,9]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\nrank = np.linalg.matrix_rank(A)\nnullity = A.shape[1] - rank\nprint(\"Rank:\", rank, \"Nullity:\", nullity)"
    },
    {
        "input": "Find the eigenvalues of A = [[0,1], [-2,-3]].",
        "output": "import numpy as np\nA = np.array([[0,1], [-2,-3]])\neigenvalues = np.linalg.eigvals(A)\nprint(eigenvalues)"
    },
    {
        "input": "Find the least squares solution to Ax=b where A = [[1,2], [3,4]], b = [5,6].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\nb = np.array([5,6])\nx = np.linalg.lstsq(A, b, rcond=None)[0]\nprint(x)"
    },
    {
        "input": "Compute the Gram-Schmidt process for vectors {(1,2,2), (2,4,5)}.",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    basis = []\n    for v in vectors:\n        v = v.astype(float).copy()\n        for u in basis:\n            v = v - np.dot(v, u) / np.dot(u, u) * u\n        norm = np.linalg.norm(v)\n        if norm > 1e-10:\n            basis.append(v / norm)\n    return np.array(basis)\nvectors = np.array([[1, 2, 2], [2, 4, 5]], dtype=float)\northonormal_basis = gram_schmidt(vectors)\nprint(orthonormal_basis)"
    },
    {
        "input": "Find the determinant of the transition matrix from basis B = {(2,3), (3,5)} to standard basis.",
        "output": "import numpy as np\nB = np.array([[2,3], [3,5]])\ndet = np.linalg.det(B)\nprint(det)"
    },
    {
        "input": "Find an orthogonal basis for the column space of A = [[1,2], [3,4]].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\nQ, R = np.linalg.qr(A)\nprint(Q)"
    },
    {
        "input": "Find the angle between the vectors (2,3,4) and (1,0,0).",
        "output": "import numpy as np\nu = np.array([2,3,4])\nv = np.array([1,0,0])\ndot_product = np.dot(u, v)\nnorm_u = np.linalg.norm(u)\nnorm_v = np.linalg.norm(v)\nangle = np.arccos(dot_product / (norm_u * norm_v))\nprint(angle)"
    },
    {
        "input": "Find the trace of A = [[1,2,3], [4,5,6], [7,8,9]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\ntrace = np.trace(A)\nprint(trace)"
    },
    {
        "input": "Find the spectral decomposition of A = [[4,0], [0,9]].",
        "output": "import numpy as np\nA = np.array([[4,0], [0,9]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nP_inv = np.linalg.inv(P)\nreconstructed_A = P @ D @ P_inv\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", P)\nprint(\"Spectral Decomposition (P D P⁻¹):\\n\", reconstructed_A)"
    },
    {
        "input": "Find the best approximation to b = [1,2] in the column space of A = [[2,3], [4,5]].",
        "output": "import numpy as np\nA = np.array([[2,3], [4,5]])\nb = np.array([1,2])\nprojection = A @ np.linalg.pinv(A) @ b\nprint(projection)"
    },
    {
        "input": "Find the determinant of the Gram matrix of the vectors {(1,0,1), (0,1,1)}.",
        "output": "import numpy as np\nV = np.array([[1,0,1], [0,1,1]])\nG = V @ V.T\ndet = np.linalg.det(G)\nprint(det)"
    },
    {
        "input": "Find the eigenvalues of the matrix A = [[1,2,3], [0,1,4], [0,0,2]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [0,1,4], [0,0,2]])\neigenvalues = np.linalg.eigvals(A)\nprint(eigenvalues)"
    },
    {
        "input": "Compute the change of basis matrix from B = {(1,1), (1,-1)} to the standard basis.",
        "output": "import numpy as np\nB = np.array([[1,1], [1,-1]])\nP = np.linalg.inv(B)\nprint(P)"
    },
    {
        "input": "Find the singular value decomposition (SVD) of A = [[1,2], [3,4], [5,6]].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4], [5,6]])\nU, S, Vt = np.linalg.svd(A)\nprint(U, '\\nSingular values:', S, '\\nV^T:', Vt)"
    },
    {
        "input": "Find the determinant of the Gram matrix of vectors {(1,2), (2,3)}.",
        "output": "import numpy as np\nV = np.array([[1,2], [2,3]])\nG = V @ V.T\ndet = np.linalg.det(G)\nprint(det)"
    },
    {
        "input": "Compute the norm of the vector v = (3,4,12) in R³.",
        "output": "import numpy as np\nv = np.array([3,4,12])\nnorm = np.linalg.norm(v)\nprint(norm)"
    },
    {
        "input": "Find the coordinate vector of v = (5,3) with respect to the basis B = {(2,1), (1,1)}.",
        "output": "import numpy as np\nB = np.array([[2,1], [1,1]])\nv = np.array([5,3])\ncoordinates = np.linalg.solve(B, v)\nprint(coordinates)"
    },
    {
        "input": "Find the best approximation to b = (2,3) in the subspace spanned by {(1,1)}.",
        "output": "import numpy as np\nb = np.array([2,3])\nv = np.array([1,1])\nprojection = (np.dot(b, v) / np.dot(v, v)) * v\nprint(projection)"
    },
    {
        "input": "Find the angle between the vectors (1,2) and (3,4).",
        "output": "import numpy as np\nv1 = np.array([1,2])\nv2 = np.array([3,4])\ncos_theta = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\nangle = np.arccos(cos_theta)\nprint(angle)"
    },
    {
        "input": "Find the orthonormal basis using Gram-Schmidt for vectors {(1,1,1), (1,2,3)}.",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    basis = []\n    for v in vectors:\n        v = v.astype(float).copy()\n        for u in basis:\n            v -= np.dot(v, u) / np.dot(u, u) * u\n        norm = np.linalg.norm(v)\n        if norm > 1e-10:\n            basis.append(v / norm)\n    return np.array(basis)\nvectors = np.array([[1, 1, 1], [1, 2, 3]], dtype=float)\northonormal_basis = gram_schmidt(vectors)\nprint(orthonormal_basis)"
    },
    {
        "input": "Compute the pseudo-inverse of A = [[1,2], [3,4], [5,6]].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4], [5,6]])\npinv_A = np.linalg.pinv(A)\nprint(pinv_A)"
    },
    {
        "input": "Find the determinant of the transition matrix from basis B = {(1,0,1), (0,1,1)} to standard basis.",
        "output": "import numpy as np\nB = np.array([[1, 0], [0, 1]])\ndet = np.linalg.det(B)\nprint(det)"
    },
    {
        "input": "Compute the eigenvalues and eigenvectors of A = [[4,-2], [1,1]].",
        "output": "import numpy as np\nA = np.array([[4,-2], [1,1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('\\nEigenvalues:',eigenvalues, '\\nEigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the dimension of the subspace spanned by {(1,2,3), (2,4,6), (5,6,7)}.",
        "output": "import numpy as np\nA = np.array([[1,2,3], [2,4,6], [5,6,7]])\ndim = np.linalg.matrix_rank(A)\nprint(dim)"
    },
    {
        "input": "Find the projection of v = (3,4,5) onto the subspace spanned by (1,1,1).",
        "output": "import numpy as np\nv = np.array([3,4,5])\nu = np.array([1,1,1])\nprojection = (np.dot(v, u) / np.dot(u, u)) * u\nprint(projection)"
    },
    {
        "input": "Find the span of the vectors {(2,3), (4,6)}.",
        "output": "import numpy as np\nA = np.array([[2,3], [4,6]])\nrank = np.linalg.matrix_rank(A)\nprint(rank)"
    },
    {
        "input": "Find the rank of the Gram matrix formed by the vectors {(1,2), (2,3)}.",
        "output": "import numpy as np\nV = np.array([[1,2], [2,3]])\nG = V @ V.T\nrank = np.linalg.matrix_rank(G)\nprint(rank)"
    },
    {
        "input": "Find the least squares solution to Ax = b for A = [[1,1], [1,-1]], b = [2,0].",
        "output": "import numpy as np\nA = np.array([[1,1], [1,-1]])\nb = np.array([2,0])\nx_ls = np.linalg.lstsq(A, b, rcond=None)[0]\nprint(x_ls)"
    },
    {
        "input": "Find an orthonormal basis for the subspace spanned by {(3,1), (2,2)} using Gram-Schmidt.",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    basis = []\n    for v in vectors:\n        v = v.astype(float)\n        for u in basis:\n            v -= np.dot(v, u) / np.dot(u, u) * u\n        norm = np.linalg.norm(v)\n        if norm > 1e-10:\n            basis.append(v / norm)\n    return np.array(basis)\nvectors = np.array([[3,1], [2,2]], dtype=float)\northonormal_basis = gram_schmidt(vectors)\nprint(orthonormal_basis)"
    },
    {
        "input": "Compute the spectral decomposition of A = [[3,1], [1,3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nP_inv = np.linalg.inv(P)\nspectral_decomposition = np.dot(np.dot(P, D), P_inv)\nprint(\"Spectral Decomposition of A:\\n\", spectral_decomposition)"
    },
    {
        "input": "Find the determinant of the transition matrix from basis B = {(1,1), (1,-1)} to standard basis.",
        "output": "import numpy as np\nB = np.array([[1,1], [1,-1]])\ndet = np.linalg.det(B)\nprint(det)"
    },
    {
        "input": "Find the trace of A = [[5,1], [2,3]].",
        "output": "import numpy as np\nA = np.array([[5,1], [2,3]])\ntrace = np.trace(A)\nprint(trace)"
    },
    {
        "input": "Find the spectral radius of A = [[4,2], [1,3]].",
        "output": "import numpy as np\nA = np.array([[4,2], [1,3]])\neigenvalues = np.linalg.eigvals(A)\nspectral_radius = max(abs(eigenvalues))\nprint(spectral_radius)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of A = [[2,1], [1,2]].",
        "output": "import numpy as np\nA = np.array([[2,1], [1,2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues, '\\nEigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the determinant of the Gram matrix for the vectors {(1,1,1), (1,2,3)}.",
        "output": "import numpy as np\nV = np.array([[1,1,1], [1,2,3]])\nG = V @ V.T\ndet = np.linalg.det(G)\nprint(det)"
    },
    {
        "input": "Find the orthogonal projection of v = (2,3,4) onto the plane spanned by (1,0,1) and (0,1,1).",
        "output": "import numpy as np\ndef projection(v, u):\n    return (np.dot(v, u) / np.dot(u, u)) * u\nV = np.array([2,3,4])\nU1 = np.array([1,0,1])\nU2 = np.array([0,1,1])\nproj = projection(V, U1) + projection(V, U2)\nprint(proj)"
    },
    {
        "input": "Find the determinant of the matrix representing the linear transformation T(x,y) = (2x+y, x+3y).",
        "output": "import numpy as np\nA = np.array([[2,1], [1,3]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of A = [[1,2,0], [0,1,3], [0,0,2]].",
        "output": "import numpy as np\nA = np.array([[1,2,0], [0,1,3], [0,0,2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues, '\\nEigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the Gram-Schmidt orthonormal basis for the vectors {(1,1,1), (1,2,3), (1,3,5)}.",
        "output": "import numpy as np\ndef gram_schmidt(vectors):\n    basis = []\n    for v in vectors:\n        v = v.astype(float)\n        for u in basis:\n            v -= np.dot(v, u) / np.dot(u, u) * u\n        norm = np.linalg.norm(v)\n        if norm > 1e-10:\n            basis.append(v / norm)\n    return np.array(basis)\nV = np.array([[1,1,1], [1,2,3], [1,3,5]], dtype=float)\northonormal_basis = gram_schmidt(V)\nprint(orthonormal_basis)"
    },
    {
        "input": "Compute the spectral decomposition of A = [[2,1], [1,2]].",
        "output": "import numpy as np\nA = np.array([[2,1], [1,2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('P:',P, 'D=', D)"
    },
    {
        "input": "Find the dimension of the subspace spanned by {(1,0,0), (0,1,1), (1,1,1), (1,2,3)}.",
        "output": "import numpy as np\nA = np.array([[1,0,0], [0,1,1], [1,1,1], [1,2,3]])\ndim = np.linalg.matrix_rank(A)\nprint(dim)"
    },
    {
        "input": "Find the matrix representation of the linear transformation T(x,y) = (x+y, 2x-3y) in the standard basis.",
        "output": "import numpy as np\nA = np.array([[1,1], [2,-3]])\nprint(A)"
    },
    {
        "input": "Find the inverse of A = [[2,1], [1,3]].",
        "output": "import numpy as np\nA = np.array([[2,1], [1,3]])\nA_inv = np.linalg.inv(A)\nprint(A_inv)"
    },
    {
        "input": "Find the rank and nullity of A = [[1,2,3], [4,5,6], [7,8,9]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\nrank = np.linalg.matrix_rank(A)\nnullity = A.shape[1] - rank\nprint('rank:',rank, 'Nullity:', nullity)"
    },
    {
        "input": "Compute the spectral radius of A = [[3,2], [1,4]].",
        "output": "import numpy as np\nA = np.array([[3,2], [1,4]])\neigenvalues = np.linalg.eigvals(A)\nspectral_radius = max(abs(eigenvalues))\nprint(spectral_radius)"
    },
    {
        "input": "Find the determinant of the transition matrix from basis B = {(1,2), (2,3)} to standard basis.",
        "output": "import numpy as np\nB = np.array([[1,2], [2,3]])\ndet = np.linalg.det(B)\nprint(det)"
    },
    {
        "input": "Find the trace of A = [[5,2], [2,4]].",
        "output": "import numpy as np\nA = np.array([[5,2], [2,4]])\ntrace = np.trace(A)\nprint(trace)"
    },
    {
        "input": "Find the matrix representation of the linear transformation T(x,y,z) = (x+y, y+z, x+z) in standard basis.",
        "output": "import numpy as np\nA = np.array([[1,1,0], [0,1,1], [1,0,1]])\nprint(A)"
    },
    {
        "input": "Find the nullity of the matrix A = [[1,2,3], [4,5,6], [7,8,9]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\nrank = np.linalg.matrix_rank(A)\nnullity = A.shape[1] - rank\nprint(nullity)"
    },
    {
        "input": "Find the transition matrix from basis B = {(1,2), (3,4)} to the standard basis.",
        "output": "import numpy as np\nB = np.array([[1,2], [3,4]])\nP = np.linalg.inv(B)\nprint(P)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of A = [[0,1], [-1,0]].",
        "output": "import numpy as np\nA = np.array([[0,1], [-1,0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('\\nEigenvalues:',eigenvalues, '\\nEigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the spectral norm of A = [[3,4], [1,2]].",
        "output": "import numpy as np\nA = np.array([[3,4], [1,2]])\nspectral_norm = np.linalg.norm(A, 2)\nprint(spectral_norm)"
    },
    {
        "input": "Find the determinant of the Gram matrix of {(1,0), (1,1)}.",
        "output": "import numpy as np\nV = np.array([[1,0], [1,1]])\nG = np.matmul(V, V.T)\ndet = np.linalg.det(G)\nprint(det)"
    },
    {
        "input": "Find the Frobenius norm of A = [[1,2,3], [4,5,6]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6]])\nnorm = np.linalg.norm(A, 'fro')\nprint(norm)"
    },
    {
        "input": "Compute the singular values of A = [[2,3], [5,7]].",
        "output": "import numpy as np\nA = np.array([[2,3], [5,7]])\nsingular_values = np.linalg.svd(A, compute_uv=False)\nprint(singular_values)"
    },
    {
        "input": "Find the eigenvalues of the identity matrix I of size 3x3.",
        "output": "import numpy as np\nI = np.eye(3)\neigenvalues = np.linalg.eigvals(I)\nprint(eigenvalues)"
    },
    {
        "input": "Find the determinant of the transformation matrix T that reflects across the line y = x.",
        "output": "import numpy as np\nT = np.array([[0,1], [1,0]])\ndet = np.linalg.det(T)\nprint(det)"
    },
    {
        "input": "Find the determinant of the skew-symmetric matrix A = [[0,2,-3], [-2,0,4], [3,-4,0]].",
        "output": "import numpy as np\nA = np.array([[0,2,-3], [-2,0,4], [3,-4,0]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find the least-squares solution to Ax = b where A = [[1,2], [3,4]] and b = [1,2].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\nb = np.array([1,2])\nx, residuals, rank, s = np.linalg.lstsq(A, b, rcond=None)\nprint(x)"
    },
    {
        "input": "Find the determinant of the Cayley-Hamilton theorem matrix A = [[2,1], [1,2]].",
        "output": "import numpy as np\nA = np.array([[2,1], [1,2]])\nchar_poly = np.poly(A)\ndet = np.linalg.det(A)\nprint('Determinant:',det, 'Characteristic polynomial:', char_poly)"
    },
    {
        "input": "Find the projection of v = (3, 4, 5) onto the subspace spanned by w = (1, 1, 1).",
        "output": "import numpy as np\nv = np.array([3, 4, 5])\nw = np.array([1, 1, 1])\nproj = (np.dot(v, w) / np.dot(w, w)) * w\nprint(proj)"
    },
    {
        "input": "Find the rank and nullity of the matrix A = [[1,2,3], [4,5,6], [7,8,9], [10,11,12]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6], [7,8,9], [10,11,12]])\nrank = np.linalg.matrix_rank(A)\nnullity = A.shape[1] - rank\nprint('Rank:',rank, 'Nullity:', nullity)"
    },
    {
        "input": "Find the Gram-Schmidt orthonormal basis for the set {(1,1,0), (1,0,1)}.",
        "output": "import numpy as np\nfrom scipy.linalg import orth\nA = np.array([[1,1,0], [1,0,1]]).T\nQ = orth(A)\nprint(Q)"
    },
    {
        "input": "Find the determinant of the matrix representation of the transformation T(x,y) = (x+y, x-y).",
        "output": "import numpy as np\nA = np.array([[1,1], [1,-1]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find the eigenvalues of the symmetric matrix A = [[2, -1], [-1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, -1], [-1, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint(eigenvalues)"
    },
    {
        "input": "Find the determinant of the matrix A = [[4, 3], [3, 4]] using the eigenvalues.",
        "output": "import numpy as np\nA = np.array([[4,3], [3,4]])\neigenvalues = np.linalg.eigvals(A)\ndet = np.prod(eigenvalues)\nprint(det)"
    },
    {
        "input": "Find the trace of the matrix A = [[5, -2, 3], [0, 4, -1], [-2, 1, 6]].",
        "output": "import numpy as np\nA = np.array([[5, -2, 3], [0, 4, -1], [-2, 1, 6]])\ntrace = np.trace(A)\nprint(trace)"
    },
    {
        "input": "Find the determinant of the outer product of u = (1,2) and v = (3,4).",
        "output": "import numpy as np\nu = np.array([1,2])\nv = np.array([3,4])\nouter = np.outer(u, v)\ndet = np.linalg.det(outer)\nprint(det)"
    },
    {
        "input": "Compute the induced 2-norm of A = [[1, 2], [3, 4]].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\nnorm = np.linalg.norm(A, 2)\nprint(norm)"
    },
    {
        "input": "Find the determinant of the matrix representing the reflection across y = -x.",
        "output": "import numpy as np\nA = np.array([[0,-1], [-1,0]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Compute the eigenvectors of the matrix A = [[2,1], [1,2]].",
        "output": "import numpy as np\nA = np.array([[2,1], [1,2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(eigenvectors)"
    },
    {
        "input": "Find the determinant of the covariance matrix of the vectors u = (1,2), v = (2,3).",
        "output": "import numpy as np\nX = np.array([[1,2], [2,3]])\ncov_matrix = np.cov(X, rowvar=False)\ndet = np.linalg.det(cov_matrix)\nprint(det)"
    },
    {
        "input": "Find the transition matrix from basis B = {(1,1), (1,-1)} to the standard basis.",
        "output": "import numpy as np\nB = np.array([[1,1], [1,-1]])\nP = np.linalg.inv(B)\nprint(P)"
    },
    {
        "input": "Find the determinant of the identity matrix of size 4.",
        "output": "import numpy as np\nI = np.eye(4)\ndet = np.linalg.det(I)\nprint(det)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the matrix A = [[3, -2], [4, -1]].",
        "output": "import numpy as np\nA = np.array([[3, -2], [4, -1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:',eigenvalues, 'Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the dot product of vectors u = (2,3,4) and v = (-1,0,5).",
        "output": "import numpy as np\nu = np.array([2,3,4])\nv = np.array([-1,0,5])\ndot_product = np.dot(u, v)\nprint(dot_product)"
    },
    {
        "input": "Compute the cross product of vectors u = (1,2,3) and v = (4,5,6).",
        "output": "import numpy as np\nu = np.array([1,2,3])\nv = np.array([4,5,6])\ncross_product = np.cross(u, v)\nprint(cross_product)"
    },
    {
        "input": "Find the determinant of the symmetric matrix A = [[1, 2, 3], [2, 5, 4], [3, 4, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 5, 4], [3, 4, 6]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find the unit vector in the direction of v = (3, 4).",
        "output": "import numpy as np\nv = np.array([3,4])\nunit_vector = v / np.linalg.norm(v)\nprint(unit_vector)"
    },
    {
        "input": "Find the rank of the transformation T(x,y,z) = (x+y, y+z, z+x).",
        "output": "import numpy as np\nA = np.array([[1,1,0], [0,1,1], [1,0,1]])\nrank = np.linalg.matrix_rank(A)\nprint(rank)"
    },
    {
        "input": "Find the orthogonal projection of u = (1,2,3) onto v = (4,5,6).",
        "output": "import numpy as np\nu = np.array([1,2,3])\nv = np.array([4,5,6])\nproj = (np.dot(u, v) / np.dot(v, v)) * v\nprint(proj)"
    },
    {
        "input": "Find the determinant of the rotation matrix by 45 degrees counterclockwise.",
        "output": "import numpy as np\nangle = np.pi / 4\nA = np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find the rank of the Gram matrix of vectors u = (1,2,3) and v = (4,5,6).",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6]])\nG = A @ A.T\nrank = np.linalg.matrix_rank(G)\nprint(rank)"
    },
    {
        "input": "Compute the eigenvectors of A = [[1, 2], [2, 1]].",
        "output": "import numpy as np\nA = np.array([[1,2], [2,1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(eigenvectors)"
    },
    {
        "input": "Find the determinant of the projection matrix onto (1,2).",
        "output": "import numpy as np\nv = np.array([[1], [2]])\nP = (v @ v.T) / (v.T @ v)\ndet = np.linalg.det(P)\nprint(det)"
    },
    {
        "input": "Find the transition matrix from basis B = {(1,2), (2,3)} to the standard basis.",
        "output": "import numpy as np\nB = np.array([[1,2], [2,3]])\nP = np.linalg.inv(B)\nprint(P)"
    },
    {
        "input": "Find the dimension of the subspace spanned by {(1, 2, 3, 4), (2, 4, 6, 8), (0, 1, 0, 1), (1, 3, 3, 7)}.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3, 4], [2, 4, 6, 8], [0, 1, 0, 1], [1, 3, 3, 7]])\nrank = np.linalg.matrix_rank(A)\nprint(rank)"
    },
    {
        "input": "Find the eigenvalues of A = [[0, 1], [-1, 0]].",
        "output": "import numpy as np\nA = np.array([[0, 1], [-1, 0]])\neigenvalues, _ = np.linalg.eig(A)\nprint(eigenvalues)"
    },
    {
        "input": "Find the rank of the projection matrix P = v*v^T where v = (1,2,3).",
        "output": "import numpy as np\nv = np.array([[1], [2], [3]])\nP = (v @ v.T) / (v.T @ v)\nrank = np.linalg.matrix_rank(P)\nprint(rank)"
    },
    {
        "input": "Find an orthonormal basis for the space spanned by {(1, 1, 0), (1, 0, 1)}.",
        "output": "import numpy as np\nfrom scipy.linalg import orth\nA = np.array([[1,1,0], [1,0,1]]).T\northonormal_basis = orth(A)\nprint(orthonormal_basis)"
    },
    {
        "input": "Find the eigenvectors of A = [[3, 1], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(eigenvectors)"
    },
    {
        "input": "Compute the Gram matrix of vectors (1,2) and (3,4).",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\nG = A.T @ A\nprint(G)"
    },
    {
        "input": "Find the rank of the Gram-Schmidt process applied to {(1,1,1), (1,2,3), (2,4,6)}.",
        "output": "import numpy as np\nfrom scipy.linalg import qr\nA = np.array([[1,1,1], [1,2,3], [2,4,6]])\nQ, R = qr(A, mode='economic')\nrank = np.linalg.matrix_rank(Q)\nprint(rank)"
    },
    {
        "input": "Find the determinant of the reflection matrix R = [[0, 1], [1, 0]].",
        "output": "import numpy as np\nR = np.array([[0, 1], [1, 0]])\ndet = np.linalg.det(R)\nprint(det)"
    },
    {
        "input": "Find the transition matrix from basis B = {(2,3), (4,5)} to the standard basis.",
        "output": "import numpy as np\nB = np.array([[2,3], [4,5]])\nP = np.linalg.inv(B)\nprint(P)"
    },
    {
        "input": "Find the determinant of the linear transformation T: R² → R² defined by T(x,y) = (3x + 4y, 2x + 5y).",
        "output": "import numpy as np\nA = np.array([[3,4], [2,5]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of A = [[1, 2, 3], [4, 5, 6], [7, 8, 10]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6], [7,8,10]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:',eigenvalues, 'Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Find the Gram matrix for the vectors u = (1,2,3) and v = (4,5,6).",
        "output": "import numpy as np\nV = np.array([[1,2,3], [4,5,6]])\nG = V @ V.T\nprint(G)"
    },
    {
        "input": "Find the spectral radius of A = [[3, -1], [2, 4]].",
        "output": "import numpy as np\nA = np.array([[3,-1], [2,4]])\neigenvalues = np.linalg.eigvals(A)\nspectral_radius = max(abs(eigenvalues))\nprint(spectral_radius)"
    },
    {
        "input": "Find an orthonormal basis using Gram-Schmidt for the set {(2,3,1), (1,0,4)}.",
        "output": "import numpy as np\nfrom scipy.linalg import orth\nA = np.array([[2,3,1], [1,0,4]]).T\northonormal_basis = orth(A)\nprint(orthonormal_basis)"
    },
    {
        "input": "Find the Frobenius norm of the matrix A = [[1,2,3], [4,5,6]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6]])\nnorm = np.linalg.norm(A, 'fro')\nprint(norm)"
    },
    {
        "input": "Find the least squares solution to Ax=b where A = [[1,2], [3,4]] and b = [1,2].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\nb = np.array([1,2])\nx, residuals, rank, s = np.linalg.lstsq(A, b, rcond=None)\nprint(x)"
    },
    {
        "input": "Find the determinant of the identity matrix of size 5.",
        "output": "import numpy as np\nI = np.eye(5)\ndet = np.linalg.det(I)\nprint(det)"
    },
    {
        "input": "Find the best approximation to b = (3,4) in the span of (1,1).",
        "output": "import numpy as np\nb = np.array([3,4])\nv = np.array([1,1])\nprojection = (np.dot(b, v) / np.dot(v, v)) * v\nprint(projection)"
    },
    {
        "input": "Compute the eigenvectors of the matrix A = [[1, 2], [2, 1]].",
        "output": "import numpy as np\nA = np.array([[1,2], [2,1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(eigenvectors)"
    },
    {
        "input": "Find the rank of the outer product of u = (1,2) and v = (3,4).",
        "output": "import numpy as np\nu = np.array([1,2])\nv = np.array([3,4])\nouter = np.outer(u, v)\nrank = np.linalg.matrix_rank(outer)\nprint(rank)"
    },
    {
        "input": "Find the rank and nullity of the projection matrix P = v*v^T where v = (1,2,3).",
        "output": "import numpy as np\nv = np.array([[1], [2], [3]])\nP = (v @ v.T) / (v.T @ v)\nrank = np.linalg.matrix_rank(P)\nnullity = P.shape[1] - rank\nprint(\"Rank:\", rank, \"Nullity:\", nullity)"
    },
    {
        "input": "Find the spectral decomposition of A = [[3,1], [1,3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nP_inv = np.linalg.inv(P)\nA_decomposed = P @ D @ P_inv\nprint('Eigenvectors (P):\\n', P)\nprint('Eigenvalues (D):\\n', D)\nprint('P^-1 (Inverse of P):\\n', P_inv)\nprint('Reconstructed A from spectral decomposition:\\n', A_decomposed)"
    },
    {
        "input": "Find the determinant of the Gram matrix of {(1,1,0), (1,0,1)}.",
        "output": "import numpy as np\nV = np.array([[1,1,0], [1,0,1]])\nG = V @ V.T\ndet = np.linalg.det(G)\nprint(det)"
    },
    {
        "input": "Compute the induced 2-norm of A = [[1,2], [3,4]].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\nnorm = np.linalg.norm(A, 2)\nprint(norm)"
    },
    {
        "input": "Compute the determinant of the Gram matrix for vectors v1=(1,2,3), v2=(4,5,6).",
        "output": "import numpy as np\nV = np.array([[1,2,3], [4,5,6]])\nG = V @ V.T\ndet = np.linalg.det(G)\nprint(det)"
    },
    {
        "input": "Find the determinant of the Householder reflection matrix that reflects across (1,2,3).",
        "output": "import numpy as np\nv = np.array([1,2,3])\nv = v / np.linalg.norm(v)\nH = np.eye(3) - 2 * np.outer(v, v)\ndet = np.linalg.det(H)\nprint(det)"
    },
    {
        "input": "Find the determinant of the skew-symmetric matrix A = [[0,-2,1], [2,0,-3], [-1,3,0]].",
        "output": "import numpy as np\nA = np.array([[0,-2,1], [2,0,-3], [-1,3,0]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find the rank of the transformation matrix that rotates by 90 degrees in 3D space.",
        "output": "import numpy as np\nangle = np.pi / 2\nR = np.array([[np.cos(angle), -np.sin(angle), 0], [np.sin(angle), np.cos(angle), 0], [0, 0, 1]])\nrank = np.linalg.matrix_rank(R)\nprint(rank)"
    },
    {
        "input": "Find the eigenvalues of the Laplacian matrix L = [[2,-1,0], [-1,2,-1], [0,-1,2]].",
        "output": "import numpy as np\nL = np.array([[2,-1,0], [-1,2,-1], [0,-1,2]])\neigenvalues = np.linalg.eigvals(L)\nprint(eigenvalues)"
    },
    {
        "input": "Compute the Frobenius norm of A = [[1,2], [3,4]].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\nnorm = np.linalg.norm(A, 'fro')\nprint(norm)"
    },
    {
        "input": "Find the determinant of the covariance matrix of vectors (1,2,3) and (4,5,6).",
        "output": "import numpy as np\nX = np.array([[1,2,3], [4,5,6]])\ncov_matrix = np.cov(X, rowvar=False)\ndet = np.linalg.det(cov_matrix)\nprint(det)"
    },
    {
        "input": "Find the determinant of the symmetric positive definite matrix A = [[4,1], [1,3]].",
        "output": "import numpy as np\nA = np.array([[4,1], [1,3]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find the determinant of the orthogonal projection matrix onto (1,1,1).",
        "output": "import numpy as np\nv = np.array([[1], [1], [1]])\nP = (v @ v.T) / (v.T @ v)\ndet = np.linalg.det(P)\nprint(det)"
    },
    {
        "input": "Find the singular values of A = [[1,2], [3,4]].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\nU, S, Vt = np.linalg.svd(A)\nprint(S)"
    },
    {
        "input": "Find the determinant of the exponential of A = [[0,-1], [1,0]].",
        "output": "import numpy as np\nfrom scipy.linalg import expm\nA = np.array([[0,-1], [1,0]])\nexp_A = expm(A)\ndet = np.linalg.det(exp_A)\nprint(det)"
    },
    {
        "input": "Compute the trace norm of A = [[1,2], [3,4]].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\ntrace_norm = np.sum(np.linalg.svd(A, compute_uv=False))\nprint(trace_norm)"
    },
    {
        "input": "Find the determinant of the Gram matrix for vectors v1=(1,0,1), v2=(0,1,1).",
        "output": "import numpy as np\nV = np.array([[1,0,1], [0,1,1]])\nG = V @ V.T\ndet = np.linalg.det(G)\nprint(det)"
    },
    {
        "input": "Find the determinant of the Cayley-Hamilton theorem matrix A = [[1,2], [3,4]].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\nchar_poly = np.poly(A)\ndet = np.linalg.det(A)\nprint('Determinant:',det, 'Characteristic polynomial:', char_poly)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of the symmetric matrix A = [[2,1], [1,2]].",
        "output": "import numpy as np\nA = np.array([[2,1], [1,2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:',eigenvalues, 'Eigenvectors:', eigenvectors)"
    },
    {
        "input": "Compute the determinant of the orthogonal matrix Q = [[0,-1], [1,0]].",
        "output": "import numpy as np\nQ = np.array([[0,-1], [1,0]])\ndet = np.linalg.det(Q)\nprint(det)"
    },
    {
        "input": "Find the projection of v=(3,4,5) onto u=(1,2,3).",
        "output": "import numpy as np\nv = np.array([3,4,5])\nu = np.array([1,2,3])\nproj = (np.dot(v, u) / np.dot(u, u)) * u\nprint(proj)"
    },
    {
        "input": "Find the determinant of the Gram matrix for vectors v1=(1,0,1), v2=(0,1,1), v3=(1,1,0).",
        "output": "import numpy as np\nV = np.array([[1,0,1], [0,1,1], [1,1,0]])\nG = V @ V.T\ndet = np.linalg.det(G)\nprint(det)"
    },
    {
        "input": "Compute the determinant of the covariance matrix of vectors (2,3,4) and (5,6,7).",
        "output": "import numpy as np\nX = np.array([[2,3,4], [5,6,7]])\ncov_matrix = np.cov(X, rowvar=False)\ndet = np.linalg.det(cov_matrix)\nprint(det)"
    },
    {
        "input": "Find the rank of the Gram matrix for v1=(1,2,3), v2=(2,4,6), v3=(3,6,9).",
        "output": "import numpy as np\nV = np.array([[1,2,3], [2,4,6], [3,6,9]])\nG = V @ V.T\nrank = np.linalg.matrix_rank(G)\nprint(rank)"
    },
    {
        "input": "Compute the trace norm of A = [[4,2], [1,3]].",
        "output": "import numpy as np\nA = np.array([[4,2], [1,3]])\ntrace_norm = np.sum(np.linalg.svd(A, compute_uv=False))\nprint(trace_norm)"
    },
    {
        "input": "Find the determinant of the Laplacian matrix L = [[3,-1,-1], [-1,2,-1], [-1,-1,2]].",
        "output": "import numpy as np\nL = np.array([[3,-1,-1], [-1,2,-1], [-1,-1,2]])\ndet = np.linalg.det(L)\nprint(det)"
    },
    {
        "input": "Find the determinant of the matrix exponential of A = [[0,1], [-1,0]].",
        "output": "import numpy as np\nfrom scipy.linalg import expm\nA = np.array([[0,1], [-1,0]])\nexp_A = expm(A)\ndet = np.linalg.det(exp_A)\nprint(det)"
    },
    {
        "input": "Find the determinant of the transformation matrix that reflects across (2,3,4).",
        "output": "import numpy as np\nv = np.array([2,3,4])\nv = v / np.linalg.norm(v)\nH = np.eye(3) - 2 * np.outer(v, v)\ndet = np.linalg.det(H)\nprint(det)"
    },
    {
        "input": "Find the determinant of the covariance matrix for v1=(1,2,3), v2=(4,5,6).",
        "output": "import numpy as np\nX = np.array([[1,2,3], [4,5,6]])\ncov_matrix = np.cov(X, rowvar=False)\ndet = np.linalg.det(cov_matrix)\nprint(det)"
    },
    {
        "input": "Compute the determinant of the Gram matrix for v1=(1,0,2), v2=(2,1,1), v3=(3,2,0).",
        "output": "import numpy as np\nV = np.array([[1,0,2], [2,1,1], [3,2,0]])\nG = V @ V.T\ndet = np.linalg.det(G)\nprint(det)"
    },
    {
        "input": "Find the rank of the Gram matrix for vectors v1=(1,2,3), v2=(3,2,1), v3=(2,1,3).",
        "output": "import numpy as np\nV = np.array([[1,2,3], [3,2,1], [2,1,3]])\nG = V @ V.T\nrank = np.linalg.matrix_rank(G)\nprint(rank)"
    },
    {
        "input": "Find the transformation matrix that rotates a vector by 45° in 2D space.",
        "output": "import numpy as np\nfrom math import radians, cos, sin\ntheta = radians(45)\nR = np.array([[cos(theta), -sin(theta)], [sin(theta), cos(theta)]])\nprint(R)"
    },
    {
        "input": "Find the eigenvalues of the transformation matrix T = [[2,0,1], [1,3,2], [0,1,4]].",
        "output": "import numpy as np\nT = np.array([[2,0,1], [1,3,2], [0,1,4]])\neigenvalues = np.linalg.eigvals(T)\nprint(eigenvalues)"
    },
    {
        "input": "Find the determinant of the orthogonal projection matrix onto span{(1,1,0), (0,1,1)}.",
        "output": "import numpy as np\nV = np.array([[1,1,0], [0,1,1]]).T\nP = V @ np.linalg.inv(V.T @ V) @ V.T\ndet = np.linalg.det(P)\nprint(det)"
    },
    {
        "input": "Find the trace norm of A = [[1,4], [2,3]].",
        "output": "import numpy as np\nA = np.array([[1,4], [2,3]])\ntrace_norm = np.sum(np.linalg.svd(A, compute_uv=False))\nprint(trace_norm)"
    },
    {
        "input": "Add the matrices A = [[1,2], [3,4]] and B = [[5,6], [7,8]].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\nB = np.array([[5,6], [7,8]])\nresult = A + B\nprint(result)"
    },
    {
        "input": "Multiply A = [[1,2,3], [4,5,6]] and B = [[7,8], [9,10], [11,12]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6]])\nB = np.array([[7,8], [9,10], [11,12]])\nresult = A @ B\nprint(result)"
    },
    {
        "input": "Find the transpose of matrix A = [[3,4,5], [6,7,8]].",
        "output": "import numpy as np\nA = np.array([[3,4,5], [6,7,8]])\nresult = A.T\nprint(result)"
    },
    {
        "input": "Find the inverse of A = [[2,3], [5,7]].",
        "output": "import numpy as np\nA = np.array([[2,3], [5,7]])\nresult = np.linalg.inv(A)\nprint(result)"
    },
    {
        "input": "Compute (A+B)^T for A = [[1,2], [3,4]] and B = [[5,6], [7,8]].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\nB = np.array([[5,6], [7,8]])\nresult = (A + B).T\nprint(result)"
    },
    {
        "input": "Find the determinant of matrix A = [[4,7], [2,6]].",
        "output": "import numpy as np\nA = np.array([[4,7], [2,6]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find the rank of matrix A = [[1,2,3], [4,5,6], [7,8,9]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\nrank = np.linalg.matrix_rank(A)\nprint(rank)"
    },
    {
        "input": "Find the trace of matrix A = [[1,2,3], [4,5,6], [7,8,9]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\ntrace = np.trace(A)\nprint(trace)"
    },
    {
        "input": "Compute A * A^T where A = [[1,2,3], [4,5,6]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6]])\nresult = A @ A.T\nprint(result)"
    },
    {
        "input": "Find the eigenvalues and eigenvectors of A = [[2,0], [0,3]].",
        "output": "import numpy as np\nA = np.array([[2,0], [0,3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(eigenvalues)\nprint(eigenvectors)"
    },
    {
        "input": "Find the inverse of a 3x3 matrix A = [[1,2,3], [0,1,4], [5,6,0]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [0,1,4], [5,6,0]])\ninv_A = np.linalg.inv(A)\nprint(inv_A)"
    },
    {
        "input": "Compute the product of the diagonal elements of A = [[5,2], [3,8]].",
        "output": "import numpy as np\nA = np.array([[5,2], [3,8]])\nproduct_diag = np.prod(np.diag(A))\nprint(product_diag)"
    },
    {
        "input": "Find the matrix representation of the function f(x,y) = (x+y, x-2y) as a linear transformation.",
        "output": "import numpy as np\nA = np.array([[1,1], [1,-2]])\nprint(A)"
    },
    {
        "input": "Find the Moore-Penrose pseudoinverse of A = [[1,2], [3,4], [5,6]].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4], [5,6]])\npinv_A = np.linalg.pinv(A)\nprint(pinv_A)"
    },
    {
        "input": "Compute the determinant of the Gram matrix for v1=(1,2), v2=(3,4).",
        "output": "import numpy as np\nV = np.array([[1,2], [3,4]])\nG = V @ V.T\ndet = np.linalg.det(G)\nprint(det)"
    },
    {
        "input": "Find the spectral norm of A = [[3,2], [2,3]].",
        "output": "import numpy as np\nA = np.array([[3,2], [2,3]])\nspectral_norm = np.linalg.norm(A, 2)\nprint(spectral_norm)"
    },
    {
        "input": "Compute A^4 for A = [[0,1], [-1,0]].",
        "output": "import numpy as np\nA = np.array([[0,1], [-1,0]])\nresult = np.linalg.matrix_power(A, 4)\nprint(result)"
    },
    {
        "input": "Find the singular value decomposition (SVD) of A = [[3,1], [1,3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\nU, S, Vt = np.linalg.svd(A)\nprint('Singular values:', S)"
    },
    {
        "input": "Find the determinant of a 4x4 upper triangular matrix A = [[2,3,1,4], [0,5,7,2], [0,0,6,3], [0,0,0,8]].",
        "output": "import numpy as np\nA = np.array([[2,3,1,4], [0,5,7,2], [0,0,6,3], [0,0,0,8]])\ndet = np.linalg.det(A)\nprint(det)"
    },
    {
        "input": "Find the determinant of the Gram matrix for vectors v1=[1,2,3], v2=[4,5,6], v3=[7,8,9].",
        "output": "import numpy as np\nV = np.array([[1,2,3], [4,5,6], [7,8,9]])\nG = V @ V.T\ndet = np.linalg.det(G)\nprint(det)"
    },
    {
        "input": "Compute the Frobenius norm of A = [[1,2,3], [4,5,6], [7,8,9]].",
        "output": "import numpy as np\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\nfrobenius_norm = np.linalg.norm(A, 'fro')\nprint(frobenius_norm)"
    },
    {
        "input": "Find the orthogonal projection of vector b = [3,4] onto the column space of A = [[1,0], [1,1]].",
        "output": "import numpy as np\nA = np.array([[1,0], [1,1]])\nb = np.array([3,4])\nprojection = A @ np.linalg.inv(A.T @ A) @ A.T @ b\nprint(projection)"
    },
    {
        "input": "Compute the Hessenberg form of matrix A = [[1,2,3], [4,5,6], [7,8,9]].",
        "output": "from scipy.linalg import hessenberg\nimport numpy as np\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\nH = hessenberg(A)\nprint(H)"
    },
    {
        "input": "Compute the LU decomposition of A = [[4,3], [6,3]].",
        "output": "import scipy.linalg as la\nimport numpy as np\nA = np.array([[4, 3], [6, 3]])\nP, L, U = la.lu(A)\nprint('L:', L, '\\nU:', U)"
    },
    {
        "input": "Find the Cholesky decomposition of A = [[4,2], [2,3]].",
        "output": "import numpy as np\nA = np.array([[4,2], [2,3]])\nL = np.linalg.cholesky(A)\nprint(L)"
    },
    {
        "input": "Find the QR decomposition of A = [[12,-51,4], [6,167,-68], [-4,24,-41]].",
        "output": "import numpy as np\nA = np.array([[12,-51,4], [6,167,-68], [-4,24,-41]])\nQ, R = np.linalg.qr(A)\nprint('Q:',Q, '\\nR:', R)"
    },
    {
        "input": "Find the spectral radius of A = [[2,3], [4,1]].",
        "output": "import numpy as np\nA = np.array([[2,3], [4,1]])\neigenvalues = np.linalg.eigvals(A)\nspectral_radius = max(abs(eigenvalues))\nprint(spectral_radius)"
    },
    {
        "input": "Compute the condition number of A = [[1,2], [3,4]].",
        "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\ncond_number = np.linalg.cond(A)\nprint(cond_number)"
    },
    {
        "input": "Find the Perron-Frobenius eigenvalue of A = [[2,1], [1,3]].",
        "output": "import numpy as np\nA = np.array([[2,1], [1,3]])\neigenvalues = np.linalg.eigvals(A)\nperron_value = max(eigenvalues)\nprint(perron_value)"
    },
    {
        "input": "Find the norm of the inverse of A = [[4,7], [2,6]].",
        "output": "import numpy as np\nA = np.array([[4,7], [2,6]])\nA_inv = np.linalg.inv(A)\nnorm_inv = np.linalg.norm(A_inv)\nprint(norm_inv)"
    },
    {
        "input": "Calculate the condition number of matrix A = [[1, 2], [3, 4]] using the 2-norm.",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number (2-norm):\", cond_number)"
    },
    {
        "input": "What is the condition number of A = [[5, 2], [1, 3]] using the infinity norm?",
        "output": "import numpy as np\nA = np.array([[5, 2], [1, 3]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number (inf-norm):\", cond_number)"
    },
    {
        "input": "Find the condition number of the matrix A = [[10, 2], [3, 7]] using the Frobenius norm.",
        "output": "import numpy as np\nA = np.array([[10, 2], [3, 7]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number (Frobenius):\", cond_number)"
    },
    {
        "input": "Determine the 1-norm condition number for matrix A = [[0.5, 0.2], [0.1, 0.4]].",
        "output": "import numpy as np\nA = np.array([[0.5, 0.2], [0.1, 0.4]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number (1-norm):\", cond_number)"
    },
    {
        "input": "Compute the condition number of matrix A = [[3, 0], [0, 0.01]] to assess stability.",
        "output": "import numpy as np\nA = np.array([[3, 0], [0, 0.01]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number (default 2-norm):\", cond_number)"
    },
    {
        "input": "Evaluate how stable matrix A = [[2, -1], [1, 2]] is using the 1-norm condition number.",
        "output": "import numpy as np\nA = np.array([[2, -1], [1, 2]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number (1-norm):\", cond_number)"
    },
    {
        "input": "Find the Frobenius norm condition number of matrix A = [[6, 2], [1, 8]].",
        "output": "import numpy as np\nA = np.array([[6, 2], [1, 8]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number (Frobenius):\", cond_number)"
    },
    {
        "input": "How numerically stable is matrix A = [[0.01, 0], [0, 100]]?",
        "output": "import numpy as np\nA = np.array([[0.01, 0], [0, 100]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number (2-norm):\", cond_number)"
    },
    {
        "input": "Assess the sensitivity of A = [[1, 1e-5], [0, 1]] using the infinity norm.",
        "output": "import numpy as np\nA = np.array([[1, 1e-5], [0, 1]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number (inf-norm):\", cond_number)"
    },
    {
        "input": "Determine the condition number for A = [[100, 1], [0, 1]] using 2-norm.",
        "output": "import numpy as np\nA = np.array([[100, 1], [0, 1]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number (2-norm):\", cond_number)"
    },
    {
        "input": "Find out if A = [[1, 2], [2, 4.00001]] is ill-conditioned using Frobenius norm.",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4.00001]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number (Frobenius):\", cond_number)"
    },
    {
        "input": "Find the infinity-norm condition number for matrix A = [[7, 1], [2, 9]].",
        "output": "import numpy as np\nA = np.array([[7, 1], [2, 9]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number (inf-norm):\", cond_number)"
    },
    {
        "input": "Evaluate how conditioning affects numerical stability for A = [[2, 0], [0, 1000]].",
        "output": "import numpy as np\nA = np.array([[2, 0], [0, 1000]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number (2-norm):\", cond_number)"
    },
    {
        "input": "Calculate the Frobenius norm condition number of A = [[4, 2], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[4, 2], [2, 3]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number (Frobenius):\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number for A = [[0.001, 0], [0, 1000]].",
        "output": "import numpy as np\nA = np.array([[0.001, 0], [0, 1000]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number (2-norm):\", cond_number)"
    },
    {
        "input": "Evaluate condition number of A = [[2, -3], [4, -6.0001]] using 1-norm.",
        "output": "import numpy as np\nA = np.array([[2, -3], [4, -6.0001]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number (1-norm):\", cond_number)"
    },
    {
        "input": "Find the condition number using default norm for A = [[0.2, 0.1], [0.1, 0.3]].",
        "output": "import numpy as np\nA = np.array([[0.2, 0.1], [0.1, 0.3]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number (2-norm):\", cond_number)"
    },
    {
        "input": "How stable is matrix A = [[1, 2], [3, 6.0001]] under 2-norm?",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 6.0001]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number (2-norm):\", cond_number)"
    },
    {
        "input": "Compute the condition number of the matrix [[3, 2], [4, 1]] using the 2-norm.",
        "output": "import numpy as np\nA = np.array([[3, 2], [4, 1]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the condition number (infinity norm) of the matrix [[1, 0], [0, 0.0001]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 0.0001]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the condition number using Frobenius norm for matrix [[2, 1], [5, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [5, 3]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 2-norm condition number of a matrix [[10, 2], [3, 0.5]].",
        "output": "import numpy as np\nA = np.array([[10, 2], [3, 0.5]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the condition number (1-norm) of matrix [[0.01, 0], [0, 100]].",
        "output": "import numpy as np\nA = np.array([[0.01, 0], [0, 100]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine the numerical stability of solving a linear system with matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the condition number of the matrix [[1e-5, 1], [1, 1]] using 2-norm.",
        "output": "import numpy as np\nA = np.array([[1e-5, 1], [1, 1]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the condition number (infinity norm) of matrix [[7, 8], [9, 10]].",
        "output": "import numpy as np\nA = np.array([[7, 8], [9, 10]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the condition number of matrix [[1, 2], [2, 4.0001]] to assess near-singularity.",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4.0001]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the Frobenius norm-based condition number for matrix [[3, 1], [0, 2]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [0, 2]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "What is the condition number of matrix [[0.5, 1.2], [1.1, 2.5]] using 2-norm?",
        "output": "import numpy as np\nA = np.array([[0.5, 1.2], [1.1, 2.5]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate condition number for matrix [[1, 1], [1, 1.00001]] using default norm.",
        "output": "import numpy as np\nA = np.array([[1, 1], [1, 1.00001]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check if the matrix [[2, 3], [5, 7]] is ill-conditioned using 1-norm condition number.",
        "output": "import numpy as np\nA = np.array([[2, 3], [5, 7]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the condition number of the matrix [[1, 2, 3], [0, 1, 4], [5, 6, 0]] using 2-norm.",
        "output": "import numpy as np\nA = np.array([[1, 2, 3], [0, 1, 4], [5, 6, 0]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess stability by computing condition number for matrix [[10, -2], [3, 0.2]].",
        "output": "import numpy as np\nA = np.array([[10, -2], [3, 0.2]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine if matrix [[1e-10, 1], [1, 1]] is ill-conditioned.",
        "output": "import numpy as np\nA = np.array([[1e-10, 1], [1, 1]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find condition number of matrix [[2, 5], [1, 3]] using 1-norm.",
        "output": "import numpy as np\nA = np.array([[2, 5], [1, 3]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the 2-norm condition number of [[100, 99], [99, 98]].",
        "output": "import numpy as np\nA = np.array([[100, 99], [99, 98]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the Frobenius norm condition number for matrix [[6, 3], [2, 1]].",
        "output": "import numpy as np\nA = np.array([[6, 3], [2, 1]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find 1-norm condition number of [[2, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute condition number (infinity norm) for matrix [[1, 2], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 3]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate condition number of matrix [[1, 0], [0, 1e-8]] to check sensitivity.",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 1e-8]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the condition number of matrix [[0.001, 2], [3, 4]] using 2-norm.",
        "output": "import numpy as np\nA = np.array([[0.001, 2], [3, 4]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the condition number (infinity norm) for matrix [[5, -2], [3, 1]].",
        "output": "import numpy as np\nA = np.array([[5, -2], [3, 1]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine if matrix [[0.0001, 1], [1, 1]] is ill-conditioned using default norm.",
        "output": "import numpy as np\nA = np.array([[0.0001, 1], [1, 1]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "What is the Frobenius norm condition number of matrix [[10, 20], [5, 15]]?",
        "output": "import numpy as np\nA = np.array([[10, 20], [5, 15]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 1-norm condition number of matrix [[9, 4], [6, 3]].",
        "output": "import numpy as np\nA = np.array([[9, 4], [6, 3]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the condition number for matrix [[8, 1], [1, 8]] using 2-norm.",
        "output": "import numpy as np\nA = np.array([[8, 1], [1, 8]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the default condition number of matrix [[100, 99.9], [99.9, 99.8]].",
        "output": "import numpy as np\nA = np.array([[100, 99.9], [99.9, 99.8]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess numerical stability for solving a system using matrix [[1, 3], [1.0001, 3]].",
        "output": "import numpy as np\nA = np.array([[1, 3], [1.0001, 3]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the Frobenius norm condition number for matrix [[0.5, 1.5], [2.5, 3.5]].",
        "output": "import numpy as np\nA = np.array([[0.5, 1.5], [2.5, 3.5]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check how sensitive the matrix [[1e-9, 1], [1, 1]] is by computing its condition number.",
        "output": "import numpy as np\nA = np.array([[1e-9, 1], [1, 1]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate condition number for matrix [[1, 1000], [0, 1]] using 2-norm.",
        "output": "import numpy as np\nA = np.array([[1, 1000], [0, 1]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the infinity norm condition number for matrix [[7, 2], [6, 4]].",
        "output": "import numpy as np\nA = np.array([[7, 2], [6, 4]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine the 1-norm condition number of matrix [[4, 2], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[4, 2], [1, 1]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess numerical stability of solving equations using matrix [[3, 3.0001], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[3, 3.0001], [1, 1]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the Frobenius norm condition number of matrix [[0.25, 0.75], [0.1, 0.3]].",
        "output": "import numpy as np\nA = np.array([[0.25, 0.75], [0.1, 0.3]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the condition number (2-norm) of matrix [[1e-4, 0], [0, 1e4]].",
        "output": "import numpy as np\nA = np.array([[1e-4, 0], [0, 1e4]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the condition number of matrix [[11, 7], [13, 9]] using Frobenius norm.",
        "output": "import numpy as np\nA = np.array([[11, 7], [13, 9]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the condition number (1-norm) of matrix [[5, 3], [2, 6]].",
        "output": "import numpy as np\nA = np.array([[5, 3], [2, 6]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute condition number (infinity norm) for matrix [[0.0002, 1], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[0.0002, 1], [1, 1]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine whether matrix [[0.01, 0], [0, 1000]] is numerically stable.",
        "output": "import numpy as np\nA = np.array([[0.01, 0], [0, 1000]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the condition number (2-norm) of matrix [[12, 6], [7, 3]].",
        "output": "import numpy as np\nA = np.array([[12, 6], [7, 3]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 1-norm condition number of matrix [[20, 10], [10, 5]].",
        "output": "import numpy as np\nA = np.array([[20, 10], [10, 5]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the condition number of matrix [[0.2, 1.1], [3.3, 0.4]] using 2-norm.",
        "output": "import numpy as np\nA = np.array([[0.2, 1.1], [3.3, 0.4]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 1-norm condition number of matrix [[7, 8], [9, 10]].",
        "output": "import numpy as np\nA = np.array([[7, 8], [9, 10]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the Frobenius condition number of matrix [[1.5, 0.5], [0.2, 2.5]].",
        "output": "import numpy as np\nA = np.array([[1.5, 0.5], [0.2, 2.5]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Is the matrix [[0.00001, 2], [2, 2]] well-conditioned? Calculate the condition number.",
        "output": "import numpy as np\nA = np.array([[0.00001, 2], [2, 2]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess the numerical stability of matrix [[6, 7], [8, 9]] using 2-norm.",
        "output": "import numpy as np\nA = np.array([[6, 7], [8, 9]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the default condition number of matrix [[4.2, 2.1], [0.3, 0.7]].",
        "output": "import numpy as np\nA = np.array([[4.2, 2.1], [0.3, 0.7]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check condition number for matrix [[2, 5], [7, 1]] using infinity norm.",
        "output": "import numpy as np\nA = np.array([[2, 5], [7, 1]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine condition number using 1-norm for matrix [[3.5, 2.1], [0.5, 0.2]].",
        "output": "import numpy as np\nA = np.array([[3.5, 2.1], [0.5, 0.2]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate numerical stability of matrix [[0.001, 1000], [1000, 0.001]].",
        "output": "import numpy as np\nA = np.array([[0.001, 1000], [1000, 0.001]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check how stable matrix [[12, 4], [3, 7]] is by computing its condition number.",
        "output": "import numpy as np\nA = np.array([[12, 4], [3, 7]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate condition number of matrix [[3, 3], [3, 3.000001]] using 2-norm.",
        "output": "import numpy as np\nA = np.array([[3, 3], [3, 3.000001]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine Frobenius condition number for matrix [[0.7, 0.2], [0.1, 0.9]].",
        "output": "import numpy as np\nA = np.array([[0.7, 0.2], [0.1, 0.9]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check condition number (1-norm) of matrix [[0.5, 0.1], [0.2, 0.8]].",
        "output": "import numpy as np\nA = np.array([[0.5, 0.1], [0.2, 0.8]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate infinity norm condition number of matrix [[100, 99], [99, 100]].",
        "output": "import numpy as np\nA = np.array([[100, 99], [99, 100]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "How sensitive is matrix [[1, 2.0001], [1, 2]]? Compute the condition number.",
        "output": "import numpy as np\nA = np.array([[1, 2.0001], [1, 2]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the condition number for matrix [[2, 3], [3, 2]] using Frobenius norm.",
        "output": "import numpy as np\nA = np.array([[2, 3], [3, 2]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check the default condition number of matrix [[9, 8], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[9, 8], [1, 2]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine how stable the matrix [[0.1, 1000], [1000, 0.1]] is numerically.",
        "output": "import numpy as np\nA = np.array([[0.1, 1000], [1000, 0.1]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number of matrix [[10, 1], [1, 10]].",
        "output": "import numpy as np\nA = np.array([[10, 1], [1, 10]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate Frobenius condition number of matrix [[1, 5], [2, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 5], [2, 6]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check condition number (2-norm) of matrix [[0.9, 0.4], [0.3, 0.6]].",
        "output": "import numpy as np\nA = np.array([[0.9, 0.4], [0.3, 0.6]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the infinity norm condition number of matrix [[3, 6], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[3, 6], [1, 2]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess the sensitivity of matrix [[1e-5, 2], [2, 2]] by computing its condition number.",
        "output": "import numpy as np\nA = np.array([[1e-5, 2], [2, 2]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine whether matrix [[4, 1], [1, 4]] is well-conditioned using 2-norm.",
        "output": "import numpy as np\nA = np.array([[4, 1], [1, 4]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the Frobenius norm condition number for matrix [[0.8, 0.3], [0.3, 0.9]].",
        "output": "import numpy as np\nA = np.array([[0.8, 0.3], [0.3, 0.9]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the 2-norm condition number of matrix [[11, 13], [17, 19]].",
        "output": "import numpy as np\nA = np.array([[11, 13], [17, 19]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the condition number of matrix [[0.25, 0.75], [0.6, 0.4]] using default norm.",
        "output": "import numpy as np\nA = np.array([[0.25, 0.75], [0.6, 0.4]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate 1-norm condition number for matrix [[5, 0], [0, 0.2]].",
        "output": "import numpy as np\nA = np.array([[5, 0], [0, 0.2]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the Frobenius condition number of matrix [[4, 2], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[4, 2], [1, 3]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check the numerical stability of matrix [[0.0001, 1], [1, 0.0001]] using 2-norm.",
        "output": "import numpy as np\nA = np.array([[0.0001, 1], [1, 0.0001]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine infinity norm condition number for matrix [[8, 9], [6, 7]].",
        "output": "import numpy as np\nA = np.array([[8, 9], [6, 7]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check condition number of matrix [[0.3, 0.1], [0.4, 0.6]] using 1-norm.",
        "output": "import numpy as np\nA = np.array([[0.3, 0.1], [0.4, 0.6]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess sensitivity of matrix [[3, 1], [2, 4]] by computing Frobenius condition number.",
        "output": "import numpy as np\nA = np.array([[3, 1], [2, 4]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the 2-norm condition number of matrix [[0.01, 1], [1, 100]].",
        "output": "import numpy as np\nA = np.array([[0.01, 1], [1, 100]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find condition number of matrix [[7, 5], [2, 1]] using default settings.",
        "output": "import numpy as np\nA = np.array([[7, 5], [2, 1]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate 1-norm condition number of matrix [[0.5, 0.3], [0.6, 0.2]].",
        "output": "import numpy as np\nA = np.array([[0.5, 0.3], [0.6, 0.2]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute infinity norm condition number of matrix [[4, 4], [2, 5]].",
        "output": "import numpy as np\nA = np.array([[4, 4], [2, 5]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess numerical stability for matrix [[1, 2], [3, 6.01]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 6.01]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find Frobenius norm condition number of matrix [[9, 2], [3, 7]].",
        "output": "import numpy as np\nA = np.array([[9, 2], [3, 7]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute condition number for matrix [[2, 3], [2, 3.00001]] using 2-norm.",
        "output": "import numpy as np\nA = np.array([[2, 3], [2, 3.00001]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check the default condition number of matrix [[8, 1], [1, 8]].",
        "output": "import numpy as np\nA = np.array([[8, 1], [1, 8]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess matrix [[0.002, 0.999], [0.999, 0.002]] for numerical sensitivity.",
        "output": "import numpy as np\nA = np.array([[0.002, 0.999], [0.999, 0.002]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute 1-norm condition number of matrix [[5, 5], [5, 5.0001]].",
        "output": "import numpy as np\nA = np.array([[5, 5], [5, 5.0001]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine condition number of matrix [[0.6, 0.9], [0.1, 0.7]] using Frobenius norm.",
        "output": "import numpy as np\nA = np.array([[0.6, 0.9], [0.1, 0.7]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check numerical stability of matrix [[2, 2.00001], [2, 2]] using default norm.",
        "output": "import numpy as np\nA = np.array([[2, 2.00001], [2, 2]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the condition number (2-norm) of matrix [[3, 2], [6, 5]].",
        "output": "import numpy as np\nA = np.array([[3, 2], [6, 5]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate Frobenius condition number of matrix [[7.1, 2.2], [4.4, 5.5]].",
        "output": "import numpy as np\nA = np.array([[7.1, 2.2], [4.4, 5.5]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number for matrix [[1, 0], [0, 0.01]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 0.01]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check the Frobenius condition number of matrix [[10, 0], [0, 0.1]].",
        "output": "import numpy as np\nA = np.array([[10, 0], [0, 0.1]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 2-norm condition number of matrix [[0.5, 0.3], [0.2, 0.1]].",
        "output": "import numpy as np\nA = np.array([[0.5, 0.3], [0.2, 0.1]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine the default condition number of matrix [[6, 2], [2, 1]].",
        "output": "import numpy as np\nA = np.array([[6, 2], [2, 1]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number for matrix [[0.01, 0.99], [0.99, 0.01]].",
        "output": "import numpy as np\nA = np.array([[0.01, 0.99], [0.99, 0.01]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check numerical stability of matrix [[1, 3], [3, 1]] using 2-norm.",
        "output": "import numpy as np\nA = np.array([[1, 3], [3, 1]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the Frobenius norm condition number of matrix [[0.2, 0.8], [0.5, 0.4]].",
        "output": "import numpy as np\nA = np.array([[0.2, 0.8], [0.5, 0.4]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 1-norm condition number of matrix [[2, 7], [3, 9]].",
        "output": "import numpy as np\nA = np.array([[2, 7], [3, 9]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess numerical stability of matrix [[0.01, 1], [1, 0.01]].",
        "output": "import numpy as np\nA = np.array([[0.01, 1], [1, 0.01]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 2-norm condition number for matrix [[10, 2], [3, 4]].",
        "output": "import numpy as np\nA = np.array([[10, 2], [3, 4]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine if matrix [[4, 1], [2, 0.5]] is numerically stable by computing its condition number.",
        "output": "import numpy as np\nA = np.array([[4, 1], [2, 0.5]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find Frobenius norm condition number for matrix [[5, 4], [3, 2]].",
        "output": "import numpy as np\nA = np.array([[5, 4], [3, 2]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute infinity norm condition number for matrix [[1, 5], [2, 8]].",
        "output": "import numpy as np\nA = np.array([[1, 5], [2, 8]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check condition number using 1-norm for matrix [[7, 1], [1, 7]].",
        "output": "import numpy as np\nA = np.array([[7, 1], [1, 7]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the default condition number for matrix [[3, 0.1], [0.1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 0.1], [0.1, 3]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the 2-norm condition number for matrix [[1, 0], [0, 0.0001]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 0.0001]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the Frobenius condition number of matrix [[6, 3], [2, 1]].",
        "output": "import numpy as np\nA = np.array([[6, 3], [2, 1]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine numerical stability for matrix [[2, 2], [2, 2.000001]] using default norm.",
        "output": "import numpy as np\nA = np.array([[2, 2], [2, 2.000001]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check 1-norm condition number for matrix [[0.7, 0.6], [0.3, 0.2]].",
        "output": "import numpy as np\nA = np.array([[0.7, 0.6], [0.3, 0.2]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number of matrix [[4, 2], [3, 1]].",
        "output": "import numpy as np\nA = np.array([[4, 2], [3, 1]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine the 2-norm condition number of matrix [[0.6, 0.4], [0.2, 0.1]].",
        "output": "import numpy as np\nA = np.array([[0.6, 0.4], [0.2, 0.1]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess default condition number of matrix [[5, 0.1], [0.1, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 0.1], [0.1, 5]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate Frobenius condition number for matrix [[0.01, 0], [0, 100]].",
        "output": "import numpy as np\nA = np.array([[0.01, 0], [0, 100]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute 1-norm condition number of matrix [[1, 2], [2, 5]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 5]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine condition number of matrix [[2, 3], [1, 1.000001]] using infinity norm.",
        "output": "import numpy as np\nA = np.array([[2, 3], [1, 1.000001]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number of matrix [[3, 1], [0, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [0, 3]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check numerical sensitivity of matrix [[9, 1], [1, 9]] using default norm.",
        "output": "import numpy as np\nA = np.array([[9, 1], [1, 9]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 2-norm condition number of the matrix [[0.1, 0.9], [0.3, 0.7]].",
        "output": "import numpy as np\nA = np.array([[0.1, 0.9], [0.3, 0.7]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the condition number using default norm for matrix [[8, 1], [6, 2]].",
        "output": "import numpy as np\nA = np.array([[8, 1], [6, 2]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the 1-norm condition number of matrix [[0.3, 0.1], [0.4, 0.6]].",
        "output": "import numpy as np\nA = np.array([[0.3, 0.1], [0.4, 0.6]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine the infinity norm condition number of matrix [[1, 0.01], [0.01, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 0.01], [0.01, 1]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check numerical stability of matrix [[0.2, 0.2], [0.4, 0.4]] using the default condition number.",
        "output": "import numpy as np\nA = np.array([[0.2, 0.2], [0.4, 0.4]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the Frobenius norm condition number of matrix [[4, 0], [0, 0.1]].",
        "output": "import numpy as np\nA = np.array([[4, 0], [0, 0.1]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess the condition number of matrix [[5, 2], [1, 5]] using the 2-norm.",
        "output": "import numpy as np\nA = np.array([[5, 2], [1, 5]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number for matrix [[3, 4], [2, 1]].",
        "output": "import numpy as np\nA = np.array([[3, 4], [2, 1]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate numerical stability of matrix [[0.5, 0.5], [0.5, 0.5]] using default norm.",
        "output": "import numpy as np\nA = np.array([[0.5, 0.5], [0.5, 0.5]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the infinity norm condition number of matrix [[2, 3], [5, 7]].",
        "output": "import numpy as np\nA = np.array([[2, 3], [5, 7]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine 2-norm condition number of matrix [[0.1, 0], [0, 1000]].",
        "output": "import numpy as np\nA = np.array([[0.1, 0], [0, 1000]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute Frobenius norm condition number of matrix [[9, 0], [0, 0.001]].",
        "output": "import numpy as np\nA = np.array([[9, 0], [0, 0.001]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate condition number using default norm for matrix [[0.1, 0.9], [0.9, 0.1]].",
        "output": "import numpy as np\nA = np.array([[0.1, 0.9], [0.9, 0.1]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find 1-norm condition number of matrix [[100, 1], [0, 100]].",
        "output": "import numpy as np\nA = np.array([[100, 1], [0, 100]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess numerical sensitivity of matrix [[1, 2], [2, 4.0001]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 4.0001]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number of matrix [[6, 1], [4, 2]].",
        "output": "import numpy as np\nA = np.array([[6, 1], [4, 2]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate Frobenius condition number of matrix [[3, 3], [3, 3.00001]].",
        "output": "import numpy as np\nA = np.array([[3, 3], [3, 3.00001]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 2-norm condition number for matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the default condition number of matrix [[2, 4], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 4], [1, 2]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check the 1-norm condition number for matrix [[10, 10], [0, 0.001]].",
        "output": "import numpy as np\nA = np.array([[10, 10], [0, 0.001]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess numerical stability using Frobenius norm for matrix [[0.01, 0.01], [0.01, 0.02]].",
        "output": "import numpy as np\nA = np.array([[0.01, 0.01], [0.01, 0.02]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the infinity norm condition number for matrix [[3, 1], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the 2-norm condition number of matrix [[1, 3], [3, 10]].",
        "output": "import numpy as np\nA = np.array([[1, 3], [3, 10]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine the condition number for matrix [[0.0001, 0], [0, 1]] using default norm.",
        "output": "import numpy as np\nA = np.array([[0.0001, 0], [0, 1]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find Frobenius norm condition number of matrix [[3, 2], [5, 1]].",
        "output": "import numpy as np\nA = np.array([[3, 2], [5, 1]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the default condition number for the matrix [[7, 3], [2, 6]].",
        "output": "import numpy as np\nA = np.array([[7, 3], [2, 6]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine the 1-norm condition number of matrix [[1, 0.1], [0.1, 1]].",
        "output": "import numpy as np\nA = np.array([[1, 0.1], [0.1, 1]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the infinity norm condition number of matrix [[2, 0], [1, 0.01]].",
        "output": "import numpy as np\nA = np.array([[2, 0], [1, 0.01]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the Frobenius norm condition number of matrix [[10, 5], [3, 8]].",
        "output": "import numpy as np\nA = np.array([[10, 5], [3, 8]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the 2-norm condition number of matrix [[9, 1], [1, 9]].",
        "output": "import numpy as np\nA = np.array([[9, 1], [1, 9]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess the numerical stability of matrix [[2, 4], [1, 3.999]].",
        "output": "import numpy as np\nA = np.array([[2, 4], [1, 3.999]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the Frobenius norm condition number of matrix [[100, 0.1], [0.1, 1]].",
        "output": "import numpy as np\nA = np.array([[100, 0.1], [0.1, 1]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the default condition number for matrix [[1, 5], [2, 6]].",
        "output": "import numpy as np\nA = np.array([[1, 5], [2, 6]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the 1-norm condition number of matrix [[0.5, 0.5], [0.5, 0.5001]].",
        "output": "import numpy as np\nA = np.array([[0.5, 0.5], [0.5, 0.5001]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine the 2-norm condition number for matrix [[4, 0], [0, 0.01]].",
        "output": "import numpy as np\nA = np.array([[4, 0], [0, 0.01]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check the numerical stability of matrix [[0.1, 0.2], [0.3, 0.4]] using default norm.",
        "output": "import numpy as np\nA = np.array([[0.1, 0.2], [0.3, 0.4]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number of matrix [[1, 2], [2, 5]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 5]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate Frobenius norm condition number for matrix [[0.9, 0.1], [0.1, 0.9]].",
        "output": "import numpy as np\nA = np.array([[0.9, 0.1], [0.1, 0.9]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine 1-norm condition number of matrix [[0.01, 1], [1, 0.01]].",
        "output": "import numpy as np\nA = np.array([[0.01, 1], [1, 0.01]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the default condition number for matrix [[3, 6], [2, 5]].",
        "output": "import numpy as np\nA = np.array([[3, 6], [2, 5]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check the 2-norm condition number of matrix [[1, 0], [0, 0.00001]].",
        "output": "import numpy as np\nA = np.array([[1, 0], [0, 0.00001]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute Frobenius condition number for matrix [[7, 4], [2, 3]].",
        "output": "import numpy as np\nA = np.array([[7, 4], [2, 3]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the infinity norm condition number for matrix [[0.1, 0.2], [0.3, 0.6]].",
        "output": "import numpy as np\nA = np.array([[0.1, 0.2], [0.3, 0.6]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine numerical stability of matrix [[0.0001, 1], [1, 0.0001]] using default norm.",
        "output": "import numpy as np\nA = np.array([[0.0001, 1], [1, 0.0001]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 2-norm condition number of matrix [[2, 3], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[2, 3], [1, 1]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find 1-norm condition number for matrix [[0.2, 0.3], [0.4, 0.5]].",
        "output": "import numpy as np\nA = np.array([[0.2, 0.3], [0.4, 0.5]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate default condition number of matrix [[0.00001, 0], [0, 100000]].",
        "output": "import numpy as np\nA = np.array([[0.00001, 0], [0, 100000]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess Frobenius condition number of matrix [[2, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute infinity norm condition number for matrix [[3, 3], [3, 3.0001]].",
        "output": "import numpy as np\nA = np.array([[3, 3], [3, 3.0001]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the default condition number of matrix [[0.5, 0.3], [0.2, 0.4]].",
        "output": "import numpy as np\nA = np.array([[0.5, 0.3], [0.2, 0.4]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number for matrix [[2, 2], [1, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 2], [1, 3]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the 2-norm condition number of matrix [[4, 1], [2, 5]].",
        "output": "import numpy as np\nA = np.array([[4, 1], [2, 5]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the Frobenius norm condition number of matrix [[0.9, 0.4], [0.3, 0.7]].",
        "output": "import numpy as np\nA = np.array([[0.9, 0.4], [0.3, 0.7]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine the infinity norm condition number for matrix [[1, 4], [2, 2]].",
        "output": "import numpy as np\nA = np.array([[1, 4], [2, 2]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check numerical stability of matrix [[1, 0.99], [0.99, 1]] using default norm.",
        "output": "import numpy as np\nA = np.array([[1, 0.99], [0.99, 1]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the 1-norm condition number of matrix [[5, 2], [3, 6]].",
        "output": "import numpy as np\nA = np.array([[5, 2], [3, 6]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number for matrix [[10, 1], [0.5, 8]].",
        "output": "import numpy as np\nA = np.array([[10, 1], [0.5, 8]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate Frobenius norm condition number of matrix [[0.2, 0.5], [0.5, 0.2]].",
        "output": "import numpy as np\nA = np.array([[0.2, 0.5], [0.5, 0.2]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess the default condition number for matrix [[3, 1], [4, 1]].",
        "output": "import numpy as np\nA = np.array([[3, 1], [4, 1]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine the 1-norm condition number of matrix [[0.8, 0.2], [0.1, 0.9]].",
        "output": "import numpy as np\nA = np.array([[0.8, 0.2], [0.1, 0.9]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate 2-norm condition number of matrix [[100, 2], [3, 90]].",
        "output": "import numpy as np\nA = np.array([[100, 2], [3, 90]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate infinity norm condition number for matrix [[2, 3], [5, 7]].",
        "output": "import numpy as np\nA = np.array([[2, 3], [5, 7]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute Frobenius condition number for matrix [[1.1, 0.1], [0.1, 1.1]].",
        "output": "import numpy as np\nA = np.array([[1.1, 0.1], [0.1, 1.1]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check numerical stability for matrix [[2, 2], [2, 2.0001]] using default norm.",
        "output": "import numpy as np\nA = np.array([[2, 2], [2, 2.0001]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 1-norm condition number of matrix [[1, 3], [2, 2]].",
        "output": "import numpy as np\nA = np.array([[1, 3], [2, 2]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate 2-norm condition number for matrix [[4, 2], [1, 6]].",
        "output": "import numpy as np\nA = np.array([[4, 2], [1, 6]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate Frobenius norm condition number for matrix [[0.05, 0.01], [0.01, 0.05]].",
        "output": "import numpy as np\nA = np.array([[0.05, 0.01], [0.01, 0.05]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine default condition number of matrix [[8, 1], [6, 2]].",
        "output": "import numpy as np\nA = np.array([[8, 1], [6, 2]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute infinity norm condition number of matrix [[0.2, 0.3], [0.4, 0.1]].",
        "output": "import numpy as np\nA = np.array([[0.2, 0.3], [0.4, 0.1]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate 1-norm condition number for matrix [[1, 2], [3, 4.01]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4.01]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check 2-norm condition number of matrix [[0.0001, 0], [0, 1]].",
        "output": "import numpy as np\nA = np.array([[0.0001, 0], [0, 1]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Assess numerical stability of matrix [[2.2, 1.1], [1.1, 2.2]] using default norm.",
        "output": "import numpy as np\nA = np.array([[2.2, 1.1], [1.1, 2.2]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Determine Frobenius norm condition number of matrix [[0.3, 0.6], [0.6, 0.3]].",
        "output": "import numpy as np\nA = np.array([[0.3, 0.6], [0.6, 0.3]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the 1-norm condition number for matrix [[6, 4], [2, 8]].",
        "output": "import numpy as np\nA = np.array([[6, 4], [2, 8]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the 2-norm condition number for matrix [[0.3, 0.9], [0.8, 0.2]].",
        "output": "import numpy as np\nA = np.array([[0.3, 0.9], [0.8, 0.2]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the Frobenius norm condition number for matrix [[0.1, 0.5], [0.5, 0.1]].",
        "output": "import numpy as np\nA = np.array([[0.1, 0.5], [0.5, 0.1]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the infinity norm condition number for matrix [[2.5, 1.5], [1.5, 2.5]].",
        "output": "import numpy as np\nA = np.array([[2.5, 1.5], [1.5, 2.5]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the default condition number of matrix [[9, 2], [3, 6]].",
        "output": "import numpy as np\nA = np.array([[9, 2], [3, 6]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the 1-norm condition number for matrix [[1.4, 0.3], [0.3, 1.4]].",
        "output": "import numpy as np\nA = np.array([[1.4, 0.3], [0.3, 1.4]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number of matrix [[2, 1], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the infinity norm condition number for matrix [[0.6, 0.2], [0.2, 0.6]].",
        "output": "import numpy as np\nA = np.array([[0.6, 0.2], [0.2, 0.6]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check the default condition number for matrix [[2, 2], [3, 3]].",
        "output": "import numpy as np\nA = np.array([[2, 2], [3, 3]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the 1-norm condition number for matrix [[0.9, 0.1], [0.2, 0.8]].",
        "output": "import numpy as np\nA = np.array([[0.9, 0.1], [0.2, 0.8]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 2-norm condition number of matrix [[5, 5], [5, 5]].",
        "output": "import numpy as np\nA = np.array([[5, 5], [5, 5]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the Frobenius norm condition number for matrix [[1, 3], [2, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 3], [2, 4]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number of matrix [[0.4, 0.2], [0.1, 0.6]].",
        "output": "import numpy as np\nA = np.array([[0.4, 0.2], [0.1, 0.6]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the default condition number for matrix [[2.5, 3.5], [1.5, 2.5]].",
        "output": "import numpy as np\nA = np.array([[2.5, 3.5], [1.5, 2.5]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the 1-norm condition number for matrix [[1.2, 1.5], [2.5, 3.1]].",
        "output": "import numpy as np\nA = np.array([[1.2, 1.5], [2.5, 3.1]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 2-norm condition number of matrix [[0.3, 0.6], [0.6, 0.3]].",
        "output": "import numpy as np\nA = np.array([[0.3, 0.6], [0.6, 0.3]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the Frobenius norm condition number for matrix [[0.1, 0.4], [0.4, 0.1]].",
        "output": "import numpy as np\nA = np.array([[0.1, 0.4], [0.4, 0.1]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the infinity norm condition number for matrix [[0.3, 0.7], [0.2, 0.5]].",
        "output": "import numpy as np\nA = np.array([[0.3, 0.7], [0.2, 0.5]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check the default condition number of matrix [[2.3, 2.8], [3.1, 1.6]].",
        "output": "import numpy as np\nA = np.array([[2.3, 2.8], [3.1, 1.6]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the 1-norm condition number for matrix [[0.7, 0.9], [0.3, 0.2]].",
        "output": "import numpy as np\nA = np.array([[0.7, 0.9], [0.3, 0.2]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 2-norm condition number of matrix [[3.1, 2.4], [2.3, 1.9]].",
        "output": "import numpy as np\nA = np.array([[3.1, 2.4], [2.3, 1.9]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the Frobenius norm condition number for matrix [[1.1, 2.5], [2.3, 3.7]].",
        "output": "import numpy as np\nA = np.array([[1.1, 2.5], [2.3, 3.7]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the infinity norm condition number for matrix [[0.5, 0.8], [0.6, 0.4]].",
        "output": "import numpy as np\nA = np.array([[0.5, 0.8], [0.6, 0.4]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check the default condition number for matrix [[2, 3], [1, 1]].",
        "output": "import numpy as np\nA = np.array([[2, 3], [1, 1]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number for matrix [[4, 7], [2, 5]].",
        "output": "import numpy as np\nA = np.array([[4, 7], [2, 5]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the 2-norm condition number for matrix [[2.1, 1.3], [0.7, 2.5]].",
        "output": "import numpy as np\nA = np.array([[2.1, 1.3], [0.7, 2.5]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the Frobenius norm condition number for matrix [[0.9, 0.1], [0.1, 0.9]].",
        "output": "import numpy as np\nA = np.array([[0.9, 0.1], [0.1, 0.9]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the infinity norm condition number for matrix [[3, 2], [1, 4]].",
        "output": "import numpy as np\nA = np.array([[3, 2], [1, 4]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the default condition number for matrix [[6, 4], [2, 6]].",
        "output": "import numpy as np\nA = np.array([[6, 4], [2, 6]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number for matrix [[0.2, 0.7], [0.3, 0.9]].",
        "output": "import numpy as np\nA = np.array([[0.2, 0.7], [0.3, 0.9]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number for matrix [[1, 2], [3, 4]].",
        "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the Frobenius norm condition number for matrix [[0.8, 0.2], [0.3, 0.7]].",
        "output": "import numpy as np\nA = np.array([[0.8, 0.2], [0.3, 0.7]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number for matrix [[1.5, 0.5], [0.5, 1.5]].",
        "output": "import numpy as np\nA = np.array([[1.5, 0.5], [0.5, 1.5]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check the default condition number for matrix [[0.5, 0.6], [0.6, 0.5]].",
        "output": "import numpy as np\nA = np.array([[0.5, 0.6], [0.6, 0.5]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number for matrix [[2.8, 1.6], [1.1, 2.3]].",
        "output": "import numpy as np\nA = np.array([[2.8, 1.6], [1.1, 2.3]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number for matrix [[1.5, 0.8], [0.2, 1.7]].",
        "output": "import numpy as np\nA = np.array([[1.5, 0.8], [0.2, 1.7]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the Frobenius norm condition number for matrix [[0.3, 0.4], [0.7, 0.9]].",
        "output": "import numpy as np\nA = np.array([[0.3, 0.4], [0.7, 0.9]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number for matrix [[2.7, 1.8], [1.2, 2.4]].",
        "output": "import numpy as np\nA = np.array([[2.7, 1.8], [1.2, 2.4]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the default condition number for matrix [[3.3, 2.2], [0.9, 3.1]].",
        "output": "import numpy as np\nA = np.array([[3.3, 2.2], [0.9, 3.1]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number for matrix [[1.3, 0.5], [0.6, 2.1]].",
        "output": "import numpy as np\nA = np.array([[1.3, 0.5], [0.6, 2.1]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the 2-norm condition number for matrix [[0.7, 0.2], [0.8, 1.3]].",
        "output": "import numpy as np\nA = np.array([[0.7, 0.2], [0.8, 1.3]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the Frobenius norm condition number for matrix [[2.4, 0.9], [0.4, 2.5]].",
        "output": "import numpy as np\nA = np.array([[2.4, 0.9], [0.4, 2.5]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number for matrix [[0.5, 1.5], [1.2, 0.7]].",
        "output": "import numpy as np\nA = np.array([[0.5, 1.5], [1.2, 0.7]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check the default condition number for matrix [[1.8, 1.2], [1.0, 1.7]].",
        "output": "import numpy as np\nA = np.array([[1.8, 1.2], [1.0, 1.7]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number for matrix [[3.2, 1.0], [1.3, 2.0]].",
        "output": "import numpy as np\nA = np.array([[3.2, 1.0], [1.3, 2.0]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number for matrix [[1.4, 0.6], [0.5, 1.1]].",
        "output": "import numpy as np\nA = np.array([[1.4, 0.6], [0.5, 1.1]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number for matrix [[5, 3], [1, 4]].",
        "output": "import numpy as np\nA = np.array([[5, 3], [1, 4]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number for matrix [[7, 2], [3, 5]].",
        "output": "import numpy as np\nA = np.array([[7, 2], [3, 5]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the Frobenius norm condition number for matrix [[2, 6], [5, 7]].",
        "output": "import numpy as np\nA = np.array([[2, 6], [5, 7]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number for matrix [[3, 5], [1, 2]].",
        "output": "import numpy as np\nA = np.array([[3, 5], [1, 2]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the default condition number for matrix [[4, 3], [2, 1]].",
        "output": "import numpy as np\nA = np.array([[4, 3], [2, 1]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number for matrix [[0.3, 0.9], [0.2, 1.4]].",
        "output": "import numpy as np\nA = np.array([[0.3, 0.9], [0.2, 1.4]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number for matrix [[0.7, 0.6], [1.2, 0.3]].",
        "output": "import numpy as np\nA = np.array([[0.7, 0.6], [1.2, 0.3]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the Frobenius norm condition number for matrix [[1.5, 0.5], [0.6, 1.7]].",
        "output": "import numpy as np\nA = np.array([[1.5, 0.5], [0.6, 1.7]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number for matrix [[1.1, 2.8], [3.0, 1.9]].",
        "output": "import numpy as np\nA = np.array([[1.1, 2.8], [3.0, 1.9]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the default condition number for matrix [[2.3, 1.2], [1.0, 3.5]].",
        "output": "import numpy as np\nA = np.array([[2.3, 1.2], [1.0, 3.5]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number for matrix [[3.4, 2.1], [0.5, 1.8]].",
        "output": "import numpy as np\nA = np.array([[3.4, 2.1], [0.5, 1.8]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number for matrix [[1.2, 1.5], [0.4, 2.3]].",
        "output": "import numpy as np\nA = np.array([[1.2, 1.5], [0.4, 2.3]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the Frobenius norm condition number for matrix [[3.2, 0.6], [0.7, 2.4]].",
        "output": "import numpy as np\nA = np.array([[3.2, 0.6], [0.7, 2.4]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number for matrix [[0.5, 0.4], [1.3, 2.1]].",
        "output": "import numpy as np\nA = np.array([[0.5, 0.4], [1.3, 2.1]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the default condition number for matrix [[3.9, 2.3], [1.1, 2.7]].",
        "output": "import numpy as np\nA = np.array([[3.9, 2.3], [1.1, 2.7]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number for matrix [[5.1, 1.5], [2.8, 0.7]].",
        "output": "import numpy as np\nA = np.array([[5.1, 1.5], [2.8, 0.7]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number for matrix [[4.2, 0.8], [0.9, 1.3]].",
        "output": "import numpy as np\nA = np.array([[4.2, 0.8], [0.9, 1.3]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the Frobenius norm condition number for matrix [[1.9, 0.6], [0.8, 1.4]].",
        "output": "import numpy as np\nA = np.array([[1.9, 0.6], [0.8, 1.4]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number for matrix [[2.1, 0.4], [1.5, 2.3]].",
        "output": "import numpy as np\nA = np.array([[2.1, 0.4], [1.5, 2.3]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the default condition number for matrix [[4.4, 3.6], [2.1, 5.7]].",
        "output": "import numpy as np\nA = np.array([[4.4, 3.6], [2.1, 5.7]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number for matrix [[3.0, 2.5], [1.4, 0.7]].",
        "output": "import numpy as np\nA = np.array([[3.0, 2.5], [1.4, 0.7]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number for matrix [[1.8, 1.0], [0.6, 2.2]].",
        "output": "import numpy as np\nA = np.array([[1.8, 1.0], [0.6, 2.2]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the Frobenius norm condition number for matrix [[2.7, 3.1], [4.2, 0.5]].",
        "output": "import numpy as np\nA = np.array([[2.7, 3.1], [4.2, 0.5]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number for matrix [[2.5, 3.4], [1.1, 2.2]].",
        "output": "import numpy as np\nA = np.array([[2.5, 3.4], [1.1, 2.2]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the default condition number for matrix [[4.0, 1.9], [1.7, 2.3]].",
        "output": "import numpy as np\nA = np.array([[4.0, 1.9], [1.7, 2.3]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number for matrix [[3.5, 2.2], [1.5, 4.3]].",
        "output": "import numpy as np\nA = np.array([[3.5, 2.2], [1.5, 4.3]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number for matrix [[6.1, 4.8], [3.3, 2.0]].",
        "output": "import numpy as np\nA = np.array([[6.1, 4.8], [3.3, 2.0]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the Frobenius norm condition number for matrix [[1.8, 0.4], [1.6, 0.9]].",
        "output": "import numpy as np\nA = np.array([[1.8, 0.4], [1.6, 0.9]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number for matrix [[7.1, 3.3], [4.2, 1.1]].",
        "output": "import numpy as np\nA = np.array([[7.1, 3.3], [4.2, 1.1]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the default condition number for matrix [[2.4, 5.7], [3.9, 1.0]].",
        "output": "import numpy as np\nA = np.array([[2.4, 5.7], [3.9, 1.0]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number for matrix [[0.6, 1.2], [1.1, 2.5]].",
        "output": "import numpy as np\nA = np.array([[0.6, 1.2], [1.1, 2.5]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number for matrix [[3.8, 2.1], [0.7, 4.6]].",
        "output": "import numpy as np\nA = np.array([[3.8, 2.1], [0.7, 4.6]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the Frobenius norm condition number for matrix [[5.4, 3.6], [2.5, 1.8]].",
        "output": "import numpy as np\nA = np.array([[5.4, 3.6], [2.5, 1.8]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number for matrix [[3.3, 1.4], [2.2, 5.0]].",
        "output": "import numpy as np\nA = np.array([[3.3, 1.4], [2.2, 5.0]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the default condition number for matrix [[1.0, 4.6], [3.5, 0.7]].",
        "output": "import numpy as np\nA = np.array([[1.0, 4.6], [3.5, 0.7]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number for matrix [[3.0, 1.1], [4.2, 3.3]].",
        "output": "import numpy as np\nA = np.array([[3.0, 1.1], [4.2, 3.3]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number for matrix [[2.3, 3.1], [4.7, 0.9]].",
        "output": "import numpy as np\nA = np.array([[2.3, 3.1], [4.7, 0.9]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the Frobenius norm condition number for matrix [[3.4, 2.6], [0.8, 4.1]].",
        "output": "import numpy as np\nA = np.array([[3.4, 2.6], [0.8, 4.1]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number for matrix [[1.7, 0.3], [2.1, 4.5]].",
        "output": "import numpy as np\nA = np.array([[1.7, 0.3], [2.1, 4.5]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the default condition number for matrix [[4.1, 2.4], [3.2, 1.3]].",
        "output": "import numpy as np\nA = np.array([[4.1, 2.4], [3.2, 1.3]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Calculate the 1-norm condition number for matrix [[2.6, 3.3], [0.7, 1.2]].",
        "output": "import numpy as np\nA = np.array([[2.6, 3.3], [0.7, 1.2]])\ncond_number = np.linalg.cond(A, 1)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number for matrix [[5.7, 3.5], [1.4, 0.2]].",
        "output": "import numpy as np\nA = np.array([[5.7, 3.5], [1.4, 0.2]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Evaluate the Frobenius norm condition number for matrix [[0.9, 1.1], [0.8, 1.4]].",
        "output": "import numpy as np\nA = np.array([[0.9, 1.1], [0.8, 1.4]])\ncond_number = np.linalg.cond(A, 'fro')\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Compute the infinity norm condition number for matrix [[2.8, 1.9], [3.0, 0.4]].",
        "output": "import numpy as np\nA = np.array([[2.8, 1.9], [3.0, 0.4]])\ncond_number = np.linalg.cond(A, np.inf)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the default condition number for matrix [[6.3, 1.1], [2.2, 4.9]].",
        "output": "import numpy as np\nA = np.array([[6.3, 1.1], [2.2, 4.9]])\ncond_number = np.linalg.cond(A)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Find the 2-norm condition number for matrix [[1.2, 0.9], [3.4, 2.3]].",
        "output": "import numpy as np\nA = np.array([[1.2, 0.9], [3.4, 2.3]])\ncond_number = np.linalg.cond(A, 2)\nprint(\"Condition number:\", cond_number)"
    },
    {
        "input": "Check numerical stability with A = [[1, 2], [2, 3.99999]] and b = [3, 6].",
        "output": "import numpy as np\nA = np.array([[1, 2], [2, 3.99999]])\nb = np.array([3, 6])\nx = np.linalg.solve(A, b)\nprint(\"Solution x:\", x)"
    }
]